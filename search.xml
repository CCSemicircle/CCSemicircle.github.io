<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/pa-chong-wei-bo-pa-chong/"/>
      <url>/2022/pa-chong-wei-bo-pa-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>手机上的信息电脑端看不到时不一定没有适配电脑端，需要自己去找，或者去查一下，手机端信息电脑端一般都有</li><li>找到对应网页后不要直接开始在HTML中爬取，最好是找到返回的json数据，直接请求该链接</li><li>找到对应请求链接后，一定要确保访问的header正确（需要去找这个header，待确定简单的方法todo）</li><li>请求头中的Accept-Encoding是设置返回的编码，一般不需要设置，如果返回的数据无法decode，一般是这个地方设置不当</li><li>如果报错400，代表请求格式错误，先打印url，然后在浏览器访问url尝试url有效性，然后再去找其他错误，如cookie过期等</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/ji-suan-ji-ji-chu-shu-ju-jie-gou/"/>
      <url>/2022/ji-suan-ji-ji-chu-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数组与字符串"><a href="#1-数组与字符串" class="headerlink" title="1 数组与字符串"></a>1 数组与字符串</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP_入门教程</title>
      <link href="/2022/nlp-ru-men-jiao-cheng/"/>
      <url>/2022/nlp-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="0-入门项目"><a href="#0-入门项目" class="headerlink" title="0 入门项目"></a>0 入门项目</h1><blockquote><p>以下项目可以根据自身兴趣选择性了解</p></blockquote><h2 id="0-1-经典开源项目汇总链接"><a href="#0-1-经典开源项目汇总链接" class="headerlink" title="0.1 经典开源项目汇总链接"></a>0.1 经典开源项目汇总链接</h2><ul><li><a href="https://inforscan.com/2019/12/26/GitHub%20%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%20NLP%20%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE/">GitHub 最受欢迎的 NLP 相关项目</a></li><li><a href="https://www.githubs.cn/collections/nlp">Github上自然语言处理开源项目推荐</a></li><li><a href="https://www.zhihu.com/question/264352009">适合初学者学习的NLP开源项目有哪些？</a></li><li><a href="https://www.yanxishe.com/columnDetail/25296">200+优秀Github项目精选</a></li><li><a href="https://zhuanlan.zhihu.com/p/51279338">练手|常见30种NLP任务的练手项目</a></li></ul><h2 id="0-2-文本分类"><a href="#0-2-文本分类" class="headerlink" title="0.2 文本分类"></a>0.2 文本分类</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/73176084">中文文本分类 pytorch实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2022/yuan-ji-chu-da-jian-ge-ren-bo-ke/"/>
      <url>/2022/yuan-ji-chu-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基于Hexo搭建个人博客"><a href="#1-基于Hexo搭建个人博客" class="headerlink" title="1 基于Hexo搭建个人博客"></a>1 基于Hexo搭建个人博客</h1><h2 id="1-1-基于Github搭建"><a href="#1-1-基于Github搭建" class="headerlink" title="1.1 基于Github搭建"></a>1.1 基于Github搭建</h2><p>参考如下两篇博客即可：</p><ul><li><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></p></li></ul><h2 id="1-2-Matery主题优化"><a href="#1-2-Matery主题优化" class="headerlink" title="1.2 Matery主题优化"></a>1.2 Matery主题优化</h2><h3 id="1-2-1-SEO优化"><a href="#1-2-1-SEO优化" class="headerlink" title="1.2.1 SEO优化"></a>1.2.1 SEO优化</h3><ul><li><a href="https://www.modb.pro/db/74215">Hexo博客SEO优化</a></li></ul><h3 id="1-2-2-页面加载优化"><a href="#1-2-2-页面加载优化" class="headerlink" title="1.2.2 页面加载优化"></a>1.2.2 页面加载优化</h3><ul><li><a href="https://blog.csdn.net/weixin_43662760/article/details/122311217">Matery主题自定义(六)页面加载动画</a></li></ul><h3 id="1-2-3-添加评论功能"><a href="#1-2-3-添加评论功能" class="headerlink" title="1.2.3 添加评论功能"></a>1.2.3 添加评论功能</h3><ul><li><p><a href="https://fenghen0918.github.io/2020/06/19/hexo/matery-zhu-ti-valine-ping-lun-xi-tong/">matery主题+Valine评论系统</a></p></li><li><p>添加评论邮件提醒：<a href="https://github.com/zhaojun1998/Valine-Admin"> Valine-Admin</a></p></li><li><p>开通Gmail授权码：<a href="https://docs.51microshop.com/document/180-99">Gmail邮箱</a></p></li><li><p>评论系统：<a href="https://console.leancloud.cn/apps">LeanCloud</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 猿基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU云服务器</title>
      <link href="/2022/ai-gpu-yun-fu-wu-qi/"/>
      <url>/2022/ai-gpu-yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-显卡介绍"><a href="#1-显卡介绍" class="headerlink" title="1 显卡介绍"></a>1 显卡介绍</h1><h2 id="1-1-NVIDIA-TESLA系列介绍"><a href="#1-1-NVIDIA-TESLA系列介绍" class="headerlink" title="1.1 NVIDIA TESLA系列介绍"></a>1.1 NVIDIA TESLA系列介绍</h2><ul><li><strong>NVIDIA TESLA V100</strong></li></ul><p>NVIDIA Tesla V100采用NVIDIA Volta架构，非常适合为要求极为苛刻的双精度计算工作流程提供加速，并且还是从P100升级的理想路径。该GPU的渲染性能比Tesla P100提升了高达80%，借此可缩短设计周期和上市时间。</p><p>Tesla V100的每个GPU均可提供125 teraflops的推理性能，配有8块Tesla V100的单个服务器可实现1 petaflop的计算性能。</p><ul><li><strong>NVIDIA TESLA P40</strong></li></ul><p>The Tesla P40能够提供高达2倍的专业图形性能。Tesla P40能够对组织中每个vGPU虚拟化加速图形和计算（NVIDIA CUDA® 和 OpenCL）工作负载。支持多种行业标准的2U服务器。</p><p>Tesla P40可提供出色的推理性能、INT8精度和24GB板载内存。</p><ul><li><strong>NVIDIA TESLA T4</strong></li></ul><p>NVIDIA Tesla T4的帧缓存高达P4的2倍，性能高达M60的2倍，对于利用NVIDIA Quadro vDWS软件开启高端3D设计和工程工作流程的用户而言，不失为一种理想的解决方案。凭借单插槽、半高外形特性以及低至70瓦的功耗，Tesla T4堪称为每个服务器节点实现最大GPU密度的绝佳之选。</p><ul><li><strong>NVIDIA TESLA P4</strong></li></ul><p>Tesla P4可加快任何外扩型服务器的运行速度，能效高达CPU的60倍。</p><p>原文链接：<a href="https://developer.aliyun.com/article/753454">https://developer.aliyun.com/article/753454</a></p><h2 id="1-2-常见GPU型号简介"><a href="#1-2-常见GPU型号简介" class="headerlink" title="1.2 常见GPU型号简介"></a>1.2 常见GPU型号简介</h2><p><img src="http://img.fdchen.host/%E5%B8%B8%E8%A7%81GPU%E5%9E%8B%E5%8F%B7%E7%AE%80%E4%BB%8B.png" alt="常见GPU型号简介"></p><p>原文链接：<a href="https://www.autodl.com/docs/gpu/">https://www.autodl.com/docs/gpu/</a></p><h1 id="2-性能对比"><a href="#2-性能对比" class="headerlink" title="2 性能对比"></a>2 性能对比</h1><h2 id="2-1-安培卡-A40等-与老推理卡-T4等"><a href="#2-1-安培卡-A40等-与老推理卡-T4等" class="headerlink" title="2.1 安培卡(A40等)与老推理卡(T4等)"></a>2.1 安培卡(A40等)与老推理卡(T4等)</h2><p><img src="https://img.fdchen.host/%E5%AE%89%E5%9F%B9%E5%8D%A1%E4%B8%8E%E8%80%81%E6%8E%A8%E7%90%86%E5%8D%A1.png" alt="安培卡与老推理卡"></p><p>数据来源：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjYzMzkzOQ==&mid=2247484738&idx=1&sn=2a1c4c86d0d07bd9d95f4ed710f97a5c&chksm=ceed067ef99a8f68051903948ee0ebd3adf6f2672f1116a52915027805cde6ce7d0fe46ba733&token=1129056787&lang=zh_CN#rd">【系统硬件】英伟达安培卡 vs 老推理卡硬件参数对比</a></p><h2 id="2-2-NVIDIA-20xx-30xx-与-Axx系列"><a href="#2-2-NVIDIA-20xx-30xx-与-Axx系列" class="headerlink" title="2.2 NVIDIA 20xx, 30xx 与 Axx系列"></a>2.2 NVIDIA 20xx, 30xx 与 Axx系列</h2><ul><li>半精算力</li></ul><p><img src="http://img.fdchen.host/NVIDIA%E7%B3%BB%E5%88%97%E6%98%BE%E5%8D%A1_%E5%8D%8A%E7%B2%BE%E7%AE%97%E5%8A%9B.png" alt="NVIDIA系列显卡_半精算力"></p><ul><li>单精算力</li></ul><p><img src="http://img.fdchen.host/NVIDIA%E7%B3%BB%E5%88%97%E6%98%BE%E5%8D%A1_%E5%8D%95%E7%B2%BE%E7%AE%97%E5%8A%9B.png" alt="NVIDIA系列显卡_单精算力"></p><p>数据来源：<a href="https://www.autodl.com/home">AutoDL算力排行</a></p><ul><li>整体介绍</li></ul><p><img src="http://img.fdchen.host/%E5%B8%B8%E8%A7%81GPU%E5%9E%8B%E5%8F%B7%E7%AE%80%E4%BB%8B.png" alt="常见GPU型号简介"></p><h2 id="2-3-NVIDIA-TESLA系列"><a href="#2-3-NVIDIA-TESLA系列" class="headerlink" title="2.3 NVIDIA TESLA系列"></a>2.3 NVIDIA TESLA系列</h2><p><img src="http://img.fdchen.host/NVIDIA_TESLA%E7%B3%BB%E5%88%97.png" alt="NVIDIA_TESLA系列"></p><p>数据来源：<a href="https://developer.aliyun.com/article/753454">NVIDIA Tesla GPU系列P4、T4、P40以及V100参数性能对比</a></p><h1 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3 应用场景"></a>3 应用场景</h1><h2 id="3-1-深度学习训练和推理对比"><a href="#3-1-深度学习训练和推理对比" class="headerlink" title="3.1 深度学习训练和推理对比"></a>3.1 深度学习训练和推理对比</h2><p>简单来说，深度学习训练要求高效率计算，深度学习推理除了高效率运算还要求高吞吐量。</p><ul><li>详见博客：<a href="https://blog.csdn.net/IMWTJ123/article/details/114803597">深度学习训练和推理有何不同？</a></li></ul><h1 id="4-云服务器选择"><a href="#4-云服务器选择" class="headerlink" title="4 云服务器选择"></a>4 云服务器选择</h1><h2 id="4-0-租用1小时试用性能再做选择"><a href="#4-0-租用1小时试用性能再做选择" class="headerlink" title="4.0 租用1小时试用性能再做选择"></a>4.0 租用1小时试用性能再做选择</h2><p>有些平台因为CPU内存或者其他限制，会导致同型号的GPU的性能降低，所以在租用长期服务器之前，<strong>应当先租用1-2小时试用性能，比如测试一下模型每运行一个epoch的时间</strong>，再选择合适平台（价格性能都还行）长期租用。</p><h2 id="4-1-腾讯云与阿里云"><a href="#4-1-腾讯云与阿里云" class="headerlink" title="4.1 腾讯云与阿里云"></a>4.1 腾讯云与阿里云</h2><p>这两家云平台是云服务器大户了，可以支持非常高的性能要求，但是价格偏高，建议能够充分利用高性能的高阶“炼丹师”使用，避免因为程序设计问题，导致性能浪费。（如果壕无人性，无脑选也可以）</p><p>附上选购指南：<a href="https://www.yunfuwuqiba.com/gpu/703.html">阿里云GPU服务器和腾讯云GPU服务器实例规格选择方法</a></p><h2 id="4-2-AutoDL"><a href="#4-2-AutoDL" class="headerlink" title="4.2 AutoDL"></a>4.2 AutoDL</h2><p>这家平台优点在于价格亲民，并且是按时计费，还给出了算力排行，可以根据自身需求进行选择。</p><p><strong>AutoDL配置CPU较差，CPU与GPU之间的数据传输效率低，如果是仅仅在平台上的服务器直接运行，不能完全利用GPU性能，运算效率相比其他平台的同型号卡比较低。</strong>但是如果作为多机多卡的分布式训练，或许可以充分利用GPU的性能（有待测试 todo）。</p><p><strong>总结：AutoDL价格便宜，但是作为单一的运行机器，效率较低。</strong></p><p>跳转链接：<a href="https://www.autodl.com/home">AutoDL</a></p><h3 id="4-2-1-部分3090显卡配置的CPU性能对比"><a href="#4-2-1-部分3090显卡配置的CPU性能对比" class="headerlink" title="4.2.1 部分3090显卡配置的CPU性能对比"></a>4.2.1 部分3090显卡配置的CPU性能对比</h3><ul><li>CPU性能评分网址：<a href="https://technical.city/zh/cpu/">https://technical.city/zh/cpu/</a></li></ul><table><thead><tr><th>每GPU分配</th><th>CPU</th><th>性能评分</th><th>包日价格</th></tr></thead><tbody><tr><td>CPU：14核<br/>内存：45GB</td><td>Intel(R) Xeon(R) Gold 6330 CPU @ 2.00GHz</td><td>39.57</td><td>52</td></tr><tr><td>CPU：15核<br/>内存：80GB</td><td>AMD EPYC 7543 32-Core Processor</td><td>51.98</td><td>52</td></tr><tr><td>CPU：10核<br/>内存：64GB</td><td>Intel(R) Xeon(R) Gold 5218R CPU @ 2.10GH</td><td>23.15</td><td>48.75</td></tr><tr><td>CPU：24核<br/>内存：80GB</td><td>AMD EPYC 7642 48-Core Processor</td><td><em>62.26</em></td><td>52</td></tr></tbody></table><h2 id="4-3-矩池云"><a href="#4-3-矩池云" class="headerlink" title="4.3 矩池云"></a>4.3 矩池云</h2><blockquote><p>待评测</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> GPU </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow</title>
      <link href="/2022/python-tensorflow/"/>
      <url>/2022/python-tensorflow/</url>
      
        <content type="html"><![CDATA[<h1 id="0-Linux安装Tensorflow"><a href="#0-Linux安装Tensorflow" class="headerlink" title="0 Linux安装Tensorflow"></a>0 Linux安装Tensorflow</h1><h2 id="0-1-基于Anaconda环境"><a href="#0-1-基于Anaconda环境" class="headerlink" title="0.1 基于Anaconda环境"></a>0.1 基于Anaconda环境</h2><ul><li>创建新的虚拟环境</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda creat -n env_name tensorflow&#x3D;&#x3D;1.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PS：1.14是版本号，1.x需要额外安装tensorflow-gpu</p><ul><li>验证tensorflow是否安装成功</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 窗口输入如下命令conda activate env_namepython  # 进入python环境# python环境下输入import tensorflow as tfprint(tf.__version__)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>1.x版本tensorflow安装tensorflow-gpu</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda install tensorflow-gpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>验证tensorflow-gpu是否安装成功</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python  # 进入python环境# python环境下输入import tensorflow as tfprint(&#39;GPU&#39;,tf.test.is_gpu_available())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_常见用法</title>
      <link href="/2022/python-chang-jian-yong-fa/"/>
      <url>/2022/python-chang-jian-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="0-安装环境"><a href="#0-安装环境" class="headerlink" title="0 安装环境"></a>0 安装环境</h1><ol><li>使用PyCharm打开项目时，默认是base环境，如果自定义了环境，需要修改Python Interpreter。</li></ol><h2 id="0-1-pip相关"><a href="#0-1-pip相关" class="headerlink" title="0.1 pip相关"></a>0.1 pip相关</h2><h3 id="0-1-1-pip不是内部命令问题"><a href="#0-1-1-pip不是内部命令问题" class="headerlink" title="0.1.1 pip不是内部命令问题"></a>0.1.1 pip不是内部命令问题</h3><ul><li>查看是否添加环境变量，没有则添加</li></ul><p>将C:\Program Files (x86)\Python\Python36-32\Scripts添加到环境变量Path中</p><p>原文链接：<a href="https://blog.csdn.net/wochunyang/article/details/52312370">https://blog.csdn.net/wochunyang/article/details/52312370</a></p><h3 id="0-1-2-更换国内pip源"><a href="#0-1-2-更换国内pip源" class="headerlink" title="0.1.2 更换国内pip源"></a>0.1.2 更换国内pip源</h3><ul><li>详见博客：<a href="https://blog.csdn.net/qq_14994573/article/details/80934201">Python 更换国内pip源</a></li></ul><h3 id="0-1-3-更新pip"><a href="#0-1-3-更新pip" class="headerlink" title="0.1.3 更新pip"></a>0.1.3 更新pip</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python -m pip install --upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0-1-4-CentOS-7-x-下载-Python-3-8-x"><a href="#0-1-4-CentOS-7-x-下载-Python-3-8-x" class="headerlink" title="0.1.4 CentOS 7.x 下载 Python 3.8.x"></a>0.1.4 CentOS 7.x 下载 Python 3.8.x</h2><ul><li>详见博客：<a href="https://blog.csdn.net/tony_vip/article/details/107161638">CentOS 7.X 升级 Python 3.8.X</a></li></ul><h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1 基本语法"></a>1 基本语法</h1><h2 id="1-1-查看变量类型，type"><a href="#1-1-查看变量类型，type" class="headerlink" title="1.1 查看变量类型，type()"></a>1.1 查看变量类型，type()</h2><h2 id="1-2-前缀操作与"><a href="#1-2-前缀操作与" class="headerlink" title="1.2 前缀操作与*"></a>1.2 前缀操作<em>与</em>*</h2><p><code>*</code> 和 <code>**</code> 的用法包括：</p><ol><li>使用 <code>*</code> 和 <code>**</code> 向函数传递参数</li><li>使用 <code>*</code> 和 <code>**</code> 捕捉传递至函数的参数</li><li>使用 <code>*</code> 接受 keyword-only 参数</li><li>使用 <code>*</code> 捕捉元组解包过程中的项</li><li>使用 <code>*</code> 将可迭代对象解包至列表&#x2F;元组</li><li>使用 <code>**</code> 将字典解包至其他字典</li></ol><p>原文链接：<a href="https://blog.csdn.net/qq_20084101/article/details/83048688">教你使用 Python 中的星号（*）操作符</a></p><h2 id="1-3-argparse参数解析"><a href="#1-3-argparse参数解析" class="headerlink" title="1.3 argparse参数解析"></a>1.3 argparse参数解析</h2><ul><li>详见博客：<a href="https://cloud.tencent.com/developer/article/1724666">python入门:argparse浅析 nargs&#x3D;’+’作用</a></li></ul><h3 id="1-3-1-Namespace与dict互转"><a href="#1-3-1-Namespace与dict互转" class="headerlink" title="1.3.1 Namespace与dict互转"></a>1.3.1 Namespace与dict互转</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> argparse<span class="token comment"># dict => Namespace</span>dic <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>args <span class="token operator">=</span> argparse<span class="token punctuation">.</span>Namespace<span class="token punctuation">(</span><span class="token operator">**</span><span class="token builtin">dict</span><span class="token punctuation">)</span><span class="token comment"># Namespace => dict</span>dic <span class="token operator">=</span> <span class="token builtin">vars</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2 文件操作"></a>2 文件操作</h1><h2 id="2-1-创建文件和文件夹"><a href="#2-1-创建文件和文件夹" class="headerlink" title="2.1 创建文件和文件夹"></a>2.1 创建文件和文件夹</h2><h3 id="2-1-1-创建文件夹"><a href="#2-1-1-创建文件夹" class="headerlink" title="2.1.1 创建文件夹"></a>2.1.1 创建文件夹</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">### 创建文件夹</span><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">mkdir</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>                   <span class="token comment">#判断是否存在文件夹如果不存在则创建为文件夹</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>path<span class="token punctuation">)</span>            <span class="token comment">#makedirs 创建文件时如果路径不存在会创建这个路径</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---  new folder...  ---"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---  OK  ---"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">print</span> <span class="token string">"---  There is this folder!  ---"</span>file_path <span class="token operator">=</span> <span class="token string">"G:\\xxoo\\test"</span>mkdir<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span>             <span class="token comment">#调用函数</span><span class="token keyword">import</span> os folder <span class="token operator">=</span> os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'new_folder\\test\\'</span><span class="token comment">#获取此py文件路径，在此路径选创建在new_folder文件夹中的test文件夹</span> <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>folder<span class="token punctuation">)</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>folder<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-2-创建文件"><a href="#2-1-2-创建文件" class="headerlink" title="2.1.2 创建文件"></a>2.1.2 创建文件</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os <span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'C:\\Users\Administrator\\Desktop\\'</span> <span class="token operator">+</span> <span class="token string">'new'</span> <span class="token operator">+</span> <span class="token string">'.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-获取文件路径"><a href="#2-2-获取文件路径" class="headerlink" title="2.2 获取文件路径"></a>2.2 获取文件路径</h2><h3 id="2-2-1-获取-py文件路径"><a href="#2-2-1-获取-py文件路径" class="headerlink" title="2.2.1 获取.py文件路径"></a>2.2.1 获取.py文件路径</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-2-获取文件绝对路径"><a href="#2-2-2-获取文件绝对路径" class="headerlink" title="2.2.2 获取文件绝对路径"></a>2.2.2 获取文件绝对路径</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-3-删除文件与文件夹"><a href="#2-3-删除文件与文件夹" class="headerlink" title="2.3 删除文件与文件夹"></a>2.3 删除文件与文件夹</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> shutil os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>path<span class="token punctuation">)</span>   <span class="token comment">#删除文件</span>os<span class="token punctuation">.</span>removedirs<span class="token punctuation">(</span>path<span class="token punctuation">)</span>   <span class="token comment">#删除空文件夹</span>os<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token comment">#删除空文件夹</span><span class="token comment"># os只能删除空文件夹，删除非空文件夹使用shutil</span>shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token comment">#递归删除文件夹，即：删除非空文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原文链接：<a href="https://blog.csdn.net/suibianshen2012/article/details/84303647?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">python 删除文件夹、删除非空文件夹</a></p><h2 id="2-4-csv文件读取"><a href="#2-4-csv文件读取" class="headerlink" title="2.4 csv文件读取"></a>2.4 csv文件读取</h2><h3 id="2-4-1-写入文件，writer-x3D-csv-writer-csvfile"><a href="#2-4-1-写入文件，writer-x3D-csv-writer-csvfile" class="headerlink" title="2.4.1 写入文件，writer &#x3D; csv.writer(csvfile)"></a>2.4.1 写入文件，writer &#x3D; csv.writer(csvfile)</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> csv<span class="token comment">#python2可以用file替代open</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.csv"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>     writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>csvfile<span class="token punctuation">)</span>    <span class="token comment">#先写入columns_name</span>    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"index"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">#写入多行用writerows</span>    writer<span class="token punctuation">.</span>writerows<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-读取文件，reader-x3D-csv-reader-csvfile"><a href="#2-4-2-读取文件，reader-x3D-csv-reader-csvfile" class="headerlink" title="2.4.2 读取文件，reader &#x3D; csv.reader(csvfile)"></a>2.4.2 读取文件，reader &#x3D; csv.reader(csvfile)</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> csv<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.csv"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>csvfile<span class="token punctuation">)</span>    <span class="token comment">#这里不需要readlines</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> reader<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>    <span class="token comment"># 获取文件行数</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-3-不同文件读写模式，’w’-‘a’-‘r’"><a href="#2-4-3-不同文件读写模式，’w’-‘a’-‘r’" class="headerlink" title="2.4.3 不同文件读写模式，’w’, ‘a’, ‘r’"></a>2.4.3 不同文件读写模式，’w’, ‘a’, ‘r’</h3><ul><li>‘w’，表示覆盖，文件不存在会创建</li><li>‘w+’，表示读写，参考’w’，文件不存在会创建，存在会覆盖</li><li>‘a’，追加</li><li>‘a+’，追加且可读</li><li>‘r’，表示读取，文件不存在会报错</li><li>‘r+’，可读可写，若文件不存在，会报错</li></ul><h3 id="2-4-4-保证csv文件存在，with-open-path-‘a-’-as-csvfile"><a href="#2-4-4-保证csv文件存在，with-open-path-‘a-’-as-csvfile" class="headerlink" title="2.4.4 保证csv文件存在，with open(path, ‘a+’) as csvfile"></a>2.4.4 保证csv文件存在，with open(path, ‘a+’) as csvfile</h3><h2 id="2-5-获取文件夹下所有文件"><a href="#2-5-获取文件夹下所有文件" class="headerlink" title="2.5 获取文件夹下所有文件"></a>2.5 获取文件夹下所有文件</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">path <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 不会区分文件与文件夹</span><span class="token comment"># 进一步识别</span><span class="token keyword">for</span> p <span class="token keyword">in</span> path<span class="token punctuation">:</span>    <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 打印文件夹名</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-txt文件读写"><a href="#2-6-txt文件读写" class="headerlink" title="2.6 txt文件读写"></a>2.6 txt文件读写</h2><h3 id="2-6-1-读取txt文件"><a href="#2-6-1-读取txt文件" class="headerlink" title="2.6.1 读取txt文件"></a>2.6.1 读取txt文件</h3><ul><li>一次性读取，read()</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>  <span class="token comment"># 打开文件</span>    data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 读取文件</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>分行读取，readlines()</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    data <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># list列表</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-3-写入txt文件"><a href="#2-6-3-写入txt文件" class="headerlink" title="2.6.3 写入txt文件"></a>2.6.3 写入txt文件</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>string<span class="token punctuation">)</span>  <span class="token comment"># 不会自动分行，如果需要分行，需要在string中人为添加换行符 \n</span><span class="token comment"># 注意如果直接使用f.write('\n')，不会换行会显示'\n'字符</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span>  <span class="token comment"># 正确直接使用写法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3 装饰器"></a>3 装饰器</h1><h2 id="3-1-staticmethod或-classmetho"><a href="#3-1-staticmethod或-classmetho" class="headerlink" title="3.1 @staticmethod或@classmetho"></a>3.1 @staticmethod或@classmetho</h2><ul><li>通常来说，我们使用一个类的方法时，首先要实例化这个类，再用实例化的类来调用其方法</li><li>使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。</li></ul><h1 id="4-matplotlib"><a href="#4-matplotlib" class="headerlink" title="4 matplotlib"></a>4 matplotlib</h1><h2 id="4-1-散点图-matplotlib-pyplot-scatter"><a href="#4-1-散点图-matplotlib-pyplot-scatter" class="headerlink" title="4.1 散点图 matplotlib.pyplot.scatter"></a>4.1 散点图 <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html">matplotlib.pyplot.scatter</a></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> norm<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> vmin<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> vmax<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> linewidths<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> edgecolors<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> plotnonfinite<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> data<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>参数说明：</li></ul><p><strong>x, y</strong>: float or array-like, shape (n, )</p><p>The data positions.</p><p><strong>s</strong>: float or array-like, shape (n, ), optional</p><p>The marker size in points**2. Default is <code>rcParams[&#39;lines.markersize&#39;] ** 2</code>.</p><p><strong>c</strong>: array-like or list of colors or color, optional</p><p>The marker colors. </p><p><strong>marker</strong>: <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.markers.MarkerStyle.html#matplotlib.markers.MarkerStyle"><code>MarkerStyle</code></a>86)</p><p>The marker style. <em>marker</em> can be either an instance of the class or the text shorthand for a particular marker. See <a href="https://matplotlib.org/stable/api/markers_api.html#module-matplotlib.markers"><code>matplotlib.markers</code></a> for more information about marker styles.</p><p><strong>alpha</strong>: float, default: None</p><p>The alpha blending value, between 0 (transparent) and 1 (opaque).</p><h1 id="5-错误和异常"><a href="#5-错误和异常" class="headerlink" title="5 错误和异常"></a>5 错误和异常</h1><h2 id="5-1-assert断言"><a href="#5-1-assert断言" class="headerlink" title="5.1 assert断言"></a>5.1 assert断言</h2><ul><li>语法格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">assert expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等价于：</p><pre class="line-numbers language-none"><code class="language-none">if not expression:    raise AssertionError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>assert 后面也可以紧跟参数:</li></ul><pre class="line-numbers language-none"><code class="language-none">assert expression [, arguments]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等价于：</p><pre class="line-numbers language-none"><code class="language-none">if not expression:    raise AssertionError(arguments)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="6-时间与日期"><a href="#6-时间与日期" class="headerlink" title="6 时间与日期"></a>6 时间与日期</h1><h2 id="6-1-计算Python的代码块或程序的运行时间"><a href="#6-1-计算Python的代码块或程序的运行时间" class="headerlink" title="6.1 计算Python的代码块或程序的运行时间"></a>6.1 计算Python的代码块或程序的运行时间</h2><ul><li>方法一</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> datetimestart <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>run_function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># do something</span>end <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>方法二</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> timestart <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>run_function<span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token builtin">str</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>方法三，推荐使用</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> timestart <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>run_function<span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token builtin">str</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token comment"># Python3.8不再支持time.clock，但在调用时依然包含该方法；需要用用time.perf_counter()替换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-格式化时间，time-strftime-‘-m-d’-time-localtime"><a href="#6-2-格式化时间，time-strftime-‘-m-d’-time-localtime" class="headerlink" title="6.2 格式化时间，time.strftime(‘%m-%d’, time.localtime())"></a>6.2 格式化时间，time.strftime(‘%m-%d’, time.localtime())</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time <span class="token comment"># 格式化成2016-03-20 11:45:39形式</span><span class="token keyword">print</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 格式化成Sat Mar 28 22:24:24 2016形式</span><span class="token keyword">print</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%a %b %d %H:%M:%S %Y"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 将格式字符串转换为时间戳</span>a <span class="token operator">=</span> <span class="token string">"Sat Mar 28 22:24:24 2016"</span><span class="token keyword">print</span> time<span class="token punctuation">.</span>mktime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token string">"%a %b %d %H:%M:%S %Y"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-PyMySQL"><a href="#7-PyMySQL" class="headerlink" title="7 PyMySQL"></a>7 PyMySQL</h1><h2 id="7-1-安装"><a href="#7-1-安装" class="headerlink" title="7.1 安装"></a>7.1 安装</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip3 install PyMySQLpython3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-2-数据库连接"><a href="#7-2-数据库连接" class="headerlink" title="7.2 数据库连接"></a>7.2 数据库连接</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pymysql <span class="token comment"># 打开数据库连接</span>db <span class="token operator">=</span> pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span><span class="token string">"testuser"</span><span class="token punctuation">,</span><span class="token string">"test123"</span><span class="token punctuation">,</span><span class="token string">"TESTDB"</span> <span class="token punctuation">)</span> <span class="token comment"># 使用 cursor() 方法创建一个游标对象 cursor</span>cursor <span class="token operator">=</span> db<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 使用 execute()  方法执行 SQL 查询 </span>cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT VERSION()"</span><span class="token punctuation">)</span> <span class="token comment"># 使用 fetchone() 方法获取单条数据.</span>data <span class="token operator">=</span> cursor<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Database version : %s "</span> <span class="token operator">%</span> data<span class="token punctuation">)</span> <span class="token comment"># 关闭数据库连接</span>db<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-3-增删改查操作"><a href="#7-3-增删改查操作" class="headerlink" title="7.3 增删改查操作"></a>7.3 增删改查操作</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pymysql <span class="token comment"># 打开数据库连接</span>db <span class="token operator">=</span> pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span><span class="token string">"testuser"</span><span class="token punctuation">,</span><span class="token string">"test123"</span><span class="token punctuation">,</span><span class="token string">"TESTDB"</span> <span class="token punctuation">)</span> <span class="token comment"># 使用cursor()方法获取操作游标 </span>cursor <span class="token operator">=</span> db<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">### 具体执行语句放在此处 ###</span> <span class="token comment"># 关闭数据库连接</span>db<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>插入</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># SQL 插入语句</span>sql <span class="token operator">=</span> <span class="token triple-quoted-string string">"""INSERT INTO EMPLOYEE(FIRST_NAME,         LAST_NAME, AGE, SEX, INCOME)         VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""</span><span class="token keyword">try</span><span class="token punctuation">:</span>   <span class="token comment"># 执行sql语句</span>   cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>   <span class="token comment"># 提交到数据库执行</span>   db<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>   <span class="token comment"># 如果发生错误则回滚</span>   db<span class="token punctuation">.</span>rollback<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># SQL 删除语句</span>sql <span class="token operator">=</span> <span class="token string">"DELETE FROM EMPLOYEE WHERE AGE > %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>   <span class="token comment"># 执行SQL语句</span>   cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>   <span class="token comment"># 提交修改</span>   db<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>   <span class="token comment"># 发生错误时回滚</span>   db<span class="token punctuation">.</span>rollback<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># SQL 更新语句</span>sql <span class="token operator">=</span> <span class="token string">"UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token string">'M'</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>   <span class="token comment"># 执行SQL语句</span>   cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>   <span class="token comment"># 提交到数据库执行</span>   db<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>   <span class="token comment"># 发生错误时回滚</span>   db<span class="token punctuation">.</span>rollback<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查询<ul><li><strong>fetchone():</strong> 该方法获取下一个查询结果集。结果集是一个对象</li><li><strong>fetchall():</strong> 接收全部的返回结果行.</li><li><strong>rowcount:</strong> 这是一个只读属性，并返回执行execute()方法后影响的行数。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># SQL 查询语句</span>sql <span class="token operator">=</span> "SELECT <span class="token operator">*</span> FROM EMPLOYEE \       WHERE INCOME <span class="token operator">></span> <span class="token operator">%</span>s" <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>   <span class="token comment"># 执行SQL语句</span>   cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>   <span class="token comment"># 获取所有记录列表</span>   results <span class="token operator">=</span> cursor<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> row <span class="token keyword">in</span> results<span class="token punctuation">:</span>      fname <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>      lname <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>      age <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>      sex <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>      income <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>       <span class="token comment"># 打印结果</span>      <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"fname=%s,lname=%s,age=%s,sex=%s,income=%s"</span> <span class="token operator">%</span> \             <span class="token punctuation">(</span>fname<span class="token punctuation">,</span> lname<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> income <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Error: unable to fetch data"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8 字符串"></a>8 字符串</h1><h2 id="8-1-其他类型转为字符串"><a href="#8-1-其他类型转为字符串" class="headerlink" title="8.1 其他类型转为字符串"></a>8.1 其他类型转为字符串</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-2-字符串前面的u-r-b-f"><a href="#8-2-字符串前面的u-r-b-f" class="headerlink" title="8.2 字符串前面的u,r,b,f"></a>8.2 字符串前面的u,r,b,f</h2><ol><li><strong>字符串前加 u</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token string">u"我是含有中文字符组成的字符串。"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>作用：后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。</p><ol start="2"><li><strong>字符串前加 r</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">r"\n\n\n\n”　　<span class="token comment"># \n表示一个普通生字符串 \n\n\n\n，而不表示换行了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>作用：加r, 则表示’\n\n\n\n’字符 ，表示不用转义；不加r, 转义，则变成了换行。</p><p>应用：常用于正则表达式，对应着re模块。</p><ol start="3"><li><strong>字符串前加 b</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">response <span class="token operator">=</span> <span class="token string">b'&lt;h1>Hello World!&lt;/h1>'</span>   <span class="token comment"># b' ' 表示这是一个 bytes 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>作用： b” “前缀表示后面字符串是bytes 类型。</p><p>用处：网络编程中，服务器和浏览器只认bytes 类型数据。</p><p>如：send 函数的参数和 recv 函数的返回值都是 bytes 类型</p><p>附：</p><p>在 Python3 中，bytes 和 str 的互相转换方式是</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token builtin">bytes</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><strong>字符串前加 f</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> timet0 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>name <span class="token operator">=</span> <span class="token string">'processing'</span><span class="token comment"># 以f开头表示在字符串内支持大括号内的python 表达式</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string"> done in </span><span class="token interpolation"><span class="token punctuation">&#123;</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t0<span class="token punctuation">:</span><span class="token format-spec">.2f</span><span class="token punctuation">&#125;</span></span><span class="token string"> s'</span></span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出：</strong>processing done in 1.00 s</p><h1 id="9-pickle数据持久存储"><a href="#9-pickle数据持久存储" class="headerlink" title="9 pickle数据持久存储"></a>9 pickle数据持久存储</h1><p>python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><h2 id="9-1-读取-写入-文件"><a href="#9-1-读取-写入-文件" class="headerlink" title="9.1 读取\写入 文件"></a>9.1 读取\写入 文件</h2><ul><li><p>pickle.dump(obj, file, [,protocol])</p><p>注解：将对象obj保存到文件file中去。<br>参数：</p><ul><li>protocol为序列化使用的协议版本。0：ASCII协议，所序列化的对象使用可打印的ASCII码表示；1：老式的二进制协议；2：2.3版本引入的新二进制协议，较以前的更高效。其中协议0和1兼容老版本的python。protocol默认值为0。</li><li>file：对象保存到的类文件对象。file必须有write()接口， file可以是一个以’w’方式打开的文件或者一个StringIO对象或者其他任何实现write()接口的对象。如果protocol&gt;&#x3D;1，文件对象需要是二进制模式打开的。</li></ul></li><li><p>pickle.load(file)<br>注解：从file中读取一个字符串，并将它重构为原来的python对象。<br>参数：</p><ul><li>file:类文件对象，有read()和readline()接口。</li></ul></li></ul><h1 id="10-tqdm"><a href="#10-tqdm" class="headerlink" title="10 tqdm"></a>10 tqdm</h1><p>Tqdm 是一个快速，可扩展的Python进度条，可以在 Python 长循环中添加一个进度提示信息，用户只需要封装任意的迭代器 tqdm(iterator)。</p><h1 id="11-字典dict"><a href="#11-字典dict" class="headerlink" title="11 字典dict"></a>11 字典dict</h1><h2 id="11-1-update"><a href="#11-1-update" class="headerlink" title="11.1 update()"></a>11.1 update()</h2><p>把字典dict2的键&#x2F;值对更新到dict里。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">dict</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>dict2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-2-get"><a href="#11-2-get" class="headerlink" title="11.2 get()"></a>11.2 get()</h2><p>返回指定键的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">dict</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数：</strong></p><ul><li>key – 字典中要查找的键。</li><li>default – 如果指定键的值不存在时，返回该默认值。</li></ul><h2 id="11-3-按key删除元素，pop-key"><a href="#11-3-按key删除元素，pop-key" class="headerlink" title="11.3 按key删除元素，pop(key)"></a>11.3 按key删除元素，pop(key)</h2><h1 id="12-字符串str"><a href="#12-字符串str" class="headerlink" title="12 字符串str"></a>12 字符串str</h1><h2 id="12-1-移除字符串头尾指定的字符，strip"><a href="#12-1-移除字符串头尾指定的字符，strip" class="headerlink" title="12.1 移除字符串头尾指定的字符，strip()"></a>12.1 移除字符串头尾指定的字符，strip()</h2><p>Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p><h2 id="12-2-eval"><a href="#12-2-eval" class="headerlink" title="12.2 eval()"></a>12.2 eval()</h2><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>x <span class="token operator">=</span> <span class="token number">7</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">eval</span><span class="token punctuation">(</span> <span class="token string">'3 * x'</span> <span class="token punctuation">)</span><span class="token number">21</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'pow(2,2)'</span><span class="token punctuation">)</span><span class="token number">4</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">'2 + 2'</span><span class="token punctuation">)</span><span class="token number">4</span><span class="token operator">>></span><span class="token operator">></span> n<span class="token operator">=</span><span class="token number">81</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">"n + 4"</span><span class="token punctuation">)</span><span class="token number">85</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-3-寻找子串，index-与find"><a href="#12-3-寻找子串，index-与find" class="headerlink" title="12.3 寻找子串，index()与find()"></a>12.3 寻找子串，index()与find()</h2><p>如果找不到目标子串，index会报错，find会返回-1</p><p>原文链接：<a href="https://www.cnblogs.com/sea-stream/p/11273317.html">python find和index的区别</a></p><h2 id="12-4-字符串切割，str-split-‘-‘"><a href="#12-4-字符串切割，str-split-‘-‘" class="headerlink" title="12.4 字符串切割，str.split(‘ ‘)"></a>12.4 字符串切割，str.split(‘ ‘)</h2><h2 id="12-5-多种字符替换为一个字符，re-sun-r’-gt-’-‘-‘-str"><a href="#12-5-多种字符替换为一个字符，re-sun-r’-gt-’-‘-‘-str" class="headerlink" title="12.5 多种字符替换为一个字符，re.sun(r’[&gt;*#]’, ‘ ‘,str)"></a>12.5 多种字符替换为一个字符，re.sun(r’[&gt;*#]’, ‘ ‘,str)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> rea<span class="token operator">=</span><span class="token string">'fs233*bb>>c##ad'</span>re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r'[\*>#]'</span><span class="token punctuation">,</span><span class="token string">'-'</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment">### 输出结果 ###</span>fs233bbcad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>re.sub() 的第一个参数是pattern，使用正则表达式，所以例子中 [*&gt;#] 代表 [] 中的任何一个字符，即替换a中*&gt;# 为’ ‘。</p><p>原文链接：<a href="https://blog.csdn.net/qq_29869111/article/details/102623640">python多种字符替换为一个字符</a></p><h2 id="12-6-字符串整体替换，replace-substr-str"><a href="#12-6-字符串整体替换，replace-substr-str" class="headerlink" title="12.6 字符串整体替换，replace(substr, str)"></a>12.6 字符串整体替换，replace(substr, str)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">'akakak'</span><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'k'</span><span class="token punctuation">,</span><span class="token string">' 8'</span><span class="token punctuation">)</span><span class="token comment"># 将字符串里的k全部替换为8</span><span class="token keyword">print</span> <span class="token builtin">str</span><span class="token operator">>></span> <span class="token string">'a8a8a8'</span><span class="token comment"># 输出结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="13-列表List"><a href="#13-列表List" class="headerlink" title="13 列表List"></a>13 列表List</h1><h2 id="13-1-在列表末尾一次性追加另一个序列中的多个值，extend"><a href="#13-1-在列表末尾一次性追加另一个序列中的多个值，extend" class="headerlink" title="13.1 在列表末尾一次性追加另一个序列中的多个值，extend()"></a>13.1 在列表末尾一次性追加另一个序列中的多个值，extend()</h2><p>extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。</p><h2 id="13-2-去掉列表中的一个元素（默认最后一个元素），pop-index"><a href="#13-2-去掉列表中的一个元素（默认最后一个元素），pop-index" class="headerlink" title="13.2 去掉列表中的一个元素（默认最后一个元素），pop(index)"></a>13.2 去掉列表中的一个元素（默认最后一个元素），pop(index)</h2><p>去掉列表中的一个元素（默认最后一个元素）</p><h2 id="13-3-将list与元组放置在一个list中"><a href="#13-3-将list与元组放置在一个list中" class="headerlink" title="13.3 将list与元组放置在一个list中"></a>13.3 将list与元组放置在一个list中</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">each_data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>data0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> j <span class="token keyword">in</span> each_data<span class="token punctuation">:</span>    data0<span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>  <span class="token comment"># 正确用法 [(0, 1), 4, 5]</span>    data1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">+</span>each_data  <span class="token comment"># 正确用法 [(0, 1), 4, 5] ，但是要求each_data要为list，不能为ndarray等</span>data2 <span class="token operator">=</span><span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>each_data<span class="token punctuation">]</span>  <span class="token comment"># 错误用法，[(0, 1), [2, 3, 4]]</span>data3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>each_data<span class="token punctuation">]</span> <span class="token comment"># 错误用法 [[0, 1], [2, 3, 4]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-4-生成tuple必须从其他序列转为tuple"><a href="#13-4-生成tuple必须从其他序列转为tuple" class="headerlink" title="13.4 生成tuple必须从其他序列转为tuple"></a>13.4 生成tuple必须从其他序列转为tuple</h2><h2 id="13-5-list包含数字，不能直接转化成字符串"><a href="#13-5-list包含数字，不能直接转化成字符串" class="headerlink" title="13.5 list包含数字，不能直接转化成字符串"></a>13.5 list包含数字，不能直接转化成字符串</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'%s'</span> <span class="token operator">%</span><span class="token builtin">id</span> <span class="token keyword">for</span> <span class="token builtin">id</span> <span class="token keyword">in</span> list1<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="13-6-负数索引，从后往前索引"><a href="#13-6-负数索引，从后往前索引" class="headerlink" title="13.6 负数索引，从后往前索引"></a>13.6 负数索引，从后往前索引</h2><h2 id="13-7-同时遍历两个list，zip"><a href="#13-7-同时遍历两个list，zip" class="headerlink" title="13.7 同时遍历两个list，zip()"></a>13.7 同时遍历两个list，zip()</h2><h2 id="13-8-切片，list-start-end-step"><a href="#13-8-切片，list-start-end-step" class="headerlink" title="13.8 切片，list[start : end : step]"></a>13.8 切片，list[start : end : step]</h2><p>start是包含的，end是不包含的。 str、tuple都可以进行切片操作</p><h2 id="13-9-指定位置插入元素，list-insert-index-item"><a href="#13-9-指定位置插入元素，list-insert-index-item" class="headerlink" title="13.9 指定位置插入元素，list.insert(index,item)"></a>13.9 指定位置插入元素，list.insert(index,item)</h2><h2 id="13-10-拼接成字符串，’-‘-join-list"><a href="#13-10-拼接成字符串，’-‘-join-list" class="headerlink" title="13.10 拼接成字符串，’ ‘.join(list)"></a>13.10 拼接成字符串，’ ‘.join(list)</h2><ol><li>列表里面的元素必须全是字符串才可以使用join()进行拼接</li><li>返回的是一个字符串</li></ol><p>原文链接：<a href="https://www.cnblogs.com/lowmanisbusy/p/10212465.html">Python 将一个列表里面的元素拼接成一个字符串</a></p><h2 id="13-11-添加多个元素，extend"><a href="#13-11-添加多个元素，extend" class="headerlink" title="13.11 添加多个元素，extend()"></a>13.11 添加多个元素，extend()</h2><ul><li>append一个list时，会把list当作整体添加</li><li>extend一个list时，会把list内所有元素逐个添加</li></ul><h1 id="14-数字Number"><a href="#14-数字Number" class="headerlink" title="14 数字Number"></a>14 数字Number</h1><h2 id="14-1-round"><a href="#14-1-round" class="headerlink" title="14.1 round()"></a>14.1 round()</h2><p><strong>round()</strong> 方法返回浮点数x的四舍五入值。</p><h1 id="15-内存管理"><a href="#15-内存管理" class="headerlink" title="15 内存管理"></a>15 内存管理</h1><h2 id="15-1-手动释放内存，del-gc-collect"><a href="#15-1-手动释放内存，del-gc-collect" class="headerlink" title="15.1 手动释放内存，del + gc.collect()"></a>15.1 手动释放内存，del + gc.collect()</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> gc<span class="token keyword">del</span> agc<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="16-Json数据"><a href="#16-Json数据" class="headerlink" title="16 Json数据"></a>16 Json数据</h1><h2 id="16-1-Json数据与普通数据的互转"><a href="#16-1-Json数据与普通数据的互转" class="headerlink" title="16.1 Json数据与普通数据的互转"></a>16.1 Json数据与普通数据的互转</h2><p>JSON 值可以是：</p><ol><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment"># 对数据进行编码。</span>json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>json_data<span class="token punctuation">)</span>  <span class="token comment">#对数据进行解码。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="17-异常处理"><a href="#17-异常处理" class="headerlink" title="17 异常处理"></a>17 异常处理</h1><h2 id="17-1-try-except-finally"><a href="#17-1-try-except-finally" class="headerlink" title="17.1 try-except-finally"></a>17.1 try-except-finally</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    divide<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"divide by 0"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"the code is no problem"</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is finally code,i'm running"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原文链接：<a href="https://blog.csdn.net/lwgkzl/article/details/81059433">https://blog.csdn.net/lwgkzl/article/details/81059433</a></p><h1 id="18-随机数"><a href="#18-随机数" class="headerlink" title="18 随机数"></a>18 随机数</h1><h2 id="18-1-无重复随机采样，random-sample-list-k"><a href="#18-1-无重复随机采样，random-sample-list-k" class="headerlink" title="18.1 无重复随机采样，random.sample(list, k)"></a>18.1 无重复随机采样，random.sample(list, k)</h2><h2 id="18-2-赋权采样，random-choices-population-weights-x3D-None"><a href="#18-2-赋权采样，random-choices-population-weights-x3D-None" class="headerlink" title="18.2 赋权采样，random.choices(population, weights&#x3D;None)"></a>18.2 赋权采样，random.choices(population, weights&#x3D;None)</h2><h1 id="19-安装setup"><a href="#19-安装setup" class="headerlink" title="19 安装setup"></a>19 安装setup</h1><h2 id="19-1-setup配置参数详解与实例"><a href="#19-1-setup配置参数详解与实例" class="headerlink" title="19.1 setup配置参数详解与实例"></a>19.1 setup配置参数详解与实例</h2><ul><li>详见博客：<a href="https://zhuanlan.zhihu.com/p/276461821">花了两天，终于把 Python 的 setup.py 给整明白了</a></li></ul><p>（因为目前还没有需求，所以只引用他人博客）</p><h2 id="19-2-安装setup"><a href="#19-2-安装setup" class="headerlink" title="19.2 安装setup"></a>19.2 安装setup</h2><pre class="line-numbers language-she" data-language="she"><code class="language-she">python setup.py buildpython setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="19-3-报错package找不到"><a href="#19-3-报错package找不到" class="headerlink" title="19.3 报错package找不到"></a>19.3 报错package找不到</h2><ul><li><p>注意在需要导入模块的根目录添加__init__.py文件（里面可以不含任何内容）</p></li><li><p>其他原因详见博客：<a href="https://blog.csdn.net/GungnirsPledge/article/details/107586458">python找不到包的总结: ImportError: No module named</a></p></li></ul><h1 id="20-元组"><a href="#20-元组" class="headerlink" title="20 元组"></a>20 元组</h1><h2 id="20-1-有名元组"><a href="#20-1-有名元组" class="headerlink" title="20.1 有名元组"></a>20.1 有名元组</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple<span class="token operator">>></span><span class="token operator">></span> Student <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Student'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">,</span> <span class="token string">'email'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Jim'</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token string">'male'</span><span class="token punctuation">,</span> <span class="token string">'123@qq.com'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>name<span class="token string">'Jim'</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>age<span class="token number">21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="21-可视化matplotlib"><a href="#21-可视化matplotlib" class="headerlink" title="21 可视化matplotlib"></a>21 可视化matplotlib</h1><h2 id="21-1-热力图-seaborn"><a href="#21-1-热力图-seaborn" class="headerlink" title="21.1 热力图 seaborn"></a>21.1 热力图 seaborn</h2><ul><li><p>官方文档：<a href="http://seaborn.pydata.org/generated/seaborn.heatmap.html?highlight=heatmap#seaborn.heatmap">seaborn.heatmap</a></p></li><li><p>基本用法</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token punctuation">;</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token punctuation">;</span> sns<span class="token punctuation">.</span>set_theme<span class="token punctuation">(</span><span class="token punctuation">)</span>uniform_data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>uniform_data<span class="token punctuation">)</span>  <span class="token comment"># 输入二维数据即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Python自带颜色条colormap：<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTg0MjczNw==&mid=2247484329&idx=1&sn=20ec36f7f5077221671b32d47c3412c8&chksm=f90d47f7ce7acee11449c5584a11a020cf05c27f7a60b9357bbdc35181cc7e8420c594d09fc5&scene=158#rd">Python可视化|matplotlib07-自带颜色条Colormap（三）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习项目搭建与训练技巧</title>
      <link href="/2022/ai-shen-du-xue-xi-xiang-mu-da-jian-yu-xun-lian-ji-qiao/"/>
      <url>/2022/ai-shen-du-xue-xi-xiang-mu-da-jian-yu-xun-lian-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="0-核心思想"><a href="#0-核心思想" class="headerlink" title="0 核心思想"></a>0 核心思想</h1><h2 id="0-1-尽可能地用计算机代替人工完成任务"><a href="#0-1-尽可能地用计算机代替人工完成任务" class="headerlink" title="0.1 尽可能地用计算机代替人工完成任务"></a>0.1 尽可能地用计算机代替人工完成任务</h2><p>虽然在短期需要一些额外的工作，但是长远开看可以节省很多的时间和成本。</p><h2 id="0-2-当出现问题时，不用凑合的办法修正，去找到出现问题的原因，或许会有意外的收获"><a href="#0-2-当出现问题时，不用凑合的办法修正，去找到出现问题的原因，或许会有意外的收获" class="headerlink" title="0.2 当出现问题时，不用凑合的办法修正，去找到出现问题的原因，或许会有意外的收获"></a>0.2 当出现问题时，不用凑合的办法修正，去找到出现问题的原因，或许会有意外的收获</h2><h2 id="0-3-在工程上，先解决80-的问题，在慢慢解决剩下20-的文图"><a href="#0-3-在工程上，先解决80-的问题，在慢慢解决剩下20-的文图" class="headerlink" title="0.3 在工程上，先解决80%的问题，在慢慢解决剩下20%的文图"></a>0.3 在工程上，先解决80%的问题，在慢慢解决剩下20%的文图</h2><h2 id="0-4-科学炼丹——快、准、稳"><a href="#0-4-科学炼丹——快、准、稳" class="headerlink" title="0.4 科学炼丹——快、准、稳"></a>0.4 科学炼丹——快、准、稳</h2><blockquote><p>原文链接：<a href="https://mp.weixin.qq.com/s/HOgdhAzyti0N2TZBmt_4Iw">别再喊我调参侠!夕小瑶”科学炼丹”手册了解一下</a></p></blockquote><h3 id="0-4-1-“准”字诀"><a href="#0-4-1-“准”字诀" class="headerlink" title="0.4.1 “准”字诀"></a>0.4.1 “准”字诀</h3><ol><li><strong>做好调研，找准起点</strong></li></ol><p>在开始调研之前，先定位算法问题所对口的学术会议或期刊，如下：</p><ul><li><strong>query-doc相关性匹配</strong>：SIGIR，CIKM等IR强相关的会议，而不是NLP的会议；</li><li><strong>NLI、问答、对话等语义匹配问题</strong>：ACL、EMNLP、NAACL、COLING等NLP会议，而不是IR会议；</li><li><strong>改进算法模型问题</strong>：ICLR、NIPS等深度学习、神经网络会议</li><li><strong>无法找到对口的问题：</strong>AAAI和IJCAI会议</li></ul><p>但是定位会议是为寻找相关模型服务的，在定位好对口的期刊或会议后，<strong>寻找几篇近两年内发表的跟待解决问题相接近的paper，了解这些paper后，追根朔源，通过这些paper里的related work与实验的baselines章节，了解到该算法问题更早的工作。</strong></p><ol start="2"><li><strong>构建策略迭代闭环，找准努力方向</strong></li></ol><p>一个比较通用的迭代闭环是：</p><p><strong>数据集分析 - 预处理策略 - 算法策略 - 模型评价 - case study</strong></p><p><strong>（1）数据集分析</strong></p><p>在开始之前对数据集做个简单的分析，可能有助于大大降低之后的体力劳动（提前排除不靠谱的策略和不敏感的超参数），并大大降低<br>初次接触新任务时犯致命错误的概率。</p><p><strong>（2）预处理策略与算法策略</strong></p><p>这个环节最直接方法就是搬运上一节的调研结果，将一些paper中比较有效的策略搬过来进行验证。不过，<strong>尤其是注意一个meaningful的问题，即搬运这个策略，甚至设计一个新的策略，目的是什么？要解决什么问题？</strong>毕竟很多paper中的策略的适用场景是很局限的，毫无目的的搬运可能会大大增加无用功。同时，这也是避免“结果主义”（魔改的模型结果好再去找原因）炼丹。<strong>因此在调研时，面对不同的模型，也要学会思考背后的理论原理或数学逻辑，才能深刻理解模型。也可以方便自己思考新的解决方案</strong></p><p><strong>（3）模型评价</strong></p><p>业务中可能有一些模棱两可的算法任务，如何无偏地评价一个模型的好坏，就需要在大规模开搞之前仔细设计清楚了。没有一个客观、无偏且自动的评价指标，策略迭代无疑会非常缓慢甚至到后期推翻重来。</p><p>即便是有一些常用的指标，也要经过你自己的思考之后再决定是否采用。</p><p><strong>（4）case study</strong></p><p>简单的说，<strong>case study就是针对犯的错误，进行反思和总结，分析原因，吸取经验和教训，给出改进措施，保证以后不再犯相同的错误或者类似的错误。</strong><br>每一次尝试之后都要做case study，同时做好记录（可见后文），这样可以不断减少无用功。</p><ol start="3"><li><strong>重视bug，找准翻车原因</strong></li></ol><p>实际上，在策略迭代过程中，刚实现一个策略时，非常容易出现bug，当初步模型效果不好时，优先考虑是存在bug。<strong>一方面可以通过打印中间过程结果检查，一方面可以通过观察模型效果检查。</strong><br>有时候调参和使用一些算法策略可以缓解bug带来的影响，导致小白误以为继续卖力的调参和疯狂试错就一定能把这个鸿沟填平。实际上，比起算法和超参，bug往往致命的多。当然了，对于一些特殊的算法问题（比如众所周知的RL问题），超参数确实极其敏感，需要具体问题具体分析。</p><h3 id="0-4-2-“快”字诀"><a href="#0-4-2-“快”字诀" class="headerlink" title="0.4.2 “快”字诀"></a>0.4.2 “快”字诀</h3><ol><li><strong>摆脱“洁癖”，提高写代码速度</strong></li></ol><p>算法探索具有极强的不确定性，很可能你写了半天的代码最后由于不work而完全废弃，因此，从代码风格上来说，<strong>一定要避免把代码写成系统，各种面向对象的封装技巧一顿乱怼是非常不必要的。</strong><br>允许一些”垃圾代码“的存在可以大大提高实验迭代的效率。</p><ul><li><strong>如何利用”垃圾代码片段“</strong></li></ul><p>（1）最简单的方法是<strong>直接使用粘合剂”Bash Script”。即将功能零散的代码片段通过bash管道命令连接起来，这样还能通过”&amp;”+wait命令的组合拳实现对大规模数据集的（多进程）并行处理。</strong></p><p>（2）<strong>对shell实在不熟悉的也可以使用jupyter notebook来进行粘合。</strong>不过，强烈建议每个NLP算法工程师熟练使用bash和vim，相当多的数据处理和分析是不需要使用python的，习惯了之后这些bash命令和vim技巧会对炼丹效率有非常明显的提升。</p><p>（3）<strong>对于更加碎片化的小代码(比如边分析边修改逻辑生成一个小字典)，则可以考虑使用ipython，完成任务后一条magic命令%save就让这些碎片代码变得可复用了。</strong></p><ol start="2"><li><strong>分规模验证，快速完成实验</strong></li></ol><p>Debug的四个阶段：</p><p><strong>第一阶段：调通代码。</strong>可以通过<strong>人为捏造有规律的少量几条数据，修正代码的语法错误与逻辑错误。</strong></p><p><strong>第二阶段：验证收敛性。</strong>在数据集中<strong>取出几百或几千条样本进行训练，看看若干epoch之后训练loss是否能降低到接近0。</strong></p><p><strong>第三阶段：小规模实验。在万级或十万级别的小样本集上验证模型表现，分析超参数敏感性，并且调整超参数取值。</strong>这一阶段在数据规模不大时（比如几十万或者一二百万）其实可有可无，当训练数据集非常大（亿级别）还是有必要的。</p><p><strong>第四阶段：大规模实验。即有多少训练数据就上多少，甚至多训练几个epoch。此时应该保证代码是高度靠谱，基本无需调参的，否则试错代价往往难以承受。</strong></p><ol start="3"><li><strong>理性调参，把算力和时间留给策略探索</strong></li></ol><p>超参数和所处环境，有的与网络结构和预训练模型强耦合等等。因此，调参的第一步， 也是<strong>最重要的一步是进行超参数敏感性分析，找到对当前任务性能影响最大的几个超参数之后再进行精调。</strong></p><p><strong>要确定各个超参数的敏感性，一方面可以根据自身经验来定，一方面可以根据各paper中的取值（差异大的超参数可能是敏感超参，大家都取值相同的一般不敏感）</strong>，实在不确定， 跑两三组实验就够确定敏感性了，完全没有必要来个“网格搜索”。</p><h3 id="0-4-3-”稳“字诀"><a href="#0-4-3-”稳“字诀" class="headerlink" title="0.4.3 ”稳“字诀"></a>0.4.3 ”稳“字诀</h3><ol><li><strong>实验管理与代码管理</strong></li></ol><p><strong>实验管理就是要记录下来每一次实验的策略名和对应的实验结果，一般以表格的形式记录。</strong>这里可以用excel、markdown编辑器等记录，当然更建议使用支持云端同步的工具来记录(比如语雀、石墨文档、印象笔记或内网的相关工具等)，以防电脑被偷、文件误删等意外导致的悲剧。<br>但是，有时候实验着急，对策略的描述不够仔细怎么办？比如某次实验同时改变了具体策略、还改了超参数、预训练模型等一堆东西， 不能用一个名字概括全部，怎么办呢?<br><strong>最简单的做法就是与版本管理工具配合，再也不用担心未来settings丢失、 模型无法复现、模型无法追溯环境等问题了。而要实现版本管理，也很简单，Git自 然是不二之选。</strong></p><ul><li><strong>怎么用Git管理版本和实验迭代呢？</strong></li></ul><p>首先，<strong>务必保证训练日志、eval日志是以文件的形式存了下来，而不是打印到屏幕上变成过眼云烟了；此外,需要保证每一次运行时的settings （比如超参数、数据集版本、ckpt存储路径等）都能保存到日志文件中，且尽量封装一个run.sh来维护训练任务的启动环境。</strong></p><p>接下来看每个人自己的习惯，此处引用原文作者的习惯：</p><p><strong>（1）主线策略每成功推进一步，就调用git tag打个tag。</strong>这里的tag即策略名，与实验管理的表格中的策略名对齐。</p><p><strong>（2）如果要在某个策略的基础上尝试一个很不靠谱的探索，那么可以在当前策略的基础上拉一个分支出来，在这个分支上完成相应事情后切回主分支。</strong>当然啦，万一这个分支上的策略work了，就可以考虑将其转正，合入主分支并打上相关tag。</p><p><strong>最后一定要记得做好备份工作，即周期性的将环境中的关键代码push到github等远程仓库。</strong>当然了，对于ckpt、数据集这种大型文件，可以写入.gitignore文件中以免把仓库撑爆，这些大型文件的最佳归宿当然就是hadoop集群啦。</p><blockquote><p>更多Git使用技巧参考：<a href="https://mp.weixin.qq.com/s/z_zFveiiLu9vLvWuBcsaIg">Git从入门到进阶，你想要的全在这里</a></p></blockquote><h1 id="1-Pytorch使用"><a href="#1-Pytorch使用" class="headerlink" title="1 Pytorch使用"></a>1 Pytorch使用</h1><h2 id="1-1-torch-sparse-mm-无法反向传播"><a href="#1-1-torch-sparse-mm-无法反向传播" class="headerlink" title="1.1 torch.sparse.mm 无法反向传播"></a>1.1 torch.sparse.mm 无法反向传播</h2><h2 id="1-2-drpout一般发生在training阶段，Pytorch模型可通过self-training获取状态"><a href="#1-2-drpout一般发生在training阶段，Pytorch模型可通过self-training获取状态" class="headerlink" title="1.2 drpout一般发生在training阶段，Pytorch模型可通过self.training获取状态"></a>1.2 drpout一般发生在training阶段，Pytorch模型可通过self.training获取状态</h2><ul><li>self.training通过model.train() &#x2F; model.eval() 设置值</li></ul><h2 id="1-3-Pytorch的tensor数值与一般的int等基本数据类型不同，注意用-item-统一类型"><a href="#1-3-Pytorch的tensor数值与一般的int等基本数据类型不同，注意用-item-统一类型" class="headerlink" title="1.3 Pytorch的tensor数值与一般的int等基本数据类型不同，注意用.item()统一类型"></a>1.3 Pytorch的tensor数值与一般的int等基本数据类型不同，注意用.item()统一类型</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">### train_label 为 doK_matrix (0,0) 1.0</span><span class="token comment">### users=tensor([0,0,0])</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> train_label <span class="token comment"># True</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> train_label  <span class="token comment"># False</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> train_label  <span class="token comment"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-调整超参"><a href="#2-调整超参" class="headerlink" title="2 调整超参"></a>2 调整超参</h1><h2 id="2-1-模型第一次完整运行注意打印关键信息，否则可能长时间无响应"><a href="#2-1-模型第一次完整运行注意打印关键信息，否则可能长时间无响应" class="headerlink" title="2.1 模型第一次完整运行注意打印关键信息，否则可能长时间无响应"></a>2.1 模型第一次完整运行注意打印关键信息，否则可能长时间无响应</h2><h2 id="2-2-为节省时间，避免用循环，尽量用矩阵操作"><a href="#2-2-为节省时间，避免用循环，尽量用矩阵操作" class="headerlink" title="2.2 为节省时间，避免用循环，尽量用矩阵操作"></a>2.2 为节省时间，避免用循环，尽量用矩阵操作</h2><p>循环操作虽然只增加2-3秒，但是在大数据集下，会显得尤为突出，2-3秒在很多个batch下会被放大</p><h2 id="2-3-模型的内容尽量写在forward里，避免不断地调用函数"><a href="#2-3-模型的内容尽量写在forward里，避免不断地调用函数" class="headerlink" title="2.3 模型的内容尽量写在forward里，避免不断地调用函数"></a>2.3 模型的内容尽量写在forward里，避免不断地调用函数</h2><p>当数据集大时会非常损耗时间，本来1秒的运行时间可能会因为循环调用函数变成10+秒，甚至重复操作也比重复调用函数来得快</p><h2 id="2-6-train-data一定要shuffle，使得loss更新"><a href="#2-6-train-data一定要shuffle，使得loss更新" class="headerlink" title="2.6 train data一定要shuffle，使得loss更新"></a>2.6 train data一定要shuffle，使得loss更新</h2><h2 id="2-7-报错-WARNING-root-NaN-or-Inf-found-in-input-tensor"><a href="#2-7-报错-WARNING-root-NaN-or-Inf-found-in-input-tensor" class="headerlink" title="2.7 报错 WARNING:root:NaN or Inf found in input tensor."></a>2.7 报错 WARNING:root:NaN or Inf found in input tensor.</h2><h3 id="2-7-1-寻找梯度消失的位置与原因"><a href="#2-7-1-寻找梯度消失的位置与原因" class="headerlink" title="2.7.1 寻找梯度消失的位置与原因"></a>2.7.1 寻找梯度消失的位置与原因</h3><ul><li><strong>大概Debug步骤</strong></li></ul><ol><li>通过打印梯度，找到最先出现nan值的地方</li><li>找到出现nan值地方后，根据下面可能的原因一一排查</li></ol><ul><li><strong>通过如下代码可以打印梯度，可以快速找到梯度从哪里开始出现nan值</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> name<span class="token punctuation">,</span> parms <span class="token keyword">in</span> net<span class="token punctuation">.</span>named_parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-->name:'</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'-->grad_requirs:'</span><span class="token punctuation">,</span>parms<span class="token punctuation">.</span>requires_grad<span class="token punctuation">,</span> \ <span class="token string">' -->grad_value:'</span><span class="token punctuation">,</span>parms<span class="token punctuation">.</span>grad<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原文链接：<a href="https://blog.csdn.net/Jee_King/article/details/103017077">https://blog.csdn.net/Jee_King/article/details/103017077</a></p><h3 id="2-7-2-可能的原因"><a href="#2-7-2-可能的原因" class="headerlink" title="2.7.2 可能的原因"></a>2.7.2 可能的原因</h3><ul><li><strong>梯度消失或梯度爆炸</strong></li></ul><ol><li>调小或调大学习率，如果涉及到多个损失函数，可以找出哪一项导致了梯度爆炸，通过减小其权重解决。</li><li>增大正则惩罚，如L1&#x2F;L2正则化</li></ol><ul><li><strong>显存或内存不够</strong></li></ul><ol><li>调小batch_size（训练与测试的batch size过大都有可能导致报错）</li></ol><ul><li><strong>代码错误</strong>：可以通过将loss设置为0检查</li></ul><ol><li>检查有无除法，将可能除0的地方，替换成1e-8</li></ol><ul><li><strong>数据集有问题</strong>：可以通过将loss设置为0检查</li></ul><ol><li>检查是否有越界数据或者Nan、Inf的数据</li></ol><ul><li><strong>代码原因（可能导致梯度反向传播的计算图出现问题，待证实 todo）</strong></li></ul><ol><li>数学上成立的偏导数在PyTorch的计算图中可能会因为数据集过大出现梯度消失的情况，比如如下公式：</li></ol><p><img src="http://img.fdchen.host/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%9B%A0%E7%9A%84%E7%A4%BA%E4%BE%8B-1.png" alt="梯度消失代码原因的示例-1"></p><ul><li><strong>出现坏样本</strong></li></ul><p>设置训练data loader的batch size为1（<strong>根据数据规模而定，当运行时间很长时，可以设置较大的batch size，然后确定大致范围再一步一步缩小batch size</strong>），逐个样本送入网络，同时设置shuffle为False，也就是不打乱顺序。出现loss为NaN表示遇到了坏样本，此时迭代的批次数，就是该坏样本在数据集的位置，从而定位了坏样本出现位置。排除后重新训练，继续观察loss的情况，直到能正常训练一个epoch，表示所有的坏样本均被去掉，可以开始正常的训练了。</p><p>另外也可以在数据集读取样本时保留其原始文件名，同样设置batch size为1，遇到loss变为NaN就输出文件名，更加方便一些。</p><ul><li><strong>不合适的损失函数带来的数学问题</strong></li></ul><p>采用一些涉及到除法、对数函数等的损失函数时，要注意除零、对数输入负数等情况，这样同样会导致loss变为NaN。这种情况的出现，一般是在开始训练就出现，不存在loss逐渐增大到爆炸的过程。</p><p>一般通过对网络输出值域以及损失函数定义的数学分析可以进行判断，并进行相应地调整。</p><p>原文链接：<a href="https://blog.csdn.net/andyL_05/article/details/119138160">训练过程中Loss突然变为NaN的可能原因与解决</a></p><h2 id="2-8-留点数据用于最终验证"><a href="#2-8-留点数据用于最终验证" class="headerlink" title="2.8 留点数据用于最终验证"></a>2.8 留点数据用于最终验证</h2><p>如果数据还算充裕，最好能留⼀部分数据，在训练结束之后再⽆偏验证⼀下模型们的表现。</p><h2 id="2-9-网格搜索寻找最优超参"><a href="#2-9-网格搜索寻找最优超参" class="headerlink" title="2.9 网格搜索寻找最优超参"></a>2.9 网格搜索寻找最优超参</h2><ul><li><p>通过设置超参数的范围（有些超参数彼此影响需要共同搜索，比如batch size与learning rate），在多个超参数取值下逐个遍历尝试，即为网格搜索</p></li><li><p>在进行网格搜索前，首先需要了解相关模型一般的敏感超参数以及其范围，这些可以通过去了解对比模型的论文参数设置收集</p></li><li><p>其次是封装好遍历运行脚本，并记录好相关结果，<strong>最好是对每一次搜索的结果都即时记录，以防一次完整搜索出现问题就要从头开始重新搜索</strong></p></li><li><p>在运行脚本前，<strong>最好对模型的执行效率进行检查，确保最大程度利用显卡性能，减少实验的时间</strong></p></li><li><p><strong>对于与迭代epoch次数无关的超参数，比如模型自身的参数设置等，可以设置较少的epoch，这些参数在较少的epoch下即可分出优劣</strong>，但是如学习率等超参数必须设置较大的epoch才能对比出结果，有时还需要结合loss图像观察，比如观察学习率是否合适</p></li></ul><p>PS：更多的超参数调整信息，可以查看以下博客</p><ol><li><a href="https://leesen998.github.io/2017/11/24/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0_%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/">深度学习 超参数调整</a></li><li><a href="https://zhuanlan.zhihu.com/p/41785031">【DL碎片4】深度学习中的的超参数调节</a></li></ol><h1 id="3-权重初始化"><a href="#3-权重初始化" class="headerlink" title="3 权重初始化"></a>3 权重初始化</h1><h2 id="3-1-Xavier"><a href="#3-1-Xavier" class="headerlink" title="3.1 Xavier"></a>3.1 Xavier</h2><p>对于每个经过的层，我们希望方差保持相同，这有助于防止梯度爆炸或消失。换句话说，我们需要以使 x 和 y  的方差保持相同的方式来初始化权重，此初始化过程称为Xavier初始化（Xavier initialization）。（Xavier 读音 zeivier）</p><h1 id="4-评价指标"><a href="#4-评价指标" class="headerlink" title="4 评价指标"></a>4 评价指标</h1><h2 id="4-1-多分类问题的准确率、召回率与F1分数"><a href="#4-1-多分类问题的准确率、召回率与F1分数" class="headerlink" title="4.1 多分类问题的准确率、召回率与F1分数"></a>4.1 多分类问题的准确率、召回率与F1分数</h2><p>把每个类别单独视为”正“，所有其它类型视为”负“，考虑使用混淆矩阵，分别计算各个类别的精确率与召回率。</p><h1 id="5-模型收敛"><a href="#5-模型收敛" class="headerlink" title="5 模型收敛"></a>5 模型收敛</h1><h2 id="5-1-避免陷入“高原平坦区”"><a href="#5-1-避免陷入“高原平坦区”" class="headerlink" title="5.1 避免陷入“高原平坦区”"></a>5.1 避免陷入“高原平坦区”</h2><p>以下内容节选自：<a href="https://mp.weixin.qq.com/s/YTNZOPgWZiN28Hm30SwstA">《你的模型真的陷⼊局部最优点了吗？》</a></p><p>在⾼维空间⾥（深度学习问题上）真正可怕的不是局部最优也不是鞍点问题，⽽是⼀些特殊地形。⽐如⼤⾯积的平坦区域。</p><p>在平坦区域，虽然导数不为0但是却不⼤。虽然是在不断下降但是路程却⾮常⻓。对于优化算法来说，它需要⾛很多很多步才有可能⾛过这⼀⽚平坦区域。甚⾄在这段地形的⼆阶导数过于特殊的情况下，⼀阶优化算法⾛⽆穷多步也⾛不出去（设想⼀下，如果终点在⼀⽶外，但是你第⼀次⾛0.5⽶，后续每⼀步都是前⼀步的⼀半⻓度，那么你永远也⾛不到⾯前的⼀⽶终点处）。 </p><p>所以相⽐于栽到最优点和鞍点上，优化算法更有可能载到这种类似平坦区的地形中（如果这个平坦区⼜是“⾼原地带”，即loss值很⾼的地带，那么恭喜你悲剧了）。更糟糕的是，由于⾼维地形难以可视化，还有很多更复杂的未知地形会导致假收敛，<strong>⼀旦陷⼊到这些危险地形中，⼏乎是⽆解的。</strong> </p><p><strong>所以说，在深度学习中，与其担忧模型陷⼊局部最优点怎么跳出来，更不如去好好考虑：</strong></p><ol><li><p>去设计⼀个尽量没有“平坦区”等危险地形的loss空间，即着⼿于loss函数的设计以及深度学习模型的设计； </p></li><li><p>尽量让模型的初始化点远离空间中的危险地带，让最优化游戏开始于简单模式，即着⼿于模型参数的初始化策略； </p></li><li><p>让最优化过程更智能⼀点，该加速冲时加速冲，该⼤胆跳跃时就⼤胆跳，该慢慢踱步时慢慢⾛，对危险地形有⼀定的判断⼒，如梯度截断策略；</p></li><li><p>开外挂，本来下⼀步要⾛向死亡的，结果被外挂给拽回了安全区，如batch normalization策略等</p></li></ol><h2 id="5-2-Pytoch梯度反向传播"><a href="#5-2-Pytoch梯度反向传播" class="headerlink" title="5.2 Pytoch梯度反向传播"></a>5.2 Pytoch梯度反向传播</h2><p>对于梯度反向传播的理解，参考下面两篇博客即可，博客内容很详细也很容易理解，此处不赘述。</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/83172023">Pytorch autograd,backward详解</a></p></li><li><p><a href="http://haokailong.top/2020/11/01/pytorch-loss-backward-%E7%9A%84%E7%90%86%E8%A7%A3/">pytorch loss.backward()的理解</a></p></li></ul><h1 id="6-减少训练时间"><a href="#6-减少训练时间" class="headerlink" title="6 减少训练时间"></a>6 减少训练时间</h1><h2 id="6-1-用列表生成式代替循环"><a href="#6-1-用列表生成式代替循环" class="headerlink" title="6.1 用列表生成式代替循环"></a>6.1 用列表生成式代替循环</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>列表生成式用C语言实现，效率非常高</li></ul><h2 id="6-2-遍历list远快于遍历tensor，避免遍历tensor"><a href="#6-2-遍历list远快于遍历tensor，避免遍历tensor" class="headerlink" title="6.2 遍历list远快于遍历tensor，避免遍历tensor"></a>6.2 遍历list远快于遍历tensor，避免遍历tensor</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> timenum <span class="token operator">=</span> <span class="token number">1000000</span>a <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>num<span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>start_time1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>    <span class="token keyword">pass</span>elapse_time1 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time1start_time2 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> b<span class="token punctuation">:</span>    <span class="token keyword">pass</span>elapse_time2 <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time2<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Traverside Tensor Elapse Time: '</span><span class="token punctuation">,</span> elapse_time1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Traverside List Elapse Time: '</span><span class="token punctuation">,</span> elapse_time2<span class="token punctuation">)</span><span class="token comment"># Traverside Tensor Elapse Time:  2.491483449935913</span><span class="token comment"># Traverside List Elapse Time:  0.036934614181518555</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-多线程（含线程同步）示例"><a href="#6-3-多线程（含线程同步）示例" class="headerlink" title="6.3 多线程（含线程同步）示例"></a>6.3 多线程（含线程同步）示例</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 多线程处理代码（含线程同步）</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npglobal_graph_data_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 由_acquire解锁执行后释放_release锁</span><span class="token keyword">def</span> <span class="token function">genegrate_graph_data</span><span class="token punctuation">(</span>feature_tensor<span class="token punctuation">,</span> edge_index<span class="token punctuation">,</span> acquire_mutex<span class="token punctuation">:</span> Lock<span class="token punctuation">,</span> release_mutex<span class="token punctuation">:</span> Lock<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment"># 不需要同步操作</span>    part_data_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> edge_index<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> feature_tensor<span class="token punctuation">]</span>    <span class="token comment"># 同步操作</span>    acquire_mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>    global_graph_data_list<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>part_data_list<span class="token punctuation">)</span>  <span class="token comment"># 进程同步以便按顺序插入</span>    release_mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>n_thread <span class="token operator">=</span> <span class="token number">4</span>n_user <span class="token operator">=</span> <span class="token number">100</span>graph_edge_index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>node_user_embeddings <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>n_user<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 此代码用于检验是否同步成功</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>node_user_embeddings<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    node_user_embeddings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token comment"># 创建n_thread个锁供n_thread个线程使用</span>mutex <span class="token operator">=</span> <span class="token punctuation">[</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_thread<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token comment"># 定义n_thread个线程</span>step <span class="token operator">=</span> n_user <span class="token operator">//</span> n_threadthreads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    feature_tensors <span class="token operator">=</span> node_user_embeddings<span class="token punctuation">[</span>step <span class="token operator">*</span> i<span class="token punctuation">:</span> step <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">&lt;</span> n_thread <span class="token keyword">else</span> node_user_embeddings<span class="token punctuation">[</span>step <span class="token operator">*</span> i<span class="token punctuation">:</span><span class="token punctuation">]</span>    thread <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>genegrate_graph_data<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>feature_tensors<span class="token punctuation">,</span> graph_edge_index<span class="token punctuation">,</span> mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> mutex<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n_thread<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token comment"># 把除了第1个的进程锁上</span><span class="token punctuation">[</span>mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n_thread<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment"># 接下来只有线程1可以先执行是因为mutex[0]并没有被占用</span><span class="token comment"># 之后的分别等待着前一个锁的释放才能继续执行</span><span class="token punctuation">[</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">]</span><span class="token punctuation">[</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>global_graph_data_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原文链接：<a href="https://cloud.tencent.com/developer/article/1738395">浅谈Python3多线程之间的执行顺序问题</a></p><h2 id="6-4-减少函数调用"><a href="#6-4-减少函数调用" class="headerlink" title="6.4 减少函数调用"></a>6.4 减少函数调用</h2><p>函数的开销很大。尽量把循环放在函数内进行。而不要让每次迭代都调用函数。</p><h2 id="6-5-尽量使用内置方法"><a href="#6-5-尽量使用内置方法" class="headerlink" title="6.5 尽量使用内置方法"></a>6.5 尽量使用内置方法</h2><p>尽量使用内置方法，因为内置的是C写的，效率肯定高很多。</p><h2 id="6-6-用xrange代替range"><a href="#6-6-用xrange代替range" class="headerlink" title="6.6 用xrange代替range"></a>6.6 用xrange代替range</h2><h2 id="6-7-对于可迭代对象尽量直接使用"><a href="#6-7-对于可迭代对象尽量直接使用" class="headerlink" title="6.7 对于可迭代对象尽量直接使用"></a>6.7 对于可迭代对象尽量直接使用</h2><h2 id="6-8-复制可迭代对象使用自带的构造函数，不要使用列表生成式"><a href="#6-8-复制可迭代对象使用自带的构造函数，不要使用列表生成式" class="headerlink" title="6.8 复制可迭代对象使用自带的构造函数，不要使用列表生成式"></a>6.8 复制可迭代对象使用自带的构造函数，不要使用列表生成式</h2><h2 id="6-9-对列表的每一个元素都调用函数，应该使用map-f-x-L"><a href="#6-9-对列表的每一个元素都调用函数，应该使用map-f-x-L" class="headerlink" title="6.9 对列表的每一个元素都调用函数，应该使用map(f(x), L)"></a>6.9 对列表的每一个元素都调用函数，应该使用map(f(x), L)</h2><p>如果想对列表的每一个元素都调用函数，应该用L1&#x3D;map(f,L),而不是L1&#x3D;[f(x) for x in L]，这里使用map的原因是涉及到重复调用函数，列表列表生成式会更慢，如果不是函数调用，则可以用列表生成式。</p><h2 id="6-10-生成器与列表生成式的选择"><a href="#6-10-生成器与列表生成式的选择" class="headerlink" title="6.10 生成器与列表生成式的选择"></a>6.10 生成器与列表生成式的选择</h2><ul><li>如果你希望使用整个列表，则使用列表推导，因为他会节省生成器带来的系统开销；</li><li>如果你只想用列表的一部分，那么使用生成器吧。</li></ul><h2 id="6-11-shuffle-取前n项，获取列表随机元素"><a href="#6-11-shuffle-取前n项，获取列表随机元素" class="headerlink" title="6.11 shuffle()+取前n项，获取列表随机元素"></a>6.11 shuffle()+取前n项，获取列表随机元素</h2><p>随机取出列表里的元素应该先用random.shuffle(list)把元素随机的打乱，然后顺序的取每一项即可。如果不想取到重复的，可以用list.pop()，既取出来了，又把这个元素从列表中删除。而且内置的pop方法，非常快速。</p><p>6.4 - 6.11 节选自他人博客，原文链接：<a href="https://blog.csdn.net/weixin_35560840/article/details/114418462">python列表生成式和map效率_python提高效率(优化)的心得总结（不断补充）</a></p><h2 id="6-12-查看GPU即时使用情况，watch-n-1-nvidia-smi"><a href="#6-12-查看GPU即时使用情况，watch-n-1-nvidia-smi" class="headerlink" title="6.12 查看GPU即时使用情况，watch -n 1 nvidia-smi"></a>6.12 查看GPU即时使用情况，watch -n 1 nvidia-smi</h2><ul><li><p>1代表1秒</p></li><li><p>可以通过nvidia-smi查看当前GPU使用情况</p></li></ul><h1 id="7-搭建模型"><a href="#7-搭建模型" class="headerlink" title="7 搭建模型"></a>7 搭建模型</h1><h2 id="7-1-一定要在人为构造的极小数据集上验证模型每个模块的正确性"><a href="#7-1-一定要在人为构造的极小数据集上验证模型每个模块的正确性" class="headerlink" title="7.1 一定要在人为构造的极小数据集上验证模型每个模块的正确性"></a>7.1 一定要在人为构造的极小数据集上验证模型每个模块的正确性</h2><p>为了避免在验证模型策略时正确有效，必须保证依据模型策略搭建的模型是正确的，<strong>必须事先人为构造极小的数据集进行测试，每一步人工计算可能的结果，然后打印验证。</strong>有时可以简单设置为tensor shape的验证，但是最好通过计算具体值来验证，保证万无一失。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Pytorch </tag>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy</title>
      <link href="/2022/python-numpy/"/>
      <url>/2022/python-numpy/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本矩阵操作"><a href="#1-基本矩阵操作" class="headerlink" title="1 基本矩阵操作"></a>1 基本矩阵操作</h1><h2 id="1-1-纵向连接矩阵，np-r-a-b"><a href="#1-1-纵向连接矩阵，np-r-a-b" class="headerlink" title="1.1  纵向连接矩阵，np.r_([a,b])"></a>1.1  纵向连接矩阵，np.r_([a,b])</h2><p>纵向连接两个矩阵，就是把两矩阵上下相连，要求列数相等，类似于pandas中的concat()。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>r_<span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## answer ##</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-横向连接矩阵，np-c-a-b"><a href="#1-2-横向连接矩阵，np-c-a-b" class="headerlink" title="1.2 横向连接矩阵，np.c_([a, b])"></a>1.2 横向连接矩阵，np.c_([a, b])</h2><p>横向连接两个矩阵，就是把两矩阵左右相连，要求行数相等，类似于pandas中的merge()。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>c_<span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## answer ##</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-随机数"><a href="#2-随机数" class="headerlink" title="2 随机数"></a>2 随机数</h1><h2 id="2-0-设置随机数种子"><a href="#2-0-设置随机数种子" class="headerlink" title="2.0 设置随机数种子"></a>2.0 设置随机数种子</h2><ul><li>有时候我们想每次生成的随机数矩阵都一样，这时只需在前面加一句np.random.seed(0)即可，数字可随意指定</li></ul><h2 id="2-1-生成随机浮点数，np-random-random"><a href="#2-1-生成随机浮点数，np-random-random" class="headerlink" title="2.1 生成随机浮点数，np.random.random()"></a>2.1 生成随机浮点数，np.random.random()</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0.7954041994194649</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-生成随机数组，np-random-rand-100-1"><a href="#2-2-生成随机数组，np-random-rand-100-1" class="headerlink" title="2.2 生成随机数组，np.random.rand(100,1)"></a>2.2 生成随机数组，np.random.rand(100,1)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 数组大小为 100*1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-线性代数-linalg"><a href="#3-线性代数-linalg" class="headerlink" title="3 线性代数 linalg"></a>3 线性代数 linalg</h1><h2 id="3-1-计算矩阵的逆，np-linalg-inv-matrix"><a href="#3-1-计算矩阵的逆，np-linalg-inv-matrix" class="headerlink" title="3.1 计算矩阵的逆，np.linalg.inv(matrix)"></a>3.1 计算矩阵的逆，np.linalg.inv(matrix)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="4-数组操作"><a href="#4-数组操作" class="headerlink" title="4 数组操作"></a>4 数组操作</h1><h2 id="4-1-计算数组的内积与矩阵积，np-dot-a-b"><a href="#4-1-计算数组的内积与矩阵积，np-dot-a-b" class="headerlink" title="4.1 计算数组的内积与矩阵积，np.dot(a, b)"></a>4.1 计算数组的内积与矩阵积，np.dot(a, b)</h2><ul><li><p>如果处理的是一维数组，则得到的是两数组的內积</p></li><li><p>如果是二维数组（矩阵）之间的运算，则得到的是矩阵积（matrix product），即列数与行数相同两矩阵相乘</p></li><li><p>dot()函数可以通过numpy库调用，也可以由数组实例对象进行调用。a.dot(b) 与 np.dot(a,b)效果相同</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token comment"># Out[28]: 4</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token comment">## answer ##</span>Out<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">:</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4.</span><span class="token punctuation">,</span> <span class="token number">4.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">4.</span><span class="token punctuation">,</span> <span class="token number">4.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-重组数组，np-reshape-a-newshepe"><a href="#4-2-重组数组，np-reshape-a-newshepe" class="headerlink" title="4.2 重组数组，np.reshape(a, newshepe)"></a>4.2 重组数组，np.reshape(a, newshepe)</h2><ul><li>在不更改数据的情况下为数组赋予新的形状</li><li>可以通过numpy库调用，也可以由数组实例对象进行调用。a.reshape((4,4)) 与 np.reshape(a,(4,4))效果相同</li><li>其他用法</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 不知道z的shape属性是多少，让z变成一列</span>z <span class="token operator">=</span> z<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 只给定行数，列数等于-1，让z变成指定行数</span>z <span class="token operator">=</span> z<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>rows<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>PS：产生新的数组，需要赋值给原来数组才能完成修改</li></ul><h2 id="4-3-创建数组，np-array"><a href="#4-3-创建数组，np-array" class="headerlink" title="4.3 创建数组，np.array()"></a>4.3 创建数组，np.array()</h2><ul><li>例子</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>向上转型：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1.</span><span class="token punctuation">,</span>  <span class="token number">2.</span><span class="token punctuation">,</span>  <span class="token number">3.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个以上的维度：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>最小尺寸2：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ndmin<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">//</span> 原本是一维数组array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>提供的类型：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">complex</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1.</span><span class="token operator">+</span><span class="token number">0.j</span><span class="token punctuation">,</span>  <span class="token number">2.</span><span class="token operator">+</span><span class="token number">0.j</span><span class="token punctuation">,</span>  <span class="token number">3.</span><span class="token operator">+</span><span class="token number">0.j</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>数据类型包含多个元素：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># int8, int16, int32, int64 四种数据类型可以使用字符串 'i1', 'i2','i4','i8' 代替</span><span class="token comment"># 'a', 'b'分别代表元组两个元素的名称</span><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'&lt;i4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'&lt;i4'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>从子类创建数组：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span><span class="token string">'1 2; 3 4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># subok: bool，可选,如果为True，则将传递子类，否则返回的数组将被强制为基类数组（默认）。</span><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mat<span class="token punctuation">(</span><span class="token string">'1 2; 3 4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> subok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>matrix<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-按数值范围创建数组，numpy-arange-start-stop-step-dtype"><a href="#4-4-按数值范围创建数组，numpy-arange-start-stop-step-dtype" class="headerlink" title="4.4 按数值范围创建数组，numpy.arange(start, stop, step, dtype)"></a>4.4 按数值范围创建数组，numpy.arange(start, stop, step, dtype)</h2><h2 id="4-5-比较数组的相同个数，numpy-sum-arr1-x3D-x3D-arr2"><a href="#4-5-比较数组的相同个数，numpy-sum-arr1-x3D-x3D-arr2" class="headerlink" title="4.5 比较数组的相同个数，numpy.sum(arr1 &#x3D;&#x3D; arr2)"></a>4.5 比较数组的相同个数，numpy.sum(arr1 &#x3D;&#x3D; arr2)</h2><h2 id="4-6-从数组中随机抽样，np-randon-choice-与-np-random-sample"><a href="#4-6-从数组中随机抽样，np-randon-choice-与-np-random-sample" class="headerlink" title="4.6 从数组中随机抽样，np.randon.choice() 与 np.random.sample()"></a>4.6 从数组中随机抽样，np.randon.choice() 与 np.random.sample()</h2><p><strong>numpy.random.choice()抽样方法的时间几乎不会随着抽样数量的变化而变化，而random.sample() 会随着抽样数量的增加而增加。</strong></p><p>所以当数量较少的时候，random.sample() 用时非常少，而numpy.random.choice()则很长；</p><p>当抽样数量很大的时候，numpy.random.choice()几乎不变，而random.sample() 用时变长。</p><h2 id="4-7-去除多维数组的轴，np-squeeze-a-axis-x3D-None"><a href="#4-7-去除多维数组的轴，np-squeeze-a-axis-x3D-None" class="headerlink" title="4.7 去除多维数组的轴，np.squeeze(a, axis&#x3D;None)"></a>4.7 去除多维数组的轴，np.squeeze(a, axis&#x3D;None)</h2><ul><li><p>注意只能去除<strong>长度为1</strong>的轴</p></li><li><p>示例</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>shape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shapeTraceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ValueError<span class="token punctuation">:</span> cannot select an axis to squeeze out which has size <span class="token keyword">not</span> equal to one<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-7-返回非0数组元组的索引，numpy-argwhere-condition"><a href="#4-7-返回非0数组元组的索引，numpy-argwhere-condition" class="headerlink" title="4.7 返回非0数组元组的索引，numpy.argwhere(condition)"></a>4.7 返回非0数组元组的索引，numpy.argwhere(condition)</h2><ul><li>condition表示索引数组的条件</li></ul><h2 id="4-8-获取非0元素值，np-nonzero"><a href="#4-8-获取非0元素值，np-nonzero" class="headerlink" title="4.8 获取非0元素值，np.nonzero()"></a>4.8 获取非0元素值，np.nonzero()</h2><h2 id="4-9-数组维数，ndarray-ndim"><a href="#4-9-数组维数，ndarray-ndim" class="headerlink" title="4.9 数组维数，ndarray.ndim"></a>4.9 数组维数，ndarray.ndim</h2><ul><li>例子</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>ndim<span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>ndim<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-10-按元素点乘-arr-a-arr-b"><a href="#4-10-按元素点乘-arr-a-arr-b" class="headerlink" title="4.10 按元素点乘 arr_a * arr_b"></a>4.10 按元素点乘 arr_a * arr_b</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a <span class="token operator">*</span> b<span class="token comment"># Out[38]: array([2, 2])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-11-获取数组大小"><a href="#4-11-获取数组大小" class="headerlink" title="4.11 获取数组大小"></a>4.11 获取数组大小</h2><h3 id="4-11-1-获取所有元素个数，size"><a href="#4-11-1-获取所有元素个数，size" class="headerlink" title="4.11.1 获取所有元素个数，size()"></a>4.11.1 获取所有元素个数，size()</h3><h3 id="4-11-2-获取数组维度，shape"><a href="#4-11-2-获取数组维度，shape" class="headerlink" title="4.11.2 获取数组维度，shape()"></a>4.11.2 获取数组维度，shape()</h3><h3 id="4-11-3-获取第一个维度大小，len"><a href="#4-11-3-获取第一个维度大小，len" class="headerlink" title="4.11.3 获取第一个维度大小，len()"></a>4.11.3 获取第一个维度大小，len()</h3><h2 id="4-12-省略符…与冒号符-的对比"><a href="#4-12-省略符…与冒号符-的对比" class="headerlink" title="4.12 省略符…与冒号符:的对比"></a>4.12 省略符…与冒号符:的对比</h2><ol><li><code>...</code>可以代表任意多维的元素，而每个<code>:</code>只能代表一个维度。</li><li><code>:</code>可以指定代表的维度的区间范围，<code>...</code>不能。</li><li><code>...</code>只能出现一次，而<code>:</code>可以出现多次，但不能超过矩阵的维度。</li></ol><h1 id="5-数学运算"><a href="#5-数学运算" class="headerlink" title="5 数学运算"></a>5 数学运算</h1><h2 id="5-1-求倒数-1-x2F-x，np-reciprocal"><a href="#5-1-求倒数-1-x2F-x，np-reciprocal" class="headerlink" title="5.1 求倒数 1&#x2F;x，np.reciprocal()"></a>5.1 求倒数 1&#x2F;x，np.reciprocal()</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SprinBoot_Debug</title>
      <link href="/2022/java-springboot-debug/"/>
      <url>/2022/java-springboot-debug/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring-Boot项目如何独立运行-springboot项目打包"><a href="#1-Spring-Boot项目如何独立运行-springboot项目打包" class="headerlink" title="1. Spring Boot项目如何独立运行(springboot项目打包)"></a>1. Spring Boot项目如何独立运行(springboot项目打包)</h3><ul><li>详见博客：<a href="https://blog.csdn.net/weixin_45764765/article/details/106830869">https://blog.csdn.net/weixin_45764765/article/details/106830869</a></li><li>一般情况下可以直接点击idea的运行按钮测试运行，最终再打包</li></ul><h3 id="2-idea报错-No-valid-Maven-installation-found-maven不能用"><a href="#2-idea报错-No-valid-Maven-installation-found-maven不能用" class="headerlink" title="2. idea报错 No valid Maven installation found.maven不能用"></a>2. idea报错 No valid Maven installation found.maven不能用</h3><ul><li>详见博客：<a href="https://blog.csdn.net/qq_40846086/article/details/81252736">https://blog.csdn.net/qq_40846086/article/details/81252736</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL使用</title>
      <link href="/2022/shu-ju-ku-mysql/"/>
      <url>/2022/shu-ju-ku-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="0-安装配置"><a href="#0-安装配置" class="headerlink" title="0 安装配置"></a>0 安装配置</h1><h2 id="0-1-MySQL-Navicat"><a href="#0-1-MySQL-Navicat" class="headerlink" title="0.1 MySQL+Navicat"></a>0.1 MySQL+Navicat</h2><ul><li><p>详见博客：<a href="https://www.runoob.com/mysql/mysql-install.html">MySQL 安装</a> （简单版，无可视化界面）</p><ul><li>修改root用户临时密码：<a href="https://blog.csdn.net/Exception_sir/article/details/82111014">mysql 修改密码报错解决</a></li></ul></li><li><p>详见博客：<a href="https://blog.csdn.net/chic_data/article/details/72286329">Windows上本地安装MySQL数据库</a></p></li></ul><blockquote><p>本机MYSQL服务名：MySQL80</p><p>root密码：XXXXXX</p></blockquote><ul><li>查看MySQL服务名，“管理工具”  –&gt; “服务”</li><li>破解版Navicat，详见博客：<a href="https://www.jianshu.com/p/3af7fccc22c7">Navicat Premium v15 中文最新破解版（附：激活工具）</a></li></ul><h2 id="0-2-windows下MySQL-my-ini文件位置"><a href="#0-2-windows下MySQL-my-ini文件位置" class="headerlink" title="0.2 windows下MySQL my.ini文件位置"></a>0.2 windows下MySQL my.ini文件位置</h2><ul><li>C:\ProgramData\MySQL\MySQL Server 8.0</li></ul><h2 id="0-3-centOS-7-安装MySQL"><a href="#0-3-centOS-7-安装MySQL" class="headerlink" title="0.3 centOS 7 安装MySQL"></a>0.3 centOS 7 安装MySQL</h2><ul><li>详见博客：<a href="https://blog.csdn.net/a774630093/article/details/79270080">CentOS7 64位安装mysql教程，亲测完美</a></li></ul><h2 id="0-4-centOS-7-执行sql文件"><a href="#0-4-centOS-7-执行sql文件" class="headerlink" title="0.4 centOS 7 执行sql文件"></a>0.4 centOS 7 执行sql文件</h2><ul><li>详见博客：<a href="https://www.cnblogs.com/kaishi/p/7575301.html">Centos 执行sql文件</a></li></ul><h2 id="0-5-JDBC数据库驱动的下载、安装与连接"><a href="#0-5-JDBC数据库驱动的下载、安装与连接" class="headerlink" title="0.5 JDBC数据库驱动的下载、安装与连接"></a>0.5 JDBC数据库驱动的下载、安装与连接</h2><ul><li>详见博客：<a href="https://blog.csdn.net/pan_junbiao/article/details/86626741">JDBC数据库驱动的下载、安装与连接</a></li></ul><h1 id="1-常见用法"><a href="#1-常见用法" class="headerlink" title="1 常见用法"></a>1 常见用法</h1><h2 id="1-1-workbench-执行语句"><a href="#1-1-workbench-执行语句" class="headerlink" title="1.1 workbench 执行语句"></a>1.1 workbench 执行语句</h2><ul><li>新建tab(new tab) ctrl+t</li><li>执行当前语句(execute current statement) ctrl+enter</li><li>执行全部或选中的语句(execute all or selection) ctrl+shift+enter</li><li>查看执行计划(explain current statement) ctrl+alt+x</li></ul><h2 id="1-2-text数据类型"><a href="#1-2-text数据类型" class="headerlink" title="1.2 text数据类型"></a>1.2 text数据类型</h2><ul><li><code>TEXT</code>可用于存储可以从<code>1</code>字节到<code>4GB</code>长度的文本字符串。</li><li>TINYTEXT - 1个字节(255个字符)</li><li>TEXT - 64KB(65,535个字符)</li><li>MEDIUMTEXT - 16MB(16,777,215个字符)</li><li>LONGTEXT - 4GB(4,294,967,295个字符)</li></ul><h2 id="1-3-命令行登录Mysql"><a href="#1-3-命令行登录Mysql" class="headerlink" title="1.3 命令行登录Mysql"></a>1.3 命令行登录Mysql</h2><ul><li>详见博客：<a href="https://blog.csdn.net/helloxiaozhe/article/details/76229074">命令行登录Mysql，远程登录Mysql的方法</a></li></ul><h2 id="1-4-设置字段值取反操作"><a href="#1-4-设置字段值取反操作" class="headerlink" title="1.4 设置字段值取反操作"></a>1.4 设置字段值取反操作</h2><ul><li>对布尔值取反，使用 ~。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token operator">~</span><span class="token keyword">status</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment"># status的值为true || false。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>对0、1 数值取反，使用abs() 取绝对值。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span>abs<span class="token punctuation">(</span><span class="token keyword">status</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment"># status的值为0 || 1。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里如果数据表里的值一开始为0，那么会报一个错：</p><p>[Err] 1690 - BIGINT UNSIGNED value is out of range in ‘(resume.r_resume.status - 1)’</p><p>原因：取绝对值之前得到负值，看看是不是status勾选了unsigned，去掉再试试。</p><p>原文链接：<a href="https://www.cnblogs.com/xinxinmifan/p/11548935.html">https://www.cnblogs.com/xinxinmifan/p/11548935.html</a></p><h1 id="2-Debug"><a href="#2-Debug" class="headerlink" title="2 Debug"></a>2 Debug</h1><h2 id="2-1-登录时报错Access-denied-for-user-‘root‘-‘localhost‘-using-password-YES"><a href="#2-1-登录时报错Access-denied-for-user-‘root‘-‘localhost‘-using-password-YES" class="headerlink" title="2.1 登录时报错Access denied for user ‘root‘@‘localhost‘ (using password: YES)"></a>2.1 登录时报错Access denied for user ‘root‘@‘localhost‘ (using password: YES)</h2><ul><li>详见博客：<a href="https://blog.csdn.net/qq_36675754/article/details/81381341">在MySQL登录时出现Access denied for user ‘root‘@‘localhost‘ (using password: YES) 拒绝访问，并可修改MySQL密码</a></li></ul><h2 id="2-2-发生系统错误5"><a href="#2-2-发生系统错误5" class="headerlink" title="2.2 发生系统错误5"></a>2.2 发生系统错误5</h2><ul><li>详见博客：<a href="https://blog.csdn.net/aaa333qwe/article/details/75195938">net stop mysql 发生系统错误 5。</a></li></ul><h2 id="2-3-报错-Duplicate-foreign-key-constraint-name-‘idXXXX’"><a href="#2-3-报错-Duplicate-foreign-key-constraint-name-‘idXXXX’" class="headerlink" title="2.3 报错 Duplicate foreign key constraint name ‘idXXXX’"></a>2.3 报错 Duplicate foreign key constraint name ‘idXXXX’</h2><ul><li>因为在之前已经加过一个名称为idmanagetype外键索引了 ，如果重复则报错，在名称后面加一个1成功了。</li></ul><h2 id="2-4-Navicat连接远程主机数据库报错"><a href="#2-4-Navicat连接远程主机数据库报错" class="headerlink" title="2.4 Navicat连接远程主机数据库报错"></a>2.4 Navicat连接远程主机数据库报错</h2><ul><li>详见博客：<a href="https://blog.csdn.net/MTbaby/article/details/56836986">解决Navicat无法连接到MySQL的问题</a></li></ul><h2 id="2-5-连接-mysql-出现Client-does-not-support-authentication-protocol-requested-by-server"><a href="#2-5-连接-mysql-出现Client-does-not-support-authentication-protocol-requested-by-server" class="headerlink" title="2.5 连接 mysql 出现Client does not support authentication protocol requested by server"></a>2.5 连接 mysql 出现Client does not support authentication protocol requested by server</h2><ul><li>详见博客：<a href="https://blog.csdn.net/u013700358/article/details/80306560">navicat 连接 mysql 出现Client does not support authentication protocol requested by server解决方案</a></li></ul><h2 id="2-6-IDEA-Database报红色下划线"><a href="#2-6-IDEA-Database报红色下划线" class="headerlink" title="2.6 IDEA Database报红色下划线"></a>2.6 IDEA Database报红色下划线</h2><ul><li><p>详见博客：<a href="https://blog.csdn.net/a328062954/article/details/105312090">IDEA Database报红色下划线</a></p></li><li><p><strong>注意使用Test conection，一般可以按照提示解决问题</strong></p></li><li><p>修改了这里的文件，也要注意修改application.yml&#x2F;application-dev.yml里关于数据库的设置，特别是password</p></li></ul><h2 id="2-7-MySql-执行-DELETE-x2F-UPDATE时，报-Error-Code-1175错误"><a href="#2-7-MySql-执行-DELETE-x2F-UPDATE时，报-Error-Code-1175错误" class="headerlink" title="2.7 MySql 执行 DELETE&#x2F;UPDATE时，报 Error Code: 1175错误"></a>2.7 MySql 执行 DELETE&#x2F;UPDATE时，报 Error Code: 1175错误</h2><ul><li>详见博客：<a href="https://blog.csdn.net/cainiao_accp/article/details/68962579">MySql 执行 DELETE&#x2F;UPDATE时，报 Error Code: 1175错误</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> Debug </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas</title>
      <link href="/2022/python-pandas/"/>
      <url>/2022/python-pandas/</url>
      
        <content type="html"><![CDATA[<h1 id="1-DataFrame"><a href="#1-DataFrame" class="headerlink" title="1 DataFrame"></a>1 DataFrame</h1><h2 id="1-1-修改某一列数据"><a href="#1-1-修改某一列数据" class="headerlink" title="1.1 修改某一列数据"></a>1.1 修改某一列数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token string">'col'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'col'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-比较两列是否相等"><a href="#1-2-比较两列是否相等" class="headerlink" title="1.2 比较两列是否相等"></a>1.2 比较两列是否相等</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>concat<span class="token punctuation">(</span><span class="token punctuation">[</span>df1<span class="token punctuation">,</span> df2<span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>df<span class="token punctuation">[</span><span class="token string">'result'</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>df<span class="token punctuation">[</span><span class="token string">'col1'</span><span class="token punctuation">]</span> <span class="token operator">==</span> df<span class="token punctuation">[</span><span class="token string">'col2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'no change'</span><span class="token punctuation">,</span> <span class="token string">'changed'</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>df<span class="token punctuation">)</span>   col1  col2     result<span class="token number">0</span>  audi  audi  no change<span class="token number">1</span>  cars  bike    changed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-按某列条件检索行数据"><a href="#1-3-按某列条件检索行数据" class="headerlink" title="1.3 按某列条件检索行数据"></a>1.3 按某列条件检索行数据</h2><pre class="line-numbers language-pyth" data-language="pyth"><code class="language-pyth">lc.loc[lc[&quot;grade&quot;] &#x3D;&#x3D; &quot;B&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-4-检查某列是否存在"><a href="#1-4-检查某列是否存在" class="headerlink" title="1.4 检查某列是否存在"></a>1.4 检查某列是否存在</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token string">'A'</span> <span class="token keyword">in</span> df<span class="token punctuation">.</span>columns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-5-索引与列互相转化"><a href="#1-5-索引与列互相转化" class="headerlink" title="1.5 索引与列互相转化"></a>1.5 索引与列互相转化</h2><ul><li>列 –&gt; 索引</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>set_index<span class="token punctuation">(</span><span class="token string">'date'</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment"># column 改为 index</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>索引 –&gt; 列</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token string">'index'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">.</span>index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-6-修改列顺序"><a href="#1-6-修改列顺序" class="headerlink" title="1.6 修改列顺序"></a>1.6 修改列顺序</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"> <span class="token comment"># 0代表插入位置，'id'代表列名，df_id代表列数据</span>df<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'id'</span><span class="token punctuation">,</span>df_id<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-7-采样随机样本"><a href="#1-7-采样随机样本" class="headerlink" title="1.7 采样随机样本"></a>1.7 采样随机样本</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">DataFrame<span class="token punctuation">.</span>sample<span class="token punctuation">(</span> n <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token punctuation">,</span> frac <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token punctuation">,</span> replace <span class="token operator">=</span> <span class="token boolean">False</span> <span class="token punctuation">,</span> weights <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token punctuation">,</span> random_state <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token punctuation">,</span> axis <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token punctuation">,</span> ignore_index <span class="token operator">=</span> <span class="token boolean">False</span> <span class="token punctuation">)</span><span class="token comment"># 从目标轴采样随机样本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-8-loc按照名称选取，iloc按照索引选取"><a href="#1-8-loc按照名称选取，iloc按照索引选取" class="headerlink" title="1.8 loc按照名称选取，iloc按照索引选取"></a>1.8 loc按照名称选取，iloc按照索引选取</h2><h2 id="1-9-条件筛选，df-query-‘A-gt-B’-或-df-df-A-gt-df-B"><a href="#1-9-条件筛选，df-query-‘A-gt-B’-或-df-df-A-gt-df-B" class="headerlink" title="1.9 条件筛选，df.query(‘A &gt; B’) 或 df[df.A &gt; df.B]"></a>1.9 条件筛选，df.query(‘A &gt; B’) 或 df[df.A &gt; df.B]</h2><p>多条件筛选，采用逻辑运算符，如下所示</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>c1<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>df<span class="token punctuation">.</span>c2<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-10-设置index的列名"><a href="#1-10-设置index的列名" class="headerlink" title="1.10 设置index的列名"></a>1.10 设置index的列名</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">.</span>index<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-操作csv文件"><a href="#2-操作csv文件" class="headerlink" title="2 操作csv文件"></a>2 操作csv文件</h1><h2 id="2-1-读取csv"><a href="#2-1-读取csv" class="headerlink" title="2.1 读取csv"></a>2.1 读取csv</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data_df.csv'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-2-index-col设置行索引"><a href="#2-2-index-col设置行索引" class="headerlink" title="2.2 index_col设置行索引"></a>2.2 index_col设置行索引</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'1.csv'</span><span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 自动添加行index</span><span class="token comment"># 如果CSV文件中没有行索引，必须设置为False，否则会将第一列设置为索引，导致第一二列数据合并</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-写入csv"><a href="#2-2-写入csv" class="headerlink" title="2.2 写入csv"></a>2.2 写入csv</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#index表示设定是否需要行索引，设定为FALSE表明不需要，就不会生成新的行索引</span><span class="token comment">#header表明是否需要列索引，设定为True（默认设置）表明需要，那么之前df的列标签就会保存。</span>data_df<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">'data_df.csv'</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>header<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch</title>
      <link href="/2022/python-pytorch/"/>
      <url>/2022/python-pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="0-Pytorch教程"><a href="#0-Pytorch教程" class="headerlink" title="0 Pytorch教程"></a>0 Pytorch教程</h1><ul><li>视频教程：<a href="https://www.bilibili.com/video/BV1hE411t7RN?p=1">PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】</a></li></ul><h1 id="1-安装相关安装包"><a href="#1-安装相关安装包" class="headerlink" title="1 安装相关安装包"></a>1 安装相关安装包</h1><h2 id="1-1-windows安装NVIDA"><a href="#1-1-windows安装NVIDA" class="headerlink" title="1.1 windows安装NVIDA"></a>1.1 windows安装NVIDA</h2><ul><li>详见博客：<a href="https://blog.csdn.net/weixin_44493841/article/details/103827326">Windows10 NVIDIA 驱动程序安装</a></li></ul><h2 id="1-2-Linux安装Anaconda"><a href="#1-2-Linux安装Anaconda" class="headerlink" title="1.2 Linux安装Anaconda"></a>1.2 Linux安装Anaconda</h2><ul><li>详见博客：<a href="https://zhuanlan.zhihu.com/p/349345180">Linux安装anaconda</a></li></ul><h2 id="1-3-在conda环境中安装Pytorch"><a href="#1-3-在conda环境中安装Pytorch" class="headerlink" title="1.3 在conda环境中安装Pytorch"></a>1.3 在conda环境中安装Pytorch</h2><p>从官网选择对应的版本，复制下载指令即可，官网链接：</p><p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><h2 id="1-4-conda导出-x2F-导入环境"><a href="#1-4-conda导出-x2F-导入环境" class="headerlink" title="1.4 conda导出&#x2F;导入环境"></a>1.4 conda导出&#x2F;导入环境</h2><ul><li><strong>不同系统迁移</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">conda activate env_name  <span class="token comment"># 切换到新的环境</span>conda env export <span class="token operator">></span> env_name<span class="token punctuation">.</span>yaml  <span class="token comment"># 导出环境</span>conda env create <span class="token operator">-</span>f env_name<span class="token punctuation">.</span>yaml  <span class="token comment"># 导入环境</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>相同系统迁移</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">conda <span class="token builtin">list</span> <span class="token operator">-</span><span class="token operator">-</span>explicit <span class="token operator">></span> requirements<span class="token punctuation">.</span>txtconda create <span class="token operator">-</span><span class="token operator">-</span>name python<span class="token operator">-</span>course <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">file</span> requirements<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/87344422">Conda 环境迁移</a></p><h2 id="1-5-下载特殊安装包"><a href="#1-5-下载特殊安装包" class="headerlink" title="1.5 下载特殊安装包"></a>1.5 下载特殊安装包</h2><h3 id="1-5-1-下载tensorboardx"><a href="#1-5-1-下载tensorboardx" class="headerlink" title="1.5.1 下载tensorboardx"></a>1.5.1 下载tensorboardx</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda install -c conda-forge tensorboardx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-2-下载PyG"><a href="#1-5-2-下载PyG" class="headerlink" title="1.5.2 下载PyG"></a>1.5.2 下载PyG</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda install pyg -c pyg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-6-window添加conda环境变量"><a href="#1-6-window添加conda环境变量" class="headerlink" title="1.6 window添加conda环境变量"></a>1.6 window添加conda环境变量</h2><ul><li>添加路径到系统变量Path下：</li></ul><ol><li>C:\xxx\xxx\Anaconda3\Scripts</li><li>C:\xxx\xxx\Anaconda3\Library\bin</li></ol><h1 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2 常用指令"></a>2 常用指令</h1><h2 id="2-1-一般指令"><a href="#2-1-一般指令" class="headerlink" title="2.1 一般指令"></a>2.1 一般指令</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#矩阵乘法</span>torch<span class="token punctuation">.</span>mm<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> mat2<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> out<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span> → Tensor<span class="token comment">#矩阵转置</span>torch<span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span> → Tensortensor<span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#生成单元矩阵，对角线为1，其余为0的矩阵</span>torch<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> out<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> layout<span class="token operator">=</span>torch<span class="token punctuation">.</span>strided<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> → Tensor<span class="token comment">#设置和运行 CUDA 操作</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>tensor<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#把tensor_1扩展成size的形状</span>tensor_1<span class="token punctuation">.</span>expand<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token comment">#把tensor_1扩展成和tensor_2一样的形状</span>tensor_1<span class="token punctuation">.</span>expand_as<span class="token punctuation">(</span>tensor_2<span class="token punctuation">)</span><span class="token comment">#修改tensor形状</span><span class="token comment">#view不会改变自身数据，返回的新的tensor与源tensor共享内存，即更改其中一个，另外一个也会跟着改变。</span>tensor<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>tensor<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 把tensor变为一维结构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-查看GPU信息"><a href="#2-2-查看GPU信息" class="headerlink" title="2.2 查看GPU信息"></a>2.2 查看GPU信息</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#cuda是否可用；</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>device_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#返回gpu数量；</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>get_device_name<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#返回gpu名字，设备索引默认从0开始；</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>current_device<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#返回当前设备索引；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-保存-x2F-加载模型，torch-save-x2F-load"><a href="#2-3-保存-x2F-加载模型，torch-save-x2F-load" class="headerlink" title="2.3 保存&#x2F;加载模型，torch.save()&#x2F;load()"></a>2.3 保存&#x2F;加载模型，torch.save()&#x2F;load()</h2><p>将优化器参数、损失值等一同保存下来，然后在恢复模型的时候连同其它参数一起恢复，示例如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">model_save_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>model_save_dir<span class="token punctuation">,</span> <span class="token string">'model.pt'</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            <span class="token string">'epoch'</span><span class="token punctuation">:</span> epoch<span class="token punctuation">,</span>            <span class="token string">'model_state_dict'</span><span class="token punctuation">:</span> model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'optimizer_state_dict'</span><span class="token punctuation">:</span> optimizer<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'loss'</span><span class="token punctuation">:</span> loss<span class="token punctuation">,</span>    <span class="token string">'metrics'</span><span class="token punctuation">:</span> metrics            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> model_save_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>加载模型</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">checkpoint <span class="token operator">=</span> torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>model_save_path<span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>checkpoint<span class="token punctuation">[</span><span class="token string">'model_state_dict'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>optimizer<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>checkpoint<span class="token punctuation">[</span><span class="token string">'optimizer_state_dict'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>epoch <span class="token operator">=</span> checkpoint<span class="token punctuation">[</span><span class="token string">'epoch'</span><span class="token punctuation">]</span>loss <span class="token operator">=</span> checkpoint<span class="token punctuation">[</span><span class="token string">'loss'</span><span class="token punctuation">]</span>metrics <span class="token operator">=</span> checkpoint<span class="token punctuation">[</span><span class="token string">'metrics'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-模型加速，torch-backends-cudnn-benchmark-x3D-True"><a href="#2-4-模型加速，torch-backends-cudnn-benchmark-x3D-True" class="headerlink" title="2.4 模型加速，torch.backends.cudnn.benchmark&#x3D;True"></a>2.4 模型加速，torch.backends.cudnn.benchmark&#x3D;True</h2><p>让程序在开始时花费一点额外时间，为整个网络的每个卷积层搜索最适合它的卷积实现算法，进而实现网络的加速。适用场景是网络结构固定（不是动态变化的），网络的输入形状（包括 batch size，图片大小，输入的通道）是不变的，其实也就是一般情况下都比较适用。反之，如果卷积层的设置一直变化，将会导致程序不停地做优化，反而会耗费更多的时间。</p><ul><li>具体详情见博客：<a href="https://zhuanlan.zhihu.com/p/73711222">torch.backends.cudnn.benchmark ?!</a></li></ul><h1 id="3-重要函数"><a href="#3-重要函数" class="headerlink" title="3 重要函数"></a>3 重要函数</h1><h2 id="3-1-torch-svd-A"><a href="#3-1-torch-svd-A" class="headerlink" title="3.1 torch.svd(A)"></a>3.1 torch.svd(A)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#计算矩阵或矩阵批次的奇异值分解input，奇异值按降序返回</span>torch<span class="token punctuation">.</span>svd<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> some<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> out<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>Tensor<span class="token punctuation">,</span> Tensor<span class="token punctuation">,</span> Tensor<span class="token punctuation">)</span>U<span class="token punctuation">,</span>S<span class="token punctuation">,</span>V<span class="token operator">=</span>torch<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>A<span class="token punctuation">)</span>。 <span class="token comment">#返回对形如 n×m的实矩阵 A 进行奇异值分解的结果，使得 A=USV^T。 U 为左奇异向量，形状为 n×n，S 为特征值矩阵，形状为 n×m ，V 为右奇异向量，形状为 m×m</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>基于SVD的主成分分析代码</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">### PCA降维 ###</span><span class="token keyword">def</span> <span class="token function">PCA_svd</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># X为输入数，n*m n维m个样本</span>    <span class="token comment"># k为目标维度数</span>    X_mean <span class="token operator">=</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">.</span>double<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">)</span>    A <span class="token operator">=</span> X <span class="token operator">-</span> X_mean<span class="token punctuation">.</span>expand_as<span class="token punctuation">(</span>X<span class="token punctuation">)</span>  <span class="token comment"># 对所有样本中心化</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span>A<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    U<span class="token punctuation">,</span>S<span class="token punctuation">,</span>V <span class="token operator">=</span> torch<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>t<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 对矩阵A做特征值分解（奇异值分解），注意此处的A进行的转置</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'V'</span><span class="token punctuation">,</span>V<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> torch<span class="token punctuation">.</span>mm<span class="token punctuation">(</span>V<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span>  <span class="token comment"># 返回新的特征矩阵</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-torch-mean-input-dim-keepdim-x3D-false"><a href="#3-2-torch-mean-input-dim-keepdim-x3D-false" class="headerlink" title="3.2 torch.mean(input, dim, keepdim&#x3D;false)"></a>3.2 torch.mean(input, dim, keepdim&#x3D;false)</h2><ul><li><strong>输入</strong>( <a href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor"><em>Tensor</em></a> ) – 输入张量。</li><li><strong>dim</strong> ( <a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <em>tuple of python:ints</em> ) – 要减少的一个或多个维度。</li><li><strong>keepdim</strong> ( <a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a> ) – 输出张量是否<code>dim</code>保留。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.0163</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.5085</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.4599</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.1807</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-unsqueeze-与squeeze"><a href="#3-3-unsqueeze-与squeeze" class="headerlink" title="3.3 unsqueeze()与squeeze()"></a>3.3 unsqueeze()与squeeze()</h2><p>unsqueeze()：    在指定位置增加一个维度</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># a的size为(2，3)</span>a<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># a.unsqueeze(-2)</span><span class="token comment"># a的size为(2,1,3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>squeeze()：在指定位置删除一个长度为1的维度，注意长度一定要为1</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># a的size为(1, 2，3)</span>a<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># 下标从0开始</span><span class="token comment"># a的size为(2,3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-4-arange-start-end-step"><a href="#3-4-arange-start-end-step" class="headerlink" title="3.4 arange(start, end, step)"></a>3.4 arange(start, end, step)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">1.0000</span><span class="token punctuation">,</span>  <span class="token number">1.5000</span><span class="token punctuation">,</span>  <span class="token number">2.0000</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-tensor乘法广播机制"><a href="#3-5-tensor乘法广播机制" class="headerlink" title="3.5 tensor乘法广播机制"></a>3.5 tensor乘法广播机制</h2><p><strong>广播的执行过程：</strong></p><p>1.如果维度个数不同，则在维度较少的左边补1，使得维度的个数相同。</p><p>2.各维度的维度大小不同时，如果有维度为1的，直接将该维拉伸至维度相同。</p><h2 id="3-6-enisum"><a href="#3-6-enisum" class="headerlink" title="3.6 enisum"></a>3.6 enisum</h2><p><img src="http://img.fdchen.host//enisum.png" alt="image-20210626003645988"></p><p><img src="http://img.fdchen.host//enisum_%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="image-20210626003925510"></p><h2 id="3-7-randint-low-x3D-0-high-size"><a href="#3-7-randint-low-x3D-0-high-size" class="headerlink" title="3.7 randint(low&#x3D;0,high, size)"></a>3.7 randint(low&#x3D;0,high, size)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-8-torch-backends-cudnn-deterministic"><a href="#3-8-torch-backends-cudnn-deterministic" class="headerlink" title="3.8 torch.backends.cudnn.deterministic"></a>3.8 torch.backends.cudnn.deterministic</h2><p>torch.backends.cudnn.deterministic是啥？顾名思义，将这个 flag 置为True的话，每次返回的卷积算法将是确定的，即默认算法。如果配合上设置 Torch 的随机种子为固定值的话，应该可以保证每次运行网络的时候相同输入的输出是固定的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 设置随机数种子</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>manual_seed<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>manual_seed_all<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>cudnn<span class="token punctuation">.</span>deterministic <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 保证每次结果一样</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-9-torch-optim"><a href="#3-9-torch-optim" class="headerlink" title="3.9 torch.optim"></a>3.9 torch.optim</h2><p>torch.optim是一个实现各种优化算法的包，实质就是更新权重。</p><ul><li><p>如何使用优化器</p><p>要使用，torch.optim您必须构造一个优化器对象，该对象将保存当前状态并根据计算出的梯度更新参数。</p></li><li><p>构建它<br>要构造一个ptimizer你必须给它一个包含Variable要优化的参数（都应该是s）的迭代。然后，您可以指定特定于优化器的选项，例如学习率、权重衰减等。示</p></li></ul><h2 id="3-10-tensor拒绝计算整数的平均数，需要用到double-函数"><a href="#3-10-tensor拒绝计算整数的平均数，需要用到double-函数" class="headerlink" title="3.10 tensor拒绝计算整数的平均数，需要用到double()函数"></a>3.10 tensor拒绝计算整数的平均数，需要用到double()函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">.</span>double<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-11-可以作为占位符接收函数不需要的返回值"><a href="#3-11-可以作为占位符接收函数不需要的返回值" class="headerlink" title="3.11 _可以作为占位符接收函数不需要的返回值"></a>3.11 _可以作为占位符接收函数不需要的返回值</h2><h1 id="4-nn的相关使用"><a href="#4-nn的相关使用" class="headerlink" title="4 nn的相关使用"></a>4 nn的相关使用</h1><h2 id="4-1-item"><a href="#4-1-item" class="headerlink" title="4.1 item()"></a>4.1 item()</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># item()返回单个值（标量）</span>loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 获得loss的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-2-detach"><a href="#4-2-detach" class="headerlink" title="4.2 detach()"></a>4.2 detach()</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># detach()阻断反向传播，返回值仍为tensor</span>gpu_info<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#返回tensor，仍在gpu上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-3-cpu"><a href="#4-3-cpu" class="headerlink" title="4.3 cpu()"></a>4.3 cpu()</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># cpu()将变量放在cpu上，仍为tensor</span>gpu_info<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span>gpu_info<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-4-设置提前停止"><a href="#4-4-设置提前停止" class="headerlink" title="4.4 设置提前停止"></a>4.4 设置提前停止</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 设置提前停止，patience代表忍受该指标多少个step不变化，当忍无可忍时，调整学习率。注，可以不是连续的n次。</span>early_stopping <span class="token operator">=</span> EarlyStopping<span class="token punctuation">(</span>patience<span class="token operator">=</span>self<span class="token punctuation">.</span>args<span class="token punctuation">.</span>patience<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-5-checkpoints"><a href="#4-5-checkpoints" class="headerlink" title="4.5 checkpoints"></a>4.5 checkpoints</h2><p>保存和加载用于推理或恢复训练的通用检查点模型有助于从上次停止的地方开始。保存一般检查点时，您必须保存的不仅仅是模型的 state_dict。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>args<span class="token punctuation">.</span>checkpoints<span class="token punctuation">,</span> setting<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-6-AMP"><a href="#4-6-AMP" class="headerlink" title="4.6 AMP"></a>4.6 AMP</h2><p>自动混合精度训练，预示着Tensor的dtype类型会自动变化，也就是框架按需自动调整tensor的dtype（其实不是完全自动，有些地方还是需要手工干预）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 在训练最开始之前实例化一个GradScaler对象</span>scaler <span class="token operator">=</span> GradScaler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> epochs<span class="token punctuation">:</span>    <span class="token keyword">for</span> <span class="token builtin">input</span><span class="token punctuation">,</span> target <span class="token keyword">in</span> data<span class="token punctuation">:</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 前向过程(model + loss)开启 autocast</span>        <span class="token keyword">with</span> autocast<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            output <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>            loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        <span class="token comment"># Scales loss. 为了梯度放大.</span>        scaler<span class="token punctuation">.</span>scale<span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># scaler.step() 首先把梯度的值unscale回来.</span>        <span class="token comment"># 如果梯度的值不是 infs 或者 NaNs, 那么调用optimizer.step()来更新权重,</span>        <span class="token comment"># 否则，忽略step调用，从而保证权重不更新（不被破坏）</span>        scaler<span class="token punctuation">.</span>step<span class="token punctuation">(</span>optimizer<span class="token punctuation">)</span>        <span class="token comment"># 准备着，看是否要增大scaler</span>        scaler<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-7-permute"><a href="#4-7-permute" class="headerlink" title="4.7 permute()"></a>4.7 permute()</h2><p>**Tensor.permute(a,b,c,d, …)**：permute函数可以对任意高维矩阵进行转置&#x2F;换位，但没有 torch.permute() 这个调用方式， 只能 Tensor.permute()：</p><pre class="line-numbers language-python3" data-language="python3"><code class="language-python3">&gt;&gt;&gt; torch.randn(2,3,4,5).permute(3,2,0,1).shapetorch.Size([5, 4, 2, 3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-8-transpose-input-dim0-dim1"><a href="#4-8-transpose-input-dim0-dim1" class="headerlink" title="4.8 transpose(input, dim0, dim1)"></a>4.8 transpose(input, dim0, dim1)</h2><p>转置&#x2F;换位tensor中指定两个维度dim0 和 dim1的数据</p><h2 id="4-9-nn-Conv1d"><a href="#4-9-nn-Conv1d" class="headerlink" title="4.9 nn.Conv1d()"></a>4.9 nn.Conv1d()</h2><p>卷积操作起源于图像处理，图像处理的数据一般为[batch_size, num_channel, height, width]</p><p>因此，通道数需要放在第二个维度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义</span>self<span class="token punctuation">.</span>tokenConv <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv1d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span>c_in<span class="token punctuation">,</span> out_channels<span class="token operator">=</span>d_model<span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span>padding<span class="token punctuation">,</span> padding_mode<span class="token operator">=</span><span class="token string">'circular'</span><span class="token punctuation">)</span><span class="token comment"># 使用</span><span class="token comment"># x的结构为 [batch_size, len, dims]</span><span class="token comment"># 此处需要获取feed_de的序列，因而先转置，以实现对len序列进行一维卷积，最后恢复原始数据维度排布</span>x <span class="token operator">=</span> self<span class="token punctuation">.</span>tokenConv<span class="token punctuation">(</span>x<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-10-nn-init-kaiming-normal"><a href="#4-10-nn-init-kaiming-normal" class="headerlink" title="4.10 nn.init.kaiming_normal_"></a>4.10 nn.init.kaiming_normal_</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 使用正态分布数据初始化模型参数</span>nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>kaiming_normal_<span class="token punctuation">(</span>m<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'fan_in'</span><span class="token punctuation">,</span> nonlinearity<span class="token operator">=</span><span class="token string">'leaky_relu'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-11-nn-embedding"><a href="#4-11-nn-embedding" class="headerlink" title="4.11 nn.embedding()"></a>4.11 nn.embedding()</h2><p>一个简单的查找表，用于存储固定字典和大小的embedding。</p><p>参数：</p><ul><li>**num_ embedding ** ( <a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> ) –embedding字典的大小</li><li><strong>embedding _dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int"> <em>int</em></a> ) – 每个embedding向量的大小</li><li><strong>padding_idx</strong> ( <a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>,</em> <em>optional</em> ) – 如果指定，则条目<code>padding_idx</code>不影响梯度；因此，嵌入向量 at<code>padding_idx</code>在训练期间不会更新，即它保持为固定的“垫”。对于新构造的Embedding，嵌入向量 at<code>padding_idx</code>将默认为全零，但可以更新为另一个值以用作填充向量。</li><li><strong>max_norm</strong> ( <a href="https://docs.python.org/3/library/functions.html#float"><em>float</em></a> <em>,</em> <em>optional</em> ) – 如果给定，则范数大于的每个嵌入向量都<code>max_norm</code> 被重新归一<strong>化为</strong>范数<code>max_norm</code>。</li><li><strong>norm_type</strong> ( <a href="https://docs.python.org/3/library/functions.html#float"><em>float</em></a> <em>,</em> <em>optional</em> ) – 要为<code>max_norm</code>选项计算的 p 范数的 p 。默认<code>2</code>.</li><li><strong>scale_grad_by_freq</strong> ( <em>boolean</em> <em>,</em> <em>optional</em> ) – 如果给定，这将按小批量中单词频率的倒数来缩放梯度。默认<code>False</code>.</li><li><strong>sparse</strong> ( <a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a> <em>,</em> <em>optional</em> ) – 如果<code>True</code>，梯度 wrt<code>weight</code>矩阵将是一个稀疏张量。有关稀疏梯度的更多详细信息，请参阅注释。</li></ul><p>变量：</p><p><strong>~Embedding.weight</strong> (<a href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor"><em>Tensor</em></a>) – 可学习权重模块的大小</p><h2 id="4-12-nn-parameter-Parameter"><a href="#4-12-nn-parameter-Parameter" class="headerlink" title="4.12 nn.parameter.Parameter()"></a>4.12 nn.parameter.Parameter()</h2><p>一种被视为模块参数的tensor。</p><p>参数：</p><ul><li><strong>data</strong>( <a href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor"><em>Tensor</em></a> ) –参数张量。</li><li><strong>requires_grad</strong> ( <a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a> <em>,</em> <em>optional</em> ) – 如果参数需要梯度。</li></ul><h2 id="4-13-self-register-buffer-‘pe’-pe"><a href="#4-13-self-register-buffer-‘pe’-pe" class="headerlink" title="4.13 self.register_buffer(‘pe’, pe)"></a>4.13 self.register_buffer(‘pe’, pe)</h2><p>1.定义parameter和buffer都只需要传入Tensor即可。也不需要将其转成gpu,这是因为，当网络进行.cuda时候，会自动将里面的层的参数，buffer等转换成相应的GPU上。</p><p>2.self.register_buffer可以将tensor注册成buffer,在forward中使用self.mybuffer,而不是self.mybuffer_tmp</p><p>3.<strong>网络存储时也会将buffer存下，当网络load模型时，会将存储的模型的buffer也进行赋值。</strong></p><p><strong>4.buffer的更新在forward中，optim.step只能更新nn.parameter类型的参数。</strong></p><h2 id="4-14-dropout"><a href="#4-14-dropout" class="headerlink" title="4.14 dropout"></a>4.14 dropout</h2><p>在训练期间，使用来自伯努利分布的样本，在概率为<code>p</code>下随机将输入tensor的某些元素归零。每个通道将在每次前转呼叫中独立归零。</p><p>一种用于正则化和防止神经元协同适应的有效技术，用于抑制过拟合。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义</span>self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span>dropout<span class="token punctuation">)</span><span class="token comment"># 使用</span>self<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-15-embedding"><a href="#4-15-embedding" class="headerlink" title="4.15 embedding()"></a>4.15 embedding()</h2><p>词嵌入在 pytorch 中非常简单，只需要调用 <code>torch.nn.Embedding(m, n)</code> 就可以了，m 表示单词的总数目，n 表示词嵌入的维度，其实词嵌入就相当于是一个大矩阵，矩阵的每一行表示一个单词.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>autograd <span class="token keyword">import</span> Variable<span class="token comment"># 定义词嵌入</span>embeds <span class="token operator">=</span> nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment"># 2 个单词，维度 5</span><span class="token comment"># 得到词嵌入矩阵</span>embeds<span class="token punctuation">.</span>weightParameter containing<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1.3426</span>  <span class="token number">0.7316</span> <span class="token operator">-</span><span class="token number">0.2437</span>  <span class="token number">0.4925</span> <span class="token operator">-</span><span class="token number">0.0191</span><span class="token operator">-</span><span class="token number">0.8326</span>  <span class="token number">0.3367</span>  <span class="token number">0.2135</span>  <span class="token number">0.5059</span>  <span class="token number">0.8326</span><span class="token punctuation">[</span>torch<span class="token punctuation">.</span>FloatTensor of size 2x5<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过 <code>weight</code> 得到了整个词嵌入的矩阵，注意，</p><ol><li><strong>这个矩阵是一个可以改变的 parameter，在网络的训练中会不断更新；</strong></li><li><strong>同时词嵌入的数值可以直接进行修改，比如我们可以读入一个预训练好的词嵌入等等。</strong></li></ol><p>通俗来说，如果是不读入预训练的词嵌入，nn.embedding()相当于把one-hot编码转换为低维向量，这个向量就称为嵌入，就是仅仅根据one-hot编码信息得出，包含的是顺序&#x2F;位置信息，以方便用表示每个元素(one-hot维度太大)。</p><h2 id="4-16-自然指数为底的对数，-log"><a href="#4-16-自然指数为底的对数，-log" class="headerlink" title="4.16 自然指数为底的对数，.log()"></a>4.16 自然指数为底的对数，.log()</h2><h2 id="4-17-获取Parameter的tesnor，Parameter-data"><a href="#4-17-获取Parameter的tesnor，Parameter-data" class="headerlink" title="4.17 获取Parameter的tesnor，Parameter.data"></a>4.17 获取Parameter的tesnor，Parameter.data</h2><h1 id="5-torch-tensor"><a href="#5-torch-tensor" class="headerlink" title="5 torch.tensor"></a>5 torch.tensor</h1><h2 id="5-1-转置-tensor-t"><a href="#5-1-转置-tensor-t" class="headerlink" title="5.1 转置 tensor.t()"></a>5.1 转置 tensor.t()</h2><h2 id="5-2-基于列向量生成对角矩阵-torch-diag-embed-tensor"><a href="#5-2-基于列向量生成对角矩阵-torch-diag-embed-tensor" class="headerlink" title="5.2 基于列向量生成对角矩阵 torch.diag_embed(tensor)"></a>5.2 基于列向量生成对角矩阵 torch.diag_embed(tensor)</h2><h2 id="5-3-求范数-torch-norm"><a href="#5-3-求范数-torch-norm" class="headerlink" title="5.3 求范数 torch.norm()"></a>5.3 求范数 torch.norm()</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>tensor <span class="token keyword">as</span> tensor a <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">#建立tensor</span>a2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>a<span class="token punctuation">)</span>      <span class="token comment">#默认求2范数</span>a1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">#指定求1范数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-判断是否有nan，torch-isnan-tensor"><a href="#5-4-判断是否有nan，torch-isnan-tensor" class="headerlink" title="5.4 判断是否有nan，torch.isnan(tensor)"></a>5.4 判断是否有nan，torch.isnan(tensor)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>tensor<span class="token punctuation">)</span>  <span class="token comment"># 返回bool类型的tensor</span>torch<span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span>tensor<span class="token punctuation">)</span>  <span class="token comment"># 判断tensor中是否有True值，返回True or False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-5-有条件替换，torch-where-condition-x-y"><a href="#5-5-有条件替换，torch-where-condition-x-y" class="headerlink" title="5.5 有条件替换，torch.where(condition, x, y)"></a>5.5 有条件替换，torch.where(condition, x, y)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>condition<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>  <span class="token comment"># condition是BoolTensor，x是满足condition位置的值，y是不满足condition位置的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>替换所有nan值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>nan<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>a <span class="token operator">=</span> torch<span class="token punctuation">.</span>where<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>full_like<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-6-返回同一值的同size的tensor，torch-full-like-tensor"><a href="#5-6-返回同一值的同size的tensor，torch-full-like-tensor" class="headerlink" title="5.6 返回同一值的同size的tensor，torch.full_like(tensor)"></a>5.6 返回同一值的同size的tensor，torch.full_like(tensor)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>full_like<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> fill_value<span class="token punctuation">)</span> → Tensor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-7-比较tensor元素，torch-eq-相关"><a href="#5-7-比较tensor元素，torch-eq-相关" class="headerlink" title="5.7 比较tensor元素，torch.eq()相关"></a>5.7 比较tensor元素，torch.eq()相关</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#  逐元素比较，=</span>torch<span class="token punctuation">.</span>equal<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 整体比较，=</span>torch<span class="token punctuation">.</span>ge<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 逐元素比较，>=</span>torch<span class="token punctuation">.</span>gt<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 逐元素比较，></span>torch<span class="token punctuation">.</span>le<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 逐元素比较，&lt;=</span>torch<span class="token punctuation">.</span>lt<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 逐元素比较，&lt;</span>torch<span class="token punctuation">.</span>ne<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 逐元素比较，!=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-8-复制tensor，repeat-size"><a href="#5-8-复制tensor，repeat-size" class="headerlink" title="5.8 复制tensor，repeat(*size)"></a>5.8 复制tensor，repeat(*size)</h2><ul><li>注意不同于numpy.repeat()，numpy.repeat()逐元素复制，torch.repeat()可以赋值扩展到新的size</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">### 结果 ###</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 1代表维持第3个维度的大小不变</span><span class="token comment"># torch.Size([4, 2, 3])</span>numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment"># array([1, 1, 2, 2, 3, 3])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-8-在已有维度上拼接tensor，torch-cat-inputs-dim"><a href="#5-8-在已有维度上拼接tensor，torch-cat-inputs-dim" class="headerlink" title="5.8 在已有维度上拼接tensor，torch.cat(inputs, dim)"></a>5.8 在已有维度上拼接tensor，torch.cat(inputs, dim)</h2><ol><li>对于需要拼接的tensor，维度数量必须相同，指定拼接的维度的尺寸可以不同，但是其它维度的尺寸必须相同。</li><li>inputs可以是tensor也可以是list</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.1997</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.6900</span><span class="token punctuation">,</span>  <span class="token number">0.7039</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.0268</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0140</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.9764</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># 在 0 维(纵向)进行拼接</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.1997</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.6900</span><span class="token punctuation">,</span>  <span class="token number">0.7039</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.0268</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0140</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.9764</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.1997</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.6900</span><span class="token punctuation">,</span>  <span class="token number">0.7039</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.0268</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0140</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.9764</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.1997</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.6900</span><span class="token punctuation">,</span>  <span class="token number">0.7039</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.0268</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0140</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.9764</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-9-在新维度上拼接tensor，torch-stack-inputs-dim"><a href="#5-9-在新维度上拼接tensor，torch-stack-inputs-dim" class="headerlink" title="5.9 在新维度上拼接tensor，torch.stack(inputs, dim)"></a>5.9 在新维度上拼接tensor，torch.stack(inputs, dim)</h2><p>把相同形状的tensor合并，并根据提供的维度序列在相应位置插入新的维度，函数会根据位置来排列数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 在 0 维插入一个维度，进行区分拼接</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 在 1 维插入一个维度，进行组合拼接</span>torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-10-在指定位置插入维度1，torch-unsqueeze-input-dim"><a href="#5-10-在指定位置插入维度1，torch-unsqueeze-input-dim" class="headerlink" title="5.10 在指定位置插入维度1，torch.unsqueeze(input, dim)"></a>5.10 在指定位置插入维度1，torch.unsqueeze(input, dim)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># tensor([[1.],</span><span class="token comment">#         [2.],</span><span class="token comment">#         [3.],</span><span class="token comment">#         [4.]])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-11-去除大小为1的维度，torch-squeeze-input-dim"><a href="#5-11-去除大小为1的维度，torch-squeeze-input-dim" class="headerlink" title="5.11 去除大小为1的维度，torch.squeeze(input, dim)"></a>5.11 去除大小为1的维度，torch.squeeze(input, dim)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">m <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># torch.Size([2, 1, 2, 1, 2])</span>n <span class="token operator">=</span> torch<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># torch.Size([2, 2, 2])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-12-查找某个值，torch-nonzero-a-x3D-x3D-10-squeeze"><a href="#5-12-查找某个值，torch-nonzero-a-x3D-x3D-10-squeeze" class="headerlink" title="5.12 查找某个值，torch.nonzero(a&#x3D;&#x3D;10).squeeze()"></a>5.12 查找某个值，torch.nonzero(a&#x3D;&#x3D;10).squeeze()</h2><h2 id="5-13-将tensor最高维度转换为list，其他维度维持tensor格式"><a href="#5-13-将tensor最高维度转换为list，其他维度维持tensor格式" class="headerlink" title="5.13 将tensor最高维度转换为list，其他维度维持tensor格式"></a>5.13 将tensor最高维度转换为list，其他维度维持tensor格式</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span><span class="token punctuation">(</span>Tensor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-14-重构tensor维度大小，view"><a href="#5-14-重构tensor维度大小，view" class="headerlink" title="5.14 重构tensor维度大小，view"></a>5.14 重构tensor维度大小，view</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>view<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>  <span class="token comment"># a * b</span>torch<span class="token punctuation">.</span>view<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># a * n/a, n代表元素个数</span>torch<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># n, 一维结构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="6-PyG-torch-geometirc"><a href="#6-PyG-torch-geometirc" class="headerlink" title="6 PyG-torch.geometirc"></a>6 PyG-torch.geometirc</h1><blockquote><p>图神经网络神器</p></blockquote><h2 id="6-1-入门教程"><a href="#6-1-入门教程" class="headerlink" title="6.1 入门教程"></a>6.1 入门教程</h2><ul><li>详见博客：<a href="https://zhuanlan.zhihu.com/p/94491664">图神经网络之神器——PyTorch Geometric 上手 &amp; 实战</a></li></ul><h2 id="6-2-构建输入"><a href="#6-2-构建输入" class="headerlink" title="6.2 构建输入"></a>6.2 构建输入</h2><p>PyG的特征输入有三种格式：Dataset，List[Data]，List[HeteroData]</p><h3 id="6-2-1-构建Dataset"><a href="#6-2-1-构建Dataset" class="headerlink" title="6.2.1 构建Dataset"></a>6.2.1 构建Dataset</h3><ul><li><strong>创建一次读入内存的数据</strong></li></ul><p>构建torch_geometric.data.InMemoryDataset，需要重写（区分重载和重写）四个函数：<br>（1）torch_geometric.data.InMemoryDataset.raw_file_names()<br>存放raw_dir目录下所有数据文件名的字符串列表，用于下载时的检查过程（正如之前的文章提到的，数据集下载的时候会检测是否已经存在，避免重复下载，也就是如何避免自动下载的httperror的解决方案）。<br>（2）torch_geometric.data.InMemoryDataset.processed_file_names()<br>和（1）类似，存放processed_dir目录下的文件名的列表，用于检测是否已经存在（不会二次处理）。<br>（3）torch_geometric.data.InMemoryDataset.download()<br>下载数据到raw_dir目录下。<br>（4）torch_geometric.data.InMemoryDataset.process()<br>对raw_dir下的数据进行处理并存储到processed_dir目录下。<br>因此，可以发现关键在于第四个函数的实现，函数内首先需要读取原始数据并创建一个torch_geometric.data.Data对象的列表，并存储到processed_dir目录下面。直接存储和使用这个python-list时间代价很高，所以在存储之前调用torch_geometric.data.InMemoryDataset.collate()函数将列表转换为一个torch_geometric.data.Data对象。处理后的数据被整合到了一个数据对象中（作为返回值），同时返回一个slices字典来获取到这个数据对象中单个数据，所以总结下来process过程一共分四步：</p><ol><li>加载数据创建列表</li><li>进行各种处理过程</li><li>调用collate()函数</li><li>存储本地</li></ol><p>最后在数据类的构造函数中加载数据集并赋值给self.data和self.slices</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch_geometric<span class="token punctuation">.</span>data <span class="token keyword">import</span> InMemoryDataset<span class="token keyword">class</span> <span class="token class-name">MyDataset</span><span class="token punctuation">(</span>InMemoryDataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> pre_transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 数据的下载和处理过程在父类中调用实现</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MyDataset<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>root<span class="token punctuation">,</span> transform<span class="token punctuation">,</span> pre_transform<span class="token punctuation">)</span>        <span class="token comment"># 加载数据</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">,</span> self<span class="token punctuation">.</span>slices <span class="token operator">=</span> torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>self<span class="token punctuation">.</span>processed_paths<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 将函数修饰为类属性</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">raw_file_names</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'file_1'</span><span class="token punctuation">,</span> <span class="token string">'file_2'</span><span class="token punctuation">]</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">processed_file_names</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'data.pt'</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">download</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># download to self.raw_dir</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">process</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        data_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>pre_filter <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            data_list <span class="token operator">=</span> <span class="token punctuation">[</span>data <span class="token keyword">for</span> data <span class="token keyword">in</span> data_list <span class="token keyword">if</span> self<span class="token punctuation">.</span>pre_filter<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>pre_filter <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            data_list <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>pre_transform<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token keyword">for</span> data <span class="token keyword">in</span> data_list<span class="token punctuation">]</span>        data<span class="token punctuation">,</span> slices <span class="token operator">=</span> self<span class="token punctuation">.</span>collate<span class="token punctuation">(</span>data_list<span class="token punctuation">)</span>        <span class="token comment"># 这里的save方式以及路径需要对应构造函数中的load操作</span>        torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> slices<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>processed_paths<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>创建大规模数据</strong></li></ul><p>大数据集一般不会直接加载到内存中，这里构建数据集的时候需要继承父类torch_geometric.data.Dataset。在上面构建数据集时，重写了四个函数，此处还需要多实现两个函数：<br>（1）torch_geometric.data.Dataset.len()<br>返回数据集的文件个数。<br>（2）torch_geometric.data.Dataset.get()<br>实现对单个数据（图数据集的话一般是单个图）的加载逻辑。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">.</span>path <span class="token keyword">as</span> osp<span class="token keyword">import</span> torch <span class="token comment"># 这里就不能用InMemoryDataset了</span><span class="token keyword">from</span> torch_geometric<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token keyword">class</span> <span class="token class-name">MyDataset</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 默认预处理函数的参数都是None</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> pre_transform<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MyDataset<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>root<span class="token punctuation">,</span> transform<span class="token punctuation">,</span> pre_transform<span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">raw_file_names</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'file_1'</span><span class="token punctuation">,</span> <span class="token string">'file_2'</span><span class="token punctuation">]</span>        <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">processed_file_names</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 一次无法加载所有数据，所以对数据进行了分解</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'data1.pt'</span><span class="token punctuation">,</span> <span class="token string">'data2.pt'</span><span class="token punctuation">,</span> <span class="token string">'data3.pt'</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">download</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># Download to raw_dir</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">process</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 遍历每一个文件路径</span>        <span class="token keyword">for</span> raw_path <span class="token keyword">in</span> self<span class="token punctuation">.</span>raw_paths<span class="token punctuation">:</span>            data <span class="token operator">=</span> Data<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>pre_filter <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>pre_filter<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>pre_transform <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                data <span class="token operator">=</span> self<span class="token punctuation">.</span>pre_transform<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>data<span class="token punctuation">,</span> osp<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>processed_dir<span class="token punctuation">,</span> <span class="token string">'data_&#123;&#125;.pt'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">def</span> <span class="token function">len</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>processed_file_names<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>osp<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>processed_dir<span class="token punctuation">,</span> <span class="token string">'data&#123;&#125;.pt'</span><span class="token punctuation">,</span><span class="token builtin">format</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其他细节以及解释，查看原文链接：<a href="https://blog.csdn.net/TwT520Ly/article/details/105633847">【PyG入门学习】四：构建自己的数据集</a></li></ul><h3 id="6-2-2-构建List-Data"><a href="#6-2-2-构建List-Data" class="headerlink" title="6.2.2 构建List[Data]"></a>6.2.2 构建List[Data]</h3><p>Data的结构由节点特征x与边索引edge_index构成，生成多个Data组成List即可，下面的示例包含使用batch处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">graph_data_list <span class="token operator">=</span> <span class="token punctuation">[</span>Data<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> edge_index<span class="token operator">=</span>self<span class="token punctuation">.</span>graph_edge_index<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> feature_input<span class="token punctuation">]</span>graph_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>graph_data_list<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token keyword">for</span> graph_batch_data <span class="token keyword">in</span> graph_dataloader<span class="token punctuation">:</span>    GATConv<span class="token punctuation">(</span>graph_batch_data<span class="token punctuation">.</span>x<span class="token punctuation">,</span> graph_batch_data<span class="token punctuation">.</span>edge_index<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更多数据集解释见博客：<a href="https://blog.csdn.net/m0_59596990/article/details/121435638?utm_source=app&app_version=5.3.0&code=app_1562916241&uLinkId=usr1mkqgl919blen">图神经网络框架-PyTorch Geometric(PyG)的使用及踩坑</a></li></ul><h3 id="6-2-3-构建异质图List-HeteroData"><a href="#6-2-3-构建异质图List-HeteroData" class="headerlink" title="6.2.3 构建异质图List[HeteroData]"></a>6.2.3 构建异质图List[HeteroData]</h3><ul><li>详见博客：<a href="https://blog.csdn.net/m0_59596990/article/details/121435638?utm_source=app&app_version=5.3.0&code=app_1562916241&uLinkId=usr1mkqgl919blen">图神经网络框架-PyTorch Geometric(PyG)的使用及踩坑</a></li></ul><h2 id="6-3-源码解释"><a href="#6-3-源码解释" class="headerlink" title="6.3 源码解释"></a>6.3 源码解释</h2><h3 id="6-3-1-GATConv源码解释"><a href="#6-3-1-GATConv源码解释" class="headerlink" title="6.3.1 GATConv源码解释"></a>6.3.1 GATConv源码解释</h3><ul><li>详见博客：<a href="https://blog.csdn.net/weixin_44839047/article/details/115724958">笔记：Pytorch-geometric: GAT代码超详细解读 | source node | target node | source_to_target</a></li></ul><h3 id="6-3-2-GCNConv源码解释"><a href="#6-3-2-GCNConv源码解释" class="headerlink" title="6.3.2 GCNConv源码解释"></a>6.3.2 GCNConv源码解释</h3><ul><li>详见博客：<a href="https://blog.csdn.net/Cyril_KI/article/details/123457698?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_aa&utm_relevant_index=10">PyG搭建GCN实现节点分类（GCNConv参数详解）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服创总结</title>
      <link href="/2021/sui-bi-fu-chuang-zong-jie/"/>
      <url>/2021/sui-bi-fu-chuang-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>纪念人生中唯一一次服创</p><p>结果：全国三等奖</p></blockquote><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>服创（大学生服务外包创新创业大赛），应该是第一次作为队长带领伙伴们参加比赛，可以说压力还是有点大——怕没能担好这个责任，没能带大家拿下好成绩。最后还确实出现了失误，而且队内气氛也没有调节好，即便到了最后还是感觉交流有点少（也可能是这个原因，导致我自己也没有太多难忘的回忆，更多是内疚和自责），等等问题。下面重点还是以反思为主。</p><span id="more"></span><h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><p>服创准备的话，还真不好说，毕竟是“命题作文”，只能说平时多积累一些技能罢了。</p><p>如果是做应用，队内成员就应该提前了解一下前端(React, Vue等)或者后端框架(SpringBoot, Django等)，避免需要花时间去学习框架，这个时间还挺长的。</p><p>而且，最好是去认识一下艺术学院的设计高手，注意，一定是要设计高手，不是每个艺术学院的都可以设计一个很好的UI。</p><h1 id="2-选题"><a href="#2-选题" class="headerlink" title="2. 选题"></a>2. 选题</h1><p>服创是“命题作文”，所以涉及到自己选题，选题这个大体方向是不要选太简单也不要选太难。太简单的上限低，不能冲击很高的奖项。太难的可能做不出来。除此之外，可以参考团队成员的兴趣，也建议选择可创新点多的，便于发挥。</p><h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h1><h2 id="3-1-小组讨论"><a href="#3-1-小组讨论" class="headerlink" title="3.1 小组讨论"></a>3.1 小组讨论</h2><ol><li>思想交流不够</li><li>队员主人翁意识不够，过于个人掌控</li><li>方向性方案应该集体讨论决定</li><li>以尽量打开讨论的氛围的目的，方法不唯一，或是分为三三两两讨论，或者自由讨论</li><li>作为组长，应该真心对待每一个组员，多发现优点，多用赞美，少用批评</li></ol><h2 id="3-2-系统设计"><a href="#3-2-系统设计" class="headerlink" title="3.2 系统设计"></a>3.2 系统设计</h2><ol><li>系统界面注意语言统一，不要中英文混杂</li><li>系统功能的设计应该从赛题出发，从目的出发，目的导向型。以数据分析为例，应该从可以提供什么帮助的角度出发，探索可以对哪些数据进行分析。而不是有哪些数据就分析哪些。</li></ol><h1 id="4-实施"><a href="#4-实施" class="headerlink" title="4. 实施"></a>4. 实施</h1><ol><li>解决方案迭代慢</li><li>进度管理失效</li><li>成员沟通不够</li></ol><h1 id="5-文档材料"><a href="#5-文档材料" class="headerlink" title="5. 文档材料"></a>5. 文档材料</h1><ol><li>重要概要性材料应该集思广益</li><li>不管什么文档，一定要借鉴其他人文档，去其糟粕，取其精华</li><li>注意用图表，增加可读性与理解</li><li>先写企业要求的材料，再写组委会要求的材料，原因是组委会要求的材料可以从企业材料中提炼</li></ol><h2 id="5-1-概要介绍文档"><a href="#5-1-概要介绍文档" class="headerlink" title="5.1 概要介绍文档"></a>5.1 概要介绍文档</h2><ol><li>尤为重要，应当包含所有的亮点，注意多用图展示，总括的图包括技术图，功能结构图等。</li><li>内容上包括项目背景、研究现状、技术方案等。</li><li>创新点和亮点注意用语高级，如智能协同、信息同步等，尽量避免使用朴实无华的亮点描述。</li></ol><h1 id="6-整体而言"><a href="#6-整体而言" class="headerlink" title="6. 整体而言"></a>6. 整体而言</h1><ol><li>注意会议记录</li><li>注重时间管理</li></ol><h1 id="7-区域赛决赛答辩"><a href="#7-区域赛决赛答辩" class="headerlink" title="7. 区域赛决赛答辩"></a>7. 区域赛决赛答辩</h1><h2 id="7-1-PPT"><a href="#7-1-PPT" class="headerlink" title="7.1 PPT"></a>7.1 PPT</h2><ol><li>演示视频最好缩短至3分钟左右</li><li>区域赛答辩，重点是查看项目是否真的完成。对于算法类，核心关注点是核心技术，对于项目类，核心关注点是项目是否完成。所以，算法类注意熟悉技术的各个细节，项目类最好是将系统部署至服务器，并且发布。</li><li>最后一定要总结实现的功能、创新点、价值等关键信息，</li></ol><h2 id="7-2-答辩"><a href="#7-2-答辩" class="headerlink" title="7.2 答辩"></a>7.2 答辩</h2><ol><li>答辩第一遍讲稿可以是提纲，也可以是讲稿，总之不能直接背记，应该反复模拟答辩，然后逐步修改讲稿</li><li>深入理解自己的创新，哪些地方超越了赛题，在答辩或者回答的过程中，可以不断有意无意地提到</li><li>回答的套路：你好老师，这个问题由我回答，·······(就问题回答的同时适当延展)，感谢评委老师的提问，我的回答不知道是否让您满意。注意每个问题至少20-40秒。</li><li>不要逞强，承认不足，感谢指点，不反问评委老师，可以说后续深入思考</li><li>答辩时站直，注意精气神</li><li>每个问题都注意展示自己的亮点和努力</li><li>项目的算法、数据、设计等部分，可以分人准备，要相信队友</li><li>多用数据和图标展示内容</li><li>可以用设问引起听众注意</li><li>团队成员简单介绍即可，可以放在开始部分</li><li>答辩看重个人魅力，一定要自信向上，以及整个团队成员的魅力</li></ol><h2 id="7-3-讲稿"><a href="#7-3-讲稿" class="headerlink" title="7.3 讲稿"></a>7.3 讲稿</h2><p>各位评委老师，各位志愿者同学，下午好，我们是来自XX大学的XXXXX团队，指导老师是XXX老师，很高兴在这里给各位评委老师展示我们的项目成果——速寻智能救援系统，我们的理念是用最短的时间找到TA。<br>首先请允许我介绍我们的团队成员，我是XXX，我们的团队成员还有：<br>XXX<br>(半鞠躬+老师们好)</p><p>以下我将从五个方面介绍我们的项目。</p><p>据统计，每年都有众多的走失事件发生，而成功找回的概率不尽如人意，往往时间越长找到的希望越小。</p><p>我们项目的目的是搭建一个智能救援的公益平台，辅助救援走失者，把握救援的黄金72小时。</p><p>首先我们先研究目前救援行动存在哪些痛点，主要的问题在于救援队员大多都是兼职志愿者，并且缺少专业的智能化平台，导致了以上高 难 少 低的四个痛点。那我们如何能解决这四个问题？</p><p>在提出我们的解决方案之前，我想通过一个视频让各位老师了解速寻系统的概貌。</p><p>接下来，我将对我们的解决方案进行详细解释。依据四大痛点，我们团队设计并研发了速寻智能救援系统，通过三大步骤和五大功能，助力救援行动的开展。后面，我将对这五个功能进行详细介绍。</p><p>第一点，救援启动快，我们通过公众号给家属提供快捷报案的途径，从事件申报到任务启动与级别判定，再到通过短信和APP通知附近队员，整个过程不到2分钟。我们还建立了易走失人员信息库即事件预申报，进一步加速救援启动。</p><p>第二点，信息协同高，我们提供统一的数据管理平台，通过APP、公众号、网页，供不同角色共享信息，而且，我们还提供将走失者信息网页通过二维码的方式向周围群众传播，群众可以使用人脸识别功能提交疑似目标线索。</p><p>第三点，智能辅助多，其一，我们提供集成了多种准确率高的人脸比对算法，并支持快速配置，其二，我们支持各类救援资源自动调取，供队员使用，其三，我们集成了高德地图接口组件，支持位置标记与地图导航。</p><p>第四点，过程跟踪细，从行动开始到结束，整个过程中的信息都详细记录，并支持一键导出，特别是当救援队报警求助时，可以将信息提交给警方，帮助警方寻找。</p><p>第五点，数据分析全，首先，我们支持依据事件发生特征，如走失时间、走失地点等，分析之后，帮助在事件高发期和高发地点进行宣传教育，预防事件发生。其二就是任务统计，加以案例分析可以帮助指挥员决策提高救援效率与成功率。</p><p>接下来，我将从业务架构，技术架构，实施路径三个方面阐述我们速寻智能救援系统的实现过程。</p><p>如图，是整个系统的业务架构，分为服务层、核心应用层、和功能模块层三层架构。</p><p>停2秒</p><p>其二，技术架构，包括前端，应用服务层和数据层，前端主要使用React与React-Native框架，后端使用Django框架。</p><p>其三，我们严格按照软件工程的流程进行项目研发，最后还进行了情景模拟以对系统功能和性能进行实际检验。</p><p>最后，我想用速寻系统研发的初衷来总结我们的关键创新点。当了解到走失事件频发的严峻状况时，我们不禁思考，科技发展至此，社会进步至此，我们该建立怎样的救助体系，为那些易走失的老人孩子构建一个安全的社会，一个走到哪里都能走回家的社会？</p><p>我们的回答是，第一，集腋成裘，聚沙成塔，汇聚社会每一份力量；第二，注重信息收集，分类汇总所有可能有用的信息，不放过任何一个机会；第三，借助智能工具，尽可能地减少不必要的时间成本；第四，不断总结反思，提供可视化数据分析，辅助指挥员决策。</p><p>以上就是我们的展示内容，感谢各位老师的倾听。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 服创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_Debug</title>
      <link href="/2021/python-debug/"/>
      <url>/2021/python-debug/</url>
      
        <content type="html"><![CDATA[<h3 id="1-JSON读取大量数据错误：JSONDecodeError-Extra-data-line-2-column-1或者ValueError-Extra-data"><a href="#1-JSON读取大量数据错误：JSONDecodeError-Extra-data-line-2-column-1或者ValueError-Extra-data" class="headerlink" title="1. JSON读取大量数据错误：JSONDecodeError: Extra data: line 2 column 1或者ValueError: Extra data"></a>1. JSON读取大量数据错误：JSONDecodeError: Extra data: line 2 column 1或者ValueError: Extra data</h3><ul><li>可以逐行读取，然后再处理成列表</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> json<span class="token comment"># 由于文件中有多行，直接读取会出现错误，因此一行一行读取</span><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"papers.json"</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>papers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> line <span class="token keyword">in</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dic <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>line<span class="token punctuation">)</span>    papers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dic<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>papers<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-‘gbk’-codec-can’t-decode-byte-0xbf-in-position-2-illegal-multibyte-sequence"><a href="#2-‘gbk’-codec-can’t-decode-byte-0xbf-in-position-2-illegal-multibyte-sequence" class="headerlink" title="2. ‘gbk’ codec can’t decode byte 0xbf in position 2: illegal multibyte sequence"></a>2. ‘gbk’ codec can’t decode byte 0xbf in position 2: illegal multibyte sequence</h3><ul><li>在打开文本时候，可以指明打开方式：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'gbk'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-连接mysql数据库报错-init-takes-1-positional-argument-but-5-were-given"><a href="#3-连接mysql数据库报错-init-takes-1-positional-argument-but-5-were-given" class="headerlink" title="3. 连接mysql数据库报错__init__() takes 1 positional argument but 5 were given"></a>3. 连接mysql数据库报错__init__() takes 1 positional argument but 5 were given</h3><ul><li>把连接语句修改成如下</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">db<span class="token operator">=</span>pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>host<span class="token operator">=</span>dbhost<span class="token punctuation">,</span>user<span class="token operator">=</span>dbuser<span class="token punctuation">,</span>password<span class="token operator">=</span>dbpass<span class="token punctuation">,</span>database<span class="token operator">=</span>dbname<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-PyTorch错误：The-“freeze-support-”-line-can-be-omitted-if-the-program-is-not-going-to-be-frozen-to-produce-an-executable"><a href="#4-PyTorch错误：The-“freeze-support-”-line-can-be-omitted-if-the-program-is-not-going-to-be-frozen-to-produce-an-executable" class="headerlink" title="4. PyTorch错误：The “freeze_support()” line can be omitted if the program is not going to be frozen to produce an executable."></a>4. PyTorch错误：The “freeze_support()” line can be omitted if the program is not going to be frozen to produce an executable.</h3><ul><li>将你要运行的代码块放到main函数中运行即可</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># your code</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-PytorchWarning-Leaking-Caffe2-thread-pool-after-fork"><a href="#5-PytorchWarning-Leaking-Caffe2-thread-pool-after-fork" class="headerlink" title="5. PytorchWarning: Leaking Caffe2 thread-pool after fork"></a>5. PytorchWarning: Leaking Caffe2 thread-pool after fork</h3><ul><li><p>解决办法：设置pin_memory&#x3D;False</p></li><li><p>pin_memory解释</p></li></ul><p>pin_memory就是锁页内存，创建DataLoader时，设置pin_memory&#x3D;True，则意味着生成的Tensor数据最开始是属于内存中的锁页内存，<strong>这样将内存的Tensor转到GPU的显存就会更快一些</strong>。</p><p>主机中的内存，有两种存在方式，一是锁页，二是不锁页，锁页内存存放的内容在任何情况下都不会与主机的虚拟内存进行交换（注：虚拟内存就是硬盘），而不锁页内存在主机内存不足时，数据会存放在虚拟内存中。而显卡中的显存全部是锁页内存！</p><p>当计算机的内存充足的时候，可以设置pin_memory&#x3D;True。当系统卡住，或者交换内存使用过多的时候，设pin_memory&#x3D;False。因为pin_memory与电脑硬件性能有关，pytorch开发者不能确保每一个炼丹玩家都有高端设备，因此pin_memory默认为False。<br>原文链接：<a href="https://blog.csdn.net/real_ilin/article/details/105320344">pytorch pin_memory</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记2021年保研经历</title>
      <link href="/2021/sui-bi-ji-2021-nian-bao-yan-jing-li/"/>
      <url>/2021/sui-bi-ji-2021-nian-bao-yan-jing-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你所走的每一步，都决定着你未来的路！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天是2021年11月7日，一直想记录一下自己前面大半年的推免经历，但是从9月28号到现在，一直沉迷于游戏和手机😅，除了前一段时间偶尔看看论文，再也没有认真学习过。但是也是有ddl在身，所以一时间不知道该先完成ddl，还是写这个不知道写多久的随笔。感觉就是想写的很多，但是一时间不知道从哪里写起，所以大概率会是断断续续地写，最后写个结尾记录一下最终完成的时间。</p><p><strong>阅读引导：</strong></p><ul><li>如果是本专业的学生，可以通篇阅读，文章虽长，但是里面有很多经验教训以及部分资源链接；</li><li>如果是了解本人苦逼的面试经历，可以直接跳到 [#6 面试经历](#6 面试经历) 开始阅读。</li></ul><h1 id="1-本人情况"><a href="#1-本人情况" class="headerlink" title="1 本人情况"></a>1 本人情况</h1><p><strong>学校：</strong>某末流985</p><p><strong>专业：</strong>软件工程</p><p><strong>排名：</strong>夏令营 10&#x2F;243，预推免 8&#x2F;243</p><p><strong>英语：</strong>CET-4：441，CET-6：493</p><p><strong>奖励：</strong>国家级奖项1个，国家级大创1个，省部级大创1个，国家励志奖学金1个，其他都是一些校级奖项。</p><p><strong>科研：</strong>国家级大创（学科交叉），重点是模型应用；课设项目，重点也是模型实现与应用。</p><p><strong>去向：</strong>国防科技大学 计算机学院 电子信息专业</p><h1 id="2-推免前准备"><a href="#2-推免前准备" class="headerlink" title="2. 推免前准备"></a>2. 推免前准备</h1><h2 id="2-1-一定要咨询学长学姐，经验贴也必不可少"><a href="#2-1-一定要咨询学长学姐，经验贴也必不可少" class="headerlink" title="2.1 一定要咨询学长学姐，经验贴也必不可少"></a>2.1 一定要咨询学长学姐，经验贴也必不可少</h2><p>首先，当然是推免前的准备了，这个推免前的准备期其实很长，虽然大多数学校的夏令营都是六七月份开始报名，但是实际上从3月份甚至寒假就需要开始提前准备了，<font color='red'><strong>具体的准备流程及事项一定要去听取学长学姐的意见【1】</strong></font>。因为他们都是亲身经历过的人，经验是很重要的，像我就没有去问过学长学姐，比如在联系老师时总是担心鸽了老师会不会不好，只联系一定会去的学校导师，却不曾想，在没有得到机会前，这种担心完全是多余的。</p><p>我也是到9月27号才知道什么叫offer，offer是成功通过学院考核，并联系到老师接收的才叫offer，个别学校只需要通过学院考核，那些没有到手的offer都不能保证你有书读，毕竟保研一片天，鸽子满天飞，鸽老师的，鸽学生的都有。总而言之，<font color='red'><strong>在整个推免过程中，在面临重大选择时，最好都与学长学姐或者学校关系比较好的老师商量下，多方调查再做选择。选择跟努力同等重要，因为如果方向错了，怎么努力都是徒劳【2】</strong></font>，后面我有很多决策失误就是因为没有咨询他人导致最终去向不是很满意。</p><aside> 💡 [1] 代表标记，后面会一一分析教训并总结，防止后面我自己或者其他看到的人踩坑。</aside><p>当然，CSDN或者知乎（主要是这两大平台）上的经验贴也是值得看的。不过因为2020年受疫情影响，很多学校采用线上面试，导致海王们面试没有太多成本（路费、时间等等），推免形势有所变化，所以如果后面推免大多是线上面试，关于定位与选择上，最好是参考近两年的经验贴，会比较有参考性。我对推免的了解主要是通过一篇本校的学长的经验贴，我觉得写得很好，链接贴上：**<a href="https://blog.csdn.net/qq_38633884/article/details/102322912">计算机保研夏令营准备流程建议</a>**，我后面也主要根据这个里面的流程来写，然后在其基础上通过穿插自己的</p><h2 id="2-2-确定自己的读研方向及意向"><a href="#2-2-确定自己的读研方向及意向" class="headerlink" title="2.2 确定自己的读研方向及意向"></a>2.2 确定自己的读研方向及意向</h2><p>其实这个问题应该很早之前就要做出选择，但是我到大概5月份才想清楚，因为我主要是记录自己的经历，读博与否的选择的话，我仅做出我自己的理解。国内读博肯定是直博大于先硕再博，不过如果想要在科研领域有更好的发展，硕士国内Top2或华五人，博士出国（当然学校或导师要比国内的好）。</p><p>那么，<strong>关键问题在于是否读博？</strong>我对自己的人生规划是比较清晰的，在初高中就有自己的大致规划，所以科研应该算一种尝试，以此决定在研究生毕业后如何发展。</p><p>我在本科阶段做过三年学生工作，也做过很多工程项目。研究生想要尝试一下研究岗位，但是目的还是很明确的，读博出来在高校内做研究肯定不是我的路子，因为最想的还是生（gao）活（qian）嘛，所以读<strong>研后的选择就很明确了：（1）继续读博进研究岗，（2）直接研究生后进研究岗或算法岗。</strong>所以我大概率不会选择直博或者有延毕风险的直博（这也是我没有尝试梦校直博的原因），这个选择我觉得不能评价好坏，只能说人都有自己的选择。如果让我读六七年，二十八九了才找工作，我觉得这种生活我是不太愿意的，我还是希望能够尽早地经济独立。顺带提一句，只有不断增长自己的本事，才不会被社会淘汰，有句话说得好，<font color='red'><strong>有多大本事挣多少钱，不要只看到别人的高薪，也要看到别人的真材实料</strong>[3]</font>。</p><h2 id="2-3-确定目标院校与招生途径"><a href="#2-3-确定目标院校与招生途径" class="headerlink" title="2.3 确定目标院校与招生途径"></a>2.3 确定目标院校与招生途径</h2><h3 id="2-3-1-确定目标院校"><a href="#2-3-1-确定目标院校" class="headerlink" title="2.3.1 确定目标院校"></a>2.3.1 确定目标院校</h3><p>确定目标院校非常重要，主要是有两点。</p><p><strong>第一，要注意分为“冲一冲”、”稳一稳“、”保一保“</strong>，每个层次所对应的学校一定要去横向对比本学院的学长学姐的录取情况，而不是自己想当然就确定了，不然“保一保”就变成“稳一稳”，“稳一稳”变成“冲一冲”，“冲一冲”的直接变成“寄一寄”。</p><p><strong>第二，一定要注意不要”挑三拣四“。</strong>以我的经验来说，一个很重要的点是：<font color='red'><strong>你有了offer才有了选择权，而不是没拿到offer就开始选择。[4]</strong></font>这里的offer的意思包含了学校与导师，并不是通过学校就行，一定要找到接收的导师才算。首先，有些学校如天津大学智算学部，是必须确定接收导师，才发放对应的offer；其次，导师对于研究生阶段来说十分重要，除非是奔着title去的就另当别论，否则找不到心意导师，这个offer也算白搭。另外，不要因为同时拿了几个导师的offer而自责，可能你的导师也有好几个备胎，我觉得听人说过的一句话很到位：<strong>你不担心你自己，反而担心那些穿金带银的主，你只有一次保研机会，而他们又有多少次可以招收学生的机会。</strong>据我所看到的，到保研前一天才释放offer的大有人在，且不在少数，最后一天释放的也都有。</p><p>我自己就是因为没有注意上面两点，导致夏令营颗粒无收，只有预推免混了一两个offer，还都是专硕，属于是上大当了。</p><h3 id="2-3-2-确定招生途径"><a href="#2-3-2-确定招生途径" class="headerlink" title="2.3.2 确定招生途径"></a>2.3.2 确定招生途径</h3><p>对于这一部分而言，其实我个人主要是通过保研群和保研信息仓库收集，当然，各学校&#x2F;学院官网肯定会有，但是除非特别关注，不然容易遗漏，所以在这里推荐一下保研群与保研信息仓库。</p><p><strong>保研群（俗称：绿群）</strong>：</p><p>一群：605176069</p><p>二群：943826679</p><p><strong>保研仓库</strong>：绿群公告中一般有，此处附上2021年保研仓库，里面的保研公告信息已经删除，但是还有一些保研经验贴，<a href="https://github.com/richardodliu/CS-BAOYAN">CS-BAOYAN</a>。</p><h2 id="2-4-制作个人简历与个人介绍"><a href="#2-4-制作个人简历与个人介绍" class="headerlink" title="2.4 制作个人简历与个人介绍"></a>2.4 制作个人简历与个人介绍</h2><h3 id="2-4-1-简历基本内容"><a href="#2-4-1-简历基本内容" class="headerlink" title="2.4.1 简历基本内容"></a>2.4.1 简历基本内容</h3><ul><li><strong>保研简历与求职简历</strong></li></ul><p>保研简历与求职简历的基本模块还是有比较不同，个人认为，保研简历侧重展现大学前三年的各类成就，研究项目虽然重，但是仍然是精练介绍，其他部分（如英语、成绩等）都是比较重要的，总的篇幅在1页左右。</p><p>但是求职简历目标很明确，专业技能，与面试岗位要求不相关的技能等基本没用，且需要花更大的篇幅详细介绍项目中你负责的内容，总的篇幅是1-2页。</p><ul><li><strong>保研简历的基本模块</strong></li></ul><ol><li><strong>教育经历</strong>：主要是包括成绩排名、部分课程成绩、英语成绩等；</li><li><strong>荣誉奖项</strong>：主要包括科研竞赛、奖学金、荣誉称号等；</li><li><strong>科研竞赛</strong>：各类项目介绍，注意有先后顺序与篇幅大小之分；</li><li><strong>组织经历</strong>：参与组织活动的经历，学生工作等，可有可无；</li><li><strong>其他</strong>：个人兴趣、爱好、技能等，可有可无；</li><li><strong>个人总结</strong>：可有可无，从不同角度非常精准地定位自己，指出自己的优势与未来可发展潜力（这里的总结应当在前面的内容中能够体现，否则就是吹捧自己），可有可无。</li></ol><h3 id="2-4-2-个人介绍基本内容"><a href="#2-4-2-个人介绍基本内容" class="headerlink" title="2.4.2 个人介绍基本内容"></a>2.4.2 个人介绍基本内容</h3><p>个人介绍这里我在夏令营的时候属于是上当了，在网上找了一些关于怎么写个人介绍的内容，我一度认为需要用“真情实感去打动老师，讲诉自己的故事”，后来才明白，这里是国内，上面的套路用来申请国外学位或许可行，国内是行不通的，属于是上大当了，我现在想想可能还是因为这个错失了软件所的面试机会。</p><p>总的来说，个人介绍其实是对个人简历的扩展，因为简历篇幅有限，很多东西都不详细，个人介绍就是用来把简历的内容讲清楚。</p><ul><li><strong>个人介绍的基本模块</strong></li></ul><ol><li><strong>学术背景：</strong>把简历里的教育经历以及荣誉奖项用书面语言精炼陈述；</li><li><strong>科研竞赛：</strong>把每个项目内容与自己负责的部分详细阐述，采用<strong>项目名称-项目内容-负责内容-最终成果</strong>的四段式阐述；</li><li><strong>社会实践：</strong>参与的其他社会实践项目等；</li><li><strong>研究规划：</strong>未来的研究方向，目前所做的努力，未来简单计划等。</li></ol><h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><p>制作个人简历和个人介绍而言，<strong>主要是不断地修改，精炼语言</strong>。注意如下几点：</p><ol><li><strong>对于一般的老师而言，最看重的是科研创新能力，其次是编程能力，然后是英语能力。</strong>因此可以得到项目优先级：科研项目 &gt;  编程竞赛 &gt; 工程项目，当然，科研项目也不一定就要发论文，参与算法研究类的竞赛也是可以的；</li><li><strong>一定要突出重点，重要的、参与得多的项目经历占更多的篇幅；</strong></li><li><strong>不熟悉的项目一定要不写上去，写在简历上的项目一定要是自己非常熟悉的，连同相关的知识点也是要熟悉，</strong>不然被问到却不会就很减分； </li><li>······</li></ol><p>PS：如果有需要借鉴我的简历与个人介绍，可以联系我，这里就不直接放了。</p><h1 id="3-联系导师"><a href="#3-联系导师" class="headerlink" title="3 联系导师"></a>3 联系导师</h1><h2 id="3-1-选择导师"><a href="#3-1-选择导师" class="headerlink" title="3.1 选择导师"></a>3.1 选择导师</h2><p>在研究生阶段，选择一个好的导师可以说是非常重要的，因为你的导师可能决定了你今后发展，以下是选择导师的几个方向，具体优先级因人而异。</p><ol><li><strong>导师的研究方向</strong>：这个一般可以在学校官网上看到；</li><li><strong>导师的人品</strong>：这个可以在导师评价网看到，本来有两个网站，但是现在去看有一个网站挂了，就先放一个吧；</li><li><strong>导师的学术能力</strong>：导师的学术能力可以通过多个渠道查看，最直观的是谷歌学术上导师的个人主页，这个还可以查看导师近几年的著作，可以知道是否还在科研一线，其次是知乎、交流论坛等，这里放几个CV、NLP领域的比较厉害导师名单；</li><li><strong>导师的title</strong>：这个也可以在学校官网上看到，一定程度上页可以反映导师的学术能力与资源，导师的资源是很重要的，有好的项目会有更大机会发优秀的文章。</li></ol><ul><li><strong>资源链接</strong></li></ul><ol><li><a href="https://www.yankong.org/review">研控</a></li><li><a href="https://github.com/CCSemicircle/CS-BAOYAN/tree/main/%E5%AF%BC%E5%B8%88%E6%8E%A8%E8%8D%90">CS-BAOYAN&#x2F;导师推荐</a></li><li><a href="https://www.zhihu.com/question/291266315">国内有哪些自然语言处理(NLP)专业比较厉害的985高校？</a></li></ol><h2 id="3-2-联系导师"><a href="#3-2-联系导师" class="headerlink" title="3.2 联系导师"></a>3.2 联系导师</h2><p>取得offer前联系导师是很重要的，其优势在我推荐的经验贴中有所提到，但是我这里想再重申一下。</p><ol><li><strong>可能会帮助你更容易入营或通过学院考核</strong>，而且对于某些强导师制的学校，导师有权利决定是否入营，比如中科大，夏令营A营就是来自导师推荐，这样提前联系好导师一方面可以避免绩点筛，另一方面更大几率通过。</li><li><strong>抢手的导师可能帮你预留名额</strong>，如果你想联系的导师名额都给出去了的话，无论你多么优秀也没有名额了。</li><li><strong>提前与导师保持联系</strong>，会给老师留下较深刻印象，有利于之后的交流。</li></ol><p>在这里还要陈述的一点是，<font color='red'><strong>一定要提前联系导师，不要害怕被忽视，不论上岸机会有多小，每个学校都要联系导师【5】。</strong></font></p><p>首先导师每天都有很多事情忙，晚回邮件是很正常的；其次，你联系的导师肯定很抢手，有时候入不了老师的眼也是正常的，可能是导师水平太高了，此时换个导师联系就行；然后，每一个学校都要联系导师，我夏令营申请的学校基本都联系了导师，个别学校如中国科学技术大学，因为不报希望没联系导师，结果错失了通过导师入营的机会，直接因为绩点排名被筛掉。</p><h1 id="4-专业课与数学复习"><a href="#4-专业课与数学复习" class="headerlink" title="4 专业课与数学复习"></a>4 专业课与数学复习</h1><p>这一部分的复习一方面是为了应对部分学校的笔试以及几乎所有学校的面试提问，所以<font color='red'><strong>专业课与数学复习至关重要，越早准备越好，准备得越久越好，拒绝临时抱佛脚，如果非要抱佛脚，刷题比系统背记好【6】。</strong></font></p><p>南大的夏令营就是通过线上笔试刷人，我通过寻找一些网上的精简的复习材料，尝试系统背记，但是最终被无情刷掉，而室友通过刷题进入复试，当然有一点也得说一下，我基本是考完专业课就忘，室友基础更加扎实，后续也因此顺利通过南大面试，还拿到学硕。所以除了抱佛脚多刷题外，<font color='red'><strong>对于专业课，平时认真学习多应用，多回顾也是非常重要的，特别是保研涉及的专业课基本都是是行业基础，就业面试也会考核【7】。</strong></font></p><p>具体而言，复习范围如下，</p><p><strong>专业课程：数据结构、计算机组成原理、操作系统、计算机网络、数据库、机器学习</strong></p><p>PS：专业课程是按重要性排序的，其中机器学习比较特殊，有科研项目经历的会针对性提问，没有相关经历自己不主动说有机器学习基础一般不会提问机器学习<br><strong>数学课程：高等数学、线性代数、概率论与数理统计、离散数学</strong></p><p>我自己也是准备了一些复习资料，有一部分来自网络，有一部分来自自己的总结，有需要的网盘自取（过期的话，联系我更新链接）。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/11dho8_5znKx9mjQbLca9fA">https://pan.baidu.com/s/11dho8_5znKx9mjQbLca9fA</a><br>提取码：2rcb </p></blockquote><h1 id="5-准备机试"><a href="#5-准备机试" class="headerlink" title="5 准备机试"></a>5 准备机试</h1><p><font color='red'><strong>机试这部分不论如何都很重要，这其实是一位Computer从业者的基础【8】。</strong></font></p><p>不过，在保研过程中，准备机试近几年会显得鸡肋，因为疫情影响，很多学校线上考核，因而大多数学校都只进行面试，准备机试显得是在浪费时间。但是我想说，如果想要冲击更好的学校或者更好的导师，这一部分必不可少，比如北航的机试，就是必须过的门槛。</p><p>机试准备的话，<strong>基础版是把《王道考研机试指南》刷完，可以应对一般学校的或导师的考研，进阶的是把《LeetCode 101》刷完</strong>。至于编程语言，保研过程中<strong>C++基本适用所有学校的要求</strong>。下面附带我自己的一些刷题练习以及总结，包含《LeetCode 101》电子版以及《王道机试指南》所有题目的在线测试链接。</p><blockquote><p><a href="https://github.com/CCSemicircle/AlgorithmExercise">《机试准备材料》</a></p></blockquote><h1 id="6-面试经历"><a href="#6-面试经历" class="headerlink" title="6 面试经历"></a>6 面试经历</h1><h2 id="6-1-夏令营"><a href="#6-1-夏令营" class="headerlink" title="6.1 夏令营"></a>6.1 夏令营</h2><h3 id="6-1-1-首战华科导师考核，潦草败北"><a href="#6-1-1-首战华科导师考核，潦草败北" class="headerlink" title="6.1.1 首战华科导师考核，潦草败北"></a>6.1.1 首战华科导师考核，潦草败北</h3><p>第一个参与考核的是华科的某一个NLP方向的导师，<strong>初步考核是给每个人发一篇论文，然后做一个汇报PPT，根据PPT内容质量初筛，然后选出一部分人进行汇报展示，汇报考核通过的在实验室实习一个月之后再决定最终人选。</strong></p><p>我作为三年从没进过实验室的人，汇报PPT可以说做得一塌糊涂，所以在PPT内容初筛部分就被淘汰了，但是对于本科阶段参与过一些科研工作特别是在实验室做过组会汇报的同学，就信手拈来了。</p><p>其实也有点可惜，我大三上的时候也去找过学校导师，导师安排了一个研究生学长带我，学长给了我几篇综述去看，但是因为很多自身原因没有做下去，最终导致科研经历这一块一直是我保研过程中的一大弱点。所以<strong>本科阶段，虽然听上去很卷，但是如果可以，能早进实验室就早进实验室，可能初期只是打杂，但是谁都是这么过来的，一定要坚持下去，这样才会在保研过程中有更大的核心竞争力。即便是大三上也不迟。</strong><font color='red'><strong>年轻最大的资本就是时间，在二十多岁的时候想做出任何改变都来得及，因为你有充分的时间，并且一切还未定型，改变的成本不会太大【9】。</strong></font></p><h3 id="6-1-2-面试中南，再临导师考核"><a href="#6-1-2-面试中南，再临导师考核" class="headerlink" title="6.1.2 面试中南，再临导师考核"></a>6.1.2 面试中南，再临导师考核</h3><p>填报中南是准备把中南作为一个保底的选择，但是后续了解到中南其实是一个非常没有底线的海王（offer远大于录取人数，在928最终录取的时候，很多等中南的都没等到，还有一个学校也是海王后面再说），我基本就不做念想了。</p><p><strong>中南的学院考核是面试，做一个自我介绍PPT，然后提问。</strong>但是当时除了基本的英语常用问答（家乡、兴趣爱好等）外，导师只问了我一个问题。我在介绍里说熟悉一个神经网络模型，导师问模型的输出是什么，但就是如此简单，我都回答错了，所以面试完我也能理解为什么只问一个题目了。这就是为什么强调不熟悉东西的一定不要说得太过，因为导师真的会问，如果被问住会很减分，所以这里又有一个技巧，<font color='red'><strong>如果你真的对某个领域很熟悉，可以引导导师往熟悉的方向提问，来规避自己不熟悉的领域，这样就比较加分【10】。</strong></font><strong>这个熟悉的领域也不一定是机器学习或者深度学习领域，我室友面试南大的时候就是引导导师提问前端开发部分。</strong></p><p>虽然面试不太理想，但是还是通过了中南的学院考核，后来也就知道其实就是学院很海，都发offer罢了。后面，我去联系了中南的一个数据挖掘方向的导师，导师考核比较常见，<strong>先机试，再面试</strong>。机试的话还是开卷（一般都不是开卷），虽然当时对《王道机试指南》的题目不太熟悉，但是因为开卷嘛，四道题目还是A了两题，剩下两题都是通过50%，然后也是顺利进入面试。面试更简单<strong>，导师随便问了一下项目经历，问了一下还有没有报其他学校</strong>就没了，在面试最后几分钟告诉我通过了。但是呢，中南导师权力不大，导师给过，学院不收也是白搭，所以后面也没有跟导师联系了，怕耽误导师招生。</p><p>在导师面试这里就有两个问题，<strong>第一个问题是关于如何回答”还有没有申请其他学校“与”还有没有其他学校offer“</strong>的问题，如果本身足够优秀，老师非常愿意留住名额，这也不是问题，但是如果遇到了这类问题，<font color='red'><strong>如果手里确实有其他offer，那就既不要全盘否定说一个都没有，也不要说太多，一般而言，说1-2个差不多，且一定要强调更倾向当前面试的学校，可以适当例举一两个理由阐释【11】。</strong></font><strong>第二个问题就是关于害怕耽误导师招生</strong>，首先，鸽子到9.28起飞都有，能够在9.26&#x2F;27释放offer的人都已经不错了，还是上文说到的，<font color='red'><strong>保研机会只有一次，在害怕耽误导师招生和确保自己上岸心仪offer之间如何取舍看个人【12】。</strong></font></p><h3 id="6-1-3-轻敌东南，错失PALM-offer"><a href="#6-1-3-轻敌东南，错失PALM-offer" class="headerlink" title="6.1.3 轻敌东南，错失PALM offer"></a>6.1.3 轻敌东南，错失PALM offer</h3><p>夏令营最后一站是东南，我先联系了PALM实验室的某个导师，参加PALM统一面试，然后再参加学院面试。</p><p><strong>PALM统一面试采用导师负责制，联系的是哪位导师就是哪位导师提问，我联系的导师基本没问什么问题，提问了一下项目相关的内容</strong>就没有了，不到两天就通知通过了，这也导致了我后面的放松，想着PALM都通过了，学院面试应该没啥问题，但是就是出问题了。</p><p>东南计算机学院的夏令营与预推免是一起的，就是说只有一次机会。面试采用提交材料以及PPT展示，因为夏令营的时候在写文档方面实属不擅长，导致在项目经历栏基本空着，为数不多的项目经历没有写上去，然后PPT展示限制在6页，而且导师一般都在看材料，全程听汇报的也在少数，导致最后材料部分就减分了，这里更加凸显<font color='red'><strong>写好文档很重要，特别是在科研经历方面，沾边的都可以写上去，有总比空着好【13】。</strong></font></p><p>面试的时候PPT展示最后需要展示自己的未来研究规划，我又犯了之前的错误，我阐述了自己更倾向于NLP方向，然后<strong>导师提问了一个基础的机器学习模型，要求解释</strong>，然后我就又答错了，但是<strong>另外问的数据结构的快排问题以及细节</strong>我都回答正确，最后还是不合格，由此证明，<font color='red'><strong>不熟悉的东西一定不要放展示PPT或简历里，很可能说多错多【14】。</strong></font>当然，也有绩点或运气因素，我一个室友也面试了东南，但是问的都是项目经历方面以及其他，专业课都问得很少，何况机器学习了。</p><h3 id="6-1-4-夏令营小结"><a href="#6-1-4-夏令营小结" class="headerlink" title="6.1.4 夏令营小结"></a>6.1.4 夏令营小结</h3><table><thead><tr><th>申请的学校（按名称排序）</th><th>是否通过初筛（不直博）</th><th>是否拿到offer</th></tr></thead><tbody><tr><td><strong>东南大学</strong></td><td><strong>是</strong></td><td><strong>否</strong></td></tr><tr><td>复旦大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>哈尔滨工业大学（深圳）</td><td>否</td><td>&#x2F;</td></tr><tr><td>华东师范大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>华中科技大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>南京大学</td><td>否（笔试未过）</td><td>&#x2F;</td></tr><tr><td>上海交通大学</td><td>否</td><td>&#x2F;</td></tr><tr><td><strong>四川大学</strong></td><td><strong>是</strong></td><td><strong>没有参加</strong></td></tr><tr><td><strong>同济大学</strong></td><td><strong>是</strong></td><td><strong>没有参加</strong></td></tr><tr><td>武汉大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>浙江大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>中科科学技术大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>中科院软件所</td><td>否</td><td>&#x2F;</td></tr><tr><td><strong>中南大学</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>中山大学</td><td>否</td><td>&#x2F;</td></tr></tbody></table><ul><li><strong>关于夏令营申请策略</strong></li></ul><p>在申请夏令营之前，我自己定了一个作死的标准——北方的学校一律不申请，夏令营最后阶段也只申请了中科院软件所一个。虽然不知道申请其他北方的学校会不会过，但是这听上去就像是”作死“，都还没拿到offer，怎么敢这么选，最后也是没有意外地只参加了三所学校的夏令营，或许有一部分是自身条件不够，但是更多的是错过了北方很多的好学校。所以这里重申一下，<strong>拿到手的offer才有选择的机会。</strong></p><ul><li><strong>关于自我评估</strong></li></ul><p>在夏令营申请的时候，<font color='red'><strong>正确的自我评估是很重要的，一定要和往届的学长学姐多多交流，评估一下自己的大致水平，尽量正确地树立目标，当然，如果没有把握，时间允许情况下，可能会去的都去尝试也是可行的【15】</strong>。</font>不要像我一样，有些学校，在夏令营的时候感觉自己肯定不会去，连夏令营都没有申请，后来想想，又是自视过高罢了。</p><ul><li><strong>关于线下考核</strong></li></ul><p>夏令营的时候我其实还通过了同济的初筛，虽然是线下考核，而且英语考核很硬核，我英语并不太行，但是因为之前很喜欢去上海（吐槽一下，当时不知道上海在22年的疫情会成这样），所以还是决定去。但是重点在于，我选择的是报道当天的飞机，然后很不幸的是，因为没有注意天气预报，飞机因为雷暴天气停飞了，高铁过去需要六个小时，因为赶不及，被迫放弃考核。所以<font color='red'><strong>如果参加线下考核，一是衡量是否与其他学校考核冲突，二是提前计划，选择稳定的出行方式，最好提前出行【16】。</strong></font></p><ul><li><strong>关于是否申请可能没有希望的学校</strong></li></ul><p><font color='red'><strong>对于一个学校，即便机会再渺茫，也要去申请，因为你不申请，一定不会通过，但是如果你去申请，即便只有百分之一的机会也是可能通过【17】。</strong></font>在申请国防科技大学时，因为本校前几名都在申请，我就放弃了申请，即便当时材料都打印好了，只需要邮寄，但还是放弃了。现在想想，十分后悔，因为有绩点排名在我后面几位的同学都入营了，我大概也是可以的，而且从最后结果看，夏令营入营的都收了，而且基本都是学硕，我预推免才申请，混了个专硕，属实是亏大了。</p><ul><li><strong>关于同学院的竞争者</strong></li></ul><p>虽然可能很多时候同学院的同学就是与你一起竞争同一个学校的竞争者，但是相比之下，更多的竞争者来自外校，所以<font color='red'><strong>如果有关系比较好的朋友，可以好好听取身边人的意见，大家相互交流沟通，可以有效避免一叶障目，共同进步【18】。</strong></font>对比我室友的夏令营申请策略，我自愧不如，也是没有好好沟通，没有听取好的建议，室友的最终去向很符合他的期望，而我感觉我的去向不尽如人意。</p><h2 id="6-2-预推免"><a href="#6-2-预推免" class="headerlink" title="6.2 预推免"></a>6.2 预推免</h2><h3 id="6-2-1-认清现实，迎战天大"><a href="#6-2-1-认清现实，迎战天大" class="headerlink" title="6.2.1 认清现实，迎战天大"></a>6.2.1 认清现实，迎战天大</h3><p>经过夏令营的毒打，我彻底认清现实，改变了自己的申请策略，陆续申请了一些北方的学校。首先面试的是<strong>天大，也是采用PPT展示+提问的形式，导师着重问了我在每个项目中负责的工作内容</strong>，但是我可能因为有点紧张，表述有点不清楚，整体面试表现也不理想，最终只拿了专硕名额。而且要求联系导师，导师确认接收才能算拿到offer，我依旧不愿意耽误导师招生，因为大概率不会去，也是没有去联系导师，最后放弃了名额。可以看出，此时的我还是没有认清楚现实的残酷。</p><p>这里值得一提的是，天大也是个没有底线的海王，它有导师团制度，导师们可以自己招生，导师要就算offer，并且是一定可以去的，然后才是夏令营与预推免，当年导师团和夏令营就基本把名额分配好了，可它还是举办预推免，导致超发offer，很多预推免通过的学生无处可去，甚至有人928因为一直等天大的录取，错过了其他的offer，实属凄惨。</p><h3 id="6-2-2-破釜沉舟，冲刺软件所"><a href="#6-2-2-破釜沉舟，冲刺软件所" class="headerlink" title="6.2.2 破釜沉舟，冲刺软件所"></a>6.2.2 破釜沉舟，冲刺软件所</h3><p>我依稀还记得，那天还是在图书馆，突然收到来到了北京的电话，我属实没有想到居然是软件所的面试邀请，软件所在国内NLP领域数一数二的实验室了，如果能去软件所，那肯定很不错。虽然他允许线上也允许线下，但是我毅然决定线下去，一是更有诚意，二是过去看看实验室。事实证明，线下过去确实更有诚意，据我所知，线上考核的，基本挂了，有的上午英语和机试就放弃了，下午只有一个线上的汇报展示。所以<font color='red'><strong>如果有能选线下考核的，并且自己非常想去的，不耽误其他学校考核的情况下，确实可以考虑线下【19】。</strong></font></p><p>但是当时留给我的时间只有三天了，还是线下考核。我既要复习英语，也要复习机试，还要复习专业课以及项目，特别是专业课还没能完整的背完，之前背的都是精简的内容。于是，我选择了晚上21点的飞机，以留出更多时间复习，甚至在机场都惶惶不安，还在看专业课复习材料。当天虽然下雨，但还好只是航空管制，晚点一个小时，凌晨一点左右我到了北京。为了第二天不会太匆忙，我定的附近的宾馆，从机场打车到宾馆都已经两点多，甚至在车上我还在改自己的展示PPT，甚至还没有打印自己一直在改的简历与材料。我只能寄希望于第二天去软件所的路上有打印店可以让我打印材料，但还好第二天的时候，虽然是早上八点多，我还是找到了打印店把材料打印好了。</p><p><strong>软件所的考核分为英语考核、机试考核以及下午的汇报展示。英语考核非常硬核，两篇阅读理解，一个撰写文章摘要150词，一个撰写个人看法小作文300词。</strong>我可以说直接摆烂，词汇词汇不熟，题目题目不会。然后是<strong>机试考核，一共有7道题目，两道简单每题20分，三道中等每题30分，三道困难每题40分，取分数最高的三题计分，可以只做三题。</strong>我一开始就先A了一道中等，但是做着做着就忘了是计三题的分数，除了一开始A的题目，我又多做了4道题目，全部都是差一点就能过，我真是傻了，应该多花时间去想怎么把剩下两道都通过，而不是花时间去做更多的题目。</p><p>然后是下午的<strong>汇报展示</strong>，虽然中午在软件所吃的外卖，但是我还是选择回宾馆一趟，一方面我还有东西留在宾馆，另一方面，我还想再练习一下英语自我介绍。PPT展示完毕后，<strong>导师没有提问过专业课基础，全都是问的项目，首先是质疑我都项目都是应用级别，有没有自己创新性做的东西</strong>，一下子就让我哑口无言，后面这个导师也是没了任何兴趣（这个导师还是主要负责人之一，我很无力，当时面试的时候就差不多知道完了）。然后<strong>导师问了一下我做数据爬取和预处理的工作</strong>，这一部分我答得挺好的，把自己的工作及克服的困难都说出来了，<strong>然后再让我用英语介绍一个项目经历</strong>，就结束了。</p><p>这次考核，一共有11个人，2个清华，1个华科，1个武大还有就不记得了，一共只有2-3个名额，最终选了两个清华和1个武大的，我候补在武大的后面，最终没有选上。但是如果当初夏令营能好好写自己的个人介绍，或许就能入营了，但是夏令营的时候文档写的真的一塌糊涂，连初筛都没过，当然也有可能是绩点排名不够。</p><h3 id="6-2-3-北航机试，一波三折"><a href="#6-2-3-北航机试，一波三折" class="headerlink" title="6.2.3 北航机试，一波三折"></a>6.2.3 北航机试，一波三折</h3><p>没想到今年大部分学校都不开预推免，从软件所回来之后，基本都没有什么预推免了。我心灰意冷之时，没想到又收到了北航的考核邀请，但是北航有机试，而且很难，不过对我而言，没有其他选择，只能参加。虽然了解了北航的机试难度，但是实际去考才发现自己机试底子有多差。</p><p>当天我在寝室参加机试，刚开始30分钟左右停电了，我人傻了，我电脑续航很差，绝对挺不过剩下的一个半小时，我纠结了几分钟，还是决定跟监考员说我要交电费。我取下作为后摄像头的手机缴费，但是我忘记了我们寝室的编码，我怕交错，最终也没有交（其实应该试一下，起码有可能对，不交肯定不会有电），想看看能不能撑到考试结束。但是万万那没想到的是，又过半小时，网络直接断了，原因是我怕网络中断，用的手机流量，现在流量停了，我只好跟监考员说我要切换校园网，然后我顺便把电费也交了，所幸后面终于没问题了，我是真的没想到考核时会这么波折。</p><p>我最终连一道题目都没A过，甚至第二题都没看。虽然有客观原因，但是更多是自己机试能力太差了。</p><h3 id="6-2-4-无处可去，尝试本校"><a href="#6-2-4-无处可去，尝试本校" class="headerlink" title="6.2.4 无处可去，尝试本校"></a>6.2.4 无处可去，尝试本校</h3><p>因为一直没有真正确定的offer，天大放弃了名额，中南是个海王，能否录取看手速，于是乎，我感觉自己实在是无处可去，报名了本校的预推免。<strong>本校也是采用PPT展示+提问的形式，只不过多了一项3分钟英语自我介绍。导师们简单问了一下项目内容就结束了</strong>，后面也是通知通过了，事实上本校只要参与基预推免基本能过。</p><p>这里还有一个非常极限的事情，北航的机试也是当天上午10：00-12：00，我本校面试也是当天上午，面试顺序靠后但是不知道确切时间。我决定赌一把，先参加北航机试，机试完再去参加本校的面试，但是还是错过了自己的顺序，不过后面补上了面试，可以说差一点连本校都上不了了。</p><h3 id="6-2-5-柳暗花明，上岸国防科大"><a href="#6-2-5-柳暗花明，上岸国防科大" class="headerlink" title="6.2.5 柳暗花明，上岸国防科大"></a>6.2.5 柳暗花明，上岸国防科大</h3><p>经过上面的学校考核，我最终只有本学校的offer，我万念俱灰，没想到奋战了大半年，最后只能选择本校（不是说本校有多么不好，只是觉得之前的努力都白费），因为如果留在本校，一开始就可以去联系本校导师，早早躺平。</p><p>但是那天在开会时无意中收到了国防科大计算机学院的考核通知，我顿时喜出望外，没想到不报希望的一投成了我最后的救命稻草。</p><p><strong>面试分为两天，第一天下午是思想政治考核，表现正常基本能过。第二天是面试考核，PPT展示+提问。</strong>我又因为研究方向的一个问题被卡住了，最终排名六十多，甚至不知道会不会录取，以至于9.28录取当天仍然忐忑不安。本校一直在问是否接受录取通知，但是国防科大这边按顺序通知，还没轮到我，我一直拖了本校两个小时才上岸，非常对不起保研本校的其他同学，耽误了这一个名额。如果能重来，我一定说自己只会专业课，让自己面试表现好一点······</p><h3 id="6-2-6-预推免小结"><a href="#6-2-6-预推免小结" class="headerlink" title="6.2.6 预推免小结"></a>6.2.6 预推免小结</h3><table><thead><tr><th>申请的学校（按名称排序）</th><th>是否通过初筛（不直博）</th><th>是否拿到offer</th></tr></thead><tbody><tr><td><strong>北京航空航天大学</strong></td><td><strong>是</strong></td><td><strong>否（机试未过）</strong></td></tr><tr><td>北京理工大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>复旦大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>国防科技大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>哈尔滨工业大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>哈尔滨工业大学（深圳）</td><td>否</td><td>&#x2F;</td></tr><tr><td>中科院计算所</td><td>否</td><td>&#x2F;</td></tr><tr><td>南京大学（软件学院）</td><td>否</td><td>&#x2F;</td></tr><tr><td><strong>中科院软件所</strong></td><td><strong>是</strong></td><td><strong>否</strong></td></tr><tr><td>上海交通大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>上海科技大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>中科院深研院</td><td>否</td><td>&#x2F;</td></tr><tr><td><strong>天津大学</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>西安交通大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>浙江大学</td><td>否</td><td>&#x2F;</td></tr><tr><td>中山大学（智能工程学院）</td><td>否</td><td>&#x2F;</td></tr></tbody></table><ul><li><strong>关于那些我错过的学校</strong></li></ul><p>有三个学校是我的意难平，分别是南大计算机、北理计算机以及中山计算机。</p><p>首先说南大计算机，南大预推免可以填报三个志愿，但是我为了表示狗屁的诚意，只填报了南大软件学院，但是南大软件的导师问我去不去的时候，我又摇摆不定，不能肯定，导致我既错过了南大软件，也错过了南大计算机。按照我预推免的绩点排名，应该是可以过南大计算机初筛的，而且南大计算机考核是专业课抽题考核，我当时已经复习了很久的专业课了，也算比较有把握。而且，更凸显的对比是同学院有一个差不多排名，夏令营高我几名，预推免排名靠后我几名的同学上岸了南大计算机专硕（最后上岸了学硕，真的很厉害）。不过当时南大计算机预推免也很卷，好像预推免上岸的只有不到5个，虽然我报名也不一定能上岸，但是连名都没报是最气的。</p><p>然后是中山计算机，中山计算机可以说很保守了，预推免只开了一天不到，白天开放报名，晚上就关闭了。然而当时我在北京，前一天刚参加完软件所面试，当天想着没有其他事，直接去爬长城了，没有注意看保研交流群的消失，直接”错亿“，错过了报名机会，深夜才看到这消息。所以，当时我就长记性了，<font color='red'><strong>当一切尘埃未定之时，一定不要出去旅游，不要过度放松【20】。</strong></font></p><p>最后是北理计算机，我填报了北理的报名材料，但是因为差不多是最后理想的去处了，所以格外的紧张，因为要求只能提交一次，填完材料后反复确认，但是我还是没有想到，我弄错了文件夹以及文件名的命名，以致于第一次提交不完全符合格式。我第二天就打电话像北理的教务导师确认，那边的回复却是用插件统一收集，不支持其他格式提交，但是我还是不依不饶地向教务老师确认是否我是否报名成功，对面问我名字（甚至没有问名字怎么写，哪个学校的），很快就回复报名成功了，我打完电话才意识到或许只是敷衍，不想让我过多纠缠罢了。我最后也是没有通过初筛，我万万没想到3%排名都没有过初筛，更气人的是当时群里还有一个绩点排名以及学校也不如的人在群里想不到自己过了，我心更凉了。当时还联系了导师，导师一直向我确认是否能通过面试，我都以为不是问题，真是人算不如天算。<font color='red'><strong>如果有重要的材料提交，特别是只能提交一次的材料，建议请他人帮忙确认，你们之间可以相互帮助确认，以求万无一失，像答辩PPT，如果能请本校导师帮忙修改当然更好【21】。</strong></font></p><ul><li><strong>关于那些我错过的offer</strong></li></ul><p>我一直到最后都没有做一个毫不留情的鸽子，即便是本校面试后，有导师曾联系过我，也是如实阐述可能会去国防科大，不想耽误导师招生，但最终我自己的保研去向不尽如人意，或许适当保留一些offer才是合理的吧。</p><p>想到这里我就不得不提我那些为数不多还错过了的offer，首先是中南的offer，虽然我不愿意去，但是过早释放了offer，导致自己最后越来越焦虑；然后是天大预推免的offer，不管如何，我都应该去联系导师，尝试就有可能，除非是导师团，鸽了导师可能会影响后面本校学生的保研申请，慎重；然后是南大软件学院导师询问是否一定去，我也不该摇摆，起码通过面试再决定。所以，<font color='red'><strong>大多时候选择与努力同等重要【22】。</strong></font></p><ul><li><strong>关于捡漏</strong></li></ul><p>我因为了解过之前有导师从邮件里面选学生上岸的案例，但是我保研结束才发现这绝对是个例，大多数捡漏应该都是递补上岸，比如南大计算机招100多一点，结果递补到400多位了，但是有一点重要的是，能够递补的前提还是参加过面试，这是最重要的，<font color='red'><strong>如果想要九推（9.28正式申请与录取）捡漏，一定得是要参与过对方学校的夏令营或者预推免，否则基本没有捡漏可能【23】。</strong></font></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>【1】具体的准备流程及事项一定要去听取学长学姐的意见；</p><p>【2】在面临重大选择时，最好都与学长学姐或者学校关系比较好的老师商量下，多方调查再做选择。选择跟努力同等重要，因为如果方向错了，怎么努力都是徒劳；</p><p>【3】有多大本事拿多少钱，不要只看到别人的高薪，也要看到别人的真材实料；</p><p>【4】你有了offer才有了选择权，而不是没拿到offer就开始选择；</p><p>【5】一定要提前联系导师，不要害怕被忽视，不论上岸机会有多小，每个学校都要联系导师；</p><p>【6】专业课与数学复习至关重要，越早准备越好，准备得越久越好，拒绝临时抱佛脚，如果非要抱佛脚，刷题比系统背记好；</p><p>【7】对于专业课，平时认真学习多应用，多回顾也是非常重要的，特别是保研涉及的专业课基本都是是行业基础，就业面试也会考核；</p><p>【8】机试这部分不论如何都很重要，这其实是一位Computer从业者的基础；</p><p>【9】年轻最大的资本就是时间，在二十多岁的时候想做出任何改变都来得及，因为你有充分的时间，并且一切还未定型，改变的成本不会太大；</p><p>【10】如果你真的对某个领域很熟悉，可以引导导师往熟悉的方向提问，来规避自己不熟悉的领域，这样就比较加分；</p><p>【11】如果手里确实有其他offer，那就既不要全盘否定说一个都没有，也不要说太多，一般而言，说1-2个差不多，且一定要强调更倾向当前面试的学校，可以适当例举一两个理由阐释；</p><p>【12】保研机会只有一次，在害怕耽误导师招生和确保自己上岸心仪offer之间如何取舍看个人；</p><p>【13】写好文档很重要，特别是在科研经历方面，沾边的都可以写上去，有总比空着好</p><p>【14】不熟悉的东西一定不要放展示PPT或简历里，很可能说多错多；</p><p>【15】正确的自我评估是很重要的，一定要和往届的学长学姐多多交流，评估一下自己的大致水平，尽量正确地树立目标，当然，如果没有把握，时间允许情况下，可能会去的都去尝试也是可行的；</p><p>【16】如果参加线下考核，一是衡量是否与其他学校考核冲突，二是提前计划，选择稳定的出行方式，最好提前出行；</p><p>【17】对于一个学校，即便机会再渺茫，也要去申请，因为你不申请，一定不会通过，但是如果你去申请，即便只有百分之一的机会也是可能通过。</p><p>【18】如果有关系比较好的朋友，可以好好听取身边人的意见，大家相互交流沟通，可以有效避免一叶障目，共同进步；</p><p>【19】如果有能选线下考核的，并且自己非常想去的，不耽误其他学校考核的情况下，确实可以考虑线下；</p><p>【20】当一切尘埃未定之时，一定不要出去旅游，不要过度放松；</p><p>【21】如果有重要的材料提交，特别是只能提交一次的材料，建议请他人帮忙确认，你们之间可以相互帮助确认，以求万无一失，像答辩PPT，如果能请本校导师帮忙修改当然更好；</p><p>【22】大多时候选择与努力同等重要；</p><p>【23】如果想要九推（9.28正式申请与录取）捡漏，一定得是要参与过对方学校的夏令营或者预推免，否则基本没有捡漏可能。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>回顾我整个保研经历，我因为一开始的定位过高，导致出现太多太多的决策失误，为自己留下了太多太多的遗憾；因为自己没有参与过科研项目，导致自己核心竞争力不够；因为自己没有认真复习专业课，导致自己专业基础不牢固，书到用时方恨少；因为自己过于放松与疏忽大意，白白错过一些机会。</p><p>我也曾很颓废，在刚保研结束的一个月里面，很难走出来，不断地设想假如当时做决定的时候怎么样，结果会不会不一样，但是每次想到最后都是以没有办法改变过去，空留遗憾收尾。</p><p>但是现在我也释然了，每个人在每个时候都不能保证自己做到最好的选择，过去的已成过去，更重要的是还未到来的将来！不论是学校还是导师，最重要的是自己能否足够努力，足够满足自己的期望，如果真有特别好的平台，自己是否能够跟上导师们的要求又是另一个问题了。</p><p>所以关键的是，在人生的每个阶段都要保持不断进步不断向上的态度！你所走的每一步，都决定着你未来的路！</p><p>今天是2022年4月12日，我终于写完这篇保研经历记录了，我虽然是一个很想写东西记录生活的人，但奈何平时干扰太多，之前因为游戏或者其他娱乐耽误，开学以来又因为毕设事情太多没时间写，最近毕设稍微没那么忙了，才能每天抽点时间出来写。好在现在终于完成了，真是难得！以后或许还有长文记录，希望知道是什么的朋友督促我一下。最后的最后，感谢诸君耐心阅读至此，在此献上诚挚感谢，感谢大家！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 保研经历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用单词</title>
      <link href="/2021/ying-yu-chang-yong-dan-ci/"/>
      <url>/2021/ying-yu-chang-yong-dan-ci/</url>
      
        <content type="html"><![CDATA[<h1 id="1-论文常用单词"><a href="#1-论文常用单词" class="headerlink" title="1. 论文常用单词"></a>1. 论文常用单词</h1><ol><li>investigate：v. 调查，研究</li><li>conversational：adj. 会话的</li><li>dialogue：n. 对话</li><li>corpora：n. 语料库</li><li>produce：v. 生产</li><li>response：v. 响应</li><li>autonomous：adj. 自主的</li><li>realistic：adj. 现实的</li><li>interaction：n. 交互</li><li>extend：v. 扩展<span id="more"></span></li><li>propose：v. 提出，建议</li><li>hierarchical：adj. 分层的；等级体系的</li><li>recurrent：adj. 复发的；周期性的，循环的</li><li>neural：adj. 神经的</li><li>demonstrate：vt. 证明；论证</li><li>state-of-the-art：adj. 最先进的；达到最高水准的</li><li>back-off：n. 退下；回退</li><li>embedding：v. 把（物体）嵌入</li><li>chatterbot：聊天机器人</li><li>process：n. 过程</li><li>deploy：vt. 配置；展开</li><li>hand-crafted：adj. 手工制作的</li><li>annotated：adj. 有注释的；带注解的</li><li>horde：n. 一大群，群</li><li>simulated：adj. 模拟的</li><li>utterance：n. 表达；说话</li><li>carry out：vt. 实行；实现</li><li>replicate：vt. 复制</li><li>emulate：vt. 仿真；模仿</li><li>off-line：adj. 离线的</li><li>inference：n. 推理</li><li>stochastically：adv. 随机地</li><li>in the long run&#x2F;term：从长远来看</li><li>yield：v. 出产；产出</li><li>adopt：vt. 采取；采用</li><li>substantially：adv. 大幅度</li><li>plausible：adj. 看似可信的；似是而非的</li><li>consecutive：adj. 连贯的</li><li>to the best of our knowledge：据我们所知</li><li>retrieve：vt. [计] 检索</li><li>subtitle：n. 副标题；说明或对白的字幕</li><li>interlocutor：n. 对话者</li><li>distribution：n. 分布；分配</li><li>arbitrary：adj. [数] 任意的</li><li>decompose：vt. 分解</li><li>analogous：adj. 类似的</li><li>preceding：adj. 在前的</li><li>token：n. 令牌</li><li>curse：n. 诅咒</li><li>curse of dimensionality：维数灾难</li><li>dimensionality：n. 维度</li><li>intractable：adj. 棘手的；难治的</li><li>dense：adj. 稠密的</li><li>means：n. 手段；方法</li><li>sparsity：n. 稀疏</li><li>a variety of：种种；各种各样的</li><li>compact：adj. 袖珍的</li><li>low-rank：低秩</li><li>corresponding：adj. 相应的；一致的</li><li>project：v. 设计；计划；预测</li><li>gradient：n. 梯度</li><li>track：n. 轨道；踪迹；vt. 追踪</li><li>iteratively：adv. 迭代地</li><li>interpret：v. 理解；解释</li><li>hyperbolic tangent：双曲正切</li><li>bidirectional：adj. 双向的；双向作用的</li><li>syntactic：adj. 句法的；语法的</li><li>reversing：v. 颠倒； 撤销</li><li>i.e.：abbr. 也就是，亦即（源自拉丁文id est），换而言之。</li><li>concatenation：n. 连结</li><li>temporal：adj. 暂时的</li><li>pool over：v. 池化</li><li>commonsense：adj. 常识的</li><li>infer：vt. 推断</li><li>variant：n. 变体；adj. 不同的</li><li>sheer：adj. 绝对的</li><li>semantic：adj. 语义的</li><li>tokenization：n. 令牌化；标记化；词语划分</li><li>co-dependencies：adj. 相互依存的</li><li>metrics：n. 度量；指标</li><li>perplexity：n. 困惑度</li><li>empirical：adj. 经验主义的</li><li>punctuation：n. 标点；标点符号</li><li>explicitly：adv. 明确地</li><li>turn-taking：轮流说话</li><li>multi-modal：adj. 多模式的</li><li>fine-grained：adj. 细粒度的</li><li>ultimately：adv. 最后</li><li>optimizing：v. 最佳化；优化</li><li>promising：adj. 有希望的</li><li>discriminate：vt. 区别；辨别</li><li>qualitative：adj. 定性的；性质上的</li><li>hyperparameter：超参</li><li>matric(es)：矩阵</li><li>orthogonal：adj. [数] 正交的</li><li>preliminary：adj. 初步的</li><li>fine-tuned：调整</li><li>deviation：n. 偏差</li><li>w.r.t. ： with respect to 的缩写。是关于；谈及，谈到的意思</li><li>convergence：n. [数] 收敛</li><li>gains：n. 收益</li><li>regime：n. 体制；制度</li><li>relatively：adv. 相当地；相对地</li><li>beam-search：n. [计] 定向搜索</li><li>approximate：adj. 近似的</li><li>generic：adj. 通用的</li><li>mutual：adj. 共同的</li><li>inherently：adv. 内在地；固有地</li><li>pronouns：n. 代词</li><li>implication：n. 含义；暗示</li><li>primarily favor model：主要支持模型</li><li>opposed：adj. 相反的</li><li>biased：adj. 有偏见的，片面的</li><li>correlate：vi. 关联</li><li>justify：vi. 证明</li><li>novel：adj. 新奇的；n. 小说</li><li>crucial：adj. 重要的</li><li>ingredient：n. 原料；要素；组成部分</li><li>monologue：n. 独白</li><li>empirical performance：实证性能</li><li>overwhelmed：adj. 被压倒的，被淹没的；不知所措的</li><li>colloquial：adj. 口语的</li><li>fruitful：adj. 富有成效的</li><li>modality：n. 形式，形态；模式</li><li>trick：n. 技巧； 诡计；恶作剧；窍门；花招</li><li>generalization：n. 泛化</li><li>minimize：vt. 使减到最少；vi. 最小化</li><li>by either：任何一方</li><li>sparsity：n. 稀疏</li><li>Residual Network：残差神经网络</li><li>shortcut connection：快捷连接</li><li>determiner：限定词</li><li>NP：名词性短语</li><li>context-free：上下文无关</li><li>dependant：n. 受扶养者</li><li>prepositional：adj. 介词的；前置词的</li><li>shuttle：n. 航天飞机</li><li>veteran：n. 老兵；老手</li><li>apposition：n. 并置，同格；同位语</li><li>new-fangled：adj. 新奇的</li><li>modifier：n. [助剂] 改性剂；[语] 修饰语</li><li>mutilated：adj. 残疾的</li><li>granular：adj. 颗粒的；细粒度的</li><li>derivative：n.导数</li><li>perplexity：n. 困惑度</li><li>benchmark：n. 基准</li><li>eigenvalue：n. [数] 特征值</li><li>magnitude：n. 大小；量级</li><li>recency：n. 新近；近因</li><li>clip：vt. 剪；剪掉</li><li>cliff：n. 悬崖</li><li>element-wise product：元素方式乘积（点乘）</li><li>fuzzy：adj. 模糊的</li><li>residual：adj. （数量）剩余的</li><li>recap：vt. 扼要重述</li><li>volatile：adj. [化学] 挥发性的；不稳定的</li><li>corrupted word：损坏的词</li><li>slope：n. 斜坡；斜率</li><li>by osmosis：潜移默化的</li><li>leaky：adj. 漏的</li><li>fidelity：n. 保真度；真实度</li><li>fertile：adj. 富饶的</li><li>versatile：adj. 通用的，多功能的</li><li>beam search：[计][电子]定向搜索</li><li>understudy：n. 候补演员；替补</li><li>flagship：n. 旗舰；（作定语）一流；佼佼者</li><li>prune：vt. 修剪</li><li>noise-contrastive estimation：噪音对比估计</li><li>unigram：n. 一元模型</li><li>Part-of-Speech tagging&#x2F;POS tagging：词性标注</li><li>dilated：adj. 扩大的；膨胀的；加宽的</li><li>weird：adj. 奇怪的</li><li>halve：v.减半（half的动词形式）</li><li>ResNet：Deep residual network，残差网络</li><li>hybrid：n. 杂种</li><li>morpheme：n. [语] 词素</li><li>suffix：n. 后缀</li><li>Hyphenated：adj. 带有连字符号的</li><li>state-of-the-art：adj. 最先进的</li><li>scratch：n. 擦伤；vt. 抓</li><li>premise：n. 前提</li><li>empiricists：n. 经验主义者</li><li>landscape：n. 风景</li><li>skew：adj. 偏的，歪斜的</li><li>truncate：v. 截断</li><li>uniform：n. 制服；校服；adj. 统一的</li><li>spiky：adj. 大钉一般的；尖刻的</li><li>explicit：adj. 明确的；显式的</li><li>collapse：v. （突然）倒塌</li><li>prompt：v. 提示，鼓励；促进；激起</li><li>engaging：adj. 迷人的；吸引人的</li><li>coreference resolution：指代消解</li><li>pronouns：n. 代词；[语] 代名词</li><li>spectre：n. 幽灵</li><li>constituency parsing：成分分析</li><li>donut：n. 炸面圈</li><li>anaphora：n. （语法）指代，前指</li><li>stuff：n. 东西；材料</li><li>pitcher：n. 投手；大水罐</li><li>contiguous：adj. 连续的</li><li>convergence：n. [数] 收敛</li><li>neat：adj. 灵巧的</li><li>recursive：adj. [数] 递归的</li><li>untie：vt. 解开</li><li>blink：vt. 眨眼</li><li>laundering：n. 洗烫</li><li>toxic：adj. 有毒的</li><li>annotate：vi. 注释</li><li>adversarial：adj. 对抗的</li><li>scramble：v. 扰乱</li><li>diagnostic：adj. 诊断的</li><li>discrete：adj. 离散的，不连续的</li><li>diploma：n. 毕业证书</li></ol><h1 id="2-刷题常用单词"><a href="#2-刷题常用单词" class="headerlink" title="2. 刷题常用单词"></a>2. 刷题常用单词</h1><ol><li>factor: 因子</li><li>bracket: 括号</li><li>odd: 奇数</li><li>even: 偶数</li><li>operator: 运算符</li><li>divide: 除</li><li>remainder: 余数</li><li>multiple: 乘</li><li>Greatest Common Divisor: 最大公约数</li><li>Least Common Multiple: 最小公倍数</li><li>prime number: 质数</li><li>factorial: 阶乘</li><li>archipelago: 群岛</li><li>permutation: 排列</li><li>fugitive: 逃犯，逃亡的</li><li>teleporting: 传送</li><li>decimal: 十进制</li><li>hexadecimal: 十六进制</li><li>octal: 八进制</li><li>volume: 体积</li><li>plural: 复数</li><li>gang: 帮派，群组</li><li>threshold: 阈值</li><li>ascending: 升序</li><li>descending: 降序</li><li>prentice: n. 徒弟，学徒</li><li>polynomials：n. [数] 多项式</li><li>coefficients：n. [数] 系数</li><li>exponents：n. 范例；n. [数] 指数</li><li>denote：vt. 表示，指示</li><li>seniority：n. 年长；级别</li><li>indices：n. 指数；目录（index的复数）</li><li>specified：adj. 规定的</li><li>radix：n. 根；[数] 基数</li><li>eulerian cycle：欧拉回路</li><li>traversal：n. [计] 遍历</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程</title>
      <link href="/2021/linux-shell-bian-cheng/"/>
      <url>/2021/linux-shell-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="1-教程"><a href="#1-教程" class="headerlink" title="1 教程"></a>1 教程</h1><ol><li>视频教程：<a href="https://www.bilibili.com/video/BV1dW411M7xL?p=58">尚硅谷Linux教程</a></li><li>文字教程：<a href="https://www.runoob.com/linux/linux-shell.html">Shell教程|菜鸟教程</a></li></ol><span id="more"></span><h1 id="2-补充"><a href="#2-补充" class="headerlink" title="2 补充"></a>2 补充</h1><h2 id="2-1-指令补充"><a href="#2-1-指令补充" class="headerlink" title="2.1 指令补充"></a>2.1 指令补充</h2><h3 id="2-1-1-条件测试"><a href="#2-1-1-条件测试" class="headerlink" title="2.1.1 条件测试"></a>2.1.1 条件测试</h3><ol><li><p>用途：测试特定的表达式是否成立，<strong>当条件成立时，命令执行后返回值为0</strong>，否则为其他值。</p></li><li><p>格式：</p><ul><li><p>test 条件表达式</p></li><li><p>[ 条件表达式 ]   <font color="red">注意，表达式左右有空格，方括号是必须有。</font></p></li></ul></li><li><p>常见的测试类型：</p><ul><li>测试文件状态</li><li>字符串比较</li><li>整数值比较</li><li>逻辑测试：<ul><li>格式：[ 表达式1 ] 逻辑符 [ 表达式2 ]</li><li>&amp;&amp;  <strong>表达式1正确，表达式2执行</strong></li><li>||   <strong>表达式1错误，表达式2执行</strong></li></ul></li></ul></li></ol><h3 id="2-1-2-传递参数，-1"><a href="#2-1-2-传递参数，-1" class="headerlink" title="2.1.2 传递参数，$1"></a>2.1.2 传递参数，$1</h3><ul><li>注意传递的参数第0个为执行的文件名，从第1个开始才是用户真正想传递的参数。</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;# 执行的文件名：.&#x2F;test.sh# 第一个参数为：1# 第二个参数为：2# 第三个参数为：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-3-条件控制"><a href="#2-1-3-条件控制" class="headerlink" title="2.1.3 条件控制"></a>2.1.3 条件控制</h3><p>PS：condition必须用[]包住，比较符号两边必须有空格，变量或者常数与[]之间也要有空格。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token number">10</span>b<span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $a <span class="token operator">==</span> $b <span class="token punctuation">]</span>then   echo <span class="token string">"a 等于 b"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> $a <span class="token operator">-</span>gt $b <span class="token punctuation">]</span>then   echo <span class="token string">"a 大于 b"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> $a <span class="token operator">-</span>lt $b <span class="token punctuation">]</span>then   echo <span class="token string">"a 小于 b"</span><span class="token keyword">else</span>   echo <span class="token string">"没有符合的条件"</span>fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> 教程 </tag>
            
            <tag> 常见用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP_经典模型</title>
      <link href="/2021/nlp-jing-dian-mo-xing/"/>
      <url>/2021/nlp-jing-dian-mo-xing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下模型由CQU 高旻老师挑选，内容由本人总结，部分内容来源网络，侵删</p><p>模型实现项目github地址：<a href="https://github.com/CQU-MinGao-NLP/NLP-learning">https://github.com/CQU-MinGao-NLP/NLP-learning</a></p></blockquote><h1 id="1-N-gram模型"><a href="#1-N-gram模型" class="headerlink" title="1 N-gram模型"></a>1 N-gram模型</h1><ul><li><strong>基本思想</strong></li></ul><p>N-gram模型引入了马尔可夫假设，这是一种独立性假设，在这里说的是<strong>某一个词语出现的的概率只由其前面的n-1个词语所决定</strong>，这被称为<strong>n元语言模型</strong> ，即<strong>n-gram</strong>，当<strong>n&#x3D;2</strong>时，相应的语言模型就被称为是<strong>二元模型</strong>。</p><ul><li><strong>概率模型</strong></li></ul><p><strong>传统语言模型（无法计算）：</strong></p><p><img src="https://img-service.csdnimg.cn/img_convert/b3a7a64560e2566de32f98c059e96436.png" alt="传统语言模型"></p><p><strong>N-gram通用模型：</strong></p><p><img src="https://img-service.csdnimg.cn/img_convert/4280e3f82f4d36a83bc1848e2429a3b0.png" alt="N-gram概率模型"></p><p><strong>Bi-gram：</strong></p><p><img src="https://img-service.csdnimg.cn/img_convert/65f503d308aad5b996b4ad50791959e3.png" alt="Bi-gram概率模型"></p><p><strong>Tri-gram:</strong></p><p><img src="https://img-service.csdnimg.cn/img_convert/a29d37d4787bc6b6a3928cf9a9fd227e.png" alt="Tri-gram概率模型"></p><ul><li><p>详见博客<a href="https://blog.csdn.net/rongsenmeng2835/article/details/108565323?spm=1001.2014.3001.5501">语言模型（一）—— 统计语言模型n-gram语言模型</a></p></li><li><p><a href="https://blog.csdn.net/rongsenmeng2835/article/details/108656674?spm=1001.2014.3001.5501">https://blog.csdn.net/rongsenmeng2835/article/details/108656674?spm=1001.2014.3001.5501</a>)</p></li></ul><h1 id="2-NNLM"><a href="#2-NNLM" class="headerlink" title="2 NNLM"></a>2 NNLM</h1><ul><li>论文链接：<a href="https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf">Nerual Network Language Model</a></li></ul><h2 id="2-1-FFNNLM"><a href="#2-1-FFNNLM" class="headerlink" title="2.1 FFNNLM"></a>2.1 FFNNLM</h2><ul><li>全称：Feedforward neural network model language model，前馈神经网络模语言模型</li></ul><p>以下内容来自博客：<a href="https://www.jiqizhixin.com/articles/2019-07-23-6">从经典结构到改进方法，神经网络语言模型综述</a></p><ul><li><strong>基本思想</strong></li></ul><p>Bengio 等人于 2003 年提出了原始 FFNNLM 的架构。这个 FFNNLM 可以写作：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/e7e35985-cbc0-4a06-a288-56c4b915cbab/640.png" alt="img"></p><p>其中，H、U 和 W 是层与层之间连接的权重矩阵；d 和 b 是隐藏层和输出层的偏置。</p><p>受到 N 元语言模型的启发，FFNNLM 将前 n-1 个单词作为了预测下一个单词的上下文。</p><p><img src="https://image.jiqizhixin.com/uploads/editor/fa95ce37-9539-4667-945e-b2ec157ef3fb/640.jpeg" alt="img"></p><ul><li><strong>优点</strong></li></ul><p>FFNNLM 通过<strong>为每个单词学习一个分布式表征</strong>来实现在连续空间上的建模。单词表征是语言模型的副产品，它往往被用于改进其它的 NLP 任务。基于 FFNNLM，Mikolov 等人于 2013 提出了两种词表征模型：「CBOW」和「Skip-gram」。FFNNLM 通过将单词转换为低维向量克服了维数诅咒。FFNNLM 引领了 NNLM 研究的潮流。</p><ul><li><strong>缺点</strong></li></ul><p>（1）在训练前指定的上下文大小是有限的，这与人类可以使用大量的上下文信息进行预测的事实是严重不符的。</p><p>（2）序列中的单词是时序相关的。而 FFNNLM 没有使用时序信息进行建模。</p><p>（3）此外，全连接 NN 需要学习许多可训练的参数，即使这些参数的数量比 N 元 少，但是仍然具有很大的计算开销，十分低效。</p><h1 id="3-Word-Embedding"><a href="#3-Word-Embedding" class="headerlink" title="3 Word Embedding"></a>3 Word Embedding</h1><h2 id="3-0-one-hot"><a href="#3-0-one-hot" class="headerlink" title="3.0 one-hot"></a>3.0 one-hot</h2><p>以下内容来自博客：<a href="https://blog.csdn.net/qq_30057549/article/details/103342841?utm_source=app&app_version=4.9.0&code=app_1562916241&uLinkId=usr1mkqgl919blen">词嵌入基础及其使用</a></p><ul><li><strong>基本思想</strong></li></ul><p>one-hot，简单来说就是单词编号是多少，哪个位置就为1，其余为0。这种词表示方法的特点就是，没有保留句子中的上下文关系（任何词之间的内积为0）。</p><p><img src="https://img-blog.csdnimg.cn/20191202151029593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMDU3NTQ5,size_16,color_FFFFFF,t_70" alt="one-hot"></p><h2 id="3-1-TF-IDF-与-BOW"><a href="#3-1-TF-IDF-与-BOW" class="headerlink" title="3.1 TF-IDF 与 BOW"></a>3.1 TF-IDF 与 BOW</h2><h3 id="3-1-1-TF-IDF"><a href="#3-1-1-TF-IDF" class="headerlink" title="3.1.1 TF-IDF"></a>3.1.1 TF-IDF</h3><p>以下内容来自博客：<a href="https://zhuanlan.zhihu.com/p/94446764">TF-IDF算法原理及其使用详解</a></p><ul><li><strong>基本思想</strong></li></ul><p>TF-IDF（Term Frequency-inverse Document Frequency）是一种针对关键词的统计分析方法，<strong>用于评估一个词对一个文件集或者一个语料库的重要程度。一个词的重要程度跟它在文章中出现的次数成正比，跟它在语料库出现的次数成反比。这种计算方式能有效避免常用词对关键词的影响，提高了关键词与文章之间的相关性。</strong></p><p>其中TF指的是某词在文章中出现的总次数，该指标通常会被归一化定义为<strong>TF&#x3D;（某词在文档中出现的次数&#x2F;文档的总词量）</strong>，这样可以防止结果偏向过长的文档（同一个词语在长文档里通常会具有比短文档更高的词频）。IDF逆向文档频率，包含某词语的文档越少，IDF值越大，说明该词语具有很强的区分能力，<strong>IDF&#x3D;log（语料库中文档总数&#x2F;包含该词的文档数+1），+1的原因是避免分母为0。TF-IDF&#x3D;TFxIDF，TF-IDF值越大表示该特征词对这个文本的重要性越大。</strong></p><ul><li><strong>具体实现</strong></li></ul><p>可以在Sklearn中调用TF-IDFVectorizer库实现TF-IDF算法，并且可以通过stopwords参数来设置文档中的停用词（没有具体意义的词，如助词，语气词等），使得停用词不纳入计算范围，提高算法的精确性。</p><h3 id="3-1-2-BOW"><a href="#3-1-2-BOW" class="headerlink" title="3.1.2 BOW"></a>3.1.2 BOW</h3><p>以下内容来自博客：<a href="https://blog.csdn.net/Elenstone/article/details/105134863">词向量之词袋模型(BOW)详解</a></p><ul><li><strong>基本思想</strong></li></ul><p>词袋模型（Bag-of-Words model，BOW）BoW(Bag of Words)词袋模型最初被用在文本分类中，将文档表示成特征矢量。它的<strong>基本思想是假定对于一个文本，忽略其词序和语法、句法，仅仅将其看做是一些词汇的集合，而文本中的每个词汇都是独立的。</strong>简单说就是讲每篇文档都看成一个袋子（因为里面装的都是词汇，所以称为词袋，Bag of words即因此而来），然后看这个袋子里装的都是些什么词汇，将其分类。如果文档中猪、马、牛、羊、山谷、土地、拖拉机这样的词汇多些，而银行、大厦、汽车、公园这样的词汇少些，我们就倾向于判断它是一篇描绘乡村的文档，而不是描述城镇的。</p><ul><li><strong>具体实现</strong></li></ul><ol><li>首先根据<strong>语料</strong>中出现的句子分词，然后构建<strong>词袋</strong>（每一个出现的词都加进来）。计算机不认识字，只认识数字，那在计算机中怎么表示词袋模型呢？其实很简单，给每个词一个位置索引就可以了。小孩放在第一个位置，喜欢放在第二个位置，以此类推。</li><li>其中key为词，value为词的索引，语料中共有9个单词， 那么每个句子我们就可以使用一个9维的向量来表示。如果句子中含有的一个词出现了一次，就让那个词的位置置为1，词出现几次就置为几，（<strong>本质是one-hot模型</strong>）</li><li>将两篇文本通过词袋模型变为向量模型，通过计算向量的余弦距离来计算两个文本间的相似度。</li></ol><ul><li><strong>缺点</strong>：基本同one-hot编码的缺点，没有上下文信息和向量稀疏。</li></ul><h2 id="3-2-Word-Embedding"><a href="#3-2-Word-Embedding" class="headerlink" title="3.2 Word Embedding"></a>3.2 Word Embedding</h2><ul><li><strong>基本思想</strong></li></ul><p>embedding是数学领域的有名词，是指某个对象 X 被嵌入到另外一个对象 Y 中，映射 f : X → Y ，例如有理数嵌入实数。word embedding，就是找到一个映射或者函数，生成在一个新的空间上的表达，该表达就是word representation。</p><p>Word Embedding 是NLP中一组语言模型和特征学习技术的总称，**把词汇表中的单词或者短语映射成由实数构成的向量上(映射)**。</p><ul><li><strong>具体实现</strong></li></ul><p>以下内容来自博客：<a href="https://blog.csdn.net/qq_30057549/article/details/103342841?utm_source=app&app_version=4.9.0&code=app_1562916241&uLinkId=usr1mkqgl919blen">词嵌入基础及其使用</a></p><p>一种表示如下图所示，在左侧一栏是维度，表格中的值是每个词在这个维度（特征）上的取值（-1，+1），越相关，绝对值越大。</p><p><img src="https://img-blog.csdnimg.cn/20191202151033329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMDU3NTQ5,size_16,color_FFFFFF,t_70" alt="WordEmbedding"></p><h2 id="3-2-Word2Vec"><a href="#3-2-Word2Vec" class="headerlink" title="3.2 Word2Vec"></a>3.2 Word2Vec</h2><ul><li><p>全称：Word to vector</p></li><li><p>论文链接：</p><ol><li><a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">skip-gra</a><a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">m</a></li><li><a href="https://arxiv.org/pdf/1301.3781.pdf">CBOW</a></li></ol></li><li><p><strong>语言模型种类</strong></p></li></ul><p>（1）如果是用一个词语作为输入，来预测它周围的上下文，那这个模型叫做『Skip-gram 模型』</p><p>（2）而如果是拿一个词语的上下文作为输入，来预测这个词语本身，则是 『CBOW 模型』</p><p>以下内容来自博客：<a href="https://zhuanlan.zhihu.com/p/61635013">Word2Vec详解</a></p><ul><li><strong>基本思想</strong></li></ul><p><strong>word2vec是用一个一层的神经网络把one-hot形式的稀疏词向量映射称为一个n维(n一般为几百)的稠密向量的过程。</strong>为了加快模型训练速度，其中的tricks包括Hierarchical softmax，negative sampling, Huffman Tree等。</p><p>模型框架：</p><p><img src="https://pic2.zhimg.com/v2-0d3bbbe2ab92b36d40ff0acb9170f311_r.jpg" alt="Word2Vec"></p><h3 id="3-2-1-CBOW"><a href="#3-2-1-CBOW" class="headerlink" title="3.2.1 CBOW"></a>3.2.1 CBOW</h3><p>全称：Continuous Bag of Words（连续词袋模型）</p><p><img src="https://pic4.zhimg.com/80/v2-8fcd03fa3dad0cf4d0af1a890ace5193_720w.jpg" alt="img"></p><p>1、输入层：上下文单词的One-Hot编码词向量，V为词汇表单词个数，C为上下文单词个数。以上文那句话为例，这里C&#x3D;4，所以模型的输入是（is,an,on,the）4个单词的One-Hot编码词向量。</p><p>2、初始化一个权重矩阵 <img src="https://www.zhihu.com/equation?tex=W_%7BV%C3%97N%7D" alt="[公式]"> ，然后用所有输入的One-Hot编码词向量左乘该矩阵,得到维数为N的向量 <img src="https://www.zhihu.com/equation?tex=%CF%89_1+%CF%89_2,%E2%80%A6,%CF%89_c" alt="[公式]"> ，这里的N由自己根据任务需要设置。</p><p>3、将所得的向量 <img src="https://www.zhihu.com/equation?tex=%CF%89_1+%CF%89_2,%E2%80%A6,%CF%89_c" alt="[公式]"> 相加求平均作为隐藏层向量h。</p><p>4、初始化另一个权重矩阵 <img src="https://www.zhihu.com/equation?tex=W_%7BN%C3%97V%7D%5E%7B%27%7D" alt="[公式]"> ,用隐藏层向量h左乘 <img src="https://www.zhihu.com/equation?tex=W_%7BN%C3%97V%7D%5E%7B%27%7D" alt="[公式]"> ，再经激活函数处理得到V维的向量y，<strong>y的每一个元素代表相对应的每个单词的概率分布</strong>。</p><p>5、<strong>y中概率最大的元素所指示的单词为预测出的中间词（target word）与true label的One-Hot编码词向量做比较，误差越小越好（根据误差更新两个权重矩阵）</strong></p><p>在训练前需要定义好<strong>损失函数（一般为交叉熵代价函数）</strong>，采用梯度下降算法更新W和W’。训练完毕后，<strong>输入层的每个单词与矩阵W（左侧的权重矩阵）相乘得到的向量的就是我们想要的Distributed Representation表示的词向量，也叫做word embedding。</strong>因为<strong>One-Hot编码词向量中只有一个元素为1，其他都为0，所以第i个词向量乘以矩阵W得到的就是矩阵的第i行</strong>，所以<strong>这个矩阵也叫做look up table，有了look up table就可以免去训练过程，直接查表得到单词的词向量了</strong>。</p><h3 id="3-2-2-Skip-gram"><a href="#3-2-2-Skip-gram" class="headerlink" title="3.2.2 Skip-gram"></a>3.2.2 Skip-gram</h3><p><img src="https://pic2.zhimg.com/80/v2-a04dca66f5e8456f50b4b43fb87b98dd_720w.jpg" alt="img"></p><p>通过在一个大的语料库训练，得到一个从输入层到隐含层的权重模型。“apple”的上下文词是（’there’，’is’，’an’，’on’,’the’,’table’）。<strong>那么以apple的One-Hot词向量作为输入，输出则是（’there’，’is’，’an’，’on’,’the’,’table’）的One-Hot词向量。训练完成后，就得到了每个词到隐含层的每个维度的权重，就是每个词的向量（和CBOW中一样）。</strong></p><ul><li><strong>如何训练神经网络模型</strong></li></ul><p>假如我们有一个句子“There is an apple on the table”。</p><p>1、首先我们选句子中间的一个词作为我们的输入词，例如我们选取“apple”作为input word；</p><p>2、有了input word以后，我们再<strong>定义一个叫做skip_window的参数，它代表着我们从当前input word的一侧（左边或右边）选取词的数量。</strong>如果我们设置skip_window&#x3D;2，那么我们最终获得窗口中的词（包括input word在内）就是[‘is’,’an’,’apple’,’on’,’the’ ]。<strong>skip_window&#x3D;2代表着选取左input word左侧2个词和右侧2个词进入我们的窗口</strong>，所以整个窗口大小span&#x3D;2x2&#x3D;4。<strong>另一个参数叫num_skips，它代表着我们从整个窗口中随机选取多少个不同的词作为我们的output word</strong>，当skip_window&#x3D;2，num_skips&#x3D;2时，我们将会得到两组 (input word, output word) 形式的训练数据，即 (‘apple’, ‘an’)，(‘apple’, ‘on’)。</p><p>3、<strong>神经网络基于这些训练数据中每对单词出现的次数习得统计结果，并输出一个概率分布，这个概率分布代表着到我们词典中每个词有多大可能性跟input word同时出现。</strong>举个例子，如果我们向神经网络模型中输入一个单词“中国“，那么最终模型的输出概率中，像“英国”， ”俄罗斯“这种相关词的概率将远高于像”苹果“，”蝈蝈“非相关词的概率。<strong>因为”英国“，”俄罗斯“在文本中更大可能在”中国“的窗口（Skip_window）中出现。</strong>我们将通过给神经网络输入文本中成对的单词来训练它完成上面所说的概率计算。</p><p>4、<strong>通过梯度下降和反向传播更新矩阵W</strong></p><p>5、W中的行向量即为每个单词的Word embedding表示</p><ul><li><strong>skip_window和num_skips</strong></li></ul><p>简单来说，<strong>skip_window和num_skips用来生成标注(label)的训练数据集，可以理解为是监督学习中的标注数据。每个(input_word, output_word)表示在模型中每个input_word 所对应的 output_word应该是什么</strong>。</p><p>skip_window代表窗口大小，num_skips &#x3D; 2 表示input用于产生label的次数限制，就是对于一个中心词 在window范围 随机选取num_skips个词，产生一系列(input_id, output_id) 。</p><p>在生成单词对时，会在<strong>语料库中先取出一个长度为skip_window*2+1连续单词列表</strong>，这个连续的单词列表是上面程序中的变量buffer。buffer中最中间的那个单词是Skip-Gram方法中“出现的单词”，其余skip_window*2个单词是它的“上下文”。<strong>会在skip_window*2个单词中随机选取num_skips个单词，放入的标签labels</strong>。</p><p>如skip_window&#x3D;1 , num_skips&#x3D;2的情况。会首先选取一个长度为3的buffer，假设它是[‘anarchism’, ‘originated’,’as’]，此时originated为中心单词，剩下的两个单词为它的上下文。再在这两个单词中选择num_skips形成标签。由于num_skips&#x3D;2，所以实际只能将这两个单词都选上（标签不能重复），最后生成的训练数据为originated -&gt;anarchism和originated -&gt; as。</p><h3 id="3-2-3-Tricks"><a href="#3-2-3-Tricks" class="headerlink" title="3.2.3 Tricks"></a>3.2.3 Tricks</h3><ul><li><strong>Hierarchical Softmax</strong></li></ul><p>Hierarchical Softmax对原模型的改进主要有两点，<strong>第一点是从输入层到隐藏层的映射，没有采用原先的与矩阵W相乘然后相加求平均的方法，而是直接对所有输入的词向量求和。</strong>假设输入的词向量为（0，1，0，0）和（0,0,0,1），那么隐藏层的向量为（0,1,0,1）。</p><p>Hierarchical Softmax的<strong>第二点改进是采用哈夫曼树来替换了原先的从隐藏层到输出层的矩阵W’。</strong>哈夫曼树的叶节点个数为词汇表的单词个数V，一个叶节点代表一个单词，而从根节点到该叶节点的路径确定了这个单词最终输出的词向量。</p><p>哈夫曼树的所有内部节点就类似之前神经网络隐藏层的神经，其中，<strong>根节点的词向量对应投影后的词向量</strong>，而<strong>所有叶子节点就类似于之前神经网络softmax输出层的神经元，叶子节点的个数就是词汇表的大小</strong>。在哈夫曼树中，隐藏层到输出层的softmax映射不是一下子完成的，而是沿着哈夫曼树一步步完成的，因此这种softmax取名为”Hierarchical Softmax”。</p><p><img src="https://images2017.cnblogs.com/blog/1042406/201707/1042406-20170727105752968-819608237.png" alt="HierarchicalSoftmax-Huffuman"></p><ul><li><strong>Negative Sampling（负采样）</strong></li></ul><p>比如我们有一个训练样本，中心词是w，它周围上下文共有2c个词，记为context(w)。由于这个中心词w，的确和context(w)相关，因此它是一个真实的正例。<strong>通过Negative Sampling采样，我们得到n个和w不同的中心词wi, i&#x3D;1,2,..n，这样context(w)和wi就组成了n个并不真实存在的负例。利用这一个正例和n个负例，我们进行二元逻辑回归，得到负采样对应每个词wi对应的模型参数θi，和每个词的词向量</strong>。</p><h2 id="3-3-GloVe"><a href="#3-3-GloVe" class="headerlink" title="3.3 GloVe"></a>3.3 GloVe</h2><ul><li>论文链接：<a href="https://www.aclweb.org/anthology/D14-1162.pdf">Global vectors for word representation</a></li></ul><p>以下内容来自博客：<a href="http://www.fanyeong.com/2018/02/19/glove-in-detail/">GloVe详解</a></p><ul><li><strong>基本思想</strong></li></ul><p><strong>GloVe的全称叫Global Vectors for Word Representation，它是一个基于全局词频统计（count-based &amp; overall statistics）的词表征（word representation）工具，它可以把一个单词表达成一个由实数组成的向量，这些向量捕捉到了单词之间一些语义特性，比如相似性（similarity）、类比性（analogy）等。</strong>我们通过对向量的运算，比如欧几里得距离或者cosine相似度，可以计算出两个单词之间的语义相似性。</p><ul><li><strong>主要模型</strong></li></ul><p><strong>构建词向量（Word Vector）和共现矩阵（Co-ocurrence Matrix）之间的近似关系</strong>，论文的作者提出以下的公式可以近似地表达两者之间的关系：</p><p><img src="http://img.fdchen.host/Glove-%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9E%8B.png" alt="image-20210806192653851"></p><p>其中，<strong>wi^T和wj是我们最终要求解的词向量；</strong>bi和bj分别是两个词向量的bias term。</p><ul><li><strong>损失函数</strong></li></ul><p><img src="http://img.fdchen.host/Glove-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="image-20210806192630927"></p><p>这个loss function的基本形式就是最简单的mean square loss，只不过在此基础上加了一个权重函数f(Xij)。</p><p><img src="http://img.fdchen.host/Glove-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E6%9D%83%E5%80%BC%E5%87%BD%E6%95%B0.png" alt="image-20210806193111470"></p><h1 id="4-Fasttext"><a href="#4-Fasttext" class="headerlink" title="4 Fasttext"></a>4 Fasttext</h1><ul><li><p>全称：Facebook开发的一款快速文本分类器</p></li><li><p>论文链接：</p><ul><li><a href="https://arxiv.org/pdf/1607.01759.pdf">Bag of Tricks for Efficient Text Classification</a>   关于文本分类</li><li><a href="https://arxiv.org/pdf/1607.04606.pdf">Enriching Word Vectors with Subword Information</a>  关于文本嵌入</li></ul></li><li><p>以下内容来自博客：<strong>fastText原理及实践</strong></p></li><li><p><strong>基本思想</strong></p></li></ul><p>fastText模型也只有三层：输入层、隐含层、输出层（Hierarchical Softmax）<strong>，输入都是多个经向量表示的单词，输出都是一个特定的target，隐含层都是对多个词向量的叠加平均。</strong>不同的是，CBOW的输入是目标单词的上下文，<strong>fastText的输入是多个单词及其n-gram特征，这些特征用来表示单个文档</strong>；CBOW的输入单词被onehot编码过，<strong>fastText的输入特征是被embedding过</strong>；CBOW的输出是目标词汇，<strong>fastText的输出是文档对应的类标。</strong></p><p>值得注意的是，fastText<strong>在输入时，将单词的字符级别的n-gram向量作为额外的特征；在输出时，fastText采用了分层Softmax</strong>，大大降低了模型训练时间。</p><ul><li><strong>主要优点：</strong>fastText是一个快速文本分类算法</li></ul><ol><li>fastText在保持高精度的情况下加快了训练速度和测试速度</li><li>fastText不需要预训练好的词向量，fastText会自己训练词向量</li><li>fastText两个重要的优化：Hierarchical Softmax、N-gram</li></ol><h1 id="5-textCNN"><a href="#5-textCNN" class="headerlink" title="5 textCNN"></a>5 textCNN</h1><ul><li>全称+论文链接：<a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1408.5882">Convolutional Neural Networks for Sentence Classification</a></li></ul><h2 id="5-1-CNN"><a href="#5-1-CNN" class="headerlink" title="5.1 CNN"></a>5.1 CNN</h2><ul><li>基本思想：</li></ul><p>卷积神经网络主要由这几类层构成：<strong>输入层、卷积层，ReLU层、池化（Pooling）层和全连接层（全连接层和常规神经网络中的一样）</strong>。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络。在实际应用中往往将卷积层与ReLU层共同称之为卷积层，<strong>所以卷积层经过卷积操作也是要经过激活函数的</strong>。具体说来，卷积层和全连接层（CONV&#x2F;FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数，即神经元的权值w和偏差b；而ReLU层和池化层则是进行一个固定不变的函数操作。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。</p><p>详细解读见博客：<a href="https://zhuanlan.zhihu.com/p/47184529">卷积神经网络（CNN）详解</a></p><ul><li><strong>卷积层</strong></li></ul><p><img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-juanji.gif" alt="卷积层"></p><ul><li><strong>池化层</strong></li></ul><p><img src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-chihua.gif" alt="池化层"></p><ul><li><strong>全连接层（Fully Connected Layer）</strong></li></ul><p>连接所有的特征，将输出值送给分类器（如softmax分类器）。</p><p><img src="http://img.fdchen.host/CNN-%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82.png" alt="image-20210730100057238"></p><ul><li><strong>感受野（receptive filed）</strong></li></ul><p>每个神经元只与输入数据的一个局部区域连接，该连接的<strong>空间大小</strong>叫做神经元的感受野（receptive field），它的尺寸是一个超参数（<strong>其实就是滤波器的空间尺寸</strong>，注意仅仅是大小相同，但是概念不一样）</p><ul><li><strong>滤波器（filter）</strong></li></ul><p>如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的卷积（这就是“卷积层”名字由来）。这也是为什么总是将这些权重集合称为滤波器（filter）（或卷积核（kernel）），因为它们和输入进行了卷积。</p><p><strong>卷积核：</strong>二维的矩阵<br><strong>滤波器：</strong>多个卷积核组成的三维矩阵，多出的一维是通道数目。</p><ul><li><strong>权值共享</strong></li></ul><p>卷积核内每一个元素值不同，但是同一深度切片使用相同卷积核，这就是权值共享。也就是说每一层（深度切片）使用同一个卷积核（一个滤波器有也多个卷积核，且一定与输入数据深度相同）。</p><ul><li><strong>深度depth（与通道类似）</strong></li></ul><p>分为输入数据的深度和输出数据的深度，输入数据深度由输入数据决定。</p><p><img src="https://img-blog.csdnimg.cn/20190523160541489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rob3JLaW5nMDE=,size_16,color_FFFFFF,t_70" alt="CNN-depth"></p><p><strong>输出数据的深度，取决于滤波器的个数，就是有滤波器有几个，深度就是多少。</strong></p><ul><li><strong>通道channel</strong></li></ul><p><img src="http://img.fdchen.host/CNN-channel.png" alt="image-20210730092433430"></p><p>可以把channels 分为三种：</p><ol><li>最初输入的图片样本的 channels ，取决于图片类型，比如RGB；</li><li>卷积操作完成后输出的 out_channels ，取决于卷积核的数量。此时的out_channels 也会作为下一次卷积时的卷积核的 in_channels；</li><li>卷积核中的 in_channels ，刚刚2中已经说了，就是上一次卷积的 out_channels ，如果是第一次做卷积，就是1中样本图片的 channels</li></ol><p>（详见博客：<a href="https://blog.csdn.net/sscc_learning/article/details/79814146">【CNN】理解卷积神经网络中的通道 channel</a>）</p><ul><li><strong>特征图</strong></li></ul><p>卷积层之后的输出结果就是特征图。</p><h2 id="5-2-textCNN"><a href="#5-2-textCNN" class="headerlink" title="5.2 textCNN"></a>5.2 textCNN</h2><ul><li><strong>基本思想</strong></li></ul><p>卷积神经网络的核心思想是<strong>捕捉局部特征</strong>，对于文本来说，局部特征就是<strong>由若干单词组成的滑动窗口</strong>，类似于N-gram。卷积神经网络的<strong>优势在于能够自动地对N-gram特征进行组合和筛选，获得不同抽象层次的语义信息</strong>。</p><p>详细解读见博客：<a href="https://zhuanlan.zhihu.com/p/77634533">深入TextCNN（一）详述CNN及TextCNN原理</a></p><p><img src="https://pic3.zhimg.com/80/v2-2ea1f0b8b166f31273b26bca3ba8e8b2_720w.jpg" alt="textCNN结构"></p><h1 id="6-textRNN"><a href="#6-textRNN" class="headerlink" title="6 textRNN"></a>6 textRNN</h1><h2 id="6-1-RNN"><a href="#6-1-RNN" class="headerlink" title="6.1 RNN"></a>6.1 RNN</h2><ul><li>基本思想</li></ul><ol><li>RNN 的输入和输出可以是不定长且不等长的</li><li>RNN 有多种结构，如下图：</li></ol><p><img src="https://image.jiqizhixin.com/uploads/editor/06aefcee-6e74-4dde-bee1-5f82a5b85c9e/1544760758227.png" alt="img"></p><ol start="3"><li>RNN网络和其他网络最大的不同就在于<strong>RNN能够实现某种“记忆功能”，对所处理过的信息留存有一定的记忆</strong>，具体而言就是<strong>上一个时刻的网络状态会应影响下一个时刻的网络状态。</strong></li></ol><p>详细解读见博客：<a href="https://www.jiqizhixin.com/articles/2018-12-14-4">RNN 结构详解</a></p><ul><li><strong>隐状态</strong></li></ul><p>隐状态h（hidden state）可以对序列形的数据提取特征，接着再转换为输出。</p><ul><li><strong>RNN经典n-to-n结构示例</strong></li></ul><p>先从h1的计算开始看：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/c672edc7-0502-4034-b555-c5cccdde8704/1544760757932.png" alt="img"></p><p>h2的计算和h1类似。要注意的是，在计算时，<strong>每一步使用的参数U、W、b都是一样的，也就是说每个步骤的参数都是共享的，这是RNN的重要特点。</strong></p><p><img src="https://image.jiqizhixin.com/uploads/editor/1780d8f0-3095-4523-b271-9230ca308a04/1544760758036.png" alt="img"></p><p>最终的输出如下：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/0c80f834-2047-44a1-b834-083dcd59e7b4/1544760758826.png" alt="RNN-最终输出"></p><p>剩下的输出类似进行（使用和y1同样的参数V和c）：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/b4ff8fa4-7e6d-405c-9900-d82e7c2c8504/1544760759148.png" alt="img"></p><p>这就是最经典的RNN结构，它的输入是x1, x2, …..xn，输出为y1, y2, …yn，也就是说，<strong>输入和输出序列必须要是等长的</strong>。</p><ul><li><strong>缺点：</strong>容易出现梯度消失</li></ul><h2 id="6-2-Encoder-Decoder"><a href="#6-2-Encoder-Decoder" class="headerlink" title="6.2 Encoder-Decoder"></a>6.2 Encoder-Decoder</h2><p>Encoder-Decoder是一种 <strong>n-to-m</strong> 结构，输入、输出为不等长的序列。</p><ul><li><strong>基本思想</strong></li></ul><p>（1）Encoder：将 input序列 →转成→ 固定长度的向量</p><p>（2）Decoder：将 固定长度的向量 →转成→ output序列</p><p>（3）Encoder 与 Decoder 可以彼此独立使用，实际上经常一起使用</p><p>Encoder-Decoder结构<strong>先将输入数据编码成一个上下文语义向量c</strong>，语义向量c可以有多种表达方式，最简单的方法就是把Encoder的最后一个隐状态赋值给c，还可以对最后的隐状态做一个变换得到c，也可以对所有的隐状态做变换。拿到c之后，就<strong>用另一个RNN网络对其进行解码，这部分RNN网络被称为Decoder</strong>。Decoder的RNN可以与Encoder的一样，也可以不一样。</p><p>详细解读见博客：<a href="https://www.jiqizhixin.com/articles/2018-12-14-4">RNN 结构详解</a></p><ul><li><strong>具体做法</strong></li></ul><p>具体做法就是<strong>将c当做之前的初始状态h0输入到Decoder中</strong>：</p><p><a href="https://github.com/YZHANG1270/Markdown_pic/blob/master/2018/11/RNN_01/013.jpg?raw=true"><img src="https://image.jiqizhixin.com/uploads/editor/ce3fc27e-cbf5-465d-86c1-4ffbfdac6dfa/1544760759311.png" alt="img"></a></p><p><strong>还有一种做法是将c当做每一步的输入</strong>：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/89a6896c-de8e-417e-8b87-30b9b90e68e5/1544760759641.png" alt="img"></p><ul><li><strong>缺点：</strong></li></ul><p>编码和解码之间的唯一联系是固定长度的语义向量c，<strong>编码要把整个序列的信息压缩进一个固定长度的语义向量c，语义向量c无法完全表达整个序列的信息</strong>，先输入的内容携带的信息，会被后输入的信息稀释掉，或者被覆盖掉。<br>输入序列越长，这样的现象越严重，这样使得在Decoder解码时一开始就没有获得足够的输入序列信息，解码效果会打折扣。</p><h2 id="6-3-Attention机制"><a href="#6-3-Attention机制" class="headerlink" title="6.3 Attention机制"></a>6.3 Attention机制</h2><ul><li><strong>基本思想</strong></li></ul><p>注意力机制（attention mechanism）是对基础Encoder-Decoder的改良。Attention机制通过在每个时间输入不同的c来解决问题，每一个c会自动去选取与当前所要输出的y最合适的上下文信息，仅Decoder部分与简单RNN不同，下图是带有Attention机制的Decoder：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/483f24d7-da8d-4a66-84d0-fcb6a45bdca9/1544760760610.png" alt="img"></p><p>详细解读见博客：<a href="https://www.jiqizhixin.com/articles/2018-12-14-4">RNN 结构详解</a></p><ul><li><strong>具体做法</strong></li></ul><p>具体来说，我们<strong>用aij衡量Decoder中第i阶段与Encoder中第j阶段的hj的相关性</strong>，最终Decoder中第i阶段的输入的上下文信息 ci就来自于所有 hj 对 aij 的加权和。</p><p>以机器翻译为例（将中文翻译成英文）：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/223b12fa-4da6-4a5f-8039-c043b3701ef5/1544760760445.png" alt="img"></p><ul><li><strong>计算权重aij</strong></li></ul><p>aij 同样是从模型中学出的，它实际和<strong>Decoder的第i-1阶段的隐状态</strong>、<strong>Encoder第j个阶段的隐状态</strong>有关。</p><p>同样还是拿上面的机器翻译举例， a1j 的计算（此时箭头就表示对h’和 hj 同时做变换）：</p><p><img src="https://image.jiqizhixin.com/uploads/editor/7c144c37-72dd-4aad-a093-954087edaf9b/1544760759945.png" alt="img"></p><ul><li><strong>优点</strong></li></ul><p>（1）让生词不只是关注全局的语义向量c，增加了“注意力范围”。表示接下来输出的词要重点关注输入序列的哪些部分。根据关注的区域来产生下一个输出。<br>（2）不要求编码器将所有信息全输入在一个固定长度的向量中。<br>（3）将输入编码成一个向量的序列，解码时，每一步选择性的从序列中挑一个子集进行处理。<br>（4）在每一个输出时，能够充分利用输入携带的信息，每个语义向量Ci不一样，注意力焦点不一样。</p><ul><li><strong>缺点</strong></li></ul><p>（1）需要为每个输入输出组合分别计算attention。50个单词的输出输出序列需要计算2500个attention。<br>（2）attention在决定专注于某个方面之前需要遍历一遍记忆再决定下一个输出是以什么。</p><ul><li><strong>强化学习</strong></li></ul><p>Attention的另一种替代方法是强化学习，来预测关注点的大概位置。但强化学习不能用反向传播算法端到端的训练。</p><p><strong>强化学习是一种试错方法，其目标是让软件智能体在特定环境中能够采取回报最大化的行为。强化学习在马尔可夫决策过程环境中主要使用的技术是动态规划（Dynamic Programming）。</strong>流行的强化学习方法包括自适应动态规划（ADP）、时间差分（TD）学习、状态-动作-回报-状态-动作（SARSA）算法、Q 学习、深度强化学习（DQN）；其应用包括下棋类游戏、机器人控制和工作调度等。</p><h2 id="6-4-LSTM"><a href="#6-4-LSTM" class="headerlink" title="6.4 LSTM"></a>6.4 LSTM</h2><p>以下内容来自博客：<a href="https://zhuanlan.zhihu.com/p/32085405">人人都能看懂的LSTM</a></p><ul><li><strong>基本思想</strong></li></ul><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p><p>LSTM结构（图右）和普通RNN的主要输入输出区别如下所示。</p><p><img src="https://pic4.zhimg.com/80/v2-e4f9851cad426dfe4ab1c76209546827_720w.jpg" alt="img"></p><p>相比RNN只有一个传递状态 <img src="https://www.zhihu.com/equation?tex=h%5Et+" alt="[公式]"> ，LSTM有两个传输状态，一个 <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]"> （cell state），和一个 <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]"> （hidden state）。（Tips：RNN中的 <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]"> 对于LSTM中的 <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]"> ）</p><p>其中对于传递下去的 <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]"> 改变得很慢，通常输出的 <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]"> 是上一个状态传过来的 <img src="https://www.zhihu.com/equation?tex=c%5E%7Bt-1%7D" alt="[公式]"> 加上一些数值。</p><p>而 <img src="https://www.zhihu.com/equation?tex=h%5Et" alt="[公式]"> 则在不同节点下往往会有很大的区别。</p><ul><li>具体做法</li></ul><p><img src="https://pic2.zhimg.com/80/v2-556c74f0e025a47fea05dc0f76ea775d_720w.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=%5Codot" alt="[公式]"> 是Hadamard Product，也就是操作矩阵中对应的元素相乘，因此要求两个相乘矩阵是同型的。 <img src="https://www.zhihu.com/equation?tex=%5Coplus" alt="[公式]"> 则代表进行矩阵加法。</p><p><strong>LSTM内部主要有三个阶段：</strong></p><p>1.忘记阶段。这个阶段主要是对上一个节点传进来的输入进行<strong>选择性</strong>忘记。简单来说就是会 “忘记不重要的，记住重要的”。</p><p>具体来说是通过计算得到的 <img src="https://www.zhihu.com/equation?tex=z%5Ef" alt="[公式]"> （f表示forget）来作为忘记门控，来控制上一个状态的 <img src="https://www.zhihu.com/equation?tex=c%5E%7Bt-1%7D" alt="[公式]"> 哪些需要留哪些需要忘。</p><p>2.选择记忆阶段。这个阶段将这个阶段的输入有选择性地进行“记忆”。主要是会对输入 <img src="https://www.zhihu.com/equation?tex=x%5Et" alt="[公式]"> 进行选择记忆。哪些重要则着重记录下来，哪些不重要，则少记一些。当前的输入内容由前面计算得到的 <img src="https://www.zhihu.com/equation?tex=z+" alt="[公式]"> 表示。而选择的门控信号则是由 <img src="https://www.zhihu.com/equation?tex=z%5Ei" alt="[公式]"> （i代表input)来进行控制。</p><blockquote><p>将上面两步得到的结果相加，即可得到传输给下一个状态的 <img src="https://www.zhihu.com/equation?tex=c%5Et" alt="[公式]"> 。也就是上图中的第一个公式。</p></blockquote><p>3.输出阶段。这个阶段将决定哪些将会被当成当前状态的输出。主要是通过 <img src="https://www.zhihu.com/equation?tex=z%5Eo" alt="[公式]"> 来进行控制的。并且还对上一阶段得到的 <img src="https://www.zhihu.com/equation?tex=c%5Eo" alt="[公式]"> 进行了放缩（通过一个tanh激活函数进行变化)。</p><ul><li><strong>LSTM的四个状态</strong></li></ul><p>首先使用LSTM的当前输入 <img src="https://www.zhihu.com/equation?tex=x%5Et" alt="[公式]"> 和上一个状态传递下来的 <img src="https://www.zhihu.com/equation?tex=h%5E%7Bt-1%7D" alt="[公式]"> 拼接训练得到四个状态。</p><p><img src="https://pic4.zhimg.com/80/v2-15c5eb554f843ec492579c6d87e1497b_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-d044fd0087e1df5d2a1089b441db9970_720w.jpg" alt="img"></p><p>其中， <img src="https://www.zhihu.com/equation?tex=z%5Ef+" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=z%5Ei" alt="[公式]"> ，<img src="https://www.zhihu.com/equation?tex=z%5Eo" alt="[公式]"> 是由拼接向量乘以权重矩阵之后，再通过一个 <img src="https://www.zhihu.com/equation?tex=sigmoid+" alt="[公式]"> 激活函数转换成0到1之间的数值，来作为一种门控状态。而 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> 则是将结果通过一个 <img src="https://www.zhihu.com/equation?tex=tanh" alt="[公式]"> 激活函数将转换成-1到1之间的值（这里使用 <img src="https://www.zhihu.com/equation?tex=tanh" alt="[公式]"> 是因为这里是将其做为输入数据，而不是门控信号）。</p><h2 id="6-5-textRNN"><a href="#6-5-textRNN" class="headerlink" title="6.5 textRNN"></a>6.5 textRNN</h2><ul><li>论文链接：<a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=F2929368FEDF4A9A7E495DC2A3137D19?doi=10.1.1.822.3091&rep=rep1&type=pdf">Recurrent</a><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=F2929368FEDF4A9A7E495DC2A3137D19?doi=10.1.1.822.3091&rep=rep1&type=pdf"> Neural Networks for Sentence Classification</a></li></ul><p>以下内容来自博客：<a href="https://www.pianshen.com/article/6169194182/">TextRNN</a></p><ul><li><strong>基本思想</strong></li></ul><p>自然语言处理中更常用的是循环神经网络（RNN, Recurrent Neural Network），<strong>能够更好的表达上下文信息</strong>。具体在文本分类任务中，Bi-directional RNN（实<strong>际使用的是双向LSTM</strong>）从某种意义上可以理解为可以捕获变长且双向的的 “n-gram” 信息。</p><ul><li><strong>Bi-LSTM</strong></li></ul><p>双向LSTM算是在自然语言处理领域非常一个标配网络了，在序列标注&#x2F;命名体识别&#x2F;seq2seq模型等很多场景都有应用，下图是Bi-LSTM用于分类问题的网络结构原理示意图，黄色的节点分别是前向和后向RNN的输出，<strong>示例中的是利用最后一个词的结果直接接全连接层softmax输出了</strong>。</p><p><img src="https://www.pianshen.com/images/297/b371970c5969284fd10846f6803228e9.png" alt="在这里插入图片描述"></p><h2 id="6-6-TextRNN-Attention"><a href="#6-6-TextRNN-Attention" class="headerlink" title="6.6 TextRNN + Attention"></a>6.6 TextRNN + Attention</h2><ul><li><strong>基本思想：用Attention Layer代替全连接层</strong></li></ul><p>Att-BiLSTM包含5部分：</p><p>输入层：输入句子到模型。</p><p>嵌入层：将每个词映射到低维向量。</p><p>LSTM层：使用BLSTM得到高层特征。</p><p>注意力层：通过与权重向量加权求和，将词级别的特征合并到句子级别的特征。</p><p>输出层：将句子层级的特征用于关系分类。</p><p>整个网络结构如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-dece7cbd3dfab01fb599e2aae338d74a_720w.jpg" alt="img"></p><ul><li><strong>Bi-LSTM</strong></li></ul><p>使用BiLSTM，句子中第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 个词的输出为，即对前向和后向的Hidden State进行拼接：</p><p><img src="https://www.zhihu.com/equation?tex=h_%7Bi%7D=%5Cleft%5B%5Coverrightarrow%7Bh_%7Bi%7D%7D+%5Coplus+%5Coverleftarrow%7Bh_%7Bi%7D%7D%5Cright%5D" alt="[公式]"></p><ul><li><strong>Attention层</strong></li></ul><p><img src="https://www.zhihu.com/equation?tex=H=%5Bh_1,h_2,...,h_T%5D" alt="[公式]"> 为LSTM层的输出向量，T是句子长度。 <img src="https://www.zhihu.com/equation?tex=H+%5Cin+%5Cmathbb%7BR%7D%5E%7Bd%5E%7Bw%7D+%5Ctimes+T%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=d%5Ew" alt="[公式]"> 是LSTM层的输出维度。 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> 的维度是 <img src="https://www.zhihu.com/equation?tex=d%5Ew" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]"> 的维度是T， <img src="https://www.zhihu.com/equation?tex=r" alt="[公式]"> 的维度是 <img src="https://www.zhihu.com/equation?tex=d%5Ew" alt="[公式]"> .</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+M+&=%5Ctanh+(H)+%5C%5C+%5Calpha+&=%5Coperatorname%7Bsoftmax%7D%5Cleft(w%5E%7BT%7D+M%5Cright)+%5C%5C+r+&=H+%5Calpha%5E%7BT%7D+%5Cend%7Baligned%7D" alt="[公式]"></p><p>然后用于最后分类的特征为 <img src="https://www.zhihu.com/equation?tex=h%5E*=tanh(r)" alt="[公式]"></p><ul><li><strong>输出层</strong></li></ul><p>最后将句子的特征 <img src="https://www.zhihu.com/equation?tex=h%5E*" alt="[公式]"> 接入softmax进行分类。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bc%7D+%5Chat%7Bp%7D(y+%5Cmid+S)=%5Coperatorname%7Bsoftmax%7D%5Cleft(W%5E%7B(S)%7D+h%5E%7B*%7D+b%5E%7B(S)%7D%5Cright)+%5C%5C+%5Chat%7By%7D=%5Carg+%5Cmax+_%7By%7D+%5Chat%7Bp%7D(y+%5Cmid+S)+%5Cend%7Barray%7D" alt="[公式]"></p><p>然后损失函数是使用交叉熵损失，并且加入了L2正则化。</p><p><img src="https://www.zhihu.com/equation?tex=J(%5Ctheta)=-%5Cfrac%7B1%7D%7Bm%7D+%5Csum_%7Bi=1%7D%5E%7Bm%7D+t_%7Bi%7D+%5Clog+%5Cleft(y_%7Bi%7D%5Cright)+%5Clambda%5C%7C%5Ctheta%5C%7C_%7BF%7D%5E%7B2%7D+" alt="[公式]"></p><ul><li><strong>正则化</strong></li></ul><p><img src="http://img.fdchen.host/L1%E4%B8%8EL2%E6%AD%A3%E5%88%99%E5%8C%96.png" alt="image-20210730130844097"></p><h1 id="7-seq2seq"><a href="#7-seq2seq" class="headerlink" title="7 seq2seq"></a>7 seq2seq</h1><ul><li>论文链接： <a href="http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">Sequence to Sequence Learning with Neural Networks  </a></li></ul><p>seq2seq 是一个Encoder–Decoder 结构的网络。</p><h1 id="8-Transformer"><a href="#8-Transformer" class="headerlink" title="8 Transformer"></a>8 Transformer</h1><h2 id="8-1-Transformer"><a href="#8-1-Transformer" class="headerlink" title="8.1 Transformer"></a>8.1 Transformer</h2><ul><li>论文链接：<a href="https://arxiv.org/pdf/1706.03762.pdf">Attention is All Your Need</a></li></ul><p>以下内容来自博客：<a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need）</a></p><ul><li><strong>基本思想</strong></li></ul><p>Transformer中抛弃了传统的CNN和RNN，整个网络结构完全是由Attention机制组成。更准确地讲，Transformer由且仅由self-Attenion和Feed Forward Neural Network组成。</p><p><img src="https://pic1.zhimg.com/80/v2-9fb280eb2a69baf5ceafcfa3581aa580_720w.jpg" alt="Transformer结构"></p><ul><li><strong>Attention计算方法</strong></li></ul><p>Attention的计算方法，整个过程可以分成7步：</p><ol><li>将输入单词转化成嵌入向量；</li><li>根据嵌入向量得到 <img src="https://www.zhihu.com/equation?tex=q" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=v" alt="[公式]"> 三个向量；</li><li>为每个向量计算一个score： <img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bscore%7D+=+q+%5Ccdot+k" alt="[公式]"> ；</li><li>为了梯度的稳定，Transformer使用了score归一化，即除以 <img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bd_k%7D" alt="[公式]"> ；</li><li>对score施以softmax激活函数；</li><li>softmax点乘Value值 <img src="https://www.zhihu.com/equation?tex=v" alt="[公式]"> ，得到加权的每个输入向量的评分 <img src="https://www.zhihu.com/equation?tex=v" alt="[公式]"> ；</li><li>相加之后得到最终的输出结果 <img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> ： <img src="https://www.zhihu.com/equation?tex=z=%5Csum+v" alt="[公式]"> 。</li></ol><p>实际计算过程中是采用基于矩阵的计算方式，那么论文中的 <img src="https://www.zhihu.com/equation?tex=Q" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=V" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=K+" alt="[公式]"> 的计算方式如图：</p><p><img src="https://pic3.zhimg.com/80/v2-bcd0d108a5b52a991d5d5b5b74d365c6_720w.jpg" alt="img"></p><p>总结为如图所示的矩阵形式：</p><p><img src="https://pic1.zhimg.com/80/v2-be73ba876922cf52df8a00a55f770284_720w.jpg" alt="img"></p><p>在self-attention需要强调的最后一点是其采用了<a href="https://zhuanlan.zhihu.com/p/42706477">残差网络</a> 中的short-cut结构，目的当然是解决深度学习中的退化问题，得到的最终结果如图13。</p><ul><li><strong>Multi-head Attention</strong></li></ul><p>Multi-Head Attention相当于 <img src="https://www.zhihu.com/equation?tex=h" alt="[公式]"> 个不同的self-attention的集成（ensemble），在这里我们以 <img src="https://www.zhihu.com/equation?tex=h=8" alt="[公式]"> 举例说明。Multi-Head Attention的输出分成3步：</p><ol><li>将数据 <img src="https://www.zhihu.com/equation?tex=X+" alt="[公式]"> 分别输入到图13所示的8个self-attention中，得到8个加权后的特征矩阵 <img src="https://www.zhihu.com/equation?tex=Z_i,+i%5Cin%5C%7B1,2,...,8%5C%7D" alt="[公式]"> 。</li><li>将8个 <img src="https://www.zhihu.com/equation?tex=Z_i" alt="[公式]"> 按列拼成一个大的特征矩阵；</li><li>特征矩阵经过一层全连接后得到输出 <img src="https://www.zhihu.com/equation?tex=Z" alt="[公式]"> 。</li></ol><p>整个过程如图14所示：</p><p><img src="https://pic3.zhimg.com/80/v2-c2a91ac08b34e73c7f4b415ce823840e_720w.jpg" alt="img"></p><ul><li><strong>Encoder-Decoder Attention</strong></li></ul><p>在解码器中，Transformer block比编码器中多了个encoder-cecoder attention。在encoder-decoder attention中， <img src="https://www.zhihu.com/equation?tex=Q" alt="[公式]"> <strong>来自于解码器的上一个输出， <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=V" alt="[公式]"> 则来自于与编码器的输出。</strong>其计算方式完全和Attention的计算过程相同。</p><p>在机器翻译中，解码过程是一个顺序操作的过程，也就是当解码第 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 个特征向量时，我们只能看到第 <img src="https://www.zhihu.com/equation?tex=k-1" alt="[公式]"> 及其之前的解码结果，论文中把这种情况下的multi-head attention叫做masked multi-head attention。</p><ul><li><strong>位置编码</strong></li></ul><p>论文中在编码词向量时引入了位置编码（Position Embedding）的特征。具体地说，位置编码会在词向量中加入了单词的位置信息，这样Transformer就能区分不同位置的单词了。</p><p>编码位置常见的模式有：a. 根据数据学习；b. 自己设计编码规则。</p><p>论文给出的编码公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=PE(pos,+2i)+=+sin(%5Cfrac%7Bpos%7D%7B10000%5E%7B%5Cfrac%7B2i%7D%7Bd_%7Bmodel%7D%7D%7D%7D)+%5Ctag3" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=PE(pos,+2i+1)+=+cos(%5Cfrac%7Bpos%7D%7B10000%5E%7B%5Cfrac%7B2i%7D%7Bd_%7Bmodel%7D%7D%7D%7D)+%5Ctag4" alt="[公式]"></p><p>作者这么设计的原因是考虑到在NLP任务中，除了单词的绝对位置，单词的相对位置也非常重要。</p><ul><li><strong>优点</strong></li></ul><p>（1）虽然Transformer最终也没有逃脱传统学习的套路，Transformer也只是一个全连接（或者是一维卷积）加Attention的结合体。但是<strong>其设计已经足够有创新，因为其抛弃了在NLP中最根本的RNN或者CNN并且取得了非常不错的效果</strong>，算法的设计非常精彩。</p><p>（2）Transformer的设计最大的<strong>带来性能提升的关键是将任意两个单词的距离是1</strong>，这对解决NLP中棘手的长期依赖问题是非常有效的。</p><p>（3）Transformer不仅仅可以应用在NLP的机器翻译领域，甚至可以<strong>不局限于NLP领域，是非常有科研潜力的一个方向</strong>。</p><p>（4）<strong>算法的并行性非常好</strong>，符合目前的硬件（主要指GPU）环境。</p><ul><li><strong>缺点</strong></li></ul><p>（1）粗暴的抛弃RNN和CNN虽然非常炫技，但是它也使<strong>模型丧失了捕捉局部特征的能力</strong>，RNN + CNN + Transformer的结合可能会带来更好的效果。（2）Transformer失去的位置信息其实在NLP中非常重要，而<strong>论文中在特征向量中加入Position Embedding也只是一个权宜之计，并没有改变Transformer结构上的固有缺陷</strong>。</p><h2 id="8-2-Informer"><a href="#8-2-Informer" class="headerlink" title="8.2 Informer"></a>8.2 Informer</h2><ul><li><p>详细解读见博客：<a href="https://mp.weixin.qq.com/s/RRv-DVm6SguQ5GC5oruf8Q">AAAI21最佳论文Informer：效果远超Transformer的长序列预测神器！</a></p></li><li><p><strong>基本思想：基于Transformer模型的三处改进</strong></p></li></ul><p>（1）<strong>ProbSparse Self-Attention</strong></p><p>在典型的Self-Attention机制中，少数点积对主要注意有贡献，其他点积对可以忽略，所以引入Query Sparsity评估。</p><p>并且使用最大值代替复杂的对数计算，既解决了计算精度问题，也降低了计算复杂度。</p><p><img src="http://img.fdchen.host/Informer-ProSparseSelfAttention%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="image-20210731210037446"></p><p>（2）<strong>Self-attention Distilling</strong></p><p>作为ProbSparse Self-attention的自然结果，encoder的特征映射会带来V值的冗余组合，利用distilling对具有支配特征的优势特征进行特权化，使它们的输出维度对齐。</p><p>（3）<strong>Generating long sequential outputs</strong></p><p>生成式长序列输出，从长序列中采样一个小部分token，作为预测序列之前的初始token，然后将初始token+初始化为0的预测序列拼接，作为Decoder的输入序列，然后通过前向过程预测所有输出，避免耗时的动态decoding。</p><h1 id="9-ELMO"><a href="#9-ELMO" class="headerlink" title="9 ELMO"></a>9 ELMO</h1><ul><li><p>全称：<a href="https://www.aclweb.org/anthology/N18-1202.pdf">Embedding from Language Model</a></p></li><li><p><strong>基本思想</strong></p></li></ul><p>以下内容来自博客：<a href="https://blog.csdn.net/qq_22795223/article/details/105924156">ELMo详解</a></p><p>之前2013年的word2vec及2014年的GloVe的工作中，每个词对应一个vector，对于多义词无能为力。ELMo的工作对于此，提出了一个较好的解决方案。不同于以往的一个词对应一个向量，是固定的。<strong>在ELMo世界里，预训练好的模型不再只是向量对应关系，而是一个训练好的模型。使用时，将一句话或一段话输入模型，模型会根据上下文来推断每个词对应的词向量。</strong>这样做之后明显的好处之一就是对于多义词，可以结合前后语境对多义词进行理解。比如appele，可以根据前后文语境理解为公司或水果。</p><p><strong>ELMO 本身是个根据当前上下文对 Word Embedding 动态调整的思路。</strong></p><ul><li><strong>算法模型</strong></li></ul><p>ELMo用到上文提到的双向的language model，给定N个tokens (t1, t2,…,tN), language model通过<strong>给定前面的k-1个位置的token序列计算第k个token的出现的概率:</strong></p><p><img src="https://www.zhihu.com/equation?tex=p(t_1,+t_2,+...,+t_N)+=+%5Cprod_%7Bk=1%7D%5EN+p(t_k%7Ct_1,+t_2,+...,+t_%7Bk-1%7D)" alt="[公式]"></p><p><strong>后向的计算方法与前向相似</strong>:</p><p><img src="https://www.zhihu.com/equation?tex=p%5Cleft(t_%7B1%7D,+t_%7B2%7D,+%5Cldots,+t_%7BN%7D%5Cright)=%5Cprod_%7Bk=1%7D%5E%7BN%7D+p%5Cleft(t_%7Bk%7D+%7C+t_%7Bk+1%7D,+t_%7Bk+2%7D,+%5Cldots,+t_%7BN%7D%5Cright)" alt="[公式]"></p><p><strong>biLM训练过程中的目标就是最大化</strong>:</p><p><img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bk=1%7D%5E%7BN%7D%5Cleft(%5Clog+p%5Cleft(t_%7Bk%7D+%7C+t_%7B1%7D,+%5Cldots,+t_%7Bk-1%7D+;+%5CTheta_%7Bx%7D,+%5Cvec%7B%5CTheta%7D_%7BL+S+T+M%7D,+%5CTheta_%7Bs%7D%5Cright)+%5Clog+p%5Cleft(t_%7Bk%7D+%7C+t_%7Bk+1%7D,+%5Cldots,+t_%7BN%7D+;+%5CTheta_%7Bx%7D,+%5Cstackrel%7B%5Cleftarrow%7D%7B%5CTheta%7D_%7BL+S+T+M%7D,+%5CTheta_%7Bs%7D%5Cright)%5Cright)" alt="[公式]"></p><p><strong>ELMo对于每个token <img src="https://www.zhihu.com/equation?tex=t_k" alt="[公式]"> , 通过一个L层的biLM计算出2L+1个表示:</strong></p><p><img src="https://www.zhihu.com/equation?tex=R_k+=+%5C%7Bx_k%5E%7BLM%7D,+%5Coverrightarrow%7Bh%7D_%7Bk,j%7D%5E%7BLM%7D,+%5Coverleftarrow%7Bh%7D_%7Bk,+j%7D%5E%7BLM%7D+%5Cvert+j=1,+...,+L%5C%7D+=+%5C%7Bh_%7Bk,j%7D%5E%7BLM%7D+%5Cvert+j=0,...,+L%5C%7D" alt="[公式]"></p><p>其中 <img src="https://www.zhihu.com/equation?tex=x_k%5E%7BLM%7D" alt="[公式]"> 是对token进行直接编码的结果(这里是<strong>字符通过CNN编码</strong>)， <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bh%7D_%7Bk,+0%7D%5E%7BL+M%7D" alt="[公式]"> 代表 <img src="https://www.zhihu.com/equation?tex=x_k%5E%7BLM%7D" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=h_%7Bk,j%7D%5E%7BLM%7D+=+%5B%5Coverrightarrow%7Bh%7D_%7Bk,j%7D%5E%7BLM%7D;+%5Coverleftarrow%7Bh%7D_%7Bk,+j%7D%5E%7BLM%7D%5D" alt="[公式]"> 是每个biLSTM层输出的结果。在实验中还发现不同层的biLM的输出的token表示对于不同的任务效果不同.最上面一层的输出 <img src="https://www.zhihu.com/equation?tex=%5Coverrightarrow%7B%5Cmathbf%7Bh%7D%7D_%7Bk,+L%7D%5E%7BL+M%7D" alt="[公式]"> 是用softmax来预测下面一个单词 <img src="https://www.zhihu.com/equation?tex=t_%7Bk+1%7D" alt="[公式]">。</p><p>应用中将ELMo中所有层的输出R压缩为单个向量， <img src="https://www.zhihu.com/equation?tex=ELMo_k+=+E(R_k;%5CTheta+_%5Cepsilon)" alt="[公式]">，最简单的压缩方法是取最上层的结果做为token的表示: <img src="https://www.zhihu.com/equation?tex=E(R_k)+=+h_%7Bk,L%7D%5E%7BLM%7D" alt="[公式]"> ，更通用的做法是<strong>通过一些参数来联合所有层的信息得到最终的ELMo向量:</strong></p><p><strong><img src="https://www.zhihu.com/equation?tex=E+L+M+o_%7Bk%7D%5E%7Bt+a+s+k%7D=E%5Cleft(R_%7Bk%7D+;+%5CTheta%5E%7Bt+a+s+k%7D%5Cright)=%5Cgamma%5E%7Bt+a+s+k%7D+%5Csum_%7Bj=0%7D%5E%7BL%7D+s_%7Bj%7D%5E%7Bt+a+s+k%7D+h_%7Bk,+j%7D%5E%7BL+M%7D" alt="[公式]"></strong></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bs%7D%5E%7B%5Coperatorname%7Btas%7D+k%7D" alt="[公式]"> 是一个softmax出来的结果, γ是一个任务相关的scale参数，我试了平均每个层的信息和学出来 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7Bs%7D%5E%7B%5Coperatorname+%7Btask%7D%7D" alt="[公式]"> 发现学习出来的效果会好很多。 文中提到γ在不同任务中取不同的值效果会有较大的差异， 需要注意， 在SQuAD中设置为0.01取得的效果要好于设置为1时。</p><p>文章中提到的Pre-trained的language model是用了两层的biLM， <strong>对token进行上下文无关的编码是通过CNN对字符级进行编码，</strong> 然后将三层的输出scale到1024维， 最后对每个token输出3个1024维的向量表示。 这里之所以将3层的输出都作为token的embedding表示是因为实验已经证实不同层的LM输出的信息对于不同的任务作用是不同的， 也就是所不同层的输出捕捉到的token的信息是不相同的。</p><ul><li><strong>具体实现</strong></li></ul><p>以下内容来自博客：<a href="https://zhuanlan.zhihu.com/p/63115885">NAACL2018:高级词向量(ELMo)详解(超详细) 经典</a></p><p>ELMO 采用了典型的两阶段过程，<strong>第一个阶段是利用语言模型进行预训练；第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的 Word Embedding 作为新特征补充到下游任务中。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-945ea2c964e548cb9a9128864b5f6d49_720w.jpg" alt="img"></p><p>上图展示的是其预训练过程，它的网络结构采用了双层双向 LSTM，目前语言模型训练的任务目标是根<strong>据单词 <img src="https://www.zhihu.com/equation?tex=W_%7Bi%7D" alt="[公式]"> 的上下文去正确预测单词 <img src="https://www.zhihu.com/equation?tex=W_%7Bi%7D" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=W_%7Bi%7D" alt="[公式]"> 之前的单词序列 Context-before 称为上文，之后的单词序列 Context-after 称为下文</strong>。图中左端的前向双层LSTM代表正方向编码器，输入的是从左到右顺序的除了预测单词外 <img src="https://www.zhihu.com/equation?tex=W_%7Bi%7D" alt="[公式]"> 的上文 Context-before；右端的逆向双层 LSTM 代表反方向编码器，输入的是从右到左的逆序的句子下文 Context-after；<strong>每个编码器的深度都是两层 LSTM 叠加。这个网络结构其实在 NLP 中是很常用的</strong>。</p><p>使用这个网络结构利用大量语料做语言模型任务就能预先训练好这个网络，如果训练好这个网络后，输入一个新句子Snew，<strong>句子中每个单词都能得到对应的三个Embedding</strong>:<strong>最底层是单词的 Word Embedding，往上走是第一层双向LSTM中对应单词位置的 Embedding，这层编码单词的句法信息更多一些；再往上走是第二层LSTM中对应单词位置的 Embedding，这层编码单词的语义信息更多一些</strong>。也就是说，ELMO 的预训练过程不仅仅学会单词的 Word Embedding，还学会了一个双层双向的LSTM网络结构，而这两者后面都有用。</p><p><img src="https://pic2.zhimg.com/80/v2-e53a17ada1d510958215cc860c33efb9_720w.jpg" alt="img"></p><p>上面介绍的是 ELMO 的第一阶段：预训练阶段。那么预训练好网络结构后，如何给下游任务使用呢？上图展示了下游任务的使用过程，比如我们的下游任务仍然是 QA 问题，此时<strong>对于问句 X，我们可以先将句子 X 作为预训练好的 ELMO 网络的输入，这样句子 X 中每个单词在 ELMO 网络中都能获得对应的三个 Embedding，之后给予这三个 Embedding 中的每一个 Embedding 一个权重a，这个权重可以学习得来，根据各自权重累加求和，将三个 Embedding 整合成一个。</strong></p><p><strong>然后将整合后的这个 Embedding 作为 X 句在自己任务的那个网络结构中对应单词的输入，以此作为补充的新特征给下游任务使用。</strong>对于上图所示下游任务 QA 中的回答句子 Y 来说也是如此处理。</p><p>因为 <strong>ELMO给下游提供的是每个单词的特征形式，所以这一类预训练的方法被称为“Feature-based Pre-Training”</strong>。</p><ul><li><strong>缺点（事后看）</strong></li></ul><ol><li>LSTM抽取特征能力远弱于Transformer</li><li>拼接方式双向融合特征，融合能力偏弱</li></ol><ul><li><strong>ELMo到XLnet模型</strong></li></ul><p><img src="http://img.fdchen.host/ELMo%E5%88%B0XLnet.png" alt="ElMo到XLnet"></p><h1 id="10-Bert"><a href="#10-Bert" class="headerlink" title="10 Bert"></a>10 Bert</h1><ul><li>全称：Bidirectional Encoder Representations from Transformers    </li><li>论文链接：<a href="https://arxiv.org/pdf/1810.04805.pdf">BERT: Pre-training of Deep Bidirectional Transformers for </a><a href="https://arxiv.org/pdf/1810.04805.pdf">Language Understanding</a></li><li>相关文档：<a href="https://d94sx79yh3.feishu.cn/docs/doccnDVZtP4PCYvvR4jRWxZDDgc">Bert</a></li></ul><p>以下内容来自博客：<a href="https://zhuanlan.zhihu.com/p/46652512">【NLP】Google BERT模型原理详解</a>、<a href="https://www.cnblogs.com/zingp/p/13849679.html">BERT模型详解</a></p><ul><li><strong>基本思想</strong></li></ul><p>模型的主要创新点都在pre-train方法上，即用了<strong>Masked LM和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation。</strong></p><p>由于模型的构成元素Transformer已经解析过，就不多说了，BERT模型的结构如下图最左：</p><p><img src="https://pic1.zhimg.com/80/v2-d942b566bde7c44704b7d03a1b596c0c_720w.jpg" alt="img"></p><p><strong>对比OpenAI GPT(Generative pre-trained transformer)，BERT是双向的Transformer block连接；就像单向RNN和双向RNN的区别，直觉上来讲效果会好一些。</strong></p><p><strong>对比ELMo，虽然都是“双向”，但目标函数其实是不同的。</strong>ELMo是分别以<img src="https://www.zhihu.com/equation?tex=P(w_i%7C+w_1,+...w_%7Bi-1%7D)" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=P(w_i%7Cw_%7Bi+1%7D,+...w_n)" alt="[公式]"> 作为目标函数，独立训练处两个representation然后拼接，而BERT则是以 <img src="https://www.zhihu.com/equation?tex=P(w_i%7Cw_1,++...,w_%7Bi-1%7D,+w_%7Bi+1%7D,...,w_n)" alt="[公式]"> 作为目标函数训练LM。</p><ul><li><strong>Embedding</strong></li></ul><p><img src="https://pic2.zhimg.com/80/v2-11505b394299037e999d12997e9d1789_720w.jpg" alt="img"></p><p>其中：</p><ol><li><strong>Token Embeddings</strong>是词向量，第一个单词是CLS标志，可以用于之后的分类任务</li><li><strong>Segment Embeddings</strong>用来区别两种句子，因为预训练不光做LM还要做以两个句子为输入的分类任务</li><li><strong>Position Embeddings</strong>和之前文章中的Transformer不一样，不是三角函数而是学习出来的</li></ol><ul><li><strong>Pre-training Task 1: Masked LM</strong></li></ul><p>在将单词序列输入给 BERT 之前，每个序列中有 15％ 的单词被 [MASK] token 替换。然后<strong>模型尝试基于序列中其他未被 mask 的单词的上下文来预测被mask的原单词。最终的损失函数只计算被mask掉那个token。</strong></p><p>如果一直用标记[MASK]代替（在实际预测时是碰不到这个标记的）会影响模型，具体的MASK是有trick的：</p><ol><li>随机mask的时候10%的单词会被替代成其他单词，10%的单词不替换，剩下80%才被替换为[MASK]。作者没有说明什么原因，应该是基于实验效果？</li><li><strong>要注意的是Masked LM预训练阶段模型是不知道真正被mask的是哪个词，所以模型每个词都要关注。</strong></li><li>训练技巧：序列长度太大（512）会影响训练速度，所以90%的steps都用seq_len&#x3D;128训练，余下的10%步数训练512长度的输入。</li><li>具体实现注意:<ul><li>i) 在encoder的输出上添加一个分类层。</li><li>ii) 用嵌入矩阵乘以输出向量，将其转换为词汇的维度。</li><li>iii) 用softmax计算词汇表中每个单词的概率。</li></ul></li><li><strong>BERT的损失函数只考虑了mask的预测值，忽略了没有掩蔽的字的预测。这样的话，模型要比单向模型收敛得慢，不过结果的情境意识增加了。</strong></li></ol><ul><li><strong>Pre-training Task 2:Next Sentence Prediction</strong></li></ul><p>LM存在的问题是，缺少句子之间的关系，这对许多NLP任务很重要。<strong>为预训练句子关系模型，bert使用一个非常简单的二分类任务：将两个句子A和B链接起来，预测原始文本中句子B是否排在句子A之后。</strong></p><ol><li><p>具体训练的时候，50％的输入对在原始文档中是前后关系，另外50％中是从语料库中随机组成的，并且是与第一句断开的。</p></li><li><p>为了帮助模型区分开训练中的两个句子，输入在进入模型之前要按以下方式进行处理：在第一个句子的开头插入 [CLS] 标记，在每个句子的末尾插入 [SEP] 标记。</p></li><li><p>将表示句子 A 或句子 B 的一个句子 embedding 添加到每个 token 上，即前文说的Segment Embeddings。</p></li><li><p>给每个token添加一个位置embedding，来表示它在序列中的位置。</p></li><li><p>为了预测第二个句子是否是第一个句子的后续句子，用下面几个步骤来预测：</p><ul><li>整个输入序列输入给 Transformer 模型用一个简单的分类层将[CLS]标记的输出变换为 2×1 形状的向量。</li><li>用 softmax 计算 IsNextSequence 的概率。</li></ul></li></ol><p><strong>在训练BERT模型时，Masked LM和 Next Sentence Prediction 是一起训练的，目标就是要最小化两种策略的组合损失函数。</strong></p><p><strong>注意：作者特意说了语料的选取很关键，要选用document-level的而不是sentence-level的，这样可以具备抽象连续长序列特征的能力。</strong></p><ul><li><strong>精调（Fine-tunning）</strong></li></ul><p><strong>对于不同的下游任务，我们仅需要对BERT不同位置的输出进行处理即可，或者直接将BERT不同位置的输出直接输入到下游模型当中。</strong>具体的如下：</p><ol><li>对于情感分析等单句分类任务，可以直接输入单个句子（不需要[SEP]分隔双句），将[CLS]的输出直接输入到分类器进行分类</li><li>对于句子对任务（句子关系判断任务），需要用[SEP]分隔两个句子输入到模型中，然后同样仅须将[CLS]的输出送到分类器进行分类</li><li>对于问答任务，将问题与答案拼接输入到BERT模型中，然后将答案位置的输出向量进行二分类并在句子方向上进行softmax（只需预测开始和结束位置即可）</li><li>对于命名实体识别任务，对每个位置的输出进行分类即可，如果将每个位置的输出作为特征输入到CRF将取得更好的效果。</li><li>对于常规分类任务中，需要在 Transformer 的输出之上加一个分类层。</li></ol><ul><li><strong>优点</strong>：<strong>效果好，</strong>横扫了11项NLP任务。bert之后基本全面拥抱transformer。微调下游任务的时候，即使数据集非常小（比如小于5000个标注样本），模型性能也有不错的提升。</li><li><strong>缺点</strong>：</li></ul><p>作者在文中主要提到的就是MLM预训练时的mask问题：</p><ol><li><strong>[MASK]标记在实际预测中不会出现，训练时用过多[MASK]影响模型表现</strong></li><li><strong>每个batch只有15%的token被预测，所以BERT收敛得比left-to-right模型（单向模型）要慢（它们会预测每个token）</strong></li></ol><ul><li><strong>特殊标志</strong></li></ul><p>BERT 的输入可以包含一个句子对 (句子 A 和句子 B)，也可以是单个句子。此外还增加了一些有特殊作用的标志位：</p><ol><li><strong>[CLS] 标志放在第一个句子的首位</strong>，经过 BERT 得到的的表征向量 C 可以用于后续的分类任务。</li><li><strong>[SEP] 标志用于分开两个输入句子</strong>，例如输入句子 A 和 B，要在句子 A，B 后面增加 [SEP] 标志。</li><li><strong>[UNK]标志指的是未知字符</strong></li><li><strong>[MASK] 标志用于遮盖句子中的一些单词，将单词用 [MASK] 遮盖之后，再利用 BERT 输出的 [MASK] 向量预测单词是什么</strong>。</li></ol><h1 id="11-XLNet"><a href="#11-XLNet" class="headerlink" title="11 XLNet"></a>11 XLNet</h1><ul><li><p>全称：XLNet: Generalized Autoregressive Pretraining for Language Understanding</p></li><li><p>论文链接：<a href="https://arxiv.org/pdf/1906.08237.pdf">https://arxiv.org/pdf/1906.08237.pdf</a></p></li><li><p>相关文档：<a href="https://d94sx79yh3.feishu.cn/docs/doccnvdvaZMeTtdKVn0gMAOkVlb">XLNet</a></p></li></ul><h1 id="12-GPT（1-2-3）"><a href="#12-GPT（1-2-3）" class="headerlink" title="12 GPT（1,2, 3）"></a>12 GPT（1,2, 3）</h1><ul><li><p>全称：Generative Pre-training Transformer  </p></li><li><p>论文链接：</p><ul><li>GPT-1  <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">Improving Language Understanding by Generative Pre-Training</a></li><li>GPT-2  <a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language-models.pdf">Language Models are Unsupervised Multitask Learners</a></li><li>GPT-3   <a href="https://arxiv.org/pdf/2005.14165.pdf">Language Models are Few-Shot Learners </a></li></ul></li><li><p>相关文档：</p><ul><li>GPT-1+GPT-2  <a href="https://d94sx79yh3.feishu.cn/docs/doccncdn7CtRQE9bFOoIqVmj14b">GPT1+GPT2</a>  </li><li>GPT-3  <a href="https://d94sx79yh3.feishu.cn/docs/doccnt7GykiRsOnslBPVi3bdq5c">GPT-3</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典模型 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2021/ji-suan-ji-ji-chu-cao-zuo-xi-tong/"/>
      <url>/2021/ji-suan-ji-ji-chu-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><ul><li><p>控制程序</p></li><li><p>资源分配器</p></li><li><p>虚拟机</p></li><li><p>一个可使用的计算系统</p></li></ul><h2 id="1-2-操作系统的组成"><a href="#1-2-操作系统的组成" class="headerlink" title="1.2 操作系统的组成"></a>1.2 操作系统的组成</h2><ul><li>CPU 管理器</li><li>内存管理器</li><li>文件系统</li><li>设备管理器</li></ul><h2 id="1-3-大型机和小型机的操作系统"><a href="#1-3-大型机和小型机的操作系统" class="headerlink" title="1.3 大型机和小型机的操作系统"></a>1.3 大型机和小型机的操作系统</h2><p>大型机和小型机有专用的操作系统</p><h3 id="1-3-1-大型机的发展历程"><a href="#1-3-1-大型机的发展历程" class="headerlink" title="1.3.1 大型机的发展历程"></a>1.3.1 大型机的发展历程</h3><p>批处理系统  &gt;  多道程序设计系统 &gt; 分时系统</p><h3 id="1-3-2-批处理系统"><a href="#1-3-2-批处理系统" class="headerlink" title="1.3.2  批处理系统"></a>1.3.2  批处理系统</h3><ul><li>同一时间能且只能运行一个应用</li><li>批处理相似的任务</li><li>第一个原始的操作系统</li></ul><h3 id="1-3-4-多道程序设计系统"><a href="#1-3-4-多道程序设计系统" class="headerlink" title="1.3.4 多道程序设计系统"></a>1.3.4 多道程序设计系统</h3><p>同时把多个程序放入内存并允许它们交替执行和共享系统中的各类资源。即当一道程序因某种原因（如I&#x2F;O请求）而暂停执行时，CPU立即转去执行另一道程序。</p><p><img src="https://img.fdchen.host/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F.png" alt="多道程序设计系统"></p><h3 id="1-3-5-分时系统"><a href="#1-3-5-分时系统" class="headerlink" title="1.3.5 分时系统"></a>1.3.5 分时系统</h3><ul><li>CPU在多个保存在内存中的任务之间切换（CPU仅分配给保存在内存中的任务）</li><li>为了需要快速响应的交互式计算而设计</li><li>造成”并发”假象，实质：快速切换</li></ul><h2 id="1-4-桌面计算机的操作系统"><a href="#1-4-桌面计算机的操作系统" class="headerlink" title="1.4 桌面计算机的操作系统"></a>1.4 桌面计算机的操作系统</h2><ul><li><p>Apple: Macintosh</p></li><li><p>Microsoft: MS-DOS, Windows 9x&#x2F;NT</p></li><li><p>IBM: OS&#x2F;2</p></li><li><p>Unix：</p><ul><li>BSD:(Berkeley Software Distribution) Unix, 包括FreeBSD，OpenBSD，NetBSD</li><li>Sun microsystem的Solaris</li><li>Apple：macOS</li></ul></li><li><p>Linux</p></li></ul><h2 id="1-5-嵌入式系统的操作系统"><a href="#1-5-嵌入式系统的操作系统" class="headerlink" title="1.5 嵌入式系统的操作系统"></a>1.5 嵌入式系统的操作系统</h2><ul><li>通常用于控制设备的专用程序中，比如说工厂控制系统（资源受到限制）</li><li>一些控制设备有时间需求，比如说：即时性——硬即时、软即时</li></ul><h1 id="2-计算机系统结构"><a href="#2-计算机系统结构" class="headerlink" title="2 计算机系统结构"></a>2 计算机系统结构</h1><h2 id="2-1-Bootstrap引导"><a href="#2-1-Bootstrap引导" class="headerlink" title="2.1 Bootstrap引导"></a>2.1 Bootstrap引导</h2><p>过程：</p><ol><li>把操作系统的内核从持久存储中加载出来</li><li>然后把控制在非常基本的环境下转移到操作系统的入口</li></ol><p>Bootstrap引导，即引导操作系统的过程，进行引导的程序叫做引导器，每个操作系统都需要有引导器boot-loader。</p><h2 id="2-2-中断"><a href="#2-2-中断" class="headerlink" title="2.2 中断"></a>2.2 中断</h2><p> 现代计算器和操作系统都是中断驱动，外围设备使用中断向CPU发送信号提示某些事要发生。</p><h3 id="2-2-1-响应中断过程"><a href="#2-2-1-响应中断过程" class="headerlink" title="2.2.1 响应中断过程"></a>2.2.1 响应中断过程</h3><p>当CPU发生中断时，必须响应中断，过程如下</p><ol><li>硬件：存储相关寄存器信息并跳转到中断服务例程interrupt service routine（ISR）</li><li>ISR中的汇编语言程序：存储剩下的必要的寄存器信息并建立一个方便的环境</li><li>ISR中的C语言程序：实际响应&#x2F;服务中断，通常是读取并缓存从外围设备输入的数据</li><li>ISR中的C语言程序：返回到ISR中的汇编语言程序</li><li>ISR中的汇编语言程序：软件负责恢复寄存器数据并返回到发生中断的位置</li></ol><h3 id="2-2-2-中断向量"><a href="#2-2-2-中断向量" class="headerlink" title="2.2.2 中断向量"></a>2.2.2 中断向量</h3><ul><li>CPU用一个独特的号码标记每一个外部设备，称为中断请求号码interrupt request number(IRQ)。</li><li>所有ISR都被收集到一个表格之中，称为中断向量表<strong>interrupt vector table(IVT)</strong></li><li>当发生中断的时候，CPU使用IRQ去IVT中索引中断向量获得ISR的地址，并跳转到对应的ISR</li></ul><h3 id="2-2-3-中断处理流程"><a href="#2-2-3-中断处理流程" class="headerlink" title="2.2.3 中断处理流程"></a>2.2.3 中断处理流程</h3><p><img src="https://img.fdchen.host/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1.png" alt="中断处理流程-1"></p><p><img src="https://img.fdchen.host/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-2.png" alt="中断处理流程-2"></p><h3 id="2-2-4-中断对比异常"><a href="#2-2-4-中断对比异常" class="headerlink" title="2.2.4 中断对比异常"></a>2.2.4 中断对比异常</h3><p><strong>中断：</strong></p><ul><li>外围设备触发</li><li>异步</li></ul><p> <strong>异常：</strong></p><ul><li>异常由CPU在执行程序过程中检测出来的，例如：除0错误和无效内存访问异常</li><li>除此之外，异常与中断一样完全一样，而且异常也有异常号码</li><li>异常又被称为software-generated interrupt软中断或者synchronous interrupt同步中断</li></ul><h2 id="2-3-CPU访问外围设备"><a href="#2-3-CPU访问外围设备" class="headerlink" title="2.3 CPU访问外围设备"></a>2.3 CPU访问外围设备</h2><p>CPU通过设备控制器来访问外围设备，设备控制器包含命令寄存器和数据寄存器。具有以下两种方式访问外围设备。</p><h3 id="2-3-1-I-x2F-O端口-I-x2F-O-port"><a href="#2-3-1-I-x2F-O端口-I-x2F-O-port" class="headerlink" title="2.3.1 I&#x2F;O端口 I&#x2F;O port"></a>2.3.1 I&#x2F;O端口 I&#x2F;O port</h3><ol><li>所有的寄存器包括设备控制器都有一个特别的地址进行标识，称为端口port</li><li>I&#x2F;O指令用来允许数据在寄存器和内存之间传递</li><li>I&#x2F;O端口是独立的地址空间，不消耗内存空间</li></ol><h3 id="2-3-2-内存映射I-x2F-O-Mempry-mapped-I-x2F-O"><a href="#2-3-2-内存映射I-x2F-O-Mempry-mapped-I-x2F-O" class="headerlink" title="2.3.2 内存映射I&#x2F;O Mempry-mapped I&#x2F;O"></a>2.3.2 内存映射I&#x2F;O Mempry-mapped I&#x2F;O</h3><ol><li>用独特的内存地址来标识每一个寄存器，而不是用端口地址</li><li>内存映射I&#x2F;O使用相同的总线来访问内存地址和I&#x2F; O设备的地址</li><li>为了容纳I&#x2F;O设备，CPU必须为I&#x2F;O设备保留可用地址空间</li></ol><p><img src="https://img.fdchen.host/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.png" alt="内存映射"></p><p><strong>优点：</strong></p><ul><li>每一条指令都可以查询内存，也可以查询设备控制器寄存器</li><li>不需要用特别的保护机制来防止用户进程执行I&#x2F;O</li></ul><p><strong>缺点：</strong></p><ul><li>现在大部分计算机都有一些缓存内存字的形式，但是缓存设备控制器寄存器将会造成灾难性后果，比如缓存即时指令导致延时</li><li>解决方法：CPU可以执行特定内存是否缓存</li></ul><h3 id="2-3-3-现代计算机系统一般使用两种方法访问外围设备"><a href="#2-3-3-现代计算机系统一般使用两种方法访问外围设备" class="headerlink" title="2.3.3 现代计算机系统一般使用两种方法访问外围设备"></a>2.3.3 现代计算机系统一般使用两种方法访问外围设备</h3><ul><li>使用内存映射I&#x2F;O访问数据缓存</li><li>使用I&#x2F;O端口访问指令寄存器</li></ul><h2 id="2-4-硬件保护方式"><a href="#2-4-硬件保护方式" class="headerlink" title="2.4 硬件保护方式"></a>2.4 硬件保护方式</h2><h3 id="2-4-1-双模式操作"><a href="#2-4-1-双模式操作" class="headerlink" title="2.4.1 双模式操作"></a>2.4.1 双模式操作</h3><ul><li><p>至少需要两种独立的操作模式</p><ul><li>用户态</li><li>内核态（管理者supervisor、系统、特权或者内核模式）</li></ul></li><li><p>模式位：添加在计算机硬件中用来标识当前模式，内核态0，用户态1</p></li></ul><p><img src="https://img.fdchen.host/INTEL-IA-32%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F%E4%BD%8D.png" alt="INTEL-IA-32系统模式位"></p><ul><li><p>初始都是设置为内核态，当操作系统被加载并启动用户程序后进入用户态</p></li><li><p>当中断或异常发生时，硬件进入内核态，此时，操作系统获得计算机控制权，属于内核态。当系统把控制权交给用户程序时再次进入用户态</p></li><li><p><strong>保护环</strong>： INTEL IA-32系统中，0环为内核态，3环为用户态，仅使用2个环</p></li></ul><p><img src="http://img.fdchen.host/%E4%BF%9D%E6%8A%A4%E7%8E%AF.png" alt="保护环"></p><h3 id="2-4-2-特权指令"><a href="#2-4-2-特权指令" class="headerlink" title="2.4.2 特权指令"></a>2.4.2 特权指令</h3><ul><li><p>所有的I&#x2F;O指令都是特权指令：</p><ul><li>硬件允许特权指令仅仅在内核态中执行</li><li>当在用户态下想要执行特权指令时，硬件不会执行，而是把它当做非法指令并产生异常</li></ul></li><li><p>必须确保所有的用户程序在内核态下不会获得计算机的控制权</p></li></ul><h3 id="2-4-3-内存保护"><a href="#2-4-3-内存保护" class="headerlink" title="2.4.3 内存保护"></a>2.4.3 内存保护</h3><ul><li>添加两个寄存器来决定寻址程序合法访问的范围<ul><li>基址寄存器Base register：存储最小的合法物理内存地址</li><li>限制寄存器Limit register：存储范围的大小</li></ul></li></ul><p><img src="https://img.fdchen.host/%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt="内存保护机制"></p><h3 id="2-4-4-CPU保护"><a href="#2-4-4-CPU保护" class="headerlink" title="2.4.4 CPU保护"></a>2.4.4 CPU保护</h3><p>操作系统仅仅在可以运行时起作用，如果故障程序进入无限循环并且不返还控制权给操作系统，那么操作系统将失去对CPU的控制权</p><ul><li><strong>计时器</strong><ul><li><strong>机制：</strong>间隔一定时间中断CPU来确保操作系统维持对CPU的控制权。理由是当中断发生时，操作系统将通过ISR获得控制权</li><li><strong>原理：</strong>计数器寄存器在石英振荡器定时发送脉冲时自动减一，当计数寄存器达到0的时候，定时器将会中断CPU，然后计数寄存器会用保存寄存器的值重新加载并重复之前的工作。保存寄存器（Holding register）来加载计数器。</li><li><strong>作用：</strong>维持时钟、分时系统的关键设备、保护CPU，维持操作系统对CPU的控制权</li></ul></li></ul><h2 id="2-5-System-call系统调用"><a href="#2-5-System-call系统调用" class="headerlink" title="2.5 System call系统调用"></a>2.5 System call系统调用</h2><p>操作系统本身没有任何用处，但是给用户程序提供了很多有用的服务，这些服务通过系统调用来提供，即系统调用是操作系统同用户程序之间的接口。</p><h3 id="2-5-1-特点"><a href="#2-5-1-特点" class="headerlink" title="2.5.1 特点"></a>2.5.1 <strong>特点</strong></h3><ul><li>用户程序只能通过系统调用来请求操作系统提供的服务</li><li>接口中的系统调用因操作系统的不同而不同</li><li>系统调用又称为监督器调用supervisor call</li></ul><h3 id="2-5-2-调用过程"><a href="#2-5-2-调用过程" class="headerlink" title="2.5.2 调用过程"></a>2.5.2 调用过程</h3><p>1-3 准备参数</p><p>4 调用系统调用的包装wrapper（用汇编语言编写）：将汇编语言”转换”成C语言，以便C文件调用：即变成C语言接口；将服务名称转为数字</p><p>5 把系统调用号码存到寄存器</p><p>6 进入（trap into）操作系统</p><p>7 通过系统调用号码在系统调用表中索引，获得系统调用服务例程</p><p>8-11 运行系统调用例程，完成以后然后返回用户程序</p><p><img src="https://img.fdchen.host/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="系统调用"></p><h3 id="2-5-3-进入操作系统"><a href="#2-5-3-进入操作系统" class="headerlink" title="2.5.3 进入操作系统"></a>2.5.3 进入操作系统</h3><ul><li>用户程序不能直接进入操作系统，进入操作系统的方法有两种（实质均为触发异常）</li></ul><ol><li><p>异常（软件生成中断）</p></li><li><p>特殊指令（触发异常）</p></li></ol><ul><li><strong>INTEL IA-32</strong><ul><li>提供了一条指令触发异常，INT</li><li>由于INT指令的额外开销，提供了特殊指令，SYSENTER和SYSEXIT，ARM处理器使用swi（Software Interrupt，软件中断）进入操作系统</li></ul></li></ul><h3 id="2-5-4-系统调用对比库函数"><a href="#2-5-4-系统调用对比库函数" class="headerlink" title="2.5.4 系统调用对比库函数"></a>2.5.4 系统调用对比库函数</h3><ol><li><p>系统调用会进入操作系统内核，但是库函数不会。这也导致系统调用比库函数慢很多</p></li><li><p>库函数等同于用户自定义的函数，我们可以用我们自己的库函数版本代替已有库函数，但是我们不能代替系统调</p></li></ol><p> 用</p><ol start="3"><li>一个操作系统中的系统调用可能成为另一个操作系统的中的库函数：将系统调用封装成库函数，以便程序从一个系统移植到另一个系统</li></ol><p><img src="https://img.fdchen.host/%E5%9F%BA%E4%BA%8E%E5%BA%93%E5%87%BD%E6%95%B0%E7%A7%BB%E6%A4%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="基于库函数移植系统调用"></p><h1 id="3-操作系统结构"><a href="#3-操作系统结构" class="headerlink" title="3 操作系统结构"></a>3 操作系统结构</h1><p>（以下内容有待排版）</p><p> 3.1. 操作系统结构</p><p> 3.1.1. 简单结构或者无结构</p><p> By CFD 12</p><p> 3.1.1.1. 举例</p><p> <strong>3.1.1.1.1. MS-DOS</strong></p><p> <strong>3.1.1.1.2. Unix</strong></p><p> <strong>3.1.1.2.</strong></p><p> 3.1.2. 分层结构</p><p> 3.1.2.1. 操作系统被分为多层，每一层建立在较低层的上面</p><p> <strong>3.1.2.2.</strong></p><p> 3.1.2.3. 举例：THE操作系统，Dijkstra创建</p><p> <strong>3.1.2.3.1.</strong></p><p> 3.1.2.4. 主要困难</p><p> By CFD 13</p><p> 3.1.2.4.1. 分层界限模糊</p><p> 3.1.2.4.2. 低效率</p><p> 3.1.3. 微内核结构</p><p> 3.1.3.1. 微内核方法通过从内核中删除所有非必要的组件并且把它们作为系统级和用户级的程序实现</p><p> 3.1.3.2. 应该留在微内核中的结构</p><p> 3.1.3.2.1. CPU管理器</p><p> 3.1.3.2.2. 内存管理器</p><p> 3.1.3.2.3. 通信设施</p><p> <strong>3.1.3.3.</strong></p><p> 3.1.3.4. 举例</p><p> <strong>3.1.3.4.1. Mach</strong></p><p> 3.1.3.4.1.1. 用于Apple macOS&#x2F;iOS&#x2F;tvOS&#x2F;watchOS</p><p> <strong>3.1.3.4.2. Micorsoft Windows NT&#x2F;XP</strong></p><p> 3.1.3.5. PS：纯微内核不可行</p><p> 3.1.4. 虚拟机</p><p> 3.1.4.1. 底层真实硬件被”克隆”成几个相同的虚拟机，该虚拟机提供与底层裸机硬件相同的接口</p><p> 3.1.4.2. 操作系统就建立在虚拟机的上面</p><p> <strong>3.1.4.2.1.</strong></p><p> By CFD 14</p><p> 3.1.4.3. 虚拟机分类</p><p> 3.1.4.3.1. 硬件虚拟机（依据实现方法分类）</p><p> 3.1.4.3.1.1. 仿真&#x2F;模拟：虚拟机模拟完整的硬件，允许一个完全不同的未修改的操作系统 CPU运行</p><p> <strong>VMware VirtualBox QEMU Bochs</strong></p><p> 3.1.4.3.1.2. 克隆-半虚拟化：虚拟机不模拟硬件，而是提供了一个特殊的API，需要操作系统修改运行</p><p> 剑桥大学的Xen</p><p> 3.1.4.3.1.3. 克隆-完全虚拟化：虚拟机的一部分模拟足够的硬件以允许未修改的操作系统独立运行，但是客户操</p><p> 作系统必须为之设计同一类型的CPU</p><p> IBM的VM&#x2F;370</p><p> 适用于Linux的KVM</p><p> 3.1.4.3.2. 应用程序虚拟机</p><p> 3.1.4.3.2.1. 一种将用户正在使用的应用程序与计算机隔离的计算机软件</p><p> By CFD 15</p><p> 3.1.4.3.2.2. 举例：Sun微系统的Java虚拟机(JVM)</p><p> 3.1.4.4. 虚拟机优缺点</p><p> 3.1.4.4.1. 虚拟机概念完成了对系统资源的保护，因为每个虚拟机设备都与其他虚拟机隔离开，即不允许直接共享资</p><p> 源</p><p> 3.1.4.4.2. 虚拟机是操作系统研究和发展的完美工具</p><p> 3.1.4.4.3. 虚拟机概念很难实现，理由是需要向底层计算机提供精确副本</p><p> 3.2. 操作系统设计</p><p> 3.2.1. 策略Policies和机制Mechanisms</p><p> 3.2.1.1. 策略-做什么</p><p> 3.2.1.1.1. 比如用户不应该能够读取其他用户的文件</p><p> 3.2.1.2. 机制-怎么做</p><p> 3.2.1.2.1. 比如说文件访问权限应该由开放的系统调用来判断</p><p> 3.2.2. 操作系统的实现</p><p> 3.2.2.1. 传统的操作系统由汇编语言编写，现在可以由高级语言编写</p><p> 3.2.2.2. 高级语言编写的优点</p><p> 3.2.2.2.1. 编写速度更快</p><p> 3.2.2.2.2. 更简洁</p><p> 3.2.2.2.3. 容易理解和Debug</p><p> 3.2.2.2.4. 方便移植到其他硬件上</p><p> 4. 进程管理</p><p> By CFD 16</p><p> 4.1. 进程概念</p><p> 4.1.1. 运行工作&#x2F;程序&#x2F;任务的抽象</p><p> 4.1.2. 组成</p><p> 4.1.2.1. 文本部分（代码）</p><p> 4.1.2.2. 数据部分（数据）</p><p> 4.1.2.3. 寄存器内的内容</p><p> 4.1.2.4. 栈</p><p> 4.1.2.5. 堆</p><p> 4.1.2.6. 其他资源，如打开的文件</p><p> <strong>4.1.2.7.</strong></p><p> 4.1.2.7.1. Gap满时显示内存不足</p><p> 4.2. 进程对比程序</p><p> 4.2.1. 程序是属于存储的被动实体，进程是包含比程序更多资源的主动实体</p><p> 4.2.2. 很多进程可能是运行相同的程序，但是进程应该是分开的运行队列，除了分享相同代码段，其他资源都不相同</p><p> 4.3. 进程状态</p><p> By CFD 17</p><p> 4.3.1. 创建状态</p><p> 4.3.2. 运行状态</p><p> 4.3.3. 等待状态：等待某些事件发生</p><p> 4.3.4. 就绪状态：等待CPU调度</p><p> 4.3.5. 终止状态</p><p> 4.3.6. Zombie僵尸状态：执行完毕但资源未回收</p><p> 4.4. 进程状态转换</p><p> <strong>4.4.1.</strong></p><p> 4.5. 进程控制块Process Control Block(PCB)，也叫任务控制块</p><p> 4.5.1. 进程号码-PID</p><p> 4.5.2. 程序计数器-PC</p><p> 4.5.3. 调度信息，包括进程优先级</p><p> <strong>4.5.4.</strong></p><p> By CFD 18</p><p> 4.6. 进程调度-决定下一个运行的进程</p><p> 4.6.1. 当前运行进程发生了什么？</p><p> 4.6.1.1. 上下文切换</p><p> <strong>4.6.1.1.1.</strong></p><p> 4.6.1.1.2. 上下文切换是纯消耗</p><p> 4.6.1.1.2.1. 取决于下层的处理器，消耗许多CPU周期</p><p> 4.6.1.1.2.2. 上下文切换已经变成了运行瓶颈，需要使用新的结构（缓存）来尽可能的避免</p><p> 4.6.2. 如何跟踪每一个进程应该做的事？</p><p> 4.6.2.1. 调度队列</p><p> 4.6.2.1.1. 工作队列：全部进程</p><p> By CFD 19</p><p> 4.6.2.1.2. 就绪队列：等待被调度执行的进程</p><p> 4.6.2.2. I&#x2F;O设备队列</p><p> <strong>4.6.2.2.1.</strong></p><p> 4.6.2.3. 队列图：进程调度的一种常用表示</p><p> <strong>4.6.2.3.1.</strong></p><p> 4.6.3. 如何决定下一个运行的进程？</p><p> 4.6.3.1. CPU调度器：从ready队列中选择一个进程，将CPU分配给这个进程</p><p> 4.7. 进程的操作</p><p> 4.7.1. 进程终止</p><p> 4.7.1.1. 正常情况</p><p> By CFD 20</p><p> 4.7.1.1.1. 一个进程被操作系统删除</p><p> 4.7.1.2. 非正常情况</p><p> 4.7.1.2.1. 一个进程被另一个进程删除，仅内存资源回收</p><p> 4.7.2. 进程协作</p><p> 4.7.2.1. 协作进程之间的同步</p><p> 4.7.2.2. 进程协作的优点</p><p> 4.7.2.2.1. 信息共享</p><p> 4.7.2.2.1.1. 几个进程共享相同的信息</p><p> 4.7.2.2.2. 计算加速</p><p> 4.7.2.2.2.1. 将问题分成几个可以并行的子任务</p><p> 4.7.2.2.3. 模块化</p><p> 4.7.2.2.3.1. 根据设计将不同功能的过程分开</p><p> 4.7.2.3. 并行执行的进程需要允许进程通信的机制来同步行为</p><p> 4.7.2.4. 举例：生产者、消费者问题</p><p> 4.7.2.4.1. 一般选择有界限的缓冲区</p><p> <strong>4.7.2.4.2.</strong></p><p> 4.7.3. 进程间通讯Interprocess communication(IPC)</p><p> By CFD 21</p><p> 4.7.3.1. 距离远：先解决通信在解决同步问题</p><p> 4.7.3.2. 距离近：同步为主要问题</p><p> 4.7.3.3. 管道Pipe</p><p> 4.7.3.3.1. 管道有两个端点:一个用于读取，另一个用于写入。先进先出FIFO原则</p><p> 4.7.3.3.2. 种类</p><p> 4.7.3.3.2.1. 匿名管道</p><p> 单工，数据只在一个方向上传输</p><p> 在父子进程间传递数据</p><p> 仅存在于进程运行时</p><p> 4.7.3.3.2.2. 命名管道</p><p> 单工或者双工，允许数据同时在两个方向上传输，全</p><p> 双工通信是两个单工通信方式的结合</p><p> 允许任意两个进程之间的通信</p><p> 可以是永久保存或者易丢失的</p><p> 5. 线程管理</p><p> 5.1. 线程与进程</p><p> 5.1.1. 进程</p><p> 5.1.1.1. 资源分配的单元 调度的单元</p><p> 5.1.2. 线程</p><p> 5.1.2.1. 传统的进程只控制一个线程</p><p> 5.1.2.2. 进程是所调用资源的容器</p><p> By CFD 22</p><p> 5.1.2.3. 线程是CPU实际调度的实体</p><p> 5.2. 线程概念</p><p> 5.2.1. CPU调度的基础单元，又称为轻量级进程lightweight <strong>process</strong></p><p> 5.2.2. 多线程</p><p> 5.2.2.1. 在相同进程中存在允许多个线程</p><p> 5.2.2.2. 共享进程中的资源，包括代码段、数据段、打开的文件等</p><p> 5.2.2.3. 每个线程拥有私有线程内容，包括CPU寄存器设置、其他状态信息和私有栈</p><p> <strong>5.2.2.3.1.</strong></p><p> 5.2.3. 单线程对比多线程</p><p> <strong>5.2.3.1.</strong></p><p> 5.3. 线程的好处</p><p> 5.3.1. 可响应性</p><p> By CFD 23</p><p> 5.3.2. 资源共享</p><p> 5.3.3. 经济</p><p> 5.3.4. 提高多处理器结构的利用率5.4. （多）线程的实现</p><p> 5.4.1. 用户线程</p><p> 5.4.2. 内核线程</p><p> 5.4.2.1. 直接由操作系统支持，内核在内核态下执行线程的创建、调度和管理</p><p> 5.4.2.2. 缺点</p><p> 5.4.2.2.1. 线程管理和上下文切换需要进入内核，由内核调度，消耗大量CPU周期</p><p> 5.4.2.3. 优点</p><p> 5.4.2.3.1. 如果进程中一个线程被阻塞，内核可以调度同一个进程中的另一个线程</p><p> 5.4.2.3.2. 当有多个处理机时，一个进程的多个线程可以同时执行</p><p> 6. CPU调度</p><p> 6.1. 基本概念</p><p> 6.1.1. 调度是操作系统的基本功能</p><p> 6.1.1.1. 空间资源的调度-内存</p><p> 6.1.1.2. 时间资源的调度-CPU</p><p> 6.1.2. 当前进程（线程）不能执行时，操作系统必须调度另一个就绪的进程（线程）执行</p><p> 6.2. CPU-I&#x2F;O 爆发周期</p><p> By CFD 24</p><p> 6.2.1. 进程执行由CPU执行和I&#x2F;O等待的周期组成</p><p> 6.2.2. 进程在这两个状态中轮流切换</p><p> <strong>6.2.3.</strong></p><p> 6.3. CPU调度器</p><p> 6.3.1. 概念</p><p> 6.3.1.1. 从内存中的挑选已经准备的进程去执行，并把CPU分配到其中一个进程。也称为短期调度器</p><p> 6.3.2. CPU调度决策发生在当进程发生如下情况时</p><p> 6.3.2.1. 进程终止</p><p> 6.3.2.2. 从运行状态变成等待状态</p><p> 6.3.2.3. 非抢占式的</p><p> 6.3.2.4. 从运行状态变成就绪状态</p><p> 6.3.2.5. 从等待状态变成就绪状态</p><p> 6.3.2.6. 抢占式的</p><p> 6.4. 调度算法</p><p> 6.4.1. 先到先服务First-come, first-served(FCFS)</p><p> By CFD 25</p><p> <strong>6.4.1.1.</strong></p><p> 6.4.2. 耗时最小的工作先执行Shortest-job-First(SJF) --调度最优解，可以获得最小的平均等待时间</p><p> 6.4.2.1. 非抢占式 -等待时间是从到达之后开始计算</p><p> <strong>6.4.2.1.1.</strong></p><p> 6.4.2.2. 抢占式Shortest-Remaining-job-First(SRJF)</p><p> <strong>6.4.2.2.1.</strong></p><p> By CFD 26</p><p> 6.4.3. 优先级调度Priority scheduling</p><p> 6.4.3.1. 每个进程被分配了一个静态优先级，CPU每次运行优先级最高的进程</p><p> 6.4.3.2. 可以是抢占式的，也可以是非抢占式的</p><p> 6.4.3.3. 问题</p><p> 6.4.3.3.1. 饿死：低优先级的进程可能永远也不会执行</p><p> 6.4.3.3.2. 优先级反转：高优先级的进程需要访问低优先级进程所持有的资源</p><p> 6.4.3.4. 解决办法-老化Aging</p><p> 6.4.3.4.1. 随着时间推移，进程的优先级会逐渐增加，即采用动态优先级</p><p> 6.4.4. 轮转调度Round-Robin scheduling(RR)-分时</p><p> 6.4.4.1. 每个进程得到一个小的CPU时间单位(时间量或时间片)，通常是10-100毫秒。这段时间过后，进程被抢占并添加到就绪队列的末尾</p><p> 6.4.4.2. 如果就绪队列中有n个进程，时间量为q，然后每个进程一次最多获得CPU总时间的1&#x2F;n，即q个时间单位，那么任</p><p> 何进程等待的时间单位都不超过(n-1)q</p><p> 6.4.4.3. 性能问题</p><p> By CFD 27</p><p> 6.4.4.3.1. q太大时就相当于是FCFS</p><p> 6.4.4.3.2. q太小时上下文切换开销太高</p><p> 6.4.5. 多级队列Multilevel queue</p><p> 6.4.5.1. 就绪队列进一步被分为多个单独的队列，每个队列都有一个优先级数字，且每个队列有它自己的调度算法</p><p> <strong>6.4.5.1.1.</strong></p><p> 6.4.5.2. 一个进程可以在不同队列中移动，比如说当一个进程执行了分配给它的时间片以后，它就会下沉到较低优先级队</p><p> 列</p><p> 6.4.6. 总结</p><p> 6.4.6.1. 在实践中做到正确要比在原则上做到正确难得多。结果是调度器很少会做出最佳选择。解决方案：调度策略与调</p><p> 度机制分离。 也就是说，调度算法以某种方式参数化，但是参数可以由用户根据需要进行填充</p><p> 7. 进程同步</p><p> 7.1. 背景</p><p> 7.1.1. 协作进程通过由内核提供的IPC设备可能共享同一块内存，同一进程内的多线程可能共享全局变量所使用的内存</p><p> 7.1.2. 并发地访问共享数据，可能会造成前后矛盾，为了维持数据一致性，需要某种机制确保协作进程的有序执行</p><p> 7.1.3. 当生产者与消费者并发执行时，可能会出现错误，由于汇编语句的交叉</p><p> By CFD 28</p><p> <strong>7.1.3.1.</strong></p><p> 7.2. 竞争条件Race condition</p><p> 7.2.1. 竞争条件是指多个进程同时访问和操作相同的数据，执行的结果取决于访问发生的特定顺序</p><p> 7.2.2. 避免方式</p><p> 7.2.2.1. 找到某种方法来禁止多个进程同时读写共享数据。也就是说，即使进程尝试并发访问，访问也必须串行化</p><p> 7.2.3. 临界区Critical section(C.S.)</p><p> 7.2.3.1. 一段访问共享资源的代码</p><p> 7.2.4. 竞争条件的解决办法必须满足以下四个条件</p><p> 7.2.4.1. 互斥：不能存在两个进程同时进入临界区</p><p> 7.2.4.2. 可运行：某个进程不执行时不能阻止其他线程进入临界区</p><p> 7.2.4.3. 必须实现的条件</p><p> 7.2.4.4. 有限等待：进程进入临界区不能永久等待</p><p> 7.2.4.5. 速度：不受CPU速度和数量影响</p><p> 7.2.5. 设计一个协议让进程用来进入和离开临界区</p><p> <strong>7.2.5.1.</strong></p><p> By CFD 29</p><p> 7.3. 解决竞争条件</p><p> 7.3.1. 第一次尝试</p><p> <strong>7.3.1.1.</strong></p><p> 7.3.1.2. 不满足可执行性progress要求，只能严格交替P0 P1 <strong>P0 P1...</strong></p><p> 7.3.2. 第二次尝试</p><p> <strong>7.3.2.1.</strong></p><p> 7.3.2.2. 不满足可执行性progress要求，存在flag[0], flag[1]同时被设置为true情况</p><p> By CFD 30</p><p> 7.3.3. 第三次尝试-Peterson算法</p><p> <strong>7.3.3.1.</strong></p><p> 7.3.4. 同步化的硬件,几个低级别硬件功能可以解决竞争条件</p><p> 7.3.4.1. 禁用中断</p><p> 7.3.4.1.1. 进程切换只发生在时钟中断或者其他中断，如果禁用中断，就不必担心产生竞争条件</p><p> 7.3.4.1.2. 例子：INTEL x86</p><p> 7.3.4.1.2.1. CLI - 关中断</p><p> 7.3.4.1.2.2. STI - 开中断</p><p> 7.3.4.1.3. 缺点</p><p> 7.3.4.1.3.1. 用户进程不应该可以禁用中断，CLI&#x2F;STI都是特权指令</p><p> 7.3.4.1.3.2. 开关中断在多道程序设计系统中是不可行的</p><p> 7.3.4.1.3.3. 会丢失一些重要中断，如时钟中断</p><p> 7.3.4.2. 特殊指令，都是原子执行语句，不可中断</p><p> 7.3.4.2.1. TSL(Test and Set Lock)返回原值并设置为真</p><p> <strong>7.3.4.2.1.1.</strong></p><p> By CFD 31</p><p> <strong>7.3.4.2.2. SWAP</strong></p><p> <strong>7.3.4.2.2.1.</strong></p><p> 7.3.4.3. 使用特殊指令解决竞争条件</p><p> <strong>7.3.4.3.1.</strong></p><p> 7.3.4.3.1.1. 满足互斥与可执行性progress，不满足有限等待</p><p> 7.3.5. 总结</p><p> 7.3.5.1. 以上的解决办法都有一个普遍的缺点：忙等</p><p> 7.3.5.1.1. 当一个进程进入临界区之后，其他进程必须在入口代码处不断循环</p><p> By CFD 32</p><p> 7.3.5.1.2. 忙等浪费CPU周期</p><p> 7.3.5.2. 解决办法：自旋锁spinlock</p><p> 7.3.5.2.1. 概念：可以被其他CPU内核调用线程</p><p> 7.3.5.2.2. 只在多处理器中有效，因为对于短时间内要执行的线程，多处理器下无上下文切换</p><p> 7.3.5.2.3. 单CPU下不可避免上下文切换，需要用开关中断手段解决竞争条件</p><p> 7.4. 信号量Semaphore</p><p> 7.4.1. 信号量介绍</p><p> 7.4.1.1. 上述解决竞争条件的方法都不容易推广，信号量可以一个同步工具克服这个问题</p><p> 7.4.1.2. 信号量由Dijkstra发明，第一次使用在THE操作系统中</p><p> 7.4.1.3. 信号量是一个整型变量，除了初始化，只能通过原子操作P(down)和V(up)改变</p><p> 7.4.2. 信号量实现</p><p> <strong>7.4.2.1.</strong></p><p> 7.4.2.2. 每个信号量均有一个进程队列</p><p> 7.4.2.3. P操作阻塞一个进程，V操作唤醒一个进程</p><p> By CFD 33</p><p> 7.4.2.4. 注意：P操作下S-\value value</p><p> 7.4.2.5. value的值代表当前可用资源数量或者某个信号量后等待进程的数量</p><p> 7.4.2.6. 利用底层方法保证P和V操作的原子性</p><p> 7.4.2.6.1. 单处理器系统禁止中断</p><p> 7.4.2.6.2. 多处理器系统采用自旋锁</p><p> 7.4.2.7. 应用程序编程接口</p><p> <strong>7.4.2.7.1. Win32</strong></p><p> <strong>7.4.2.7.1.1. CreateSemaphore&#x2F;CloseHandle</strong></p><p> <strong>7.4.2.7.1.2. WaitForSingleObeject&#x2F;ReleaseSemaphore</strong></p><p> <strong>7.4.2.7.2. POSIX</strong></p><p> <strong>7.4.2.7.2.1. sem_init&#x2F;sem_destroy</strong></p><p> <strong>7.4.2.7.2.2. sem_wait&#x2F;sem_post</strong></p><p> 7.4.3. 著名同步问题</p><p> 7.4.3.1. 生产者-消费者问题</p><p> <strong>7.4.3.1.1.</strong></p><p> By CFD 34</p><p> 7.4.3.2. 读-写问题</p><p> <strong>7.4.3.2.1.</strong></p><p> 7.4.3.3. PS：mutex互斥信号量的个数（单个变量还是数组）由缓冲区个数决定，保证同一时刻仅有一个进程访问一个缓</p><p> 冲区</p><p> 7.4.4. 二元信号量</p><p> 7.4.4.1. 前面描述的信号量结构通常称为计数信号量，因为它的值可以在不受限制的域内变化。二进制信号量是一个整数</p><p> 值范围仅在0和1之间的信号量，它比某些硬件架构上的计数信号量更易于实现。计数信号量可以使用二进制信号量实现</p><p> 7.4.4.2. 二元信号量实现</p><p> <strong>7.4.4.2.1.</strong></p><p> 7.4.4.2.2. bP和bV操作必须为原子操作</p><p> 7.4.4.3. 使用二元信号量实现计数信号量</p><p> By CFD 35</p><p> <strong>7.4.4.3.1.</strong></p><p> 7.5. 管程Monitor</p><p> 7.5.1. 高级语言同步结构，将程序、变量和数据结构组合成包</p><p> 7.5.2. 管程有一个重要的特性，这使得它们对于实现互斥非常有用：在监视器中，任何时刻都只能有一个进程处于活动状态</p><p> 7.5.3. 条件变量：定义为一种变量类型，它只有两个操作</p><p> <strong>7.5.3.1. C.wait()</strong></p><p> 7.5.3.1.1. 表示调用它的进程将挂起，直到另一个进程调用</p><p> <strong>7.5.3.2. C.signal()</strong></p><p> 7.5.3.3. 如果没有进程挂起，则signal()操作没有效果</p><p> <strong>7.5.4.</strong></p><p> 7.5.5. 可能出现一种情况，P进程调用C.signal()唤醒了进程Q，有三种可能的解决办法</p><p> By CFD 36</p><p> 7.5.5.1. 挂起P，让Q运行</p><p> 7.5.5.2. 布林奇·汉森式：P必须立即离开管程</p><p> 7.5.5.3. Mesa风格（Mesa是一种编程语言）：让P运行并挂起Q</p><p> 7.5.6. 语言支持</p><p> 7.5.6.1. 管程构造必须由编程语言支持才能使用，也就是说，编译器必须识别监视器构造并生成代码以支持其功能</p><p> 7.5.6.2. Java（只有一个条件变量的Mesa样式管程），通过向方法声明中添加synchronized关键字，Java保证一旦任何线程已经开始执行该方法，不允许其他线程开始执行该类中</p><p> 的任何其他同步方法，Java提供了两个操作：wait和notify以阻止和唤醒线程</p><p> 7.6. 管程与信号量</p><p> 7.6.1. 信号量和监视器在功能上是等价的，但是它们的使用和实现是完全不同的</p><p> 7.6.2. 使用管程实现信号量</p><p> <strong>7.6.2.1.</strong></p><p> 7.7. 总结</p><p> By CFD 37</p><p> <strong>7.7.1.</strong></p><p> 8. 死锁</p><p> 8.1. 死锁问题</p><p> 8.1.1. 如果进程集合中的每个进程都在等待或只有集合中的另一个进程可以发生的事件，则一组进程将被死锁</p><p> 8.1.2. 产生原因</p><p> 8.1.2.1. 计算机行为</p><p> 8.1.2.1.1. 比如两个磁盘机相互等待</p><p> 8.1.2.2. 人为造成的程序错误</p><p> <strong>8.1.2.2.1.</strong></p><p> 8.2. 系统模型</p><p> 8.2.1. 一个系统由有限数量的资源组成，这些资源被分配到多个相互竞争的进程中</p><p> 8.2.2. 使用资源的步骤</p><p> 8.2.2.1. 请求</p><p> By CFD 38</p><p> 8.2.2.1.1. 如果无法立即授予请求，则请求进程必须等待，直到它能够获取资源</p><p> 8.2.2.2. 使用</p><p> 8.2.2.3. 释放</p><p> 8.2.3. 死锁特征：如果以下四个条件同时保持，则可能会出现死锁</p><p> 8.2.3.1. 互斥mutual exclusion</p><p> 8.2.3.1.1. 一次只能使用一个进程</p><p> 8.2.3.2. 持有和等待hold and wait</p><p> 8.2.3.2.1. 至少持有一个资源的进程在等待其他进程的资源</p><p> 8.2.3.3. 无抢占no preemption</p><p> 8.2.3.3.1. 资源只能由持有它的进程在该进程完成其任务后自动释放</p><p> 8.2.3.4. 循环等待circular wait</p><p> 8.2.4. 资源分配图</p><p> <strong>8.2.4.1.</strong></p><p> <strong>8.2.4.2.</strong></p><p> By CFD 39</p><p> 8.2.5. 死锁和资源分配图</p><p> 8.2.5.1. 如果资源分配图里面没有环，就没有进程死锁；如果资源分配图里面有环，则可能存在死锁</p><p> <strong>8.2.5.2.</strong></p><p> 8.3. 解决死锁的方法</p><p> 8.3.1. 死锁预防-攻击四个条件</p><p> 8.3.1.1. 攻击互斥</p><p> 8.3.1.1.1. 对于可共享资源（如只读文件）来说，它不是必需的；对于不可共享资源（如打印机），它必须保持</p><p> 8.3.1.1.2. 如果设备（如打印机）可以排队执行，只有打印机服务器使用打印机资源（其他进程将文档发送到要打印</p><p> 的打印机服务器），打印机死锁将被清除</p><p> 8.3.1.1.3. 但是，并不是所有的设备都可以排队执行，一般</p><p> By CFD 40</p><p> 来说，我们不能通过攻击互斥来防止死锁一些本质上是不</p><p> 可共享的资源</p><p> 8.3.1.2. 攻击持有和等待</p><p> 8.3.1.2.1. 我们必须保证，每当进程请求资源时，它不保存任何其他资源</p><p> 8.3.1.2.2. 因此要求进程在开始执行之前请求并分配其所有资源，或者仅当进程没有资源时才允许进程请求资源</p><p> 8.3.1.2.3. 可能导致资源利用率低和饿死</p><p> 8.3.1.3. 攻击非抢占式</p><p> 8.3.1.3.1. 如果持有某些资源的进程请求另一个不能立即分配给它的资源，那么当前持有的所有资源都将被释放</p><p> 8.3.1.3.2. 这可以应用于那些状态可以轻松保存和存储的资源，例如CPU，通常不能应用于打印机和磁带机等资源</p><p> 8.3.1.4. 攻击循环等待</p><p> 8.3.1.4.1. 我们可以强制所有资源类型的总排序，并要求每个进程以递增的枚举顺序请求资源</p><p> 8.3.2. 死锁避免</p><p> 8.3.2.1. 要求系统提供一些额外的先验信息</p><p> 8.3.2.2. 最简单和最有用的模型要求每个进程声明它可能需要的每种类型的最大资源数</p><p> 8.3.2.3. 死锁避免算法动态检查资源分配状态，以确保永远不会有循环等待条件</p><p> 8.3.2.4. 资源分配状态由可用和分配的资源数以及进程的最大需求定义</p><p> 8.3.3. 安全状态</p><p> By CFD 41</p><p> 8.3.3.1. 如果存在所有进程的安全序列，则系统处于安全状态</p><p> 8.3.3.2. 基本事实</p><p> 8.3.3.2.1. 如果系统处于安全状态，没有死锁</p><p> 8.3.3.2.2. 如果系统处于不安全状态，避免死锁必须确保系统永远不会进入非安全状态</p><p> 8.3.4. 银行家算法</p><p> 8.3.4.1. 概念</p><p> 8.3.4.1.1. 它是1968年由Dijkstra发明的，用于THE操作系统</p><p> 8.3.4.1.2. 要求一个新进程必须声明它可能需要的每个资源类型的最大项数。此算法需要m x n个操作的顺序才能进行</p><p> 安全检测</p><p> 8.3.4.2. 数据结构</p><p> <strong>8.3.4.2.1.</strong></p><p> <strong>8.3.4.2.2.</strong></p><p> 8.3.4.3. 安全检测，Finish[i] &#x3D; true代表结束进程</p><p> <strong>8.3.4.3.1.</strong></p><p> By CFD 42</p><p> 8.3.4.3.2. Work代表工作区可用资源数量，Work &#x3D; Work + Allocation，代表把当前进程结束Finish[i] &#x3D; true之后，需要把之前分配出去的资源回收</p><p> 8.3.4.4. 资源请求</p><p> <strong>8.3.4.4.1.</strong></p><p> <strong>8.3.4.4.2.</strong></p><p> 8.3.4.5. 举例</p><p> <strong>8.3.4.5.1.</strong></p><p> By CFD 43</p><p> 8.4. 死锁检测和恢复</p><p> 8.4.1. 如果死锁预防和死锁避免算法无法起作用，那么死锁就可能发生。在这种情况下，操作系统必须提供一种算法来判断死</p><p> 锁是否发生以及从死锁中恢复</p><p> <strong>8.4.2.</strong></p><p> 8.4.3. 举例</p><p> <strong>8.4.3.1.</strong></p><p> By CFD 44</p><p> <strong>8.4.3.2.</strong></p><p> 8.4.4. 什么时候唤醒死锁检测算法</p><p> 8.4.4.1. 取决于死锁多久发生一次</p><p> 8.4.4.2. 取决于有多少进程在死锁发生时会被影响</p><p> 8.4.5. 死锁恢复</p><p> 8.4.5.1. 当死锁检测判定死锁发生时，有两种选择</p><p> 8.4.5.1.1. 结束进程</p><p> 8.4.5.1.1.1. 直接全部死锁内所有进程</p><p> 8.4.5.1.1.2. 每次结束一个进程直到死锁解除</p><p> 8.4.5.1.2. 抢占资源</p><p> 8.4.6. 鸵鸟算法</p><p> 8.4.6.1. 我们可以完全忽略这个问题，假装永远不会出现死锁。在大多数操作系统中，包括Windows, Unix&#x2F;Linux。因为死锁很少发生，死锁预防、避免或死锁检测和恢复算法代价高昂。这是方便与正确之间的权衡</p><p> 9. 内存管理</p><p> 9.1. 内存管理介绍</p><p> 9.1.1. 内存管理的任务</p><p> 9.1.1.1. 提供一个虚拟的机器接口，让每一个进程都以为是自己在独占RAM</p><p> By CFD 45</p><p> 9.2. 基本方法</p><p> 9.2.1. 以MS-DOS为例</p><p> <strong>9.2.1.1. MS-DOS</strong></p><p> 9.2.1.1.1. 单用户、单任务</p><p> 9.2.1.1.2. 只能访问1MB内存-INTEL 8086&#x2F;80286只有20根地址线</p><p> 9.2.1.1.3. 没有任何保护机制</p><p> 9.2.1.2. 在MS-DOS中，MS-DOS自己要占用1&#x2F;3左右，剩余部分留给系统唯一的进程使用。如果在某个MOS-DOS下的应用程序需要超过640K的内存才能运行，怎么办？</p><p> 9.2.1.2.1. 覆盖Overlay：一种使进程大于分配给它的内存量的技术。 覆盖的思想是在内存中只保存在任何给定时间所需的指令和数据</p><p> <strong>9.2.1.2.2.</strong></p><p> 9.2.1.2.3. 覆盖Overlay的思想：无论进程在运行时占有多大的内存，在某一段时间内，它只会访问其中的一部分</p><p> 9.2.1.3. 假设MS-DOS支持多任务，即系统中有多个进程。而且，进程必须在内存中才能运行，运行中的进程可能会申请额外的内存。假设系统目前有两个进程：P1和P2，而且系统已经没有内存可以用。此时，正在运行的P1又要申请更多的内存才能继续运行，怎么办？</p><p> By CFD 46</p><p> 9.2.1.3.1. 交换Swap：一个进程可以暂时从内存中交换到缓冲存储区，然后进入内存继续执行</p><p> <strong>9.2.1.3.2.</strong></p><p> 9.2.1.3.3. Swap的限制</p><p> 9.2.1.3.3.1. 要求计算机必须配备足够大的backing- store，backing-store一般是快速、大容量的硬盘</p><p> 9.2.1.3.3.2. 上下文切换要花费大量的时间，主要用于磁盘数据传输，因此调度算法尤其重要，应尽量减少上下</p><p> 文切换</p><p> 9.2.1.3.3.3. 被swap-out的进程必须被重新swap-in到相同的内存地址才能继续运行</p><p> 9.2.1.3.4. Swap思想：当系统内存不足是，可以向backing- store”借”一部分来使用</p><p> 9.2.2. 多任务多系统的内存管理</p><p> 9.2.2.1. 重定位问题relocation</p><p> 9.2.2.1.1. 源程序变成进程的过程</p><p> 9.2.2.1.1.1. 代码source code先被编译成目标文件<strong>object file</strong></p><p> 9.2.2.1.1.2. 链接器linkage editor连接成可执行文件<strong>executable</strong></p><p> By CFD 47</p><p> 链接过程</p><p> 相同属性的东西（code或data）放置在一起写好调用函数的地址</p><p> 9.2.2.1.1.3. 最后由操作系统加载可执行文件到内存形成进程</p><p> 9.2.2.1.2. 重定位概念</p><p> 9.2.2.1.2.1. 在多任务环境中，可执行文件可能会被加载到内存的任何位置运行</p><p> 9.2.2.1.2.2. 链接器在生成可执行文件时必须确定程序中各个符号（如函数、全局变量）的地址，把程序中的符</p><p> 号映射为地址的过程叫做地址绑定address binding</p><p> 9.2.2.1.2.3. 事实上，由于链接器无法预知程序将被加载到哪个内存位置，因此无法完成绝对的地址绑定。因</p><p> 此，链接器只能假定程序中第一条指令的地址是0，从而用相对于它的偏移量来进行相对的地址绑定。这样的程序只能被加载到0地址的内存运行，如果该程序被加载到其他非0的地址，必须对程序中所应用的地址进行修改才能运行，这个修改的过程就称为重定位。</p><p> 9.2.2.1.3. 重定位步骤</p><p> 9.2.2.1.3.1. 几个概念</p><p> 逻辑地址logical address：程序中引用的地址，也就是CPU产生的地址</p><p> 物理地址physical address：系统中内存单元所看到的地址</p><p> 内存管理单元Memory Management Unit, MMU：专</p><p> 门完成逻辑地址到物理地址转换的硬件单元，一般是</p><p> CPU的一部分</p><p> <strong>9.2.2.1.3.2.</strong></p><p> By CFD 48</p><p> 9.2.2.2. 内存保护问题protection</p><p> 9.2.2.2.1. 操作系统如何保护自己和应用程序的内存不被其他进程访问或破坏？</p><p> 9.2.2.2.1.1. 对应用程序访问的每一个逻辑内存地址进行检查，看是否超出了内存范围。为了获得最好的性能，</p><p> 一般用MMU通过硬件来实现检查功能。</p><p> <strong>9.2.2.2.1.2.</strong></p><p> 9.2.2.2.1.3. 需要硬件的支持才能实施保护</p><p> 9.2.2.3. 内存分配问题allocation</p><p> 9.2.2.3.1. 在多任务环境中，操作系统需要为每个新创建的进程分配一定数量的内存才能运行，当进程退出后，操作</p><p> 系统要回收它所占用的内存。操作系统如何有效地管理内存的分配和回收，以尽量满足进程的需求？也称为动态内存分配问题</p><p> 9.2.2.3.1.1. 做法</p><p> By CFD 49</p><p> 操作系统保留一个表，指示哪些内存部分可用，哪些</p><p> 内存块占用</p><p> 可用的内存块称为洞hole。最初，所有内存都可用于用户进程。当进程到达并需要内存时，操作系统搜索一个足够大的洞hole提供给进程。</p><p> 当一个进程终止时，它将内存作为一个洞hole返回给操作系统，如果新的洞与其他的洞是相邻的，那么这些相邻的洞将合并成一个更大的洞</p><p> 9.2.2.3.1.2. 算法</p><p> 随着系统中进程的创建和退出，系统中可能会形成很</p><p> 多小的hole，这些hole既不足以满足任何进程的需</p><p> 求，也不能被合并以形成打的hole。这些hole被称为外部碎片。</p><p> 用来进行内存分配和释放以减少外部碎片提高内存使</p><p> 用率的常用算法</p><p> 首次适应First fit最佳适应Best fit最坏适应Worst fit</p><p> 9.2.2.3.1.3. 其他方法</p><p> 把系统内存分成固定大小的内存块，操作系统以块为单位进行内存的分配和释放，最终分配的内存可能会比所需求要多，多出来的部分称为内部碎片</p><p> 相对于外部碎片，内部碎片的情况不是很严重</p><p> 9.2.2.3.1.4. 内存的分配和回收不仅出现在OS中，应用程序面临同样的问题</p><p> 当进程被创建时，操作系统会采用某种算法分配一块足够大的内存给进程，由进程自己挂你（其中的一部分）</p><p> By CFD 50</p><p> 由进程自己管理，库函数new&#x2F;delete（或</p><p> ）就是操纵heap中的内存</p><p> 9.3. 分页内存管理</p><p> 9.3.1. 介绍</p><p> 9.3.1.1. 分页解决了以下问题</p><p> 9.3.1.1.1. 进程所占用的物理内存不必连续</p><p> 9.3.1.1.2. 没有外部碎片，但有一定量的内部碎片</p><p> 9.3.1.1.3. 可以对进程所占用的部分内存进行swap-in&#x2F; <strong>swap-out</strong></p><p> 9.3.1.2. 早起，分页系统主要由硬件来实现，如今，分页由硬件和操作系统共同完成</p><p> 9.3.1.3. 基本概念</p><p> 9.3.1.3.1. 物理内存被分成固定大小的块，称为帧</p><p> 9.3.1.3.2. 逻辑内存也被分成大小相同的块，称为页</p><p> 9.3.1.3.3. 页表的条目称为页表条目Page Table Entry(PTE)，每一个映射关系对应一个PTE</p><p> 9.3.2. 方法</p><p> 9.3.2.1. 把逻辑地址分为两部分</p><p> 9.3.2.1.1. 第一部分称为页码page number</p><p> 9.3.2.1.2. 第二部分称为页偏移量page offset</p><p> By CFD 51</p><p> 9.3.2.2. 地址转换</p><p> 9.3.2.2.1. 在page table的帮助下，MMU把CPU产生的逻辑地址转换成物理地址</p><p> <strong>9.3.2.2.2.</strong></p><p> <strong>9.3.2.2.2.1.</strong></p><p> 9.3.2.2.3. PS：page大小必须为2^n，提高转换性能</p><p> <strong>9.3.2.2.3.1.</strong></p><p> By CFD 52</p><p> 9.3.2.2.4. 共享代码的实现：利用page table指向相同的物理地址</p><p> 9.3.2.3. 地址划分</p><p> <strong>9.3.2.3.1.</strong></p><p> 9.3.2.4. 结论</p><p> 9.3.2.4.1. 分页的一个重要方面是内存的用户视图和实际的物理内存之间的清晰分离，它们之间的差异通过地址转换</p><p> 硬件来协调，他的映射对用户是隐藏的，由操作系统控制</p><p> 9.3.2.4.2. 由于是操作系统控制地址映射，它必须记录系统物理内存的使用情况。一般使用一个称为frame table的数</p><p> 据结构来保存系统中每一个frame的状态，为每一个进程保存一个page table，也就是说，每一个进程都有自己的逻辑地址空间</p><p> By CFD 53</p><p> 9.3.3. 实现</p><p> 9.3.3.1. page table必须被保存在内存中，CPU中的两个寄存器记录了它的信息</p><p> 9.3.3.1.1. Page-table base register(PTBR)保存了page table的地址</p><p> 9.3.3.1.2. Page-table length rejister(PTLR)保存了page table的大小</p><p> 9.3.3.2. 因此在分页中，每一个内存访问都需要两次内存操作，一次访问page table，一次访问内存数据</p><p> 9.3.3.3. 为了提高地址转换效率，MMU中包含了一个高速缓存称为translation look-aside buffers(TLBs)</p><p> 9.3.3.3.1. TLB结构</p><p> <strong>9.3.3.3.1.1.</strong></p><p> 9.3.3.3.2. 对于逻辑地址A的转换，如果A在TLB中，直接获取相应映射帧，否则访问内存里的page table</p><p> 9.3.3.3.3. 增加了TLB的地址转换过程</p><p> <strong>9.3.3.3.3.1.</strong></p><p> By CFD 54</p><p> 9.3.3.3.4. 性能，注意始终至少一次访问内存</p><p> <strong>9.3.3.3.4.1.</strong></p><p> 9.3.4. 内存保护</p><p> 9.3.4.1. 在分页系统中，内存保护是以页为单位，保护信息通常都保存在PTE中，可以提供只读、读写和执行（Read，Write，eXecute）保护</p><p> 9.3.4.2. 此外，不是所有的PTE都可以使用，PTE中的一位表示该PTE是否可以使用（valid&#x2F;inValid），仅当该位有效时，MMU才能用它进行地址转换，否则MMU就通过异常向OS报</p><p> 告错误</p><p> 9.3.5. 页表问题</p><p> 9.3.5.1. 页表大小计算</p><p> <strong>9.3.5.1.1.</strong></p><p> By CFD 55</p><p> 9.3.5.2. 层级页表Hierarchical Page Tables-以二级页表为例</p><p> 9.3.5.2.1. 把一个巨大的线性表分割成很多个小的页表，通过称为outer page table的表，把小页表组织起来，通常称outer page table为页目录page directory，其中的每一项称为页目录条目Page Directory Entry(PDE)。<strong>size(PDE)&#x3D;4B</strong></p><p> <strong>9.3.5.2.2.</strong></p><p> 9.3.5.2.3. 地址划分</p><p> <strong>9.3.5.2.3.1.</strong></p><p> 9.3.5.2.4. 地址转换</p><p> <strong>9.3.5.2.4.1.</strong></p><p> By CFD 56</p><p> 9.3.5.3. 哈希页表Hashed Page Tables</p><p> 9.3.5.4. 反向页表Inverted Page Tables</p><p> 9.3.6. 帧管理</p><p> 9.3.6.1. 操作系统需要管理系统中所有frame的分配和回收</p><p> 9.3.6.2. 最简单的方法是维护一个空闲的frame链表（free- frame list）</p><p> <strong>9.3.6.2.1.</strong></p><p> 9.4. 分段内存管理</p><p> 9.4.1. 介绍</p><p> 9.4.1.1. 分段把进程的逻辑地址空间分成一个个大小不等的段，每一段集中了一种类型的数据，如代码、数据、栈等等</p><p> 9.4.2. 用户视角的分段式内存</p><p> <strong>9.4.2.1.</strong></p><p> By CFD 57</p><p> <strong>9.4.2.2.</strong></p><p> 9.4.3. 实现</p><p> 9.4.3.1. 逻辑地址由两部分组成</p><p> 9.4.3.2. 段表用于将逻辑地址映射到物理地址</p><p> 9.4.3.3. 每个表条目内容</p><p> 9.4.3.3.1. 基址base：指定段的长度</p><p> 9.4.3.3.2. 限制limit：指定段的长度</p><p> 9.4.3.3.3. 保护位protection bits(RWX)</p><p> 9.4.3.4. Segment-table base register(STBR)：指向内存中的段表位置</p><p> By CFD 58</p><p> 9.4.3.5. Segment-table length register (TLR)：指示进程使用的段数</p><p> 9.4.3.6. 地址转换</p><p> <strong>9.4.3.6.1.</strong></p><p> <strong>9.4.3.6.1.1.</strong></p><p> 9.4.3.7. 内存保护与共享</p><p> 9.4.3.7.1. 在分段系统中，内存的保护与共享以段为单位</p><p> 9.4.4. 结论</p><p> 9.4.4.1. 分段会产生外部碎片，由于系统无法预测每个进程使用内存的状况，外部碎片很难控制，因此，单纯的分段系统</p><p> 目前很少使用</p><p> By CFD 59</p><p> 9.5. 段页式内存管理</p><p> 9.5.1. INTEL IA-32(80386以后CPU的统称，包含80386)是段页式内存管理的典范</p><p> 9.5.2. 以IA-32为例</p><p> 9.5.2.1. 分段是必须的，每个段最大可以为4GB，段表项被称为描述符descriptor，相应的段表被称为描述符表descriptor table，逻辑地址中的segment被称为段选择子segment selector，简称selector</p><p> 9.5.2.2. 分页是可选的，页面和frame大小为4KB，采用二级页表</p><p> 9.5.2.3. 地址转换</p><p> 9.5.2.3.1. 段页式内存管理的地址转换包括两个步骤：先分段再分页</p><p> <strong>9.5.2.3.2.</strong></p><p> 10. 虚拟内存</p><p> 10.1. 介绍</p><p> 10.1.1. 虚拟内存是用户逻辑内存和物理内存的分离</p><p> 10.1.1.1. 为每个进程提供一个巨大的、连续的和私有的逻辑内存，它可能比物理内存大得多。程序只有一部分需要在内</p><p> By CFD 60</p><p> 存中执行</p><p> 10.1.1.2. 允许多个进程共享地址空间以更高效地创建进程</p><p> 10.1.2. 实现方法</p><p> 10.1.2.1. 按需分页demand paging</p><p> 10.1.2.2. 按需分段demand segmentation</p><p> <strong>10.1.3.</strong></p><p> 10.2. 按需分页相关概念</p><p> 10.2.1. 一般情况下，我们用swapper表示整个进程的交换，而用pager来表示对页进行交换的lazy swapper</p><p> 10.3. 什么时候引入页面</p><p> 10.3.1. 对于每个页表条目（PTE），都会关联一个valid-inValid位，如果该位设置为”有效”，则表示相关联的页是有效的且在</p><p> 内存中；否则，它表示页面不合法（即不在进程的逻辑地址空</p><p> 间中），或合法但当前不在内存中</p><p> <strong>10.3.2.</strong></p><p> By CFD 61</p><p> 10.4. 如果页面不在内存中会发生什么？</p><p> 10.4.1. 在MMU地址转换期间，如果PTE中的valid-inValid位无效，CPU触发一个缺页异常page-fault，进入操作系统。然后OS查看一个内部表（通常保存在PCB中）来决定它是否是合法</p><p> 的映射，如果是不合法映射，OS终止进程，合法但不在内存中，操作系统会引入相应页面</p><p> 10.4.2. 缺页异常服务例程Page-fault service routine</p><p> 10.4.2.1. 1. 我们检查此进程的内部表，以确定其是否合法或非法内存访问</p><p> 10.4.2.2. 2. 如果引用是非法的，我们将终止该过程，如果引用是合法的，但是我们还没有引入该页，我们现在将其引入</p><p> 10.4.2.3. 3. 我们找到一个空闲的frame</p><p> 10.4.2.4. 4. 我们调度一个磁盘操作，将所需的页读入新的分配帧frame</p><p> 10.4.2.5. 5. 当磁盘读取完成时，我们修改进程中保留的页表，以指示页现在在内存中</p><p> 10.4.2.6. 6. 我们重新启动被page-fault中断的指令。此时进程可以访问该页，就好像它一直在内存中一样</p><p> <strong>10.4.2.7.</strong></p><p> By CFD 62</p><p> 10.4.3. 结构要求</p><p> 10.4.3.1. 页表</p><p> 10.4.3.2. 辅助存储器</p><p> 10.4.3.2.1. 这个存储器保存主存储器中不存在的页。通常称为交换空间swap space</p><p> 10.4.3.3. 发生page-fault后正确重启指令的能力</p><p> 10.5. 页面替换page replacement</p><p> 10.5.1. 如果没有空闲帧frame会发生什么?</p><p> 10.5.1.1. 在内存中查找一个frame，但不在使用中，将其分页</p><p> 10.5.2. 通过在页错误服务例程增加页替换来防止内存过度分配</p><p> 10.5.2.1. 找到一个空闲帧</p><p> 10.5.2.2. 如果有空闲帧，请使用它：否则使用页面替换算法选择牺牲帧；将牺牲页面写入磁盘；相应地更改PTE</p><p> 10.5.2.3. 将所需页面读入（新的）空闲框架；更改PTE</p><p> 10.5.2.4. 重新启动指令</p><p> <strong>10.5.2.5.</strong></p><p> By CFD 63</p><p> 10.5.3. 页面替换完成了可以在较小的物理内存上提供较大的虚拟内存</p><p> 10.5.4. 改进</p><p> 10.5.4.1. 如果没有帧是空闲的，则需要两页传输一写一读</p><p> 10.5.4.2. 我们可以通过将每个页面关联一个修改位（或脏位）来减少这一开销，每当页面被修改时，硬件都会设置这个位，只有在设置了脏位时才需要写出去</p><p> 10.5.5. 算法</p><p> 10.5.5.1. 算法目标：最低page-fault率</p><p> 10.5.5.2. 评估算法</p><p> 10.5.5.2.1. 引用字符串-内存引用的字符串，通常以页面为单位</p><p> 10.5.5.2.2. 通过在引用字符串上运行算法并计算该字符串上的页面错误数来评估算法</p><p> 10.5.5.2.3. 参考字符串<strong>7,0,1,2,0,3,0,4,2,3,0,3,3,3,2,1,2,0,1,7,0</strong></p><p> 10.5.5.3. page-fault数与frame数关系</p><p> <strong>10.5.5.3.1.</strong></p><p> By CFD 64</p><p> 10.5.6. 常用page replacement算法</p><p> 10.5.6.1. 先到先得页面替换FIFO page replacement</p><p> 10.5.6.1.1. 15次page-fault</p><p> 10.5.6.1.2. 一般情况下，page-fault会随着frame的数量增加而减少，但是，如 果采用FIFO算法，情况有时并非如</p><p> 此。</p><p> <strong>10.5.6.1.2.1.</strong></p><p> 10.5.6.2. 最佳页面替换Optimal page replacement</p><p> 10.5.6.2.1. 替换长时间不使用的页</p><p> <strong>10.5.6.2.2.</strong></p><p> By CFD 65</p><p> 10.5.6.2.3. 需要预测未来，无法实现，仅提供最优解参考</p><p> 10.5.6.3. 最近最少使用(least-recently-used)LRU page <strong>replacement</strong></p><p> 10.5.6.3.1. 可能需要大量的硬件协助来确定上次使用时定义的帧的顺序</p><p> <strong>10.5.6.3.2.</strong></p><p> <strong>10.5.6.4. Second-chance page replacement</strong></p><p> 10.5.6.4.1. 很少有计算机系统为真正的LRU算法提供足够的硬件支持，为了近似，一些硬件提供了一些引用（R）或访</p><p> 问（A）位的格式</p><p> 10.5.6.4.2. 每当访问一个页面时，硬件将设置与该页面相关联的R位，当一个页面被选中时，我们检查它的R位，如</p><p> 果R&#x3D;0，替换这个页面；否则，我们再给它一次机会，然后继续选择下一页。当一个页面获得第二次机会时，由软件将它的R位清除。</p><p> <strong>10.5.6.4.3.</strong></p><p> By CFD 66</p><p> 10.5.6.4.4. 又称为时钟页面替换：当出现页面错误时，检查指针指向的页面所采取的操作取决于R位。R&#x3D;0：替换页</p><p> 面，R&#x3D;1：清除R并前进</p><p> <strong>10.5.6.4.4.1.</strong></p><p> 10.5.7. 抖动Thrashing</p><p> 10.5.7.1. 介绍</p><p> 10.5.7.1.1. 如果系统没有帧，则页面错误率非常高。这会导致以下问题</p><p> 10.5.7.1.1.1. CPU利用率低</p><p> 10.5.7.1.1.2. 接纳调度器认为它需要增加多道程序设计的程度</p><p> 10.5.7.1.1.3. 系统中添加了更多进程</p><p> By CFD 67</p><p> 10.5.7.2. 概念</p><p> 10.5.7.2.1. 一种系统忙于将页面导入和导出而没有任何用处的情况</p><p> <strong>10.5.7.2.2.</strong></p><p> 10.5.7.3. 局部模型Locality model</p><p> 10.5.7.3.1. 局部Locality定义为系统中活动使用的一组页</p><p> 10.5.7.3.2. 进程从一个Locality迁移到另一个Locality</p><p> <strong>10.5.7.3.2.1.</strong></p><p> 10.5.7.3.3. Locality model 也是caches可以工作的原因（cache中缓存的就是最近系统使用的页）</p><p> 10.5.7.3.4. 抖动发生原因</p><p> <strong>10.5.7.3.4.1.</strong></p><p> By CFD 68</p><p> 10.5.7.4. 工作集Work-set model</p><p> 10.5.7.4.1. 工作集模型是局部模型的近似，它定义了一个名为working-set窗口，△，作为页引用的数量</p><p> 10.5.7.4.2. 工作集指的是在最近working-set窗口中的页集合，因此工作集模型就是Locality模型的近似</p><p> 10.5.7.4.3. 我们用WSS来表示进程P最近working-set窗口里的工作集</p><p> <strong>10.5.7.4.4.</strong></p><p> 10.5.7.4.5. 举例</p><p> <strong>10.5.7.4.5.1.</strong></p><p> 10.5.7.4.6. 工作集的使用</p><p> 10.5.7.4.6.1. 操作系统监视每个进程的工作集，并将足够的帧定位到该工作集，以提供其工作集大小</p><p> 10.5.7.4.6.2. 如果有足够的额外帧，则可以创建新进程；否则，如果工作集大小的总和超过总帧，则操作系统将</p><p> 选择一个进程来挂起</p><p> 10.5.7.4.6.3. 工作集策略在保持多道程序设计尽可能高的程度的同时防止抖动</p><p> 11. 文件管理</p><p> 11.1. 文件系统接口</p><p> By CFD 69</p><p> 11.1.1. 文件概念</p><p> 11.1.1.1. 逻辑上的连续辅助存储器，把磁盘虚拟化</p><p> 11.1.1.2. 类型</p><p> 11.1.1.2.1. 数据文件</p><p> 11.1.1.2.2. 程序</p><p> 11.1.1.3. 文件结构</p><p> 11.1.1.3.1. 无结构，仅仅是字节序列</p><p> 11.1.1.3.2. 简单记录结构，线性，固定长度或可变长度</p><p> 11.1.1.3.3. 复杂结构</p><p> 11.1.1.3.3.1. 格式化文档Formatted document</p><p> <strong>11.1.1.3.3.2. Object file</strong></p><p> 11.1.1.3.3.3. 可执行文件executable file</p><p> 11.1.1.3.4. 由操作系统和程序决定</p><p> 11.1.1.4. 文件属性</p><p> 11.1.1.4.1. 名字</p><p> 11.1.1.4.2. 类型</p><p> 11.1.1.4.3. 位置</p><p> 11.1.1.4.4. 大小</p><p> 11.1.1.4.5. 保护-访问权限</p><p> 11.1.1.4.6. 时间，数据以及用户标识</p><p> 11.1.1.5. 文件操作</p><p> By CFD 70</p><p> 11.1.1.5.1. 创建</p><p> 11.1.1.5.2. 打开</p><p> 11.1.1.5.2.1. 当文件被打开时，除了存储在设备上的信息外，还需要一些数据来管理打开的文件</p><p> 文件指针-指向上次读&#x2F;写位置的指针，每个打开文件的进程</p><p> File-open count-当最后一个进程关闭文件表时，允许从打开的文件表中删除数据的文件打开次数的计数器</p><p> 数据访问信息的文件缓存的设备位置</p><p> 访问权限-每个进程访问模式信息</p><p> 11.1.1.5.3. 关闭</p><p> 11.1.1.5.4. 读取</p><p> 11.1.1.5.5. 写入</p><p> 11.1.1.5.6. 查找</p><p> 11.1.1.5.7. 删除</p><p> 11.1.1.6. 文件类型</p><p> <strong>11.1.1.6.1.</strong></p><p> By CFD 71</p><p> 11.1.2. 访问方式</p><p> 11.1.2.1. 顺序访问</p><p> 11.1.2.2. 随机访问</p><p> 11.1.3. 目录结构</p><p> <strong>11.1.3.1.</strong></p><p> 11.1.3.2. 目录操作</p><p> 11.1.3.2.1. 查找文件</p><p> 11.1.3.2.2. 创建文件</p><p> 11.1.3.2.3. 删除文件</p><p> 11.1.3.2.4. 列出文件目录</p><p> 11.1.3.2.5. 重命名文件</p><p> By CFD 72</p><p> 11.1.3.2.6. 遍历整个文件系统</p><p> 11.1.3.3. 单级目录</p><p> <strong>11.1.3.3.1.</strong></p><p> 11.1.3.3.2. 问题</p><p> 11.1.3.3.2.1. 命名问题</p><p> 11.1.3.3.2.2. 分组问题</p><p> 11.1.3.4. 二级目录</p><p> <strong>11.1.3.4.1.</strong></p><p> 11.1.3.4.2. 功能</p><p> 11.1.3.4.2.1. 支持文件路径定位</p><p> 11.1.3.4.2.2. 支持重名文件</p><p> 11.1.3.5. 三级目录</p><p> <strong>11.1.3.5.1.</strong></p><p> By CFD 73</p><p> 11.1.3.5.2. 功能</p><p> 11.1.3.5.2.1. 支持分组</p><p> 11.1.3.5.2.2. 支持绝对路径或相对路径定位</p><p> 11.1.3.5.2.3. 每个进程的工作（当前）目录</p><p> 11.1.3.6. 环状目录</p><p> <strong>11.1.3.6.1.</strong></p><p> 11.1.3.6.2. 功能</p><p> 11.1.3.6.2.1. 支持同一文件的两个不同名称，即别名</p><p> 11.1.3.6.2.2. 悬垂指针问题</p><p> 有些操作系统不支持非循环图形目录，例如MS-DOS</p><p> By CFD 74</p><p> UNIX&#x2F;LINUX和Windows（7+）通过符号链接支持</p><p> 11.1.4. 文件系统挂载</p><p> 11.1.4.1. 文件必须装入位于设备上的文件系统才能进行访问</p><p> 11.1.4.1.1. 挂载文件系统的位置称为挂载点</p><p> 11.1.4.1.2. 通常，装入点是一个空目录</p><p> <strong>11.1.4.2.</strong></p><p> 11.1.5. 文件共享</p><p> 11.1.5.1. 在多用户系统上共享文件是可取的，大多数系统通过其唯一的用户标识或UID来标识用户</p><p> 11.1.5.2. 除了UID，一些系统还实现了组功能，每个组被分配一个唯一的组标识或GID，每个用户可以在一个或多个组中</p><p> 11.1.5.3. 当文件或目录最初创建时，它与使用的UID和GID相关联，拥有文件的用户是该文件的所有者</p><p> 11.1.6. 文件保护</p><p> 11.1.6.1. 文件所有者可以控制文件被哪些人以什么方式访问，读、写、执行、添加、删除、列出</p><p> 11.1.6.2. UNIX&#x2F;Linux 文件和目录保护</p><p> <strong>11.1.6.2.1.</strong></p><p> By CFD 75</p><p> 11.1.6.3. 访问控制列表</p><p> <strong>11.1.6.3.1.</strong></p><p> 11.2. 文件系统实现</p><p> 11.2.1. 文件系统结构</p><p> 11.2.1.1. 文件</p><p> 11.2.1.1.1. 逻辑存储单元</p><p> 11.2.1.1.2. 相关信息的收集</p><p> 11.2.1.1.3. 文件控制块（File Control Block, FCB）包含文件的所有元信息</p><p> <strong>11.2.1.1.3.1.</strong></p><p> By CFD 76</p><p> 11.2.1.2. 文件系统驻留在辅助存储上，并被组织成层</p><p> 11.2.1.2.1. 内存文件系统结构</p><p> 11.2.1.2.1.1. 内存分区表，其中包含有关每个已装入分区的信息</p><p> 11.2.1.2.1.2. 一种内存目录结构，保存最近访问的目录的目录信息</p><p> 11.2.1.2.1.3. 系统范围的打开文件表，包含每个打开文件的FCB副本以及其他信息</p><p> 11.2.1.2.1.4. 每个进程打开文件表，包含指向系统范围打开文件表中相应项的指针，以及其他信息</p><p> <strong>11.2.1.2.1.5.</strong></p><p> By CFD 77</p><p> 11.2.2. 文件系统实现</p><p> 11.2.2.1. 虚拟文件系统Virtual File System(VFS)</p><p> 11.2.2.1.1. 大多数操作系统使用面向对象技术来简化、组织和模块化</p><p> 11.2.2.1.1.1. 公共文件系统接口，实现与文件系统实现分离</p><p> 11.2.2.1.1.2. 文件系统接口，包含诸</p><p> 如”openclose..write and seek”等系统调用</p><p> 11.2.2.1.2. 示意图</p><p> <strong>11.2.2.1.2.1.</strong></p><p> 11.2.2.1.3. VFS接口提供两个重要功能</p><p> 11.2.2.1.3.1. 通过定义一个干净的VFS接口将文件系统通用操作与其实现分离</p><p> 11.2.2.1.3.2. VFS基于一个文件表示结构，称为vnode，它包含一个用于网络范围内唯一文件的数字指示符</p><p> 11.2.3. 目录实现</p><p> 11.2.3.1. 许多操作系统把目录当作一个文件对待，一个目录可能包括许多文件或者子目录</p><p> By CFD 78</p><p> 11.2.3.2. 实现方式</p><p> 11.2.3.2.1. 线性表Linear List-众多操作系统的选择</p><p> 11.2.3.2.2. 哈希表Hash table</p><p> 11.2.4. 分配实现</p><p> 11.2.4.1. 连续分配Contiguous allocation</p><p> 11.2.4.1.1. 每个文件占用磁盘上的一组相邻块</p><p> 11.2.4.1.2. 优点</p><p> 11.2.4.1.2.1. 简单：只保存起始块和长度（块数）</p><p> 11.2.4.1.2.2. 支持随机访问和缓存友好（局部性好）</p><p> 11.2.4.1.3. 缺点</p><p> 11.2.4.1.3.1. 遭受外部碎片的折磨-动态存储分配问题</p><p> 11.2.4.1.3.2. 难以扩展文件</p><p> <strong>11.2.4.1.4.</strong></p><p> 11.2.4.2. 链接分配Linked allocation</p><p> 11.2.4.2.1. 每个文件都是数据块的链接列表</p><p> By CFD 79</p><p> 11.2.4.2.1.1. FCB包含指向文件的第一个和最后一个块的指针，每个块都包含指向下一个块的指针，这些指针对</p><p> 用户不可见</p><p> 11.2.4.2.1.2. 因此，如果数据块是512字节，块地址（指针）需要4字节，那么用户会看到508字节的块</p><p> 11.2.4.2.2. 优点</p><p> 11.2.4.2.2.1. 简单：只需要起始地址</p><p> 11.2.4.2.2.2. 不浪费空间</p><p> 11.2.4.2.3. 缺点</p><p> 11.2.4.2.3.1. 指针所需的额外空间</p><p> 11.2.4.2.3.2. 无随机访问</p><p> 11.2.4.2.3.3. 指针分散，可靠性差，某一个FCB中指向下一FCB的地址错误，会造成严重后果</p><p> 11.2.4.2.4. 文件分配表File Allocation Table(FAT)</p><p> 11.2.4.2.4.1. 为了解决简单的链接分配问题，在每个分区的开头留出一段磁盘来包含一个包含文件系统所有指针</p><p> 的表这个表被称为文件分配表（FAT）</p><p> <strong>11.2.4.2.4.2.</strong></p><p> By CFD 80</p><p> 11.2.4.2.4.3.</p><p> 11.2.4.3. 索引分配Indexed allocation</p><p> 11.2.4.3.1. 将指向文件数据块的所有指针合并到一个位置索引块中，索引块保存数据块地址数组</p><p> 11.2.4.3.2. 优缺点</p><p> 11.2.4.3.2.1. 需要索引表</p><p> 11.2.4.3.2.2. 随机存取</p><p> 11.2.4.3.2.3. 没有外部碎片但有索引块开销的动态访问</p><p> <strong>11.2.4.3.3.</strong></p><p> 11.2.4.3.4. 索引块结构</p><p> 11.2.4.3.4.1. 链表结构</p><p> 11.2.4.3.4.2. 多级结构</p><p> 11.2.4.3.4.3. 链表和多级结构的混合</p><p> 11.2.4.3.5. UNIX文件系统的FCB结构，inode</p><p> <strong>11.2.4.3.5.1.</strong></p><p> By CFD 81</p><p> 11.2.4.3.5.2. 小到40K文件，大到TB级别文件都可以存储</p><p> 11.2.5. 空闲空间管理</p><p> 11.2.5.1. 比特向量，又叫位映射</p><p> 11.2.5.1.1. 空闲置1</p><p> 11.2.5.1.2. 被分配（占用）置0</p><p> 11.2.5.2. 链表</p><p> 11.2.5.2.1. 将所有空闲磁盘块链接在一起，并将指向第一个空闲块的指针放在磁盘上的特定位置，然后将其快速缓存</p><p> 到内存中</p><p> 11.2.5.2.2. 优缺点</p><p> 11.2.5.2.2.1. 指针（链接头除外）保存在空闲块中，占用空间小</p><p> 11.2.5.2.2.2. 遍历列表以获取空闲块是无效的，因此在开始时缓存空闲块的几个地址</p><p> <strong>11.2.5.2.3.</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2021/ji-suan-ji-ji-chu-ji-suan-ji-wang-luo/"/>
      <url>/2021/ji-suan-ji-ji-chu-ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算机网络体系结构"><a href="#1-计算机网络体系结构" class="headerlink" title="1 计算机网络体系结构"></a>1 计算机网络体系结构</h1><h2 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h2><h3 id="1-1-1-计算机网络基本概念"><a href="#1-1-1-计算机网络基本概念" class="headerlink" title="1.1.1 计算机网络基本概念"></a>1.1.1 计算机网络基本概念</h3><ul><li><strong>广义观点</strong></li></ul><p>实现远程信息处理的系统或者能进一步达到资源共享的系统。</p><ul><li><strong>资源共享观点</strong></li></ul><ol><li>以能够相互共享资源的方式互联起来的自治计算机系统的集合</li><li>目的：资源共享</li><li>组成单元：分布在不同地理位置的多台独立的“自治计算机”</li><li>网络协议：网络中计算机必须遵循的统一规则</li></ol><ul><li><strong>用户透明性观点</strong></li></ul><p>能为用户自动管理资源的网络操作系统，能够调用用户所需要的资源，整个网络就像一个大的计算机系统一样对用户是透明的。</p><h3 id="1-1-2-计算机网络的组成"><a href="#1-1-2-计算机网络的组成" class="headerlink" title="1.1.2 计算机网络的组成"></a>1.1.2 计算机网络的组成</h3><ul><li><strong>组成部分角度</strong></li></ul><ol><li>硬件：主机（端系统）、通信链路（双绞线、光纤）、交换设备（路由器、交换机）以及通信处理机（网卡等）</li><li>软件：实现资源共享的软件以及方便用户使用的各种工具软件（网络操作系统、邮件收发程序、FTP程序、聊天程序）</li><li>协议：计算机网络的核心，规定了网络传输数据遵循的规定</li></ol><ul><li><strong>工作角度</strong></li></ul><ol><li>边缘部分：所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（传输数据、音频或者视频和资源共享）。</li><li>核心部分：大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。</li></ol><ul><li><strong>功能组成角度</strong></li></ul><ol><li>通信子网：传输介质、通信设备，相应的网络协议。使得网络具有数据传输，交换，控制和存储的能力，实现联网计算机之间的数据通信。</li><li>资源子网：实现资源共享功能以及软件的集合，向网络用户提供共享其他计算机硬件、软件和数据的服务。</li></ol><h3 id="1-1-3-计算机网络的功能"><a href="#1-1-3-计算机网络的功能" class="headerlink" title="1.1.3 计算机网络的功能"></a>1.1.3 计算机网络的功能</h3><ul><li><strong>数据通信</strong></li></ul><p>最基本最重要的功能，实现联网计算机之间的信息传输，将分散的计算机联系起来。</p><ul><li><strong>资源共享</strong></li></ul><p>实现软件、硬件、数据的共享，使得计算机网络中的资源互通有无，分工协作，提高硬件、软件和数据资源的利用率。</p><ul><li><strong>分布式处理</strong></li></ul><p>将某个计算机负载过重的任务分散到多台计算机上，提高整个系统的利用率。</p><ul><li><strong>提高可靠性</strong></li></ul><p>各台计算机可通过网络互为替代机。</p><ul><li><strong>负载均衡</strong></li></ul><p>将工作任务均衡地分配给计算机网路中的各台计算机。</p><h3 id="1-1-4-计算机网络的分类"><a href="#1-1-4-计算机网络的分类" class="headerlink" title="1.1.4 计算机网络的分类"></a>1.1.4 计算机网络的分类</h3><ul><li><strong>按照分布范围分类</strong></li></ul><table><thead><tr><th>类别</th><th>范围</th><th>距离</th><th>地位</th></tr></thead><tbody><tr><td>广域网</td><td>提供长距离通信，运送主机发送的数据</td><td>几十千米到几千千米</td><td>广域网是因特网的核心部分，连接广域网各结点交换机的链路一般是高速链路，具有较大的通信容量，采用交换技术</td></tr><tr><td>城域网</td><td>跨域几个街区甚至几个城市</td><td>5-50km</td><td>多采用以太网技术</td></tr><tr><td>局域网</td><td>微机或者工作站通过高速线路相连，覆盖范围小</td><td>几十米到几千米</td><td>对计算机配置数量没有太多限制，采用广播技术</td></tr><tr><td>个人区域网</td><td>个人工作的地方将电子设备用无线技术链接起来的网络</td><td>区域直径为10m</td><td></td></tr></tbody></table><ul><li><strong>按照传输技术分类</strong></li></ul><ol><li>广播式网络</li></ol><p>所有联网计算机共享一个公共通信信道，一台计算机发送报文分组，其他计算机也能收听到这个分组（根据报文目的地址进行接收），采用广播通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。</p><ol start="2"><li>点对点网络</li></ol><p>每个物理线路连接一对计算机，计算机通过直接或者中间节点对分组进行接收，存储和转发直到目的地，采用分组存储转发机制。</p><ul><li><strong>按照拓扑结构分类</strong></li></ul><ol><li>星形网络</li></ol><p>每个终端或者计算机都以单独的线路与中央设备相连。</p><p>优点：便于集中控制和管理。</p><p>缺点：成本高，中心节点对故障敏感。</p><ol start="2"><li>总线形网络</li></ol><p>用单根传输线把计算机连接起来。</p><p>优点：建网容易，增减节点方便，节省线路。</p><p>缺点：重负载时通信效率不高，总线任意处对故障敏感。</p><ol start="3"><li>环形网络</li></ol><p>所有计算机接口设备连接成一个环。</p><p>典型：令牌环局域网。</p><ol start="4"><li>网状形网络</li></ol><p>每个节点至少有两条链路与其它节点相连，形成一个网状结构。</p><p>优点：可靠性高。</p><p>缺点：成本高，控制复杂。</p><ul><li><strong>按照使用者分类</strong></li></ul><ol><li>公用网：公众使用的网络</li><li>专用网：为满足某个部门特殊业务建立的网络（军队、电力、铁路）</li></ol><ul><li><strong>按照传输介质分类</strong></li></ul><ol><li>有线网络：双绞线网络、同轴电缆网络</li><li>无线网络：蓝牙、微波、无线电</li></ol><h3 id="1-1-5-计算机网络的标准化工作及相关组织"><a href="#1-1-5-计算机网络的标准化工作及相关组织" class="headerlink" title="1.1.5 计算机网络的标准化工作及相关组织"></a>1.1.5 计算机网络的标准化工作及相关组织</h3><ul><li><strong>生成RFC（Request For Comments）的过程</strong></li></ul><ol><li>因特网草案</li><li>建议标准</li><li>草案标准</li><li>因特网标准</li></ol><ul><li><strong>国际组织</strong></li></ul><ol><li>国际标准化组织（ISO）：OSI参考模型、HDLC等。</li><li>国际电信联盟（ITU）：远程通信标准</li><li>国际电气电子工程协会（IEEE）：802标准</li></ol><p>PS：</p><p>高级数据链路控制（High-Level Data Link Control或简称<em>HDLC</em>），是一个在同步网上传输数据、面向比特的协议的数据链路层协议，</p><p>IEEE 802 指IEEE标准中关于局域网和城域网的一系列标准。 更确切的说，IEEE 802标准仅限定在传输可变大小数据包的网络。 其中最广泛使用的有以太网、令牌环、无线局域网等。</p><h3 id="1-1-6-计算机网络的性能指标"><a href="#1-1-6-计算机网络的性能指标" class="headerlink" title="1.1.6 计算机网络的性能指标"></a>1.1.6 计算机网络的性能指标</h3><ul><li><p><strong>带宽</strong>：网络在通信线路中传送该数据的能力，单位：比特&#x2F;每秒。</p></li><li><p><strong>时延</strong>：数据从网络的一段传送到另一端所需要的总时间。</p></li></ul><ol><li>发送时延：发送分组的第一个比特开始，到最后一个比特发送结束的时间。</li></ol><p>发送时延 &#x3D; 分组长度 &#x2F; 信道带宽。</p><ol start="2"><li>传播时延：一个比特从链路的一端到另一端需要的时间。</li></ol><p>传播时延 &#x3D; 信道长度 &#x2F; 电磁波在信道上的传播速率。</p><ol start="3"><li>处理时延：数据在交换节点为存储转发而进行的一些必要的处理所花费的时间。</li></ol><p>如：分析分组的首部，从分组中提取数据部分，差错检验，寻找适当的路由器。</p><ol start="4"><li>排队时延：分组在进入路由器后，像排队一样等待被转发的时间。</li></ol><p>PS：</p><p>排队时延和处理时延一般可以忽略不计。</p><p>对于高速链路，提高的仅仅是数据发送速率而非比特在链路上的传播速率。提高数据的发送速率只是为了减少数据的发送时延。</p><ul><li><strong>时延带宽积</strong>：发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已发出的比特数。</li></ul><p>时延带宽积 &#x3D; 传播时延 * 信道带宽。</p><ul><li><p><strong>往返时延</strong>：从发送数据到接收到接收端的确认，经历的时延。</p></li><li><p><strong>吞吐量</strong>：单位时间内通过某个网络的数据量。</p></li></ul><p>受到网络带宽或者网络额定速率的限制。</p><ul><li><strong>速率</strong>：连接到计算机网络上主机在数据信道上传送数据的速率（数据率或者比特率）。最高的数据率即为带宽。</li></ul><h2 id="1-2-计算机网络体系结构与参考模型"><a href="#1-2-计算机网络体系结构与参考模型" class="headerlink" title="1.2 计算机网络体系结构与参考模型"></a>1.2 计算机网络体系结构与参考模型</h2><h3 id="1-2-1-网络分层"><a href="#1-2-1-网络分层" class="headerlink" title="1.2.1 网络分层"></a>1.2.1 网络分层</h3><ul><li><strong>原则</strong></li></ul><ol><li>每层实现一种相对独立的功能，降低系统的复杂度。</li><li>各层之间界面清晰，易于理解，相互交流少。</li><li>各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务。</li><li>整个分层结构应能促进标准化工作。</li></ol><ul><li><strong>基本概念</strong></li></ul><ol><li>实体：任何可以发送或接收信息的硬件或软件进程。</li><li>不同机器上的同一层称为对等层，同一层的实体称为对等实体。</li><li>n层实体实现的服务为n+1层所利用。</li><li>服务数据单元（SDU）：完成用户所要求的功能而传送的数据，第n层为 n-SDU。</li><li>协议控制信息（PCI）：控制层协议操作的信息，第n层为 n-PCI。</li><li>协议数据单元（PDU）：对等层次之间传送的数据单元称为该层的PDU n-PDU。</li></ol><ul><li><strong>层次结构含义</strong></li></ul><ol><li>第n层的实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向第n+1层提供本层的服务，该服务是第n层及下面提供的服务总和。</li><li>最底层只提供服务，是整个层次结构的基础，中间各层既是下一层的服务使用者，又是上一层的服务提供者，最高层面向用户提供服务。</li><li>上一层只能通过临近层的接口使用下一层的服务，而不能调用其他层的服务，下一层所提供的服务的实现细节对上一层透明。</li><li>两台主机通信时，对等层在逻辑上有一条直接通信，表现为不经过下层就把信息传送到对方。</li></ol><h3 id="1-2-2-计算机网络协议、接口、服务的概念"><a href="#1-2-2-计算机网络协议、接口、服务的概念" class="headerlink" title="1.2.2 计算机网络协议、接口、服务的概念"></a>1.2.2 计算机网络协议、接口、服务的概念</h3><ul><li><strong>协议</strong></li></ul><ol><li>控制两个或多个对等实体进行通信的规则集合，是水平的。</li><li>不对等实体之间是没有协议的。</li><li>组成：<ul><li>语法：规定了传输数据的格式。</li><li>语义：规定了要完成的功能。</li><li>同步：规定了执行各种操作的条件、时序关系。</li></ul></li><li>协议是水平的，是控制对等实体之间通信的规则。</li></ol><ul><li><strong>接口</strong></li></ul><ol><li>同一节点内相邻两层间交换信息的连接点，是一个系统内部的规定。</li><li>每层只能为紧邻的层次之间定义接口，不能跨层定义接口。</li></ol><ul><li><strong>服务</strong></li></ul><ol><li><p>下层为紧邻的上层提供的功能调用，是垂直的。</p></li><li><p>服务原语：</p><ul><li>请求（Request） 用户实体要求服务做某项工作</li><li>指示（Indication） 用户实体被告知某事件发生</li><li>响应（Response） 用户实体表示对某事件的响应</li><li>确认（Confirm） 用户实体收到关于它的请求的答复</li></ul></li><li><p>只有本层的协议的实现才能保证向上一层提供服务，本层的服务用户只能看见服务，而无法看见下面的协议。</p></li></ol><ul><li><strong>服务的分类</strong></li></ul><ol><li><strong>面向连接服务和无连接服务</strong></li></ol><p><strong>面向连接服务：</strong></p><p>通信双方必须建立连接，分配相应资源，结束后释放连接与资源（可靠服务）。</p><p>阶段：连接建立，数据传输，连接释放。</p><p>代表协议：TCP协议</p><p><strong>无连接服务：</strong></p><p>通信双方不需要建立连接，直接发送数据（不可靠服务）</p><p>尽最大努力交付（IP协议 UDP协议）</p><ol start="2"><li><strong>可靠服务和不可靠服务</strong></li></ol><p><strong>可靠服务</strong>：</p><p>网络具有纠错，检错，应答机制，保证数据正确可靠地传送到目的地。</p><p><strong>不可靠服务</strong>：</p><p>网络尽可能正确，可靠地传送，不能保证数据地正确，可靠地传送到目的地。</p><p>可靠性由应用或者用户来保障。</p><ol start="3"><li><strong>有应答服务和无应答服务</strong></li></ol><p><strong>有应答服务：</strong></p><p>接收方在收到数据后向发送方发出相应的应答，传输系统自动实现。</p><p><strong>无应答服务</strong>：</p><p>接收方收到数据后不会自动给出应答，如果需要应答就由高层实现。</p><h3 id="1-2-3-OSI参考模型"><a href="#1-2-3-OSI参考模型" class="headerlink" title="1.2.3 OSI参考模型"></a>1.2.3 OSI参考模型</h3><ul><li><strong>目的</strong>：支持异构网络系统的互联互通。</li><li><strong>资源子网</strong>：应用层、表示层、会话层</li><li>传输层：承上启下，资源子网和通信子网的桥梁</li><li><strong>通信子网</strong>：网络层、数据链路层、物理层</li></ul><h4 id="1-2-3-1-物理层"><a href="#1-2-3-1-物理层" class="headerlink" title="1.2.3.1 物理层"></a>1.2.3.1 物理层</h4><ul><li><strong>传输单位：</strong>比特流。</li><li><strong>任务：</strong>透明传输的比特流。</li><li><strong>功能：</strong>物理媒体上为数据端设备透明的传输原始比特流。</li><li>定义数据终端设备和数据通信设备的物理与逻辑连接方法，如接口的机械形状和尺寸，交换电路的数量和排列。</li><li>接口协议：EIA-232C、EIA&#x2F;TIA RS-449、CCITT的X2.1等。</li></ul><h4 id="1-2-3-2-数据链路层"><a href="#1-2-3-2-数据链路层" class="headerlink" title="1.2.3.2 数据链路层"></a>1.2.3.2 数据链路层</h4><ol><li><strong>传输单位：</strong>帧</li><li><strong>任务：</strong>将网络层传来的IP数据包组装成帧，</li><li><strong>功能：</strong>成帧、差错控制、流量控制、传输管理。差错控制是指对传输中收到干扰的信号进行检错，并对其丢弃。流量控制是指控制发送方的速度。</li><li>介质访问子层控制共享信道的访问。</li><li><strong>典型协议：</strong>SDLC、HDLC、PPP、STP、帧中继。</li></ol><h4 id="1-2-3-3-网络层"><a href="#1-2-3-3-网络层" class="headerlink" title="1.2.3.3 网络层"></a>1.2.3.3 网络层</h4><ol><li><strong>传输单位：</strong>数据报</li><li><strong>任务：</strong>把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网络上的不同主机提供通信服务。</li><li><strong>功能：</strong>流量控制、拥塞控制、差错控制、网际互联。拥塞控制是指对网络中因为来不及接收导致大量丢失的情况，网络层采取一定的错误对拥塞进行缓解。网际互联是指将大量异构网络通过路由器连接起来。</li><li><strong>典型协议：</strong>IP、IPX、ICMP、APR、PARP、OSPF</li></ol><h4 id="1-2-3-4-传输层"><a href="#1-2-3-4-传输层" class="headerlink" title="1.2.3.4 传输层"></a>1.2.3.4 传输层</h4><ol><li><strong>传输单位：</strong>报文段（TCP）或者用户数据报（UDP）</li><li><strong>任务：</strong>主机之间两个进程的相互通信。</li><li><strong>功能：</strong>端到端传输、流量控制、差错控制、服务质量、数据传输管理等服务。</li><li><strong>典型协议：</strong>TCP、UDP</li></ol><h4 id="1-2-3-5-会话层"><a href="#1-2-3-5-会话层" class="headerlink" title="1.2.3.5 会话层"></a>1.2.3.5 会话层</h4><ol><li><strong>任务：</strong>允许不同主机上的各个进程之间进行通话。</li><li><strong>功能：</strong>建立会话同步，管理主机间的会话进程（建立、管理及终止）</li><li>使用校验点恢复通信，实现数据同步。</li></ol><h4 id="1-2-3-6-表示层"><a href="#1-2-3-6-表示层" class="headerlink" title="1.2.3.6 表示层"></a>1.2.3.6 表示层</h4><ol><li><strong>任务：</strong>处理两个通信系统中交换信息的表示方式。</li><li><strong>功能：</strong>数据压缩、加密和解密、数据表示交换。</li></ol><h4 id="1-2-3-7-应用层"><a href="#1-2-3-7-应用层" class="headerlink" title="1.2.3.7 应用层"></a>1.2.3.7 应用层</h4><ol><li><strong>任务：</strong>用户与网络的界面，为特定类型的网络应用提供访问OSI环境的手段。</li><li>典型协议：FTP、SMTP、HTTP</li></ol><h3 id="1-2-4-TCP-x2F-IP模型"><a href="#1-2-4-TCP-x2F-IP模型" class="headerlink" title="1.2.4 TCP&#x2F;IP模型"></a>1.2.4 TCP&#x2F;IP模型</h3><h4 id="1-2-4-1-应用层"><a href="#1-2-4-1-应用层" class="headerlink" title="1.2.4.1 应用层"></a>1.2.4.1 应用层</h4><ol><li>对应OSI的会话层、表示层和应用层</li><li>包含所有高层协议（Telnet、FTP、DNS、SMTP、HTTP）</li></ol><h4 id="1-2-4-2-传输层"><a href="#1-2-4-2-传输层" class="headerlink" title="1.2.4.2 传输层"></a>1.2.4.2 传输层</h4><ol><li>对应OSI的传输层</li><li>实现发送端和目的端主机上的对等实体进行对话</li><li>传输控制协议（TCP）：面向连接（可靠交付）、数据传输的基本单位是报文段。</li><li>用户数据报协议（UDP）：无连接的（不可靠交付）、传输基本单位是用户数据报（尽最大努力交付）。</li></ol><h4 id="1-2-4-3-网际层"><a href="#1-2-4-3-网际层" class="headerlink" title="1.2.4.3 网际层"></a>1.2.4.3 网际层</h4><ol><li>对应OSI的网络层</li><li>将分组发送到任何网络上，选择合适的路由</li><li>不能保证有序到达，有序交付交给高层负责</li><li>定义了IP协议 IPv4、IPv6</li></ol><h4 id="1-2-4-4-网络接口层"><a href="#1-2-4-4-网络接口层" class="headerlink" title="1.2.4.4 网络接口层"></a>1.2.4.4 网络接口层</h4><ol><li>对应OSI的数据链路层和物理层</li><li>指出主机必须使用的某种协议与网络连接</li><li>作用：从主机或者结点接收IP分组，并把他们发送到指定的物理网络上</li></ol><h3 id="1-2-5-TCP-x2F-IP模型和OSI模型的比较"><a href="#1-2-5-TCP-x2F-IP模型和OSI模型的比较" class="headerlink" title="1.2.5 TCP&#x2F;IP模型和OSI模型的比较"></a>1.2.5 TCP&#x2F;IP模型和OSI模型的比较</h3><ul><li><strong>相同</strong></li></ul><ol><li>都是采用分层结构</li><li>都是基于独立的协议栈的概念</li><li>都可以解决异构网络的互联，实现不同厂家的计算机的相互通信</li></ol><ul><li><strong>不同</strong></li></ul><ol><li>OSI精确地定义了服务、接口和协议，TCP&#x2F;IP没有明确区分</li><li>OSI通用性良好，TCP&#x2F;IP是对已有协议的描述，但是不适用于其他非TCP&#x2F;IP的协议栈</li><li>OSI没有考虑多种异构网络的互联问题</li><li>网络层（网际层）：OSI中支持无连接和面向连接，TCP&#x2F;IP只有无连接的通信</li><li>传输层：OSI支持面向连接的通信，TCP&#x2F;IP支持面向连接和无连接的通信</li></ol><h3 id="1-2-6-信息传输过程"><a href="#1-2-6-信息传输过程" class="headerlink" title="1.2.6 信息传输过程"></a>1.2.6 信息传输过程</h3><ol><li>用户发送数据报</li><li>应用层：将自然语言转化为通信数据</li><li>然后开始每层都会加上SDU和PCI进行包裹包装</li><li>到达目的主机又会进行包裹拆包，将SDU和PCI一层层拆开，最终获得数据</li></ol><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2 物理层"></a>2 物理层</h1><h2 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h2><h3 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h3><ul><li><strong>数据</strong></li></ul><ol><li>传送信息的实体，是指数据的电气或者电磁表现，是数据在传输过程中的存在形式。</li><li>模拟数据（模拟信号）：连续变化的数据或者信号。</li><li>数据数据（数字信号）：取值仅允许为有限的几个离散数值的数据称为数字信号或者数字数据。</li></ol><ul><li><strong>传输方式</strong></li></ul><ol><li>串行传输：一个一个的比特按照时间顺序传输。</li><li>并行传输：多个比特通过多条通信信道同时传输。</li></ol><ul><li><strong>码元</strong></li></ul><p>一个固定时长的信号波形（数字脉冲）表示一位K进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为K进制码元，而该时长称为码元宽度。</p><ul><li><strong>信源</strong></li></ul><p>产生和发送数据的源头。</p><ul><li><strong>信道</strong></li></ul><p>发送端信源发送的信号经过变换成合适的信号后在信道上传输到信宿。</p><p>信道是信号的传输媒介。</p><p>噪声源是指信道上的噪声（对信号的干扰），及分散在通信系统其它各处的噪声的集中表示。</p><ul><li><strong>信宿</strong></li></ul><p>接收数据的终点。</p><p>PS：信源、信道、信宿是一个通信系统的组成部分。</p><ul><li><strong>信号传输形式的不同</strong></li></ul><p>传送模拟信号的模拟信道、传送数字信号的数字信道。</p><ul><li><strong>传输介质的不同</strong></li></ul><p>无线信道、有线信道</p><ul><li><strong>通信交互方式</strong></li></ul><ol><li>单工通信：只有一个方向的通信，没有反方向的交互（无线电广播、电视广播）</li><li>半双工通信：通信双方都可以发送或者接收信息，但是任何一方不能同时发送和接收信息（需要两条信道）。</li><li>全双工通信：通信双方可以同时发送和接收信息，需要两条信道。</li></ol><ul><li><strong>速率</strong></li></ul><ol><li>数据的传输速率，单位时间内传输的数据量。</li><li>码元传输速率（码元速率，波形速率）：单位时间内数字通信系统所传输的码元个数（单位是波特）。</li><li>信息传输速率（信息速率，比特率）：表示单位时间内数字通信系统传输的二进制码元个数（比特数），单位是比特&#x2F;秒。</li></ol><p>PS：波特和比特是两个不同的概念，码元传输速率也称调制速率、波形速率或符号速率。但码元传输速率与信息传输速率在数量上却又有一定的关系。若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为Mn比特&#x2F;秒。</p><ul><li><strong>带宽</strong></li></ul><p>网络的通信线路所能传输数据的能力（b&#x2F;s）。</p><h3 id="2-1-2-奈奎斯特定理与香农定理"><a href="#2-1-2-奈奎斯特定理与香农定理" class="headerlink" title="2.1.2 奈奎斯特定理与香农定理"></a>2.1.2 奈奎斯特定理与香农定理</h3><ul><li><strong>奈奎斯特（Nyquist）定理</strong></li></ul><ol><li>理想低通（没有噪声，带宽有限）的信道中，极限码元传输速率为2W波特（W是理想低通信道的带宽，单位HZ）。</li><li>结论：任何信道中，码元的传输速率是有上限的。信道的频带越宽，就可以用更高的速率进行码元的有效传输。奈氏准则给出了码元传输速率的限制，没有给出信息传输速率的限制（即一个码元可以对应多少个二进制位没有限制）。</li></ol><ul><li><strong>香农（Shannon）定理</strong></li></ul><ol><li>香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限传输速率，当用此速率进行传输时，可以做到不产生误差。</li><li>香农定理定理为：信道的极限数据传输速率 &#x3D; W*log(1+S&#x2F;N)，单位为 b&#x2F;s，式中，W为信道的带宽，S为信道所传输信号的平均速率，N为信道内部的高斯噪声功率。S&#x2F;N为信噪比，即信号的平均功率与噪声的平均功率之比。</li><li>结论：信道的带宽或者信道中的信噪比越大，信息的极限传输速率越高。对一定的传输带宽和一定的信噪比，信息传输速率的上限时确定的。只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。香农定理得出的是极限信息传输速率，实际信道的传输速率要比他低很多。</li></ol><h3 id="2-1-3-编码与调制"><a href="#2-1-3-编码与调制" class="headerlink" title="2.1.3 编码与调制"></a>2.1.3 编码与调制</h3><ul><li><strong>概念</strong></li></ul><p>调制：数据变换为模拟信号的过程。</p><p>编码：数据变换为数字信号的过程。</p><ul><li><strong>数字数据编码为数字信号</strong></li></ul><p>数字数据编码用于基带传输中，在不改变数字信号频率的情况下，直接传输数字信号。</p><ol><li>非归零编码：用两个电压来代表两个二进制数字，低电平为0，高电平为1。</li></ol><p>优点：容易实现</p><p>缺点：无法使双方同步，没有检错功能</p><ol start="2"><li>曼彻斯特编码：将一个码元分为两个相等的间隔，前一个间隔为高电平后一个间隔为低电平表示1，码元0的表示方法相反。</li></ol><p>优点：可以进行双方的同步。</p><p>缺点：占用的频带宽度是原始基带宽带的两倍。</p><p>以太网使用的编码就是曼彻斯特编码。</p><ol start="3"><li>差分曼彻斯特编码：若码元为1，前半个码元的电平与上一个码元的后半个电平相同，若码元为0，情况相反。</li></ol><p>优点：可以实现自同步，抗干扰性好</p><p>主要是用在局域网传输。</p><ol start="5"><li>48&#x2F;5B编码：将发送的数据流每4位作为一组，然后按照48&#x2F;5B编码规则将其转换为相应的5位码。</li></ol><p>5位码共有32种组合，但是只是用其中的16位对应16种不同的4位码，其他的16种作为控制码（帧的开始和结束，线路的状态信息等）或保留</p><ul><li><strong>数字数据调制为模拟信号</strong></li></ul><ol><li>幅移键控（ASK）：通过改变载波信号的振幅来表示数字信号1和0，载波的频率和相位不发生变化。比较容易实现，抗干扰能力强。</li><li>频移键控（FSK）：通过改变载波信号的频率来表示数字信号1和0，载波的振幅和相位不发生改变。容易实现，抗干扰能力强，应用广泛。</li><li>相位键控（PSK）：通过改变载波信号的相位来表示数字信号1和0，载波的振幅和频率不发生改变。又分绝对调相和相对调相。</li><li>正交振幅调制（QAM）：频率相同的前提下，将ASK和PSK结合起来，形成叠加信号。设波特率为B，采用m个相位，每个相位有n种振幅，该QAM技术的数据传输率R为 R &#x3D; B log(mn)，单位为 b&#x2F;s。</li></ol><ul><li><strong>模拟数据编码为数字信号</strong></li></ul><ol><li>采样</li></ol><p>对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。</p><p>采样频率大于等于模拟数据的频带带宽（最高变化率）的两倍</p><ol start="2"><li>量化</li></ol><p>把采样取得的电平幅值按照一定的分级标度，转化为对应的数字值并取整数。</p><p>这样就把连续的电平幅值转换为离散的数字量。</p><p>采样和量化的实质就是分割和转换。</p><ol start="3"><li>编码</li></ol><p>把量化的结果转化为与之对应的二进制编码。</p><ul><li><strong>模拟数据调制为模拟信号</strong></li></ul><p>需要较高的频率，使用频分复用（FDM）技术，充分利用带宽资源。</p><p>电话局和本地局交换机采用模拟信号传输模拟数据的编码方式。</p><p>模拟的声音数是加载到模拟的载波信号种传输的。</p><h3 id="2-1-4-电路交换"><a href="#2-1-4-电路交换" class="headerlink" title="2.1.4 电路交换"></a>2.1.4 电路交换</h3><ul><li>数据传输前，先建立起一条专用（双方独占）的物理通信路径。</li><li>直通方式传输数据。</li><li>电路交换技术的三个阶段：连接建立，数据传输，连接释放。</li><li>优点：</li></ul><ol><li>通信时延小：通信线路双方专用，传输时延非常小。</li><li>有序传输：双方通信时按发送顺序发送数据，不存在失序问题。</li><li>没有冲突：不同的通信双方有着不同的信道。</li><li>适用范围广：可以传输模拟信号，也可以传输数字信号。</li><li>实时性强：双方的物理通路一旦建立，双方就可以随时通信。</li><li>控制简单：电路交换的交换设备（交换机等）及控制均较简单。</li></ol><ul><li>缺点：</li></ul><ol><li>建立连接时间长：电路交换的平均连接建立时间对计算机通信来说时间较长。</li><li>线路独占：使用效率较低，只能供通信双方使用。</li><li>灵活性差：只要通信双方的任何一点出现故障，就必须重新建立连接。</li><li>难以规格化：数据的不同类型，不同规格，不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</li><li>无数据存储能力，难以平滑通信量。</li></ol><h3 id="2-1-5-报文交换"><a href="#2-1-5-报文交换" class="headerlink" title="2.1.5 报文交换"></a>2.1.5 报文交换</h3><ul><li>数据交换的单位是报文，报文携带有目的地址、源地址等信息。</li><li>报文交换的时候使用存储转发方式。</li><li>优点：</li></ul><ol><li>无须建立连接：不需要建立专用线路，随时可以发送报文，不存在建立连接时延。</li><li>动态分配线路：当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择一条合适的空闲线路，将报文发送出去。</li><li>提高线路的可靠性：如果某条传输路径发生故障，那么可重新选择另一条路径传输数据，因此提高了传输的可靠性。</li><li>提高线路利用率：通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通道。</li><li>提供多目标服务：一个报文可以同时发送给多个目的地址。</li></ol><ul><li>缺点：</li></ul><ol><li>数据进入交换节点后要经过存储、转发，所以存在转发时延（包括接收报文，检验正确性，排队，发送时间等）。</li><li>报文交换对报文的大小没有限制，所以网络节点要有较大的缓存空间。</li></ol><p>现在已经很少使用，多使用分组交换方式代替。</p><h3 id="2-1-6-分组交换"><a href="#2-1-6-分组交换" class="headerlink" title="2.1.6 分组交换"></a>2.1.6 分组交换</h3><ul><li>采用存储转发方式，限制了每次传送的数据块的大小上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息（源地址，目的地址，编号信息），构成分组。</li><li>网络结点根据控制信息把分组送到下一结点，下一结点收到分组后暂时保存并排队等待传输，根据分组控制信息选择它的下一个结点，直到目的结点。</li><li>采用存储转发方式。</li><li><strong>优点：</strong></li></ul><ol><li>没有建立时延：不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。</li><li>线路利用率高：通信双方不是固定占有一条通信线路，而是在不同的事件一段一段地部分占有这条物理通路。</li><li>简化了存储管理（相对于报文交换）：因为分组的长度固定，相应的缓冲区的大小也固定，在交换节点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。</li><li>加速传输：分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间；传输一个分组所需的缓冲区比传输一次报文所需的缓冲区小，这样因缓冲区不足而等待发送的概率及时间也会少。</li><li>减少了出错概率和重发数据量：分组较短，出错概率减小，重发的数据也就减少，提高了可靠性，也减少了传输时延。</li></ol><ul><li>缺点：</li></ul><ol><li>存在传输时延</li><li>需要额外的信息量：每个小数据块都要加上源地址、目的地址和分组编号等信息。</li><li>当分组交换采用数据包服务时，会出现失序，丢失或者重复分组，到达目的地后要对分组进行排序工作。</li></ol><h3 id="2-1-7-数据报服务"><a href="#2-1-7-数据报服务" class="headerlink" title="2.1.7 数据报服务"></a>2.1.7 数据报服务</h3><ul><li>网络层提供无连接服务，发送方可随时发送分组</li><li>每个分组有着完整的目的地址</li><li>每个分组独立的进行路由选择和转发</li><li>不保证分组的有序到达</li><li>不保证可靠通信，可靠性由用户来保证</li><li>出故障的节点丢失分组，其他分组路径选择不发生变化可以正常传输</li><li>由用户主机进行流量控制，不保证数据报的可靠性</li><li>分组在交换节点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换节点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换节点还可根据情况丢弃部分分组</li><li>网络具有冗余路径，当某一交换节点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障地适应能力强</li><li>适用于突发性通信，不适于长报文，会话式通信</li></ul><h3 id="2-1-8-虚电路服务"><a href="#2-1-8-虚电路服务" class="headerlink" title="2.1.8 虚电路服务"></a>2.1.8 虚电路服务</h3><ul><li>必须建立连接</li><li>仅在建立连接阶段使用，每个分组使用长度较短的虚电路信号</li><li>属于同一条虚电路的分组按照同一个路由转发</li><li>保证分组的有序到达</li><li>可靠性由网络保证</li><li>所有经过故障节点的虚电路都不能正常工作</li><li>可由分组交换网负责，也可以由用户主机负责</li></ul><h3 id="2-1-9-通信方式"><a href="#2-1-9-通信方式" class="headerlink" title="2.1.9 通信方式"></a>2.1.9 通信方式</h3><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道</li><li>半双工通信&#x2F;双向交替通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道</li><li>全双工通信&#x2F;双向同时通信：通信双方可以同时发送和接收信息，也需要两条信道</li></ol><h3 id="2-1-10-串行传输与并行传输"><a href="#2-1-10-串行传输与并行传输" class="headerlink" title="2.1.10 串行传输与并行传输"></a>2.1.10 串行传输与并行传输</h3><ul><li><strong>串行传输</strong></li></ul><ol><li>将表示一个字符的8位二进制数按由低位到高位的顺序依次发送</li><li>速度慢，费用低，适合远距离</li></ol><ul><li><strong>并行传输</strong></li></ul><ol><li>将表示一个字符的8位二进制数同时通过8条信道发送</li><li>用于计算机内部的数据传输</li><li>速度快，费用高，适合近距离</li></ol><h3 id="2-1-11-同步传输与异步传输"><a href="#2-1-11-同步传输与异步传输" class="headerlink" title="2.1.11 同步传输与异步传输"></a>2.1.11 同步传输与异步传输</h3><ul><li><strong>同步传输</strong></li></ul><ol><li>在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输</li><li>在传送数据时，需先送出一个或多个同步字符，再送出整批的数据</li></ol><ul><li><strong>异步传输</strong></li></ul><ol><li>异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达</li><li>传送数据时，加一个字符起始位和一个字符终止位</li></ol><h2 id="2-2-传输介质"><a href="#2-2-传输介质" class="headerlink" title="2.2 传输介质"></a>2.2 传输介质</h2><h3 id="2-2-1-双绞线、同轴电缆、光纤与无线传输介质"><a href="#2-2-1-双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="2.2.1 双绞线、同轴电缆、光纤与无线传输介质"></a>2.2.1 双绞线、同轴电缆、光纤与无线传输介质</h3><ul><li><strong>双绞线</strong></li></ul><ol><li><strong>简介</strong></li></ol><p>最常用的古老传输介质，由两根采用一定规则并排绞合的相互绝缘的铜导线组成。</p><p>绞合可以减少对相邻导线的电磁干扰。</p><p>屏蔽双绞线（STP）：在双绞线的外面加上一个由金属丝编织成的屏蔽层。</p><p>非屏蔽双绞线（UTP）：无屏蔽层。</p><ol start="2"><li><strong>优点</strong></li></ol><p>价格便宜。适用范围广。</p><ol start="3"><li><strong>使用范围</strong></li></ol><p>局域网、传统电话网。</p><p>模拟传输和数字传输。</p><ol start="4"><li><strong>传输距离</strong></li></ol><p>几千米到数十千米。</p><ol start="5"><li><strong>距离过大</strong></li></ol><p>模拟传输使用放大器放大衰减的信号。</p><p>数字传输使用中继器将失真的信号整形。</p><ul><li><strong>同轴电缆</strong></li></ul><ol><li>由内导体、绝缘层、网状编织屏蔽层和塑料外层构成。</li><li>50欧姆同轴电缆：主要传输基带数字信号。</li><li>75欧姆同轴电缆：主要传送宽带信号，主要用于有线电视系统</li><li>优点</li></ol><p>良好的抗干扰特性；</p><p>广泛用于传输较高速率的数据；</p><p>传输距离更远。</p><ol start="5"><li>缺点</li></ol><p>价格相对于双绞线贵。</p><ul><li><strong>光纤</strong></li></ul><ol><li>利用光导纤维传递光脉冲</li><li>利用光的全反射原理在光纤中不断的传输</li><li>多模光纤：从不同角度入射的多束光线在一条光纤中传输</li><li>单模光纤：光纤的直径减小到仅一个光波长度时，光纤就像一根波导那样，可使光线一直向前传播，而不会产生多次反射</li><li>优点</li></ol><p>传输损耗小，中继距离长，对远距离传输特别经济。</p><p>抗雷电和电磁干扰性能好。</p><p>无串音干扰，保密性好，也不容易被窃听或者截取数据。</p><p>体积小，重量轻。</p><ul><li><strong>无线传输介质</strong></li></ul><ol><li><strong>无线电波</strong></li></ol><p>无线电波具有较强的穿透能力，可以传输很长的距离，所以它被广泛应用于通信领域。</p><p>无线电波使信号向所有方向传播，因此有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接，简化了通信连接。</p><ol start="2"><li><strong>微波、红外线和激光</strong></li></ol><p>相同点：需要发送方和接收方之间存在一条视线通路，有很强的方向性，都沿直线传播，有时统称这三者为视线介质。</p><p>不同点：</p><p>（1）红外通信和激光通信要把传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p><p>（2）微波通信的频率高，频段范围宽，载波频率通常为2-40GHz，因而通信信道的容量大。</p><p>（3）微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力。</p><ol start="3"><li><strong>卫星通信</strong></li></ol><p>（1）卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面的传播距离有限，超过一定距离后就要用中继站来接力。</p><p>（2）优点：通信容量大、距离远、覆盖广</p><p>（3）缺点：端到端传播时延长，一般为250-270ms</p><h3 id="2-2-2-物理接口的特性"><a href="#2-2-2-物理接口的特性" class="headerlink" title="2.2.2 物理接口的特性"></a>2.2.2 物理接口的特性</h3><ul><li>机械特性</li></ul><p>主要定义物理连接的边界点，即接插装置。规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况等。</p><ul><li>电气特性</li></ul><p>规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。</p><ul><li>功能特性</li></ul><p>指明某条线上出现的某一电平的电压表示何种意义，接口部件的信号线（数据线、控制线、定时线等）的用途。</p><ul><li>规程特性</li></ul><p>主要定义各条物理线路的工作规程和时许关系。</p><ul><li>接口标准</li></ul><p>EIA RS-232-C、ADSL、SONET&#x2F;SDH</p><h2 id="2-3-物理层设备"><a href="#2-3-物理层设备" class="headerlink" title="2.3 物理层设备"></a>2.3 物理层设备</h2><h3 id="2-3-1-中继器"><a href="#2-3-1-中继器" class="headerlink" title="2.3.1 中继器"></a>2.3.1 中继器</h3><ul><li><strong>功能：</strong>将数字信号整形并放大再转发出去，消除信号的失真和衰减。</li><li><strong>原理：</strong>信号再生。</li><li><strong>优点：</strong>局域网环境下扩大网络规模最简单、最廉价的互联设备</li><li><strong>缺点：</strong>不能够连接两个不同速率的局域网；中继器出现故障，相邻的两个网段都会产生影响。</li></ul><p>如果网络设备具有存储转发功能，那么这个设备就可以连接两个不同的协议（不同速率的网段）。</p><ul><li><strong>限制：</strong>5-4-3规则，相互串联的中继器的个数不能超过4个，4个中继器串联的5段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段。</li></ul><p><img src="https://bkimg.cdn.bcebos.com/pic/242dd42a2834349b28c172a6c9ea15ce37d3bec9?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto" alt="5-4-3规则"></p><ul><li>与放大器对比：放大器放大的是模拟信号，原理是将衰减信号放大而不是再生。</li></ul><h3 id="2-3-2-集线器（HUB）"><a href="#2-3-2-集线器（HUB）" class="headerlink" title="2.3.2 集线器（HUB）"></a>2.3.2 集线器（HUB）</h3><ul><li><strong>功能</strong></li></ul><ol><li><p>实质是一个多端口的中继器，也可以对信号进行整形再生。</p></li><li><p>收到信号后，就将信号从其他端口发出。</p></li><li><p>如果有多端口输入，输出时就会发生冲突，数据都无效。</p></li></ol><ul><li><strong>优点</strong></li></ul><p>扩大网络的传输范围。</p><ul><li><strong>缺点</strong></li></ul><ol><li>不具有定向传送能力。</li><li>只能工作在半双工状态下。</li><li>HUB每个端口连接的网络部分是同一个网络的不同网段。</li><li>不能分割冲突域。</li><li>多台主机同时交互时，会使其工作效率降低。</li></ol><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3 数据链路层"></a>3 数据链路层</h1><h2 id="3-1-数据链路层的功能"><a href="#3-1-数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h2><h3 id="3-1-1-概要"><a href="#3-1-1-概要" class="headerlink" title="3.1.1 概要"></a>3.1.1 概要</h3><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><h3 id="3-1-2-为网络层提供服务"><a href="#3-1-2-为网络层提供服务" class="headerlink" title="3.1.2 为网络层提供服务"></a>3.1.2 为网络层提供服务</h3><p>有连接就一定要有确认，不存在无确认的面向连接的服务。</p><ul><li><strong>无确认的无连接服务</strong></li></ul><ol><li><strong>特点</strong></li></ol><p>源机器发送数据帧时不需要先建立链路连接，目的机器收到数据帧时不需要发回确认。</p><p>对丢失的帧，数据链路层不负责重发而交给上层处理。</p><ol start="2"><li><strong>使用范围</strong></li></ol><p>适用于实时通信或误码率较低的通信信道，如以太网。</p><ul><li><strong>有确认的无连接服务</strong></li></ul><ol><li><strong>特点</strong></li></ol><p>源机器发送数据帧时不需要建立链路连接，但目的机器收到数据帧时必须发回确认。</p><p>源机器在所规定的时间内未收到确认信号时，就重传丢失的帧，以提高传输的可靠性。</p><ul><li><strong>使用范围</strong></li></ul><p>适用于误码率较高的通信信道，如无线通信。</p><ul><li><strong>有确认的面向连接服务</strong></li></ul><ol><li><strong>特点</strong></li></ol><p>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。</p><p>目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧。</p><ol start="2"><li><strong>使用范围</strong></li></ol><p>适用于通信要求（可靠性、实时性）较高的场合。</p><h3 id="3-1-3-链路管理"><a href="#3-1-3-链路管理" class="headerlink" title="3.1.3 链路管理"></a>3.1.3 链路管理</h3><ul><li><strong>概述</strong></li></ul><p>链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。</p><ul><li><strong>实现过程</strong></li></ul><ol><li>首先确认对方已处理就绪状态</li><li>交换一些必要的信息以对帧序号初始化</li><li>建立连接，在传输过程中则要能维持连接，而在传输完毕后要释放该连接</li></ol><h3 id="3-1-4-帧定界、帧同步与透明传输"><a href="#3-1-4-帧定界、帧同步与透明传输" class="headerlink" title="3.1.4 帧定界、帧同步与透明传输"></a>3.1.4 帧定界、帧同步与透明传输</h3><ul><li><strong>概述</strong></li></ul><p>两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。</p><ul><li><strong>帧定界</strong></li></ul><p>将一段数据的前后分别添加首部和尾部就构成了帧。首部和尾部中含有很多控制信息，其作用是确定帧的界限。</p><ul><li><strong>帧同步</strong></li></ul><p>接收方应能从接收到的二进制比特流中区分帧的起始与终止。</p><ul><li><strong>透明传输</strong></li></ul><p>采取有效的措施解决误认为“传输结束”而丢弃后面的数据的问题。</p><h3 id="3-1-5-流量控制"><a href="#3-1-5-流量控制" class="headerlink" title="3.1.5 流量控制"></a>3.1.5 流量控制</h3><ul><li><strong>概述</strong></li></ul><p>收发双方各自的工作速率和缓存空间的差异，出现发送方的发送能力大于接收方的接收能力的现象，如不对其进行流量控制就会导致数据丢失。</p><ul><li><strong>实现</strong></li></ul><p>通过控制发送方的发送速度，从而实现流量控制。</p><h3 id="3-1-6-差错控制"><a href="#3-1-6-差错控制" class="headerlink" title="3.1.6 差错控制"></a>3.1.6 差错控制</h3><ul><li><strong>概述</strong></li></ul><p>使发送方确定接收方是否正确接收到由其发送的数据的方法。分为位错和帧错。</p><ol><li>位错：数据中的某些位出现错误。</li><li>帧错：帧的丢失、重复或失序等错误。</li></ol><ul><li><strong>解决方法</strong></li></ul><ol><li>解决位错：CRC循环冗余码</li><li>解决帧错：自动重传请求（ARQ）</li></ol><h2 id="3-2-组帧"><a href="#3-2-组帧" class="headerlink" title="3.2 组帧"></a>3.2 组帧</h2><h3 id="3-2-1-功能实现"><a href="#3-2-1-功能实现" class="headerlink" title="3.2.1 功能实现"></a>3.2.1 功能实现</h3><p>为了使接收方能正确地接收并检查所传输的帧，发送方必须依据一定的规则把网络层递交的分组封装成帧。</p><p>解决问题：帧定界、帧同步、透明传输等。</p><h3 id="3-2-2-字符计数法"><a href="#3-2-2-字符计数法" class="headerlink" title="3.2.2 字符计数法"></a>3.2.2 字符计数法</h3><ul><li><strong>实现方法</strong>：在帧头部使用一个计数字段来标明帧内字符数。</li><li><strong>缺点</strong>：如果计数字段出错，收发双方将失去同步从而导致错误。</li></ul><h3 id="3-2-3-字符填充的首尾定界符法"><a href="#3-2-3-字符填充的首尾定界符法" class="headerlink" title="3.2.3 字符填充的首尾定界符法"></a>3.2.3 字符填充的首尾定界符法</h3><ul><li><strong>实现方法</strong></li></ul><ol><li>使用一些特定的字符来定界一帧的开始（DLE STX）与结束（DLE EXT）</li><li>在特殊字符前面填充一个转义字符（DLE），防止特殊字符被误判为帧的首尾定界符。</li></ol><h3 id="3-2-4-零比特填充的首尾标志法"><a href="#3-2-4-零比特填充的首尾标志法" class="headerlink" title="3.2.4 零比特填充的首尾标志法"></a>3.2.4 零比特填充的首尾标志法</h3><ul><li><strong>实现方法</strong></li></ul><ol><li>使用一个特定的比特模式，即01111110来标志一帧的开始和结束</li><li>发送方的数据链路层在信息位中遇到5个连续的1，就自动在后面加0，防止信息位中的01111110被误判为帧的首尾标志。</li><li>接收方的数据链路层在信息位中遇到5个连续的1，就自动在后面减0，以恢复原信息。</li></ol><ul><li><strong>优点</strong></li></ul><p>零比特填充法很容易由硬件来实现，性能优于字符填充法。</p><h3 id="3-2-5-违规编码法"><a href="#3-2-5-违规编码法" class="headerlink" title="3.2.5 违规编码法"></a>3.2.5 违规编码法</h3><ul><li><strong>使用条件</strong></li></ul><ol><li>在物理层进行比特编码时，通常采用违规编码法。</li><li>违规编码法只适用于采用冗余编码的特殊编码环境。</li></ol><ul><li><strong>实现方法</strong></li></ul><p>正常情况下：曼彻斯特编码中比特”1“编码成”高-低“电平，比特”0“编码成”低-高“电平。</p><p>违规编码（没使用）：曼彻斯特编码中比特”1“编码成”高-高“电平，比特”0“编码成”低-低“电平。</p><p>借用违规编码序列来界定帧的起始和终止。</p><ul><li><strong>具体示例：</strong>局域网IEEE 802标准。</li></ul><p><strong>PS：目前较常用的组帧方法是比特填充法和违规编码法。</strong></p><h2 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><h3 id="3-3-1-概要"><a href="#3-3-1-概要" class="headerlink" title="3.3.1 概要"></a>3.3.1 概要</h3><ul><li><strong>影响因素：</strong>信道固有噪声干扰</li><li><strong>解决办法：</strong>提高信噪比</li></ul><p>但是外界的冲击噪声是产生差错的重要原因，没有办法通过提高信号幅度来降低干扰。</p><h3 id="3-3-2-利用编码技术进行差错控制"><a href="#3-3-2-利用编码技术进行差错控制" class="headerlink" title="3.3.2 利用编码技术进行差错控制"></a>3.3.2 利用编码技术进行差错控制</h3><ul><li><strong>自动重传请求ARQ</strong></li></ul><p>接收端检测出差错时，就设法通知发送端重发，直到接收到正确的码字为止。</p><ul><li><strong>前向纠错FEC</strong></li></ul><p>接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正。</p><h3 id="3-3-3-检错编码"><a href="#3-3-3-检错编码" class="headerlink" title="3.3.3 检错编码"></a>3.3.3 检错编码</h3><ul><li><p><strong>奇偶校验码</strong></p></li><li><p><strong>循环冗余码</strong></p></li></ul><p>循环冗余码具有纠错功能，只是数据链路层仅使用了它的检错功能，检测到帧出错则直接丢弃，因此放在检错编码中。</p><h3 id="3-3-4-纠错编码"><a href="#3-3-4-纠错编码" class="headerlink" title="3.3.4 纠错编码"></a>3.3.4 纠错编码</h3><ul><li><strong>海明码</strong></li></ul><p>在有效信息位中加入几个校验位形成海明码，并把海明码的每个信息位二进制位分配到几个奇偶校验组中，当某一位出错后,就会引起有关的几个校验位的值发生变化,这不但可以发现错位,而且能指出错位的位置。</p><h2 id="3-4-流量控制与可靠传输机制"><a href="#3-4-流量控制与可靠传输机制" class="headerlink" title="3.4 流量控制与可靠传输机制"></a>3.4 流量控制与可靠传输机制</h2><h3 id="3-4-1-流量控制、可靠传输与滑动窗口机制"><a href="#3-4-1-流量控制、可靠传输与滑动窗口机制" class="headerlink" title="3.4.1 流量控制、可靠传输与滑动窗口机制"></a>3.4.1 流量控制、可靠传输与滑动窗口机制</h3><p>流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧。</p><ul><li><strong>停止-等待流量控制</strong></li></ul><p>基本原理：每次只允许发送一帧,然后就陷入等待接收方确认信息的过程中，因而传输效率很低。如果接收方不反馈应答信号，那么发送方必须一直等待</p><ul><li><strong>滑动窗口流量控制</strong></li></ul><ol><li>基本原理</li></ol><p>发送方都维持一组连续的允许发送的帧的序号， 称为发送窗口。</p><p>接收方也维持一组连续的允许接收帧的序号，称为接收窗口。</p><p>发送窗口的大小代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧，用来对发送方进行流量控制。</p><p>接收方接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧，帧的序号落入接收窗口之内，将该数据帧收下，帧的序号落在接收窗口之外，则将其丢弃。</p><ol start="2"><li>滑动窗口的特性</li></ol><p>（1）只有接收窗口向前滑动(同时接收方发送了确认帧)时,发送窗口才有可能(只有发送方收到确认帧后才一定)向前滑动。</p><p>（2）从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：</p><p>① 停止-等待协议：发送窗口大小&#x3D;1，接收窗口大小&#x3D;1；</p><p>② 后退N帧协议：发送窗口大小 &gt; 1，接收窗口大小&#x3D;1；</p><p>③ 选择重传协议：发送窗口大小 &gt; 1，接收窗口大小 &gt; 1。</p><p>（3）接收窗口的大小为1时，可保证帧的有序接收。</p><p>（4）数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（与传输层的滑动窗口协议不同）。</p><ul><li><strong>可靠传输机制</strong></li></ul><ol><li>通常使用确认和超时重传两种机制</li><li>基本概念</li></ol><p>确认帧：是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。</p><p>捎带确认：为了提高传输效率，将确认捎带在一个回复帧中。</p><p>超时重传：发送方在发送某个数据帧后就开启一个计时器，一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧。直到发送成功为止。</p><p>自动重传请求（Auto Repeat reQuest）：接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法。包含三种方法：停止-等待（Stop-and-Wait）ARQ，后退N帧（Go-Back-N）ARQ，选择重传（Selective Repeat）ARQ。</p><h3 id="3-4-2-单帧滑动窗口与停止等待-协议"><a href="#3-4-2-单帧滑动窗口与停止等待-协议" class="headerlink" title="3.4.2 单帧滑动窗口与停止等待-协议"></a>3.4.2 单帧滑动窗口与停止等待-协议</h3><p>在停止-等待协议中，源站发送单个帧后必须等待确认，在目的站的回答到达源站之前，源站不能发送其他的数据帧。<strong>从滑动窗口机制的角度看，停止-等待协议相当于发送窗口和接收窗口大小均为1的滑动窗口协议。</strong></p><p>在停止-等待协议中，<strong>除数据帧丢失外，还有其他两种差错：</strong></p><ol><li><strong>到达目的站的帧可能已遭破坏</strong>，解决办法：装备计时器，计时器计满时仍未收到确认，那么再次发送相同的帧，直到该数据帧无错误达到为之。</li><li><strong>数据帧正确而确认帧被破坏</strong>，解决办法：发送方重传已被接收大数据帧，接收方收到同样的数据帧时丢弃该帧，并重传一个该帧对应的确认帧。</li></ol><p><strong>帧缓冲区：</strong></p><ol><li>目的：为了超时重发和判定重复帧的需要。</li><li>实现方法：发送端在发送完数据帧时，必须<strong>在其发送缓存中保留此数据帧的副本</strong>，这样才能在出差错时进行重传。只有在收到对方发来的确认帧ACK时 。方可清除此副本</li></ol><p><strong>帧编号：</strong></p><ol><li>由于每发送一个数据帧就停止并等待，因此用1bit来编号就足够。帧交替用0和1编号，连续出现相同序号的确认帧，代表发送端进行了超时重传，接收端收到了重复帧。</li></ol><h3 id="3-4-3-多帧滑动窗口与后退N帧协议（GBN）"><a href="#3-4-3-多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="3.4.3 多帧滑动窗口与后退N帧协议（GBN）"></a>3.4.3 多帧滑动窗口与后退N帧协议（GBN）</h3><ul><li><strong>后退N帧ARQ</strong></li></ul><ol><li>发送方连续发送帧，当接收方检测出失序的信息帧后,要求发送方<strong>重发</strong>最后一个正确接收的信息帧之后的<strong>所有未被确认的帧</strong>(累积确认)</li><li>优点：连续发送数据帧而提高了信道的利用率。</li><li>缺点：若信道的传输质量很差导致误码率较大时 ，后退N帧协议不一定优于停止-等待协议。</li></ol><ul><li><p><strong>窗口大小</strong>：n比特编号，则发送窗口的大小W，1 ≤ W ≤ 2^n-1，如果大于2^n-1，则无法区分新帧和旧帧。</p></li><li><p><strong>GBN协议重点</strong></p></li></ul><ol><li><strong>累计确认（偶尔捎带确认）：</strong>可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认信息，或者可在自己有数据要发送时才将对以前正确收到的帧加以捎带确认。</li><li>接收方只按顺序接收帧，不按序则丢弃。</li><li>确认序列号最大的、按序到达的帧。</li><li>发送窗口大小范围1 ≤ W ≤ 2^n-1。</li></ol><h3 id="3-4-4-多帧滑动窗口与选择重传协议（SR）"><a href="#3-4-4-多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="3.4.4 多帧滑动窗口与选择重传协议（SR）"></a>3.4.4 多帧滑动窗口与选择重传协议（SR）</h3><p>设法只重传出现差错的数据帧或计时器超时的数据帧，但是必须加大接收窗口，以便接收未按序但正确的帧。</p><ul><li><strong>选择重传</strong></li></ul><ol><li>每个发送缓冲区对应一个计时器（对应一个数据帧），当计时器超时时，缓冲区的帧就会重传。</li><li>一且接收方怀疑帧出错，就会发一个否定帧NAK给发送方,要求发送方对NAK中指定的帧进行重传。</li><li>接收端要设置具有相当容量的缓冲区来暂存那些未按序正确收到的帧。</li><li>优点：提高了信道的利用率</li><li>缺点：需要开辟缓存空间用来存储数据</li></ol><ul><li><strong>窗口大小</strong>：n bit 编码</li></ul><p>为了保证接收方向前移动后，新窗口与旧窗口序号没有重叠部分，必须满足：接受窗口+发送窗口  ≤ 2^n。</p><p>假定仍采用累计确认方法，并且接收窗口显然不能超过发送窗口（否则无意义），那么接收窗口尺寸不应超过序号范围的一半，所以接收窗口最大时，接收窗口大小 &#x3D; 发送窗口大小 &#x3D; 2^(n-1)，一般情况下二者也是相同的。</p><ul><li><strong>信道效率（信道利用率）</strong></li></ul><p>可从不同角度定义信道效率，给出一种从时间角度除法的定义：信道效率是对发送方而言的，是指<strong>发送方在一个发送周期的时间内，有效地发送数据所需要地时间占整个发送周期的比率。</strong></p><p>例如，发送方从开始发送数据到接收到第一个确认帧为止，称为一个发送周期，设为T，发送方在这个周期内共发送L比特的数据，发送方的传输速率为C，则发送方用于发送有效数据的时间为L&#x2F;C，此时，信道利用率为 <strong>(L&#x2F;C)&#x2F;T</strong>。</p><p><strong>信道吞吐率 &#x3D; 信道利用率 * 发送方的发送速率。</strong></p><h2 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h2><h3 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1 概述"></a>3.5.1 概述</h3><ul><li><strong>主要任务</strong></li></ul><p>为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。</p><ul><li><p><strong>介质访问控制(Medium Access Control, MAC)子层：</strong>用来决定广播信道中信道分配。</p></li><li><p><strong>常见介质访问控制方法</strong></p></li></ul><ol><li>信道划分介质访问控制（静态划分信道）</li><li>随机访问介质访问控制（动态分配信道）</li><li>轮询访问介质访问控制（动态分配i信道）</li></ol><h3 id="3-5-2-信道划分介质访问控制"><a href="#3-5-2-信道划分介质访问控制" class="headerlink" title="3.5.2 信道划分介质访问控制"></a>3.5.2 信道划分介质访问控制</h3><p>信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备。</p><ul><li><strong>多路复用技术</strong></li></ul><p>多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源。</p><p>优点：提高了信道的利用率。</p><ul><li><strong>信道划分介质访问控制分类</strong></li></ul><ol><li><strong>频分多路复用（FDM）</strong></li></ol><p>将多路基带信号调制到不同频率载波上,再叠加形成一个复合信号。</p><p>优点：充分利用传输介质的带宽,系统效率高。</p><p>不足：需要在相邻信道之间加入保护频带防止子信道相互干扰。</p><ol start="2"><li><strong>时分多路复用（TDM）</strong></li></ol><p>时分多路复用是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。</p><p>缺点：由于计算机的数据的突发性，对于子信道的利用率不高。</p><p>优化：统计时分多路复用( STDM，异步时分多路复用)，采用STDM帧，STDM帧不固定分配时隙，而是按需动态地分配时隙。</p><ol start="3"><li><strong>波分多路复用（WDM）</strong></li></ol><p>在一根光纤中<strong>传输多种不同波长(频率)的光信号</strong>，由于波长(频率)不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><p>PS：频分多路复用是调制载波信号（电磁波），波分多路复用是光信号（光波）。</p><ol start="4"><li><strong>码分多路复用（CDM）</strong></li></ol><p>采用不同的编码来区分各路原始信号的一种复用方式。与FDM和TDM不同,它既共享信道的频率，又共享时间。实际上更常用的名词是<strong>码分多址（Code Division Multiple Access，CDMA）</strong>。</p><p><strong>基本原理：</strong></p><p>（1）每个比特时间被划分成m个短的时间槽，称为码片（chip），通常m的值是64或128；</p><p>（2）每个站点被指派一个唯一的m位码片序列，发送1时发送它的码片序列，发送0时，发送该码片序列的反码；</p><p>（3）当两个或多个站点同时发送时，各路数据在信道中线性相加，接收端用各站的码片序列与相加后的码片序列（向量）进行规格化内积即可得到各站所要发送的信号。为从信道中分离出各路信号，要求站点的码片序列相互正交（规格化内积为0，其中向量中的0用-1表示）。</p><p>PS：规格化内积是指得到两个向量的内积后再除以向量的分量的个数。任何码片向量与其自身的规格化内积为1，与其反码的规格化内积为-1。</p><p><strong>优点：</strong>码分多路复用技术具有频谱利用率高、抗干扰能力强、保密性强、语音质量好等优点，还可以减少投资和降低运行成本。</p><h3 id="3-5-3-随机访问介质访问控制"><a href="#3-5-3-随机访问介质访问控制" class="headerlink" title="3.5.3 随机访问介质访问控制"></a>3.5.3 随机访问介质访问控制</h3><p>不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。</p><ol><li><strong>ALOHA协议：Additive Link On-line HAwaii system</strong></li></ol><p><strong>（1）纯ALOHA协议</strong></p><p><strong>思想：</strong>当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功</p><p><strong>缺陷：</strong>数据碰撞的概率较大，所以网络的吞吐量很低。</p><p><strong>（2）时隙ALOHA协议</strong></p><p><strong>思想：</strong>所有各站在时间上同步起来,并将时间划分为一段段等长的时隙（Slot），规定只能在每个时隙开始时才能发送一个帧。</p><p><strong>优点：</strong>避免了用户发送数据的随意性；减少了数据产生冲突的可能性；提高了信道的利用率。</p><p><strong>缺点：</strong>每个用户都是想发就发,碰撞概率还是很大。</p><ol start="2"><li><strong>CSMA协议：Carrier Sense Multiple Access，载波侦听多路访问协议</strong></li></ol><p>（1）<strong>1-坚持CSMA</strong></p><p><strong>思想：</strong>一个节点要发送数据时，首先侦听信道，如果信道空闲，那么立即发送数据；如果信道忙，那么等待，同时继续侦听直至信道空闲；如果发生冲突，那么随机等待一段时间后，再重新开始侦听信道。</p><p><strong>缺陷：</strong>传播时延对协议的性能影响较大；存在碰撞现象。</p><p>（2）<strong>非坚持CSMA</strong></p><p><strong>思想：</strong>一个节点要发送数据时，首先侦听信道，如果信道空闲，那么立即发送数据；如果信道忙,那么放弃侦听，等待一个随机的时间后再重复该过程。</p><p><strong>优点：</strong>降低了多个节点等待信道空闲后同时发送数据导致冲突的概率。</p><p><strong>缺陷：</strong>增加数据在网络中的延迟时间。</p><p>（3）<strong>p-坚持CSMA</strong></p><p><strong>思想：</strong>一个结点要发送数据时,首先帧听信道，如果信道忙，就持续侦听，直至信道空闲；如果信道空闲，那么以概率p发送数据，以1-p概率推迟到下一个时隙(依次循环)。</p><p><strong>优点：</strong>减少了冲突概率，减少了时间延迟。</p><h3 id="3-5-4-CSMA-x2F-CD协议"><a href="#3-5-4-CSMA-x2F-CD协议" class="headerlink" title="3.5.4 CSMA&#x2F;CD协议"></a>3.5.4 CSMA&#x2F;CD协议</h3><p>载波侦听多路访问&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection，CSMA&#x2F;CD）协议是CSMA协议的改进方案。</p><ul><li>适用于总线型网路或半双工网络环境</li><li>思想：发送数据时先广播告知其他节点在某段时间内不要发送数据，以免出现碰撞。</li><li><strong>工作流程：先听后发，边听边发，冲突停发，随机重发</strong></li></ul><ol><li>适配器从网络层获得一个分组，封装成以太网帧，放入适配器的缓存，准备发送；</li><li>如果适配器侦听到信道空闲，那么它开始发送该帧。如果适配器侦听到信道忙，那么持续侦听直至信道上没有信号能量，然后开始发送该帧；</li><li>在发送过程中，适配器持续检测信道。若一直未检测到碰撞，则顺利地把这个帧发送完毕。若检测到碰撞，则终止数据的发送，并发送一个拥塞信号，以让用户都知道。</li><li>在中止发送后，适配器就执行指数退避算法，等待一段随机时间后返回到步骤（2）。</li></ol><ul><li><strong>最小帧长</strong></li></ul><p>为了保证发送站在发送数据的同时能检测到可能存在的碰撞，需要<strong>在发送完帧之前就能正确接受到冲突发生的信号</strong>，即帧的传输时延至少要两倍于信号在总线中的传播时延，所以CSMA&#x2F;CD总线网中的所有数据帧都必须要大于一个最小帧长。任何站点收到帧长小于最小帧长的帧时，就把它当作无效帧立即丢弃。</p><p>最小帧长 &#x3D; 总线传播时延 * 数据传输率 * 2</p><ul><li><strong>二进制指数退避算法</strong></li></ul><ol><li>确定基本退避时间，一般取两倍的总线端到端传播时延（争用期）</li><li>定义参数k，它等于重传次数，但k不超过10，即 k &#x3D; min(重传次数，10)。</li><li>从离散的整数集合中[0, 1, … , 2^k-1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间。r * 2 * 争用期。</li><li>当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li></ol><p>优点：重传需要推迟的平均时间随重传次数的增大而增大,降低发生碰撞的概率，有利于整个系统的稳定。</p><ul><li><strong>基本概念总结</strong></li></ul><ol><li>载波侦听多路访问&#x2F;碰撞检测协议是CSMA协议的改进方案。</li><li>载波侦听：发送前先侦听，即每个站在发送数据之前先要检测一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时再发送</li><li>碰撞检测：就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站点是否也在发送数据</li><li>争用期（冲突窗口，碰撞窗口）：以太网端到端的往返时间，只有度过了争用期才能确定本次传输不会发生冲突。</li></ol><h3 id="3-5-5-CSMA-x2F-CA协议"><a href="#3-5-5-CSMA-x2F-CA协议" class="headerlink" title="3.5.5 CSMA&#x2F;CA协议"></a>3.5.5 CSMA&#x2F;CA协议</h3><ul><li>CSMA&#x2F;CD协议适用于使用有线连接的局域网，无线局域网不能使用CSMA&#x2F;CD协议</li></ul><ol><li><p>接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度的动态变化范围很大。</p></li><li><p>而且并非所有的站点都能够听见对方, 存在“隐蔽站”问题。</p></li></ol><ul><li><strong>思想：</strong>发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免出现碰撞。”碰撞避免“并不是指协议可以完全避免碰撞，而是指协议的设计要尽量降低碰撞发生的概率。</li><li>802.11标准定义了广泛应用于无线局域网的CSMA&#x2F;CA协议，使用链路层确认&#x2F;重传（ARQ）方案，即站点每通过无线局域网发送完一帧，就要在收到对方确认帧后才能继续发送下一帧。</li><li>为了尽量避免碰撞，802.11规定，<strong>所有站完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间称为帧间间隔（InterFrame Space，IFS）</strong>。帧间间隔的长短取决于该站要发送的帧的类型。802.11使用3中IFS：</li></ul><ol><li>SIFS（短IFS）：最短的IFS，用来分隔属于一次对话的各帧，使用SIFS的帧类型有ACK帧、CTS帧、分片后的数据帧，以及所有回答AP探询的帧等。</li><li>PIFS（点协调IFS）：中等长度的IFS，在PCF操作中使用。</li><li>DIFS（分布式协调IFS）：最长的IFS，用于异步帧竞争访问的时延。</li></ol><ul><li><strong>CSMA&#x2F;CA退避算法</strong></li></ul><p>信道从忙态变成空闲态时，任何一个站要发送数据帧，不仅要等待一个时间间隔，而且要进入争用窗口，计算随机退避时间以便再次试图接入信道，因此降低了碰撞发生的概率。当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不是用退避算法。其他所有情况都必须使用退避算法，具体为：① 在发送第一个帧前检测到信道忙； ② 每次重传； ③ 每次成功发送后要发送下一帧。</p><ul><li><strong>CSMA&#x2F;CA算法</strong></li></ul><ol><li>若站点最初有数据要发送（而不是发送不成功再进行重传），且检测到信道空闲，在等待DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA&#x2F;CA退避算法，选取一个随机退回值。一旦检测到信道忙，退避计时器就保持不变。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器减到0时（此时信道只可能是空闲的），站点就发送整个帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧倍目的站正确接收。这时如果要发送第二帧，就要从步骤2开始。</li><li>若发送站在规定时间内没有收到确认帧ACK（由重传计时器控制），就必须重传该帧再次使用CSMA&#x2F;CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。</li></ol><ul><li><strong>处理隐蔽站问题：RTS和CTS</strong></li></ul><p>预约信道：发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度（发送方发送RTS控制帧），让其他站点在这段时间内不发送数据（接收方发送CTS广播，给源站明确的发送许可，同时指示其他站点在预约期不要发送），避免碰撞。</p><h3 id="3-5-6-CSMA-x2F-CD与CSMA-x2F-CA区别"><a href="#3-5-6-CSMA-x2F-CD与CSMA-x2F-CA区别" class="headerlink" title="3.5.6 CSMA&#x2F;CD与CSMA&#x2F;CA区别"></a>3.5.6 CSMA&#x2F;CD与CSMA&#x2F;CA区别</h3><ul><li>CSMA&#x2F;CD可以检测冲突，但无法避免; CSMA&#x2F;CA发送包的同时不能检测到信道上有无冲突</li><li>传输介质不同，CSMA&#x2F;CD用于总线形以太网，CSMA&#x2F;CA用于无线局域网802.1 la&#x2F;b&#x2F;g&#x2F;n等</li><li>检测方式不同，CSMA&#x2F;CD通过电缆中的电压变化来检测，而CSMA&#x2F;CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式</li></ul><h3 id="3-5-7-轮询访问介质访问控制：令牌传递协议"><a href="#3-5-7-轮询访问介质访问控制：令牌传递协议" class="headerlink" title="3.5.7 轮询访问介质访问控制：令牌传递协议"></a>3.5.7 轮询访问介质访问控制：令牌传递协议</h3><ul><li>通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配</li><li>令牌在固定次序中转圈，拿到令牌就可以发送数据</li><li>适用于负载很高的广播信道</li></ul><h2 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h2><h3 id="3-6-1-基本概念"><a href="#3-6-1-基本概念" class="headerlink" title="3.6.1 基本概念"></a>3.6.1 基本概念</h3><p>在一个较小的地理范围(如一所学校)内。将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起來，组成资源和信息共享的计算机互联网络。</p><ul><li><strong>特点</strong></li></ul><ol><li>为一个单位所拥有,且地理范围和站点数目均有限</li><li>所有站点共享较高的总带宽(即较高的数据传输率)</li><li>较低的时延和较低的误码率</li><li>各站为平等关系而非主从关系</li><li>能进行广播和组播</li></ol><ul><li>局域网的特性主要是由三个要素决定：<strong>拓扑结构、传输介质、介质访问控制方式</strong>，最重要的是介质访问控制方式，它决定着局域网的技术特性</li><li><strong>常见的局域网拓扑结构</strong></li></ul><ol><li>星形结构</li><li>环形结构</li><li>总线形结构</li><li>星形和总线型结合的复合型结构</li></ol><ul><li><strong>传输介质</strong></li></ul><p>双绞线、铜缆和光纤，双绞线为主流传输介质。</p><ul><li><strong>介质访问控制方法</strong></li></ul><ol><li><p>总线型局域网：CSMA&#x2F;CD、令牌总线</p></li><li><p>环形局域网：令牌环</p></li></ol><ul><li><strong>局域网拓扑实现</strong></li></ul><ol><li>以太网：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构</li><li>令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构</li><li>FDDI（光纤分布数字接口）：逻辑拓扑是环形结构，物理拓扑是双环结构</li></ol><ul><li><strong>逻辑链路控制（LLC）子层</strong></li></ul><p>向网络层提供无确认连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型。</p><ul><li><strong>媒体介入控制（MAC）子层</strong></li></ul><p>向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括：组帧和拆卸帧、比特传输、差错检测、透明传输</p><h3 id="3-6-2-以太网与IEEE-802-3"><a href="#3-6-2-以太网与IEEE-802-3" class="headerlink" title="3.6.2 以太网与IEEE 802.3"></a>3.6.2 以太网与IEEE 802.3</h3><p>采用总线形拓扑结构。</p><ul><li><strong>简化通信</strong></li></ul><ol><li>采用无连接的工作方式（尽最大努力交付）</li><li>差错的纠正由高层完成</li></ol><ul><li><strong>传输介质的适用情况</strong></li></ul><p><img src="http://img.fdchen.host/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E7%9A%84%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5.png" alt="image-20210814132922540"></p><ul><li><strong>网卡</strong></li></ul><ol><li>局域网中连接计算机和传输介质的接口</li><li>功能：</li></ol><p>（1）实现与局域网传输介质之间的物理连接和电信号匹配。</p><p>（2）实现帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能。</p><ul><li><strong>介质访问控制（MAC）地址</strong></li></ul><ol><li>网卡在出厂时都有一个唯一的代码</li><li>用于控制主机在网络上的数据通信</li></ol><ul><li><strong>以太网的MAC帧</strong></li></ul><ol><li>网卡从网络上每收到一个MAC帧，首先要用硬件检查MAC帧中的MAC地址，如果是发往本站的帧，那么就收下，否则丢弃</li><li>结构组成：</li></ol><p>（1）地址：通常使用6字节( 48bit )地址</p><p>（2）类型：2字节，指出数据域中携带的数据应交给哪个协议实体处理</p><p>（3）数据：46-1500字节，包含高层的协议消息。由于CSMA&#x2F;CD算法的限制，以太网帧必须满足最小长度要求64字节,数据较少时必须加以填充( 0-46字节)</p><p>（4）填充：0-46字节，当帧长太短时填充帧，使之达到64字节的最小长度</p><p>（5）校验码( FCS)：采用CRC循环冗余码</p><h3 id="3-6-3-高速以太网"><a href="#3-6-3-高速以太网" class="headerlink" title="3.6.3 高速以太网"></a>3.6.3 高速以太网</h3><ul><li><strong>100BASE-T 以太网</strong></li></ul><ol><li>在双绞线上传送100Mb&#x2F;s基带信号的星形拓扑结构以太网</li><li>使用CSMA&#x2F;CD协议(半双工)</li><li>支持全双工方式，支持半双工方式.</li></ol><ul><li><strong>吉比特以太网</strong></li></ul><ol><li>在1Gb&#x2F;s下用全双工和半双工两种方式工作 </li><li>半双工方式下使用CSMA&#x2F;CD协议</li></ol><ul><li><strong>10吉比特以太网</strong></li></ul><ol><li>使用光纤作为传输媒体</li><li>只工作在全双工方式，因此没有争用问题，也不使用CSMA&#x2F;CD协议</li></ol><h3 id="3-6-4-IEEE-802-11"><a href="#3-6-4-IEEE-802-11" class="headerlink" title="3.6.4 IEEE 802.11"></a>3.6.4 IEEE 802.11</h3><p>IEEE 802.11是无线局域网的一系列协议标准，包括802.11a和802.11b等，它们制定了MAC层协议,运行在多个物理层标准上。</p><ul><li><strong>有固定基础设施无线局域网</strong></li></ul><ol><li>802.11标准规定无线局域网的最小构件是基本服务集(BSS)</li><li>组成：一个基本服务集包括一个基站和若干移动站</li><li>所有的站在本BSS内都可以直接通信，但在与本BSS外的站通信时都要通过本BSS的基站</li></ol><ul><li><strong>无固定基础设施无线局域网自组织网络</strong></li></ul><ol><li>由一些平等状态移动站相互通信组成的临时网络，各结点之间地位平等，中间结点都为转发结点，这些结点都具有路由器功能。</li><li>移动自组织网络把移动性扩展到无线领域中的自治系统，具有自己特定的路由选择协议，井且可以不和因特网相连。</li></ol><h3 id="3-6-5-令牌环网的基本原理"><a href="#3-6-5-令牌环网的基本原理" class="headerlink" title="3.6.5 令牌环网的基本原理"></a>3.6.5 令牌环网的基本原理</h3><p>令牌环网的每一站通过电缆与环接口干线耦合器(TCU)相连。TCU的主要作用是传递所有经过的帧，为接入站发送和接收数据提供接口。</p><ul><li><strong>控制机制</strong></li></ul><ol><li>分布式控制模式的循环方法</li><li>拿到令牌就可以占有信道发送数据</li></ol><ul><li><strong>物理上采用星形拓扑结构，但逻辑上仍是环形拓扑结构</strong></li></ul><h3 id="3-7-广域网"><a href="#3-7-广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h3><h3 id="3-7-1-广域网基本概念"><a href="#3-7-1-广域网基本概念" class="headerlink" title="3.7.1 广域网基本概念"></a>3.7.1 广域网基本概念</h3><p>通常是覆盖范围很广的长距离网络，广域网由节点交换机以及连接这些交换机的链路组成，节点交换机用来将分组存储和转发。</p><h3 id="3-7-2-广域网与局域网对比"><a href="#3-7-2-广域网与局域网对比" class="headerlink" title="3.7.2 广域网与局域网对比"></a>3.7.2 广域网与局域网对比</h3><table><thead><tr><th>类型</th><th>广域网</th><th>局域网</th></tr></thead><tbody><tr><td>覆盖范围</td><td>很广，通常跨区域</td><td>较小，通常在一个区域内</td></tr><tr><td>连接方式</td><td>点到点连接</td><td>多点接入</td></tr><tr><td>OSI层次</td><td>物理层、数据链路、网络层</td><td>物理层、数据链路层</td></tr><tr><td>着重点</td><td>强调资源共享</td><td>强调数据传输</td></tr></tbody></table><h3 id="3-7-3-PPP协议（Point-to-Point-Protocol）"><a href="#3-7-3-PPP协议（Point-to-Point-Protocol）" class="headerlink" title="3.7.3 PPP协议（Point-to-Point Protocol）"></a>3.7.3 PPP协议（Point-to-Point Protocol）</h3><ul><li><strong>概要</strong></li></ul><p>使用串行线路通信的面向字节的协议，该协议应用在直接连接两个结点的链路上。</p><ul><li><strong>目的</strong></li></ul><p>主要是用来通过拨号或专线方式建立点对点连接发送数据。</p><ul><li><strong>背景</strong></li></ul><p>SLIP主要完成数据报的传送。但没有寻址、数据检验、分组类型识别和数据压缩等功能，只能传送IP分组。</p><p>PPP协议是在SLIP协议的基础上发展而来的,它既可以在异步线路上传输，又可在同步线路上使用；不仅用于Modem链路，也用于租用的路由器到路由器的线路。</p><ul><li><strong>组成部分</strong></li></ul><ol><li>链路控制协议(LCP)：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</li><li>网络控制协议(NCP)：PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li><li>一个将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元(MTU)的限制。</li></ol><ul><li><strong>注意</strong></li></ul><ol><li>PPP提供差错检测但不提供纠错功能只保证无差错接收 (通过硬件进行CRC校验)，它是不可靠的传输协议，因此也不使用序号和确认机制。</li><li>它仅支持点对点的链路通信,不支持多点线路。</li><li>PPP只支持全双工链路。</li><li>PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信。</li><li>PPP是面向字节的，当信息字段出现和标志字段一致的比特组合时，PPP有两种不同的处理方法：若PPP用在异步线路(默认) , 则采用字节填充法；若PPP用在SONET&#x2F;SDH等同步线路，则协议规定采用硬件来完成比特填充(和HDLC的做法一样)。</li></ol><h3 id="3-7-4-HDLC协议（High-level-Data-Link-Control）"><a href="#3-7-4-HDLC协议（High-level-Data-Link-Control）" class="headerlink" title="3.7.4 HDLC协议（High-level Data Link Control）"></a>3.7.4 HDLC协议（High-level Data Link Control）</h3><ul><li><strong>概要</strong></li></ul><ol><li>数据报文可透明传输，用于实现透明传输的0比特插入法易于硬件实现。</li><li>全双工通信，有较高的数据链路传输效率。</li><li>传输控制功能与处理功能分离，具有较大的灵活性。</li><li>所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重发，传输可靠性高。</li></ol><p>PS：”0比特插入法“是指零比特填充的首尾标志法。</p><ul><li><strong>两种配置方式</strong></li></ul><ol><li>非平衡配置的特点是由一个主站控制整个链路的工作。</li><li>平衡配置的特点是链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要得到对方复合站的允许。</li></ol><ul><li><strong>站类型</strong></li></ul><ol><li><strong>主站：</strong>负责控制链路的操作,主站发出的帧称为命令帧。</li><li><strong>从站：</strong>受控于主站,按主站的命令进行操作，发出的帧称为响应帧。</li><li><strong>复合站：</strong>可以发出命令帧和响应帧。</li></ol><ul><li><strong>数据操作方式</strong></li></ul><ol><li><strong>常响应方式：</strong>这是一种非平衡结构操作方式，即主站向从站传输数据，从站响应传输，但从站只有在收到主站的许可后，才可进行响应。</li><li><strong>异步平衡方式：</strong>这是一种平衡结构操作方式。在这种方式中，每个复合站都可以进行对另一站的数据传输。</li><li><strong>异步响应方式：</strong>这是一种非平衡结构操作方式。在这种方式中，从站即使未受到主站的允许，也可进行传输。</li></ol><ul><li><strong>HDLC帧</strong></li></ul><ol><li>信息帧(D)：第1位为0，<strong>用来传输数据信息，或使用捎带技术对数据进行确认</strong>。</li><li>监督帧(S)：第1、2位分别为1、0，<strong>用于流量控制和差错控制</strong>，执行对信息帧的确认、请求重发和请求暂停发送等功能。</li><li>无编号帧(U)：第1、2位均为1，<strong>用于提供对链路的建立、拆除等多种控制功能</strong>。</li></ol><h2 id="3-8-数据链路层设备"><a href="#3-8-数据链路层设备" class="headerlink" title="3.8 数据链路层设备"></a>3.8 数据链路层设备</h2><h3 id="3-8-1-网桥的概念及其基本原理"><a href="#3-8-1-网桥的概念及其基本原理" class="headerlink" title="3.8.1 网桥的概念及其基本原理"></a>3.8.1 网桥的概念及其基本原理</h3><p>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段。网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域。</p><p>PS：网桥处理数据的对象是帧，所以它是工作在数据链路层的设备，中继器、放大器处理数据的对象是信号，所以它是工作在物理层的设备。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/77c6a7efce1b9d16bd8ee8c4f4deb48f8d5464cd?x-bce-process=image/resize,m_lfit,w_1054,limit_1/format,f_auto" alt="网桥示意图"></p><ul><li><strong>基本特点</strong></li></ul><ol><li>具备寻址和路径选择能力，可以确定帧的传输方向。</li><li>从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧。</li><li>网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换。</li><li>网桥对接收到的帧不做任何修改，或只对帧的封装格式做很少的修改。</li><li>可以把原协议的信息段的内容作为另一种协议的信息部分封装在帧中。</li><li>有足够大的缓冲空间。</li></ol><ul><li><strong>优点</strong></li></ul><ol><li>能过滤通信量</li><li>扩大了物理范围</li><li>可使用不同的物理层</li><li>可互联不同类型的局城网</li><li>提高了可靠性</li><li>性能得到改善</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>增大了时延</li><li>只适用于用户数不多和通信量不大的网络</li><li>没有流量控制功能（流量控制需要用到编号机制，编号机制的实现在LLC子层）</li><li>不同MAC子层的网段桥接在一起需要进行帧格式转换</li></ol><h3 id="3-8-2-路径选择算法"><a href="#3-8-2-路径选择算法" class="headerlink" title="3.8.2 路径选择算法"></a>3.8.2 路径选择算法</h3><ul><li><strong>透明网桥（选择的不是最佳路由）</strong></li></ul><ol><li><p><strong>建立转发表，采用自学习算法处理收到的帧。</strong></p></li><li><p><strong>工作原理：</strong></p></li></ol><p>（1）如果源LAN和目的LAN相同，那么丢弃该帧</p><p>（2）如果源LAN和目的LAN不同，那么转发该帧</p><p>（3）如果目的LAN未知，那么扩散该帧</p><ol start="3"><li><strong>网桥自学习和转发帧的一般步骤：</strong></li></ol><p>（1）网桥收到一帧后先进行自学习。查找转发表中与收到数据帧的源地址有无匹配的项目。如果没有，就在转发表中增加一个项目（记录数据帧的源地址，进入网桥的接口和时间）。如果有，则把原来的项目进行更新。</p><p>（2）转发帧。查找转发表中与收到数据帧的目的地址有无相匹配的项目。如果没有，则通过其他的接口（但进入网桥的接口除外）进行转发。如果有，则按转发表中给出的接口进行转发。但应当注意，若转发表中给出的接口就是该帧进入网桥的接口，则应该丢弃这个数据帧（因为这种情况不需要经过网桥进行转发）。</p><p>（3）使用生成树算法，即互连载一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站点之间只有一条路径。</p><ul><li><strong>源路由网桥（选择的是最佳路由）</strong></li></ul><ol><li>路由选择由发送数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行接收和转发。</li><li><strong>源路由的生成过程：</strong>源站以广播方式向目的站发送一个发现帧( Discovery Frame )作为探测之用，途中的每个网桥都转发此帧，最终该发现帧可能从多个途径到达目的站，目的站也将一一发送应答帧，每个应答帧都将通过原路径返回，途经的网桥把自己的标志记录在应答帧中，源站选择出一个最佳路由。</li><li><strong>缺陷：</strong>如果发现帧过多，会导致网络出现阻塞。</li></ol><p>PS：<strong>最佳路由并不是经过路由器最少的路由，而可以是发送帧往返时间最短的路由</strong>，这样才能真正地进行负载平衡。</p><h3 id="3-8-3-局域网交换机及其工作原理"><a href="#3-8-3-局域网交换机及其工作原理" class="headerlink" title="3.8.3 局域网交换机及其工作原理"></a>3.8.3 局域网交换机及其工作原理</h3><ul><li><strong>局域网交换机</strong></li></ul><p>又称以太网交换机，从本质上说，以太网交换机是一一个多端口的网桥。能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽。</p><p><strong>优点：</strong></p><ol><li>对工作站是透明的，管理开销低廉。</li><li>简化了网络结点的增加、移动和网络变化的操作。</li><li>方便地实现虚拟局域网(VLAN)，VLAN可以隔离冲突域，而且可以隔离广播域。</li></ol><ul><li><strong>原理</strong></li></ul><p>检测从以太端口来的数据帧的源和目的地的MAC (介质访问层)地址，然后与系统内部的动态查找表进行比较。若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</p><ul><li><strong>特点</strong></li></ul><ol><li>每个端口都直接与单台主机相联（普通网桥端口往往连接到以太网的一个网段），并且一般工作在全双工方式</li><li>能同时连通多对端口，使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据</li><li>转发表也是通过自学习算法自动地逐渐建立起来的</li><li>使用了专用的交换结构芯片。因此交换速率较高</li><li>（一个用户在通信时）独占传输媒体的带宽，而不是跟其他用户共享带宽</li></ol><p>PS：对于10 Mb&#x2F;s的端口，半双工端口带宽为 10 Mb&#x2F;s，全双工端口带宽为 20 Mb&#x2F;s。</p><p>拥有N对 10 Mb&#x2F;s 端口的交换机可同时支持N对节点同时进行半全双工通信，所以总的容量为 N*10 Mb&#x2F;s，注意是 N对，即2*N个端口。</p><ul><li><strong>两种交换模式</strong></li></ul><ol><li><strong>直通式交换机</strong>：只检查帧的目的地址,数据帧可以马上就被传输出去</li></ol><p>优点：速度快。<br>缺点：缺乏智能性和安全性，也无法支持具有不同速率的端口的交换。</p><ol start="2"><li><strong>存储转发式交换机</strong>：先将接收到的帧缓存，然后并检查数据是否正确，正确就发送出去，发现帧有错，那么就将其丢弃</li></ol><p>优点：可靠性高，并能支持不同速率端口间的转换。</p><p>缺点：延迟较大。</p><ul><li><strong>交换机与网桥的区别</strong></li></ul><ol><li><strong>端口数量区别。</strong>交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即<strong>网桥一般分有两个端口，而交换机具有高密度的端口。</strong> </li><li><strong>分段能力区别</strong>。由于交换机能够支持多个端口，因此可以把网络系统划分成为更多的物理网段，这样使得整个网络系统具有更高的带宽。而网桥仅仅支持两个端口，所以，<strong>网桥划分的物理网段是相当有限的</strong>。 </li><li><strong>传输速率区别。</strong>交换机与网桥数据信息的传输速率相比，<strong>交换机要快于网桥</strong>。 </li><li><strong>数据帧转发方式的区别 <strong>。</strong>网桥在发送数据帧前，通常要接收到完整的数据帧并执行帧检测序列FCS后，才开始转发该数据帧。</strong>交换机具有存储转发和直接转发两种帧转发方式。直接转发方式在发送数据以前，不需要在接收完整个数据帧和经过32bit循环冗余校验码CRC的计算检查后的等待时间。</li></ol><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4 网络层"></a>4 网络层</h1><h2 id="4-1-网络层的功能"><a href="#4-1-网络层的功能" class="headerlink" title="4.1 网络层的功能"></a>4.1 网络层的功能</h2><h3 id="4-1-1-异构网络互联"><a href="#4-1-1-异构网络互联" class="headerlink" title="4.1.1 异构网络互联"></a>4.1.1 异构网络互联</h3><ul><li><strong>异构网络</strong></li></ul><p>不同的寻址方案，不同的网络接入机制、不同的差错处理方法，不同的路由选择机制等。</p><ul><li><strong>网络互联</strong></li></ul><p>将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备(即中间设备)相互连接起来，以构成更大的网络系统。</p><ul><li><strong>中继系统</strong></li></ul><ol><li>物理层中继系统：中继器，集线器(Hub)</li><li>数据链路层中继系统：网桥或交换机</li><li>网络层中继系统：路由器、TCP&#x2F;IP体系在网络互联上采用的做法式在网络层（IP层）采用标准化协议，相互连接的网络可以是异构的</li><li>网络层以上的中继系统：网关</li></ol><p>PS：使用物理层或数据链路层的中继系统时，只是把一个网络扩大了,而从网络层的角度看，它仍然是同一个网络，一般并不称之为网络互联。</p><ul><li><strong>虚拟互联网络</strong></li></ul><p>也就是逻辑互联网络，即互连起来的各种物理网络的异构本来是客观存在的，但是通过使用IP就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。</p><h3 id="4-1-2-路由与转发"><a href="#4-1-2-路由与转发" class="headerlink" title="4.1.2 路由与转发"></a>4.1.2 路由与转发</h3><p>功能：</p><ul><li><strong>路由选择（确定哪一条路径）</strong></li></ul><p>根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表按照复杂的分布式算法。根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。</p><ul><li><strong>分组转发（当一个分组到达时所采取的动作）</strong></li></ul><p>处理通过路由器的数据流。关键操作是转发表查询、转发及相关的队列管理和任务调度等。</p><p>路由器根据转发表将用户的IP数据报从合适的端口转发出去。</p><h3 id="4-1-3-拥塞控制"><a href="#4-1-3-拥塞控制" class="headerlink" title="4.1.3 拥塞控制"></a>4.1.3 拥塞控制</h3><p>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞。</p><ul><li><strong>判断拥塞状态的方法</strong></li></ul><ol><li>轻度拥塞：随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量。</li><li>拥塞状态：网络的吞吐量随着网络负载的增大而下降。</li><li>死锁状态：网络的负载继续增大，而网络的吞吐量下降到零。</li></ol><ul><li><strong>避免拥塞现象</strong></li></ul><p>获取网络中发生拥塞的信息，从而利用这些信息进行控制。以避免由于拥塞而出现分组的丢失，以及严重拥塞而产生网络死锁的现象。</p><ul><li><strong>作用</strong></li></ul><p>确保子网能够承载所达到的流量。</p><ul><li><strong>实现方法</strong></li></ul><ol><li>这是一个全局过程，合理优化主机，路由器及路由器内部的转发处理过程等。</li><li>单一地增加资源井不能解决拥塞。</li></ol><ul><li><strong>流量控制和拥塞控制的区别</strong></li></ul><ol><li>流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。</li></ol><ul><li><strong>拥塞控制的方法</strong></li></ul><ol><li><strong>开环控制</strong></li></ol><p>设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</p><p>优点：一种静态的预防方法，一旦整个系统启动并运行，中途就不再需要修改。</p><ol start="2"><li><strong>闭环控制</strong></li></ol><p>事先不考虑有关发生拥塞的各种因素，用监测网络系统去监视，及时检查出哪里发生了拥塞，然后将拥塞信息传到合适的地方。</p><p>优点：基于反馈环路的概念，是一种动态的方法。</p><h2 id="4-2-路由算法"><a href="#4-2-路由算法" class="headerlink" title="4.2 路由算法"></a>4.2 路由算法</h2><h3 id="4-2-1-静态路由与动态路由"><a href="#4-2-1-静态路由与动态路由" class="headerlink" title="4.2.1 静态路由与动态路由"></a>4.2.1 静态路由与动态路由</h3><ul><li><strong>静态路由算法（又称非自适应路由算法）</strong></li></ul><ol><li><strong>概念：</strong>由网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。</li><li><strong>优点：</strong>简便、可靠,在负荷稳定、拓扑变化不大的网络中运行效果很好。</li><li><strong>缺陷：</strong></li></ol><p>（1）大型和复杂的网络环境通常不宜采用</p><p>（2）管理员难以全面了解网络拓扑结构</p><p>（3）发生变化后需要大范围修改和调整路由信息</p><ol start="4"><li><strong>适用范围：</strong>广泛用于高度安全的军事系统和较小的商业网络。</li></ol><ul><li><strong>动态路由算法（又称自适应路由算法）</strong></li></ul><ol><li><strong>概念：</strong>路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的。路由信息会在一 定时间间隙里不断更新。以适应不断变化的网络，随时获得最优的寻路效果。</li><li><strong>优点：</strong>改善网络的性能并有助于流量控制。</li><li><strong>缺点：</strong></li></ol><p>（1）算法复杂，会增加网络的负担</p><p>（2）对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性</p><h3 id="4-2-2-动态路由算法"><a href="#4-2-2-动态路由算法" class="headerlink" title="4.2.2 动态路由算法"></a>4.2.2 动态路由算法</h3><ul><li><strong>距离-向量路由算法</strong></li></ul><ol><li><p><strong>原理：</strong>所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。</p></li><li><p><strong>路由选择表内容：</strong>每条路径的目的地(另一结点)和路径的代价(也称距离)。</p></li><li><p><strong>更新路由表的条件</strong>：</p></li></ol><p>（1）被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</p><p>（2）来的路由信息中有一条到达某个目的地的路由。该路由与当前使用的路由相比，有较短的距离 (较小的代价)。</p><ol start="4"><li><strong>缺点：</strong>容易出现路由环路问题。</li><li><strong>最常见的距离-向量路由算法是RIP算法，它采用”跳数“（从源端口到达目的端口所经过的路由器个数，每到达一个路由器跳数加一）作为距离的度量。</strong></li></ol><ul><li><strong>链路状态路由算法</strong></li></ul><ol><li><p><strong>原理：</strong>链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息，主动测试所有邻接结点的状态，定期地将链路状态传播给所有其他结点(或称路由结点)。</p></li><li><p><strong>特点：</strong>使用泛洪法向所有相邻的路由器发送信息，然后相邻路由器又向其他相邻路由器发送信息。发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<br>只有当链路状态发生变化时，路由器才向所有路由器发送此消息。</p></li><li><p><strong>适用范围：</strong>用于大型的或路由信息变化聚敛的互联网环境。</p></li><li><p><strong>优点：</strong></p></li></ol><p>（1）每个路由结点都使用同样的原始状态数据独立地计算路径,而不依赖中间结点的计算。</p><p>（2）链路状态报文不加改变地传播，因此采用该算法易于查找故障。</p><p>（3）当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。</p><p>（4）链路状态算法比距离-向量算法有更好的规模可伸展性。</p><ol start="5"><li><strong>典型的链路状态算法是OSPF算法</strong></li></ol><h3 id="4-2-3-层次路由"><a href="#4-2-3-层次路由" class="headerlink" title="4.2.3 层次路由"></a>4.2.3 层次路由</h3><ul><li><strong>背景</strong></li></ul><p>当网络规模扩大时，路由器的路由表成比例地增大。这不仅会消耗越来越多的路由器缓冲区空间，而</p><p>且需要用更多CPU时间来扫描路由表，用更多的带宽来交换路由状态信息。因此路由选择必须按照层次的方式进行。</p><ul><li><strong>路由选择协议</strong></li></ul><p>互联网将整个互联网划分为许多较小的自治系统（一个自治系统中包含很多局域网），每个自治系统有权自主地决定本系统内应采用何种路由选择协议。如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此因特网将路由选择协议分为两大类。</p><ol><li><strong>内部网关协议（IFP）</strong></li></ol><p>也称域内路由选择，是自治系统内部所使用的路由选择协议，具体的协议有RIP、OSPF等。</p><ol start="2"><li><strong>外部网关协议（EGP）</strong></li></ol><p>也称域间路由选择，是不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径，具体的协议有BGP。</p><ul><li><strong>特点</strong></li></ul><p>使用层次路由时，OSPF将一个自治系统再划分为若干区域，每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。</p><p>采用分层次划分区域的方法虽然使交换信息的种类增多，但也会使OSPF协议更加复杂。但这样做却能使每个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模很大的自治系统中。</p><h2 id="4-3-IPv4"><a href="#4-3-IPv4" class="headerlink" title="4.3 IPv4"></a>4.3 IPv4</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><ol><li>IPv4即现在普遍使用的IP ( 版本4 )</li><li>IP定义数据传送的基本单元——IP分组及 其确切的数据格式</li><li>IP也包括一套规则，指明分组如何处理、错误怎样控制</li><li>包含非可靠投递的思想,以及与此关联的分组路由选择的思想</li></ol><h3 id="4-3-2-IPv4分组"><a href="#4-3-2-IPv4分组" class="headerlink" title="4.3.2 IPv4分组"></a>4.3.2 IPv4分组</h3><ul><li><strong>IPv4分组格式</strong></li></ul><p><img src="http://img.fdchen.host/IPv.png" alt="IPv4分组格式"></p><ol><li>版本：指IP版本,目前广泛使用的版本号是4</li><li>首部长度：占4位。<strong>基本单位为4B</strong>，最大值为60B (15*4B)，最常用的首部长度是20B</li><li>总长度：占16位。<strong>基本单位为1B</strong>，指首部与数据之和的长度最大长度65535B</li><li>标识：占16位。是一个计数器用于保证数据报片能够正确组装称为原来的数据报</li><li>标志：占3位。最低位MF&#x3D; 1代表分片，中间位DF&#x3D;0代表可以分片</li><li>片偏移：占13位。<strong>基本单位为8B</strong>，指出分片后，某片在原分组中的相对位置</li><li>首部校验和：占16位。IP数据报的首部校验和只校验分组的首部，而不校验数据部分</li><li>生存时间TTL：占8位。保证分组不会在网络中循环，每次路由转发TTL-1，当TTL为0 丢弃该分组</li><li>协议：占8位。指出该分组使用的协议( 6为TCP协议，17为UDP协议 )</li><li>源地址字段：占4B。标识发送发的IP地址</li><li>目的地址字段：占4B。标识接收方的IP地址</li><li>最大传送单元( MTU)： 一个链路层数据报能承载的最大数据量</li></ol><ul><li><strong>IP数据报分片</strong></li></ul><ol><li><strong>最大传送单元( MTU) ：</strong>一个链路层数据报能承载的最大数据量</li></ol><p>以太网：1500B<br>广域网：一般不超过576B</p><ol start="2"><li><p><strong>分片：</strong>当数据报长度大于链路MTU时，就要对其进行分片传输，分片会在目的地进行组装,不会在中间路由处进行组装。</p></li><li><p><strong>标志位含义：</strong></p></li></ol><p>MF ( more fragment)：为1代表进行了分片<br>DF ( don’t fragment)：为0时才可以进行分片</p><ul><li><strong>网络层转发分组的流程</strong></li></ul><ol><li>从数据报的首部提取目的主机的IP地址D，得出目的网络地址N。</li><li>若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这称为路由器的直接交付；否则是间接交付，执行步骤3。</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则执行步骤4。</li><li>若路由表中有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由器；否则执行步骤5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行步骤6。</li><li>报告转发分组出错。</li></ol><p>PS：得到下一跳路由器的IP地址后并不是直接将该地址填入待发送的数据报，而是将该IP地址转换成MAC地址（通过ARP协议），将其放到MAC帧首部中，然后根据这个MAC地址找到下一跳路由器。在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化，但是网桥在转发帧时，不改变帧的源地址。</p><h3 id="4-3-3-IPv4与NAT"><a href="#4-3-3-IPv4与NAT" class="headerlink" title="4.3.3 IPv4与NAT"></a>4.3.3 IPv4与NAT</h3><ul><li><strong>IPv4地址</strong></li></ul><ol><li><p><strong>IP地址：</strong>连接到因特网上的每台主机(或路由器)都分配一个32比特的全球唯一标识符。</p></li><li><p><strong>分类：</strong></p></li></ol><p><img src="https://img-blog.csdn.net/20160312194714388" alt="IP地址分类"></p><p>在这五类IP地址中，我们最常使用的是A类、B类和C类地址。</p><p><strong>（1）A类地址</strong></p><p>A类地址第1字节为网络号，其它3个字节为主机号。</p><p>A类地址的网络号第一位固定为0，网络号只有7位可以使用，可以指派的网络号是2^7-2 &#x3D; 126个。</p><p>网络号全是0（0000 0000）的IP地址是保留地址，意思是“本网络”。</p><p>网络号是127（0111 1111）的IP地址也是保留地址，作为本地环回软件测试。</p><hr><p>A类地址的主机号占3个字节，每个A类网络中的最大主机数是2^24-2个。</p><p>主机号全是0的IP地址表示是“本主机”所连接到的单个网络。</p><p>主机号全是1的IP地址表示是该网络上的所有主机。</p><p><strong>（2）B类地址</strong></p><p>B类地址的前两个字节为网络号，后两个字节为主机号。</p><p>B类地址的网络号第一、二位固定为10，网络号有14位可以使用，可以指派的网络号是2^14-1个。</p><p>B类地址网络号为128.0（1000 000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p><hr><p>B类地址的主机号占2个字节，每个B类网络中的最大主机数是2^16-2个。</p><p>主机号全是0的IP地址表示是“本主机”所连接到的单个网络。</p><p>主机号全是1的IP地址表示是该网络上的所有主机。</p><p><strong>（3）C类地址</strong></p><p>C类地址的前三个字节为网络号，最后一个字节为主机号。</p><p>C类地址的网络号第一、二、三位固定为110，网络号有21位可以使用，可以指派的网络号是2^21-1个。</p><p>C类地址网络号为192.0.0（1000 000  0000 0000  0000 0000）的IP地址是不指派的，所以可指派的网络号需要减一。</p><hr><p>C类地址的主机号占1个字节，每个C类网络中的最大主机数是2^8-2个。</p><p>主机号全是0的IP地址表示是“本主机”所连接到的单个网络。</p><p>主机号全是1的IP地址表示是该网络上的所有主机。</p><ol start="3"><li><strong>IP地址的指派范围：</strong></li></ol><p><img src="https://img-blog.csdn.net/20160312204806217" alt="IP地址的指派范围"></p><ol start="4"><li><strong>一般不使用的特殊IP地址：</strong></li></ol><p><img src="https://img-blog.csdn.net/20160312204806217" alt="一般不适用的特殊IP地址"></p><p>PS：无论哪类IP地址都由网络号和主机号两部分组成。</p><ul><li><strong>网络地址转换（NAT）</strong></li></ul><ol><li><p><strong>概述：</strong>通过将专用网络地址(如Intranet，只用于LAN )转换为公用地址(如Internet )，从而对外隐藏内部管理的IP地址。</p></li><li><p><strong>优点：</strong></p></li></ol><p>（1）只需要一个全球IP地址就可以与因特网连通，由于专用网本地IP地址是可重用的，所以NAT大大节省了IP地址的消耗。<br>（2）隐藏了内部网络结构，从而降低了内部网络受到攻击的风险。</p><ol start="3"><li><strong>具体实现：</strong></li></ol><p>本地地址的主机和外界通信时，<strong>NAT路由器使用NAT转换表将本地地址转换成全球地址，或将全球地址转换成本地地址</strong>。</p><ol start="4"><li><strong>注意：</strong></li></ol><p>（1）普通路由器在转发IP数据报时，不改变其源IP地址和目的IP地址</p><p>（2）NAT路由器在转发IP数据报时，一定要更换其IP地址</p><p>（3）普通路由器仅工作在网络层</p><p>（4）NAT路由器转发数据报时需要查看和转换传输层的端口号</p><ol start="5"><li><strong>私有IP地址网段</strong></li></ol><p>A类：1个A类网段，<strong>10</strong>.0.0.0 ~ <strong>10</strong>.255.255.255</p><p>B类：16个B类网段，<strong>172.16</strong>.0.1~<strong>172.31</strong>.255.255</p><p>C类：256个C类网段，<strong>192.168.0</strong>.0~<strong>192.168.255</strong>.255</p><h3 id="4-3-4-子网划分与子网掩码、CIDR"><a href="#4-3-4-子网划分与子网掩码、CIDR" class="headerlink" title="4.3.4 子网划分与子网掩码、CIDR"></a>4.3.4 子网划分与子网掩码、CIDR</h3><ul><li><strong>子网划分</strong></li></ul><ol><li><strong>背景</strong></li></ol><p>两级IP地址的缺点：IP地址空间的利用率有时很低；两级的IP地址不够灵活；会使路由表变得太大而使网络性能变坏。</p><ol start="2"><li><strong>概述</strong></li></ol><p>两级IP地址变成了三级IP地址。</p><ol start="3"><li><strong>划分思路</strong></li></ol><p>（1）子网划分纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络</p><p>（2）从主机号借用若干比特作为子网号，当然主机号也就相应减少了相同的比特</p><p>（3）IP地址&#x3D;{《网络号》 ，(子网号)，《主机号》 }</p><p>（4）先找到连接到本单位网络上的路由器，然后该路由器在收到IP数据报后，按目的网络号和子网号找到目的子网，最后把IP数据报直 接交付给目的主机</p><ol start="4"><li><strong>注意</strong></li></ol><p>（1）子网号全为0和全为1不能作为主机号</p><p>（2）全为0为本网络号，全为1为子网的广播地址</p><ul><li><strong>子网掩码</strong></li></ul><ol><li><strong>概念</strong></li></ol><p>子网掩码是一个与IP地址相对应的、长32 bit的二进制串，它由一串1和跟随的一串0组成。其中，1对应于IP地址中的网络号及子网号，而0对应于主机号。计算机只需将IP地址和其对应的子网掩码逐位”与“（AND），就可以得出相应子网的网络地址。</p><ol start="2"><li><strong>分类</strong></li></ol><p>现在因特网标准规定：所有的网络都必须使用子网掩码。如果一个网络未划分子网，那么就采用默认子网。</p><p>A类：255.0.0.0</p><p>B类：255.255.0.0</p><p>C类：255.255.255.0</p><ol start="3"><li><strong>在使用子网掩码情况下</strong></li></ol><p>（1）一台主机在设置IP地址的同时必须设置子网掩码</p><p>（2）同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码</p><p>（3）路由表中必须包含有目的网络地址，子网掩码，下一跳地址</p><ul><li><strong>无分类域间路由选择（Classless Inter-Domain Routing，CIDR）</strong></li></ul><ol><li><strong>概述</strong></li></ol><p>无分类域间路由选择是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以</p><p>在软件的支持下实现超网构造的一种IP地址的划分方法。</p><ol start="2"><li><strong>特点</strong></li></ol><p>（1）消除了传统A、B、C类地址及划分子网的概念，因而可以更有效地分配IPv4的地址空间</p><p>（2）使用”网络前缀“代替子网络的概念，IP&#x3D;{&lt;网络前缀&gt;，&lt;主机号&gt; }</p><p>（3）将网络前缀都相同的连续IP地址组成CIDR地址块，这种地址的聚合称为路由聚合，或称构成超</p><p>网</p><p>（4）网络前缀越长，其地址块就越小，路由就越具体</p><p>（5）CIDR还采用”斜线记法“，即 IP地址&#x2F;网络前缀所占比特数</p><ol start="3"><li><strong>优点</strong></li></ol><p>（1）有利于减少路由器之间的路由选择信息的交换,提高网络性能</p><p>（2）网络前缀长度具有灵活性</p><ol start="4"><li><strong>查找路由表使用的数据结构方法：二叉线索树</strong></li></ol><p>PS：线索二叉树就是利用n+1个空链域来存放结点的前驱和后继结点的信息。</p><h3 id="4-3-5-IP地址与硬件地址"><a href="#4-3-5-IP地址与硬件地址" class="headerlink" title="4.3.5 IP地址与硬件地址"></a>4.3.5 IP地址与硬件地址</h3><ul><li><strong>概述</strong></li></ul><ol><li>IP地址是网络层使用的地址，它是分层次等级的</li><li>硬件地址是数据链路层使用的地址(如MAC地址)，它是平面式的</li><li>在网络层及网络层之上使用IP地址，IP地址放在IP数据报的首部，而MAC地址放在MAC帧的首部</li><li>数据链路层看不见数据报分组中的IP地址</li></ol><ul><li><strong>地址解析协议（Address Resolution Protocol，ARP）</strong></li></ul><ol><li><p><strong>作用：</strong>实现IP地址到MAC地址的映射</p></li><li><p><strong>ARP表：</strong>每台主机都设有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表。</p></li><li><p><strong>可能出现的情况</strong></p></li></ol><p>（1）发送方是主机时，要把IP数据报发送到本网络上的另一台主机：这时用ARP找到目的主机的硬件地址；</p><p>（2）发送方是主机时，要把IP数据报发送到另一个网络 上的一台主机：这时用ARP找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成；</p><p>（3）发送方是路由器时，要把IP数据报转发到本网络上的一台主机：这时用ARP找到目的主机的硬件地址。</p><p>（4）发送方是路由器时，要把IP数据报发送到另一个网络 上的一台主机：这时用ARP找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成</p><ol start="4"><li><strong>工作原理</strong></li></ol><p>首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</p><p>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。</p><p>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><ul><li><strong>动态主机配置协议（DHCP）</strong></li></ul><ol><li><strong>概述</strong></li></ol><p>常用于给主机动态地分配IP地址，提供了即插即用联网的机制这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与，DHCP是应用层协议，它是基于UDP的。</p><ol start="2"><li><strong>实现过程</strong></li></ol><p>（1）DHCP客户机广播”DHCP发现”消息，试图找到网络中的DHCP服务器</p><p>（2）DHCP服务器收到“DHCP发现”消息后，向网络中广播“DHCP提供”消息，其中包括提供DHCP客户机的IP地址和相关配置信息</p><p>（3）DHCP客户机收到”DHCP提供”消息，如果接收DHCP服务器所提供的相关参数，那么通过广播”DHCP请求”消息向DHCP服务器请求提供IP地址</p><p>（4）DHCP服务器广播“DHCP确认”消息，将IP地址分配给DHCP客户机</p><ol start="3"><li><strong>注意</strong></li></ol><p>（1）DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址，DHCP称这段时间为租用期。租用期的数值应由DHCP服务器自己决定，DHCP客户机也可在自己发送的报文中提出对租用期的要求。</p><p>（2）DHCP的客户端和服务器端需要通过广播方式来进行交互。</p><ul><li><strong>网际控制报文协议（ICMP）</strong></li></ul><ol><li><strong>目的：</strong>为了提高IP数据报交付成功的机会,在网络层使用了网际控制报文协议( ICMP)来让主机或路由器报告差错和异常情况。</li><li><strong>种类</strong></li></ol><p><strong>（1）ICMP差错报告报文</strong></p><p><strong>终点不可达：</strong>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文</p><p><strong>源点抑制：</strong>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</p><p><strong>时间超过：</strong>当路由器收到生存时间( TTL )为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文</p><p><strong>参数问题：</strong>当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文</p><p><strong>改变路由(重定向)：</strong>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)</p><p><strong>（2）ICMP询问报文</strong></p><p>回送请求和回答报文</p><p>时间戳请求和回答报文</p><p>掩码地址请求和回答报文</p><p>路由器询问和通告报文</p><ol start="3"><li><strong>不应发送ICMP差错报告报文的情况</strong></li></ol><p>（1）对ICMP差错报告报文不再发送ICMP差错报告报文</p><p>（2）对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</p><p>（3）对具有组播地址的数据报都不发送ICMP差错报告报文</p><p>（4）对具有特殊地址(如127.0.0.0或0.0.0.0 )的数据报不发送ICMP差错报告报文</p><p>PS：组播是指在IP网络中将数据包以尽力传送的形式发送到某个确定的节点集合（即组播组），其基本思想是：源主机（即组播源）只发送一份数据，其目的地址为组播组地址；组播组中的所有接收者都可收到同样的数据拷贝，并且只有组播组内的主机可以接收该数据，而其它主机则不能收到。</p><ol start="4"><li><strong>ICMP的应用</strong></li></ol><p><strong>（1）分组网间探测PING</strong></p><p>测试两台主机之间的连通性，使用了ICMP回送请求和回答报文。</p><p><strong>（2）Traceroute</strong></p><p>用来跟踪分组经过的路由，使用了ICMP时间超过报文。</p><h2 id="4-4-IPv6"><a href="#4-4-IPv6" class="headerlink" title="4.4 IPv6"></a>4.4 IPv6</h2><p><strong>IPv6是解决IP地址耗尽的最根本方法，缓解方法是超网聚合NAT等。</strong></p><h3 id="4-4-1-IPv6主要特点"><a href="#4-4-1-IPv6主要特点" class="headerlink" title="4.4.1 IPv6主要特点"></a>4.4.1 IPv6主要特点</h3><ol><li>更大的地址空间IPv6将地址从IPv4的32位增大到了128位</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>改进的选项</li><li>允许协议继续扩充</li><li>支持即插即用(即自动配置)</li><li>支持资源的预分配</li><li>IPv6只有在包的源结点才能分片，是端到端的，传输路径中的路由器不能分片</li><li>IPv6首部长度必须是8B的整数倍，而IPv4首部是4B的整数倍</li><li>增大了安全性，身份验证和保密功能是IPv6的关键特征</li></ol><h3 id="4-4-2-IPv6地址"><a href="#4-4-2-IPv6地址" class="headerlink" title="4.4.2 IPv6地址"></a>4.4.2 IPv6地址</h3><ul><li><strong>基本类型</strong></li></ul><ol><li><strong>单播：</strong>传统的点对点通信。</li><li><strong>多播：</strong>多播是一点对多点的通信，分组被交付到一组计算机的每台计算机。</li><li><strong>任播：</strong>这是IPv6增加的一种类型，任播的目的站是一组计算机，但数据报在交付时只交付其中的一台计算机。</li></ol><ul><li><strong>IPv6地址缩写</strong></li></ul><p>IPv6中指定了一种比较紧凑的表示法，把地址中的每4位用一个十六进制数表示，并用冒号分隔每16位，如 4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170。</p><ol><li>当16位域的开头有一些0时，可以采用一种缩写表示法，但在域中必须至少有一个数字，如4BF5:<strong>0000:0000:0000</strong>:BA5F:<strong>000A</strong>:BE9A:2170，可以缩写为 4BF5:<strong>0:0:0</strong>:BA5F:039A:<strong>A</strong>:2170</li><li>当有相继的0值域时，还可以进一步缩写，这些域可以用双冒号缩写(:)，但是双冒号缩写只能出现一次，因为0值域的个数没有编码，需要从总的个数来推算。如 4BF5:<strong>0:0:0</strong>:BA5F:039A:<strong>A</strong>:2170 可进一步缩写为 4BF5**::**BA5F:039A:<strong>A</strong>:2170。</li></ol><ul><li><strong>IPv6拓展了IPv4的分级概念</strong></li></ul><ol><li>第一级（顶级）指明全球都知道的公共拓扑</li><li>第二级（场点级）指明单个场点</li><li>第三级指明单个网络接口</li></ol><ul><li><strong>IPv4向IPv6过渡</strong></li></ul><ol><li><strong>双协议栈：</strong>双协议栈技术是指在一台设备 上同时装有IPv4和IPv6协议栈，那么这台设备既能和IPv4网络通信，又能和IPv6网络通信。</li><li><strong>隧道技术：</strong>将整个IPv6数据报封装到IPv4数据报的数据部分，使得IPv6数据报可以在IPv4网络的隧道中传输。</li></ol><h2 id="4-5-路由协议"><a href="#4-5-路由协议" class="headerlink" title="4.5 路由协议"></a>4.5 路由协议</h2><h3 id="4-5-1-自治系统（Autonomous-System，AS）"><a href="#4-5-1-自治系统（Autonomous-System，AS）" class="headerlink" title="4.5.1 自治系统（Autonomous System，AS）"></a>4.5.1 自治系统（Autonomous System，AS）</h3><ul><li><strong>概述</strong></li></ul><p>单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由。</p><h3 id="4-5-2-域内路由和域间路由"><a href="#4-5-2-域内路由和域间路由" class="headerlink" title="4.5.2 域内路由和域间路由"></a>4.5.2 域内路由和域间路由</h3><ul><li><strong>内部网关协议（Interior Gateway Protocol，IGP）</strong></li></ul><p>在一个自治系统内部使用的路由选择协议，目前该路由选择协议使用得最多，如RIP和OSPF。</p><ul><li><strong>外部网关协议（External Gateway Protocol，EGP）</strong></li></ul><p>源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时(两个自治系统可能使用不同的IGP)，需要使用一种协议将路由选择信息传递到另一个自治系统中，目前使用最多的外部网关协议是BGP-4。</p><h3 id="4-5-3-路由信息协议（RIP）"><a href="#4-5-3-路由信息协议（RIP）" class="headerlink" title="4.5.3 路由信息协议（RIP）"></a>4.5.3 路由信息协议（RIP）</h3><p>路由信息协议（Routing Information Protocol，RIP）是内部网关协议( IGP )中最先得到广泛应用的协议，是一种分布式的基于距离向量的路由选择协议，其最大优点就是简单。</p><ul><li><strong>实现</strong></li></ul><ol><li>网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录（因此这是一组距离，称为<strong>距离向量</strong>）</li><li>距离也称<strong>跳数（Hop Count）</strong>，规定从一个路由器到直接连接网络的距离（跳数）为1，而每经过一个路由器，距离（跳数）加1。</li><li>RIP认为好的路由就是它通过的路由器的数目少，即优先选择跳数少的路径。</li><li>RIP最多允许15跳，超过15跳即为不可达。可见RIP只适用于小型互联网。规定最高跳数的目的是为了防止数据报不断循环在环路上，减少网络拥塞的可能性。</li><li>RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表(动态路由表)。</li><li>在RIP中不支持子网掩码的RIP广播，所以RIP中每个网络的子网掩码必须相同。但在新的RIP2中，支持变长子网掩码和CIDR。</li></ol><ul><li><strong>特点</strong></li></ul><ol><li>仅和相邻路由器交换信息</li><li>路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表</li><li>按固定的时间间隔交换路由信息，如每隔30秒</li></ol><ul><li><strong>缺陷</strong></li></ul><ol><li>RIP限制了网络的规模，它能使用的最大距离为15 ( 16表示不可达)</li><li>路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销也越大</li><li>网络出现故障时，会出现**慢收敛现象(即需要较长时间才能将此信息传送到所有路由器)**，俗称“坏消息传得慢“，使更新过程的收敛时间长</li></ol><ul><li><strong>优点</strong></li></ul><p>实现简单、开销小、收敛过程较快。</p><p>PS：RIP是应用层协议，它使用UDP传送数据（端口520）.</p><h3 id="4-5-4-开放最短路径优先（OSPF）协议"><a href="#4-5-4-开放最短路径优先（OSPF）协议" class="headerlink" title="4.5.4 开放最短路径优先（OSPF）协议"></a>4.5.4 开放最短路径优先（OSPF）协议</h3><p>开放最短路径优先（Open Shortest Path First）协议是使用分布式链路状态路由算法的典型代表，也是内部网关协议(IGP )的一种。</p><ul><li><strong>实现</strong></li></ul><ol><li>OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态</li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛快</li><li>OSPF是网络层协议，它不使用UDP或TCP，而直接用IP数据报传送</li></ol><ul><li><strong>特点</strong></li></ul><ol><li>OSPF对不同的链路可根据IP分组的不同服务类型( TOS )而设置成不同的代价</li><li>OSPF对于不同类型的业务可计算出不同的路由，十分灵活</li><li>多路径间的负载平衡：如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径</li><li>所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息</li><li>支持可变长度的子网划分和无分类编址CIDR</li><li>每个链路状态都带上一个32位的序号，序号越大，状态就越新</li><li>使用Dijkstra算法</li><li>使用洪泛法，就像水波一样，相互交互路由表信息</li></ol><ul><li><strong>工作原理</strong></li></ul><ol><li>由于各路由器之间频繁地交换链路状态信息，因此所有路由器最终都能建立一个<strong>链路状态数据库</strong>。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（称为链路状态数据库的同步）。</li><li>然后每个路由器根据这个全网拓扑结构图，使用Dijkstra最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。</li><li>此后，当链路状态发生变化时，每个路由器重新计算到个目的网络的最优路径，构造新的路由表。</li></ol><p>PS：虽然使用Dijkstra算法能计算出完整的最优路径，但路由表中不会存储完整路径，只存储“下一跳”。</p><ul><li><strong>OSPF扩展</strong></li></ul><p>为使OSPF能够用于规模很大的网路，OSPF将一个自治系统在划分为若干更小的范围，称为<strong>区域</strong>。</p><p>划分区域的好处是，将利用洪泛法交换链路状态信息的范围局限于每个区域而非整个自治系统，减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑。</p><p>这些区域也有层次之分，处在上层的域称为<strong>主干区域</strong>，负责连通其他下层的区域，并且还连接其他自治域。</p><ul><li><strong>分组类型</strong></li></ul><ol><li>问候分组，用来发现和维持邻站的可达性</li><li>数据库描述分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求分组，向对方请求发送某些链路状态项目的详细信息</li><li>链路状态更新分组，用洪泛法对全网更新链路状态</li><li>链路状态确认分组，对链路更新分组的确认</li></ol><h3 id="4-5-5-边界网关协议（BGP）"><a href="#4-5-5-边界网关协议（BGP）" class="headerlink" title="4.5.5 边界网关协议（BGP）"></a>4.5.5 边界网关协议（BGP）</h3><p>边界网关协议（Border Gateway Protocol，BGP）是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议，边界网关协议常用于互联网的网关之间。BGP采用的是路径向量路由选择协议，是应用层协议，基于TCP。</p><ul><li><strong>工作原理</strong></li></ul><ol><li>每个自治系统的管理员要选择至少一个路由器作为该自治系统的”BGP发言人”</li><li>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，先建立TCP连接，再利用BGP会话交换路由信息</li><li>所有BGP发言人都相互交换网络可达性的信息后，各BGP发言人就可找出到达各个自治系统的较好路由</li></ol><ul><li><strong>特点</strong></li></ul><ol><li>BGP交换路由信息的结点数量级是自治系统的数量级，要比这些自治系统中的网络数少很多</li><li>每个自治系统中BGP发言人(或边界路由器)的数目是很少的</li><li>BGP支持CIDR</li><li>在BGP刚运行时，BGP的邻站交换整个BGP路由表，但以后只需在发生变化时更新有变化的部分</li></ol><ul><li><strong>报文类型</strong></li></ul><ol><li>打开( Open )报文：用来与相邻的另一个BGP发言人建立关系</li><li>更新( Update )报文：用来发送某一路由的信息，以及列出要撤销的多条路由</li><li>保活( Keepalive )报文：用来确认打开报文并周期性地证实邻站关系</li><li>通知( Notification )报文：用来发送检测到的差错</li></ol><h3 id="4-5-6-路由协议比较"><a href="#4-5-6-路由协议比较" class="headerlink" title="4.5.6 路由协议比较"></a>4.5.6 路由协议比较</h3><p><img src="http://img.fdchen.host/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83.png" alt="image-20210815154858645"></p><h2 id="4-6-IP组播"><a href="#4-6-IP组播" class="headerlink" title="4.6 IP组播"></a>4.6 IP组播</h2><h3 id="4-6-1-组播的概念"><a href="#4-6-1-组播的概念" class="headerlink" title="4.6.1 组播的概念"></a>4.6.1 组播的概念</h3><ul><li><strong>概述</strong></li></ul><ol><li>组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收。组播仅应用于UDP。</li><li>因特网中的IP组播也使用组播组的概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址。</li></ol><ul><li><strong>实现过程</strong></li></ul><ol><li>主机使用一个称为IGMP (因特网组管理协议)的协议加入组播组</li><li>使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望</li><li>通过扩展路由器的路由选择和转发功能，可以在许多路由器互联的支持硬件组播的网络上面实现因特网组播</li></ol><ul><li><strong>优点</strong></li></ul><p>数据只需发送一-次就可发送到所有接收者,大大减轻了网络的负载和发送者的负担。</p><ul><li><strong>注意</strong></li></ul><p>组播需要路由器的支持才能实现,能够运行组播协议的路由器称为组播路由器。</p><h3 id="4-6-2-IP组播地址"><a href="#4-6-2-IP组播地址" class="headerlink" title="4.6.2 IP组播地址"></a>4.6.2 IP组播地址</h3><ul><li><strong>结构</strong></li></ul><p>IP组播使用D类地址格式。D类地址的前4位是 1110，因此D类地址的范围是224.0.0.0~239.255.255.255，每个D类IP地址标志一个组播组。</p><ul><li><strong>组播数据报和一般的IP数据报的区别</strong></li></ul><ol><li>组播数据报也是”尽最大努力交付”。不提供可靠交付</li><li>组播地址只能用于目的地址，而不能用于源地址</li><li>对组播数据报不产生ICMP差错报文。因此，若在PING命令后面键入组播地址,将永远不会收到响应</li><li>并非所有的D类地址都可作为组播地址</li></ol><ul><li><strong>分类</strong></li></ul><ol><li>只在本局域网上进行硬件组播</li><li>在因特网的范围内进行组播</li></ol><p>PS：在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员。</p><ul><li>硬件地址的映射关系不是唯一的，因此收到组播数据报的主机，还要在IP层利用软件进行过滤把不是本主机要接收的数据报丢弃。</li></ul><h3 id="4-6-3-IGMP和组播路由算法"><a href="#4-6-3-IGMP和组播路由算法" class="headerlink" title="4.6.3 IGMP和组播路由算法"></a>4.6.3 IGMP和组播路由算法</h3><ul><li><strong>用途</strong></li></ul><p>利用因特网组管理协议(Internet Group Management Protocol， IGMP )使路由器知道组播组成员的信息。</p><ul><li><strong>工作阶段</strong></li></ul><p>IGMP是TCP&#x2F;IP的一部分，其工作可分为两个阶段。</p><ol><li><p>第一阶段：主机加入新的组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明要成为该组的成员，本地的组播路由器收到IGMP报文后,将组成员关系转发给因特网上的其他组播路由器。</p></li><li><p>第二阶段：本地组播路由器周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，那么组播路由器就认为这个组是活跃的，一个组在经过几次的探询后仍然没有一 台主机响应时，则不再将该组的成员关系转发给其他的组播路由器。</p></li></ol><ul><li><strong>实现因特网组播的路由算法</strong></li></ul><ol><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播( PIM) (可以建立在任何路由器协议之上)</li></ol><h2 id="4-7-移动IP"><a href="#4-7-移动IP" class="headerlink" title="4.7 移动IP"></a>4.7 移动IP</h2><h3 id="4-7-1-移动IP的概念"><a href="#4-7-1-移动IP的概念" class="headerlink" title="4.7.1 移动IP的概念"></a>4.7.1 移动IP的概念</h3><p>支持移动性的因特网体系结构与协议共称为移动IP，它是为了满足移动结点(计算机、服务器、网段等)在移动中保持其连接性而设计的。</p><ul><li><strong>三种功能实体</strong></li></ul><ol><li><strong>移动结点：</strong>具有永久IP地址的移动结点</li><li><strong>本地代理：</strong>在一个网络环境中一个移动结点的永久”居所”被称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体称为归属代理(本地代理) 。它根据移动用户的转交地址，采用隧道技术转交移动结点的数据包。</li><li><strong>外部代理：</strong>在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理</li></ol><ul><li><strong>移动IP与动态IP对比</strong></li></ul><ol><li><strong>动态IP：</strong>局域网中的计算机可以通过网络中的DHCP服务器动态地获得一个IP地址。</li><li><strong>移动IP：</strong>移动结点以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变。</li></ol><h2 id="4-7-2-移动IP通信过程"><a href="#4-7-2-移动IP通信过程" class="headerlink" title="4.7.2 移动IP通信过程"></a>4.7.2 移动IP通信过程</h2><ol><li>移动结点在本地网时,按传统的TCP&#x2F;IP方式进行通信(在本地网中有固有的地址)。</li><li>移动结点漫游到一个外地网络时，仍然使用固定的IP地址进行通信。为了能够收到通信对端发给它的IP分组，移动结点向本地代理注册当前的位置地址，即<strong>转交地址</strong>（它可以是外部代理的地址或动态配置的一个地址）。</li><li>本地代理接收到转交地址的注册后，会构建一条通向转向转交地址的隧道，将截获的发送给移动节点的IP分组通过隧道发送给转交地址。</li><li>到达转交地址，恢复成原来数据，发送给移动结点。</li><li>移动结点在外网通过外网的路由器或外部代理向通信对端发送IP数据包。</li><li>移动结点来到另一个外网时，只需向本地代理更新注册的转交地址，就可继续通信。</li><li>移动结点回到本地网时，移动结点向本地代理注销转交地址，这时移动结点又将使用传统的TCP&#x2F;IP方式进行通信。</li></ol><h2 id="4-8-网络层设备"><a href="#4-8-网络层设备" class="headerlink" title="4.8 网络层设备"></a>4.8 网络层设备</h2><h3 id="4-8-1-路由器的组成和功能"><a href="#4-8-1-路由器的组成和功能" class="headerlink" title="4.8.1 路由器的组成和功能"></a>4.8.1 路由器的组成和功能</h3><p><img src="http://img.fdchen.host/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="路由器体系结构"></p><ul><li><strong>基本描述</strong></li></ul><p>路由器是一种具有多个输入&#x2F;输出端口的专用计算机。</p><ul><li><strong>任务</strong></li></ul><p>连接不同的网络(连接异构网络)并完成路由转发。</p><ul><li><strong>功能</strong></li></ul><p>可以隔离广播域。</p><p>PS：不同层次的设备隔离不同的域，集线器不隔离，网桥隔离碰撞域（所以有广播风暴），路由器隔离广播域。</p><ul><li><strong>工作过程</strong></li></ul><ol><li>源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器。</li><li>源主机和目标主机不在同一个网络上，路由器按照转发表指出的路由将数据报转发给下一个路由器，即间接交付。</li></ol><ul><li><strong>功能结构组成</strong></li></ul><ol><li><strong>路由选择部分（控制部分）</strong></li></ol><p>（1）核心构件：路由选择处理机</p><p>（2）任务：根据选定的路由选择协议构造出路由表；和其他相邻路由器交换路由信息然后更新和维护路由表。</p><ol start="2"><li><strong>分组转发部分</strong></li></ol><p><strong>（1）交换结构：</strong>根据转发表对分组进行处理，将从输入口进入的分组从一个合适的输出端口转发出去。<br><strong>交换方法有通过存储器进行交换、通过总线进行交换、通过互联网络进行交换。</strong></p><p><strong>（2）一组输入端口：</strong>从物理层接收到的比特流中提取出链路层帧，进而从帧中提取出网络层数据报。</p><p><strong>（3）一组输出端口：</strong>将数据报变为比特流发送到物理层。</p><ul><li><strong>注意</strong></li></ul><p>如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段(网络)。</p><ul><li><strong>功能</strong></li></ul><ol><li><strong>分组转发</strong></li></ol><p>处理通过路由器的数据流，转发表杳询、转发及相关的队列管理和任务调度等。</p><ol start="2"><li><strong>路由计算</strong></li></ol><p>通过和其他路由器进行基于路由协议的交互，完成路由表的计算。</p><ul><li><strong>路由器和网桥区别</strong></li></ul><ol><li><strong>网桥与高层协议无关</strong></li><li><strong>路由器是面向协议的</strong>，依据网络地址进行操作，并进行路径选择、分段、 帧格式转换、对数据报的生存时间和流量进行控制等</li></ol><ul><li><strong>支持协议</strong></li></ul><p>OSI、TCP&#x2F;IP、IPX等</p><h3 id="4-8-2-路由表与路由转发"><a href="#4-8-2-路由表与路由转发" class="headerlink" title="4.8.2 路由表与路由转发"></a>4.8.2 路由表与路由转发</h3><ul><li><strong>路由表的功能：</strong>实现路由选择</li><li><strong>路由表结构</strong></li></ul><ol><li>目的网络IP地址</li><li>子网掩码</li><li>下一跳IP地址</li><li>接口</li></ol><ul><li><strong>转发</strong></li></ul><p>路由器根据转发表把收到的IP数据报从合适的端口转发出去，仅涉及一个路由器。</p><ul><li><strong>路由选择</strong></li></ul><p>涉及很多路由器，路由表是许多路由器协同工作的结果。</p><ul><li><strong>默认路由（路由表中）</strong></li></ul><p>目的：减少转发表的重复项目，使用一个默认路由代替所有具有相同”下一跳” 的项目（IP分组）。</p><h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5 传输层"></a>5 传输层</h1><h2 id="5-1-传输层提供的服务"><a href="#5-1-传输层提供的服务" class="headerlink" title="5.1 传输层提供的服务"></a>5.1 传输层提供的服务</h2><h3 id="5-1-1-传输层的功能"><a href="#5-1-1-传输层的功能" class="headerlink" title="5.1.1 传输层的功能"></a>5.1.1 传输层的功能</h3><ul><li><strong>概述</strong></li></ul><p>传输层向它上面的应用层提供通信服务。它属于面向通信部分的最高层，同时也是用户功能中的最低层。为运行在不同主机上的进程之问提供了逻辑通信。</p><ul><li><strong>传输层的功能</strong></li></ul><ol><li><strong>传输层提供应用进程之间的逻辑通信(即端到端的通信)</strong></li><li><strong>复用：</strong>发送方不同的应用进程都可使用同一个传输层协议传送数据</li><li><strong>分用：</strong>接收方的传输层在省去报文的首部后能够把这些数据正确交付到目的应用进程</li><li>传输层还要对收到的报文进行差错检测(首部和数据部分)</li><li>提供两种不同的传输协议，即面向连接的TCP和无连接的UDP</li><li>向高层用户屏蔽低层网络核心的细节(如网络拓扑、路由协议等)，使应用进程好像在两个传输层实体之间有一条端到端的逻辑通信信道</li></ol><h3 id="5-1-2-传输层的寻址与端口"><a href="#5-1-2-传输层的寻址与端口" class="headerlink" title="5.1.2 传输层的寻址与端口"></a>5.1.2 传输层的寻址与端口</h3><ul><li><strong>端口的作用</strong></li></ul><ol><li>端口可以标识主机中的应用进程</li><li>让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程</li><li>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的</li></ol><ul><li><strong>软件端口与硬件端口</strong></li></ul><ol><li><strong>软件端口：协议栈层间的抽象的协议端口，</strong>是应用层的各种协议进程与传输实体进行层间交互的一种地址，传输层使用的是软件端口</li><li><strong>硬件端口：不同硬件设备进行交互的接口</strong></li></ol><ul><li><strong>端口号</strong></li></ul><ol><li><strong>服务器使用的端口号</strong></li></ol><p>（1）熟知端口号（0~1023）</p><p>FTP    21<br>TELNET    23<br>SMTP    25<br>DNS    53<br>TFTP    69<br>HTTP    80<br>SNMP    161</p><p>（2）登记端口号（1024~49151）</p><p>使用这类端口号必须在IANA(Internet Assigned Numbers Authority)登记，以防止重复。</p><ol start="2"><li><strong>客户端使用的端口号（49151~65535）</strong></li></ol><p>又称短暂端口号(也称临时端口)，这类端口号仅在客户进程运行时才动态地选择，通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程使用。</p><ul><li><strong>套接字</strong></li></ul><ol><li><strong>背景</strong></li></ol><p>IP地址来标识和区别不同的主机，端口号来标识和区分一台主机中的不同应用进程，端口号拼接到IP地址即构成套接字Socket。</p><ol start="2"><li><strong>在网络中采用发送方和接收方的套接字( Socket )组合来识别端点</strong></li></ol><p>（1）套接字&#x3D; (主机IP地址，端口号)</p><p>（2）唯一地标识网络中的一台主机和其上的一个应用(进程)</p><p>（3）实际上是一个通信端点</p><h3 id="5-1-3-无连接服务与面向连接服务"><a href="#5-1-3-无连接服务与面向连接服务" class="headerlink" title="5.1.3 无连接服务与面向连接服务"></a>5.1.3 无连接服务与面向连接服务</h3><ul><li><strong>面向连接服务</strong></li></ul><p>在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后应该释放这个连接。</p><ul><li><strong>无连接服务</strong></li></ul><p>两个实体之间的通信不需要先建立好连接，需要通信时，直接将信息发送到”网络”中，让该信息的传递在网上尽力而为地往目的地传送。</p><ul><li><strong>TCP&#x2F;IP协议簇的传输协议</strong></li></ul><ol><li>面向连接的传输控制协议( TCP )：采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道。</li><li>无连接的用户数据报协议( UDP )：采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。</li></ol><ul><li><strong>TCP&#x2F;IP协议</strong></li></ul><ol><li>TCP提供面向连接的可靠传输服务，增加了许多开销，如确认、流量控制、计时器及连接管理等</li><li>TCP主要适用于可靠性更重要的场合，如文件传输协议(FTP)、超文本传输协议(HTTP)、远程登录( TELNET )等</li></ol><ul><li><strong>UDP协议</strong></li></ul><ol><li>在IP之上仅提供两个附加服务：多路复用和对数据的错误检查</li><li>远程主机的传输层收到UDP报文后，不需要给出任何确认</li><li>UDP简单，执行速度比较快、实时性好</li><li>UDP的应用有：小文件传送协议(TFTP )、DNS、SNMP和实时传输协议( RTP )</li></ol><p>PS：</p><ul><li><strong>IP数据报和UDP数据报的区别</strong></li></ul><ol><li>IP数据报在网络层要经过路由的存储转发</li><li>UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，UDP数据报的信息对路由是不可见的</li></ol><ul><li><strong>TCP和网络层虚电路的区别</strong></li></ul><ol><li>TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见；虚电路所经过的交换结点都必须保存虚电路状态信息。</li><li>网络层若采用虚电路方式，则无法提供无连接服务；而传输层采用TCP不影响网络层提供无连接服务。</li></ol><ul><li><strong>虚电路</strong></li></ul><p>虚电路是分组交换的两种传输方式中的一种。在通信和网络中，虚电路是由分组交换通信所提供的面向连接的通信服务。在两个节点或应用进程之间建立起一个逻辑上的连接或虚电路后，就可以在两个节点之间依次发送每一个分组，接收端收到分组的顺序必然与发送端的发送顺序一致，因此接收端无须负责在接收分组后重新进行排序。虚电路协议向高层协议隐藏了将数据分割成段，包装成帧的过程。</p><p>虚电路是建立一条逻辑连接，发送方与接收方不需要预先建立连接。</p><h2 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h2><h3 id="5-2-1-UDP数据报"><a href="#5-2-1-UDP数据报" class="headerlink" title="5.2.1 UDP数据报"></a>5.2.1 UDP数据报</h3><p>UDP实现了传输协议能够做的最少工作，在IP的数据报服务之上增加了两个最基本的服务：多路复用和分用以及差错检测。</p><ul><li><strong>UDP优点</strong></li></ul><ol><li>UDP无须建立连接，不会有建立连接的时延</li><li>无连接状态，UDP不维护连接状态，应用服务器使用UDP时，一般都能支持更多的活动客户机</li><li>分组首部开销小</li></ol><ul><li><strong>特点</strong></li></ul><ol><li>UDP常用于一次性传输较少数据的网络应用，如DNS、SNMP等</li><li>UDP提供尽最大努力的交付，即不保证可靠交付，所有维护传输可靠性的工作需要用户在应用层来完成</li><li>UDP是面向报文的，报文是UDP数据报处理的最小单位</li></ol><ul><li><strong>UDP的数据报格式</strong></li></ul><p><img src="http://c.biancheng.net/uploads/allimg/191111/6-1911111249535K.gif" alt="UDP数据报格式"></p><ol><li><strong>源端口：</strong>源端口号.在需要对方回信时选用，不需要时可用全0</li><li><strong>目的端口：</strong>这在终点交付报文时必须使用到。</li><li><strong>长度：</strong>UDP数据报的长度(包括首部和数据)，其最小值是8 (仅有首部，单位是 B)</li><li><strong>校验和：</strong>检测UDP数据报在传输中是否有错，有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。</li></ol><ul><li><strong>收到数据报</strong></li></ul><ol><li>根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程</li><li>如果接收方UDP发现收到的报文中的目的端口号不正确，丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</li></ol><h3 id="5-2-2-UDP校验"><a href="#5-2-2-UDP校验" class="headerlink" title="5.2.2 UDP校验"></a>5.2.2 UDP校验</h3><p>UDP的校验和只检查首部和数据部分。</p><p>校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节。如果UDP校验和校验出UDP数据报是错误的，那么可以丢弃，也可以交付给上层，但是需要附上错误报告。</p><ul><li><strong>伪首部</strong></li></ul><p>在计算校验和时，要在UDP数据报之前增加12B的伪首部，伪首部不是UDP真正首部，只是在计算校验和时，临时添加在UDP数据报前面，得到一个临时的UDP数据报。</p><p>通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。</p><p><img src="http://img.fdchen.host/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.png" alt="UDP数据报的首部和伪首部"></p><h2 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h2><h3 id="5-3-1-TCP协议的特点"><a href="#5-3-1-TCP协议的特点" class="headerlink" title="5.3.1 TCP协议的特点"></a>5.3.1 TCP协议的特点</h3><p>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的<strong>可靠、有序、无丢失和不重复</strong>问题。</p><ul><li><strong>特点</strong></li></ul><ol><li>TCP是面向连接的传输层协议</li><li>每条TCP连接只能有两个端点，每条TCP连接只能是点对点的(一对一)</li><li>TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序</li><li>TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据</li><li>TCP是<strong>面向字节流</strong>的</li></ol><h3 id="5-3-2-TCP报文段"><a href="#5-3-2-TCP报文段" class="headerlink" title="5.3.2 TCP报文段"></a>5.3.2 TCP报文段</h3><p>TCP传送的数据单元称为报文段。</p><ul><li><strong>作用</strong></li></ul><p>运载数据，建立连接、释放连接和应答。</p><ul><li><strong>字段意义</strong></li></ul><p><img src="http://img.fdchen.host/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F.png" alt="image-20210815190656123"></p><ol><li><strong>源端口和目的端口字段：</strong>各占2B，端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口实现</li><li><strong>序号字段：</strong>占4B，TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的数据流中的每个字节都编上一个序号。<strong>序号字段的值指的是本报文段所发送的数据的第一个字节的序号</strong>。</li><li><strong>确认号字段：</strong>占4B，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li><strong>数据偏移(即首部长度)：</strong>占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。单位是 4B，因此当字段值为15时，代表首部长度为 60B。</li><li><strong>保留字段：</strong>占6位，保留为今后使用。</li><li><strong>紧急位URG：</strong>URG&#x3D; 1时，表明紧急指针字段有效，它告诉系统报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</li><li><strong>确认位ACK：</strong>ACK&#x3D;1时，确认号字段才有效；ACK&#x3D; 0时，确认号无效。TCP协议规定，在连接建立后所有传送的报文段都必须把ack置1。</li><li><strong>推送位PSH ( Push)：</strong>接收TCP收到PSH&#x3D;1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满后再向上交付。</li><li><strong>复位位RST ( Reset)：</strong>RST&#x3D;1时，表明TCP连接中出现严重差错(如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</li><li><strong>同步位SYN：</strong>SYN&#x3D; 1表示这是-一个连接请求或连接接收报文。</li><li><strong>终止位FIN ( Finish)：</strong>用来释放一个连接，FIN&#x3D; 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</li><li><strong>窗口字段：</strong>占2B，表示允许对方发送的数据量，用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。</li><li><strong>校验和：</strong>占2B，校验和字段检验的范围包括首部和数据两部分</li><li><strong>紧急指针字段：</strong>占2B，指出在本报文段中紧急数据共有多少字节(紧急数据放在本报文段数据的最前面)。</li><li><strong>选项字段：</strong>长度可变，TCP最初只规定了一-种选项，即<strong>最大报文段长度（Maximum Segment Size, MSS），MSS是TCP报文段中的数据字段的最大长度</strong>。</li><li><strong>填充字段：</strong>使整个首部长度是4B的整数倍。</li></ol><p>PS：MTU（Maximum Transmission Unit）最大传输单元，在TCP&#x2F;IP协议族中，指的是IP数据报能经过链路层的最大报文长度，其中包括了IP首部(从20个字节到60个字节不等)。</p><p>MSS（Maximum Segment Size，最大报文段大小，指的是TCP报文（一种IP协议的上层协议）的最大数据报长度，其中不包括TCP首部长度。MSS由TCP链接的过程中由双方协商得出，其中SYN字段中的选项部分包括了这个信息。如果MSS+TCP首部+IP首部大于MTU，那么IP报文就会存在分片，如果小于，那么就可以不需要分片正常发送。一般来说，MSS &#x3D; MTU - IP首部大小 - TCP首部大小</p><h3 id="5-3-3-TCP连接管理"><a href="#5-3-3-TCP连接管理" class="headerlink" title="5.3.3 TCP连接管理"></a>5.3.3 TCP连接管理</h3><p>TCP连接的管理就是使传输连接的建立和释放都能正常进行。</p><ul><li><strong>连接阶段</strong></li></ul><p>连接建立<br>数据传送<br>连接释放</p><ul><li><strong>TCP连接建立时面对的问题</strong></li></ul><ol><li>要使每一方都能够确知对方的存在</li><li>要允许双方协商一些参数 (如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等)</li><li>能够对传输实体资源(如缓存大小、连接表中的项目等)进行分配</li></ol><ul><li><strong>连接的建立（三次握手）</strong></li></ul><p><strong>第一次握手：</strong>客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 seq&#x3D; x。此时客户端处于 SYN-SEND（同步已发送） 状态。首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p><p><strong>第二次握手：</strong>服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 seq&#x3D;y。同时会把客户端的 x + 1 作为确认号ack 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN-REVD（同步收到） 的状态。在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p><p><strong>第三次握手：</strong>客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 y + 1 作为 确认号ack 的值，表示已经收到了服务端的 SYN 报文，序号 seq &#x3D; x+1，此时客户端处于 ESTABLISHED（已建立连接） 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p><img src="http://img.fdchen.host/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png" alt="image-20210815201340283"></p><hr><p><strong>Q：为什么需要三次握手？</strong></p><p>A：</p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p><strong>试想如果是用两次握手，则会出现下面这种情况：</strong></p><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><p><strong>Q：什么是SYN洪泛攻击？</strong></p><p>A：</p><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。<strong>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</strong>SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p><p>PS：DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。</p><p>分布式拒绝服务（Distributed Denial of Service）攻击指借于客户&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，来破坏目标服务器，服务或网络的正常流量。</p><ul><li><strong>连接的释放（四次挥手）</strong></li></ul><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的<strong>半关闭（half-close）</strong>造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>第一次挥手：</strong>客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN-WAIT-1（终止等待1）状态。</p><p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT（终止等待）状态，等待服务端的确认。</p><p><strong>第二次挥手：</strong>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE-WAIT（关闭等待） 状态。</p><p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），<strong>服务端进入CLOSE-WAIT（关闭等待）状态</strong>，此时的TCP处于半关闭状态，客户端到服务端的连接释放。<strong>客户端收到服务端的确认后，进入FIN-WAIT-2（终止等待2）状态</strong>，等待服务端发出的连接释放报文段。</p><p><strong>第三次挥手：</strong>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST-ACK（最后确认） 的状态。</p><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST-ACK（最后确认）状态，等待客户端的确认。</p><p><strong>第四次挥手：</strong>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客<strong>户端处于 TIME-WAIT 状态</strong>。但是此时TCP连接还未释放，<strong>必须经过时间等待计时器设置的时间2MSL（Maximum Segment Lifetime，最长报文段寿命）后，以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED （连接关闭）状态</strong>，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED （连接关闭）状态。</p><p><img src="http://img.fdchen.host/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B.png" alt="image-20210815201917813"></p><hr><p><strong>Q：为什么需要四次挥手？</strong></p><p>A：</p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><p><strong>Q：为什么要等待2MSL？</strong></p><p>A：</p><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p><strong>为了保证客户端发送的最后一个ACK报文段能够到达服务器。</strong>因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><h3 id="5-3-4-TCP可靠传输（实现机制）"><a href="#5-3-4-TCP可靠传输（实现机制）" class="headerlink" title="5.3.4 TCP可靠传输（实现机制）"></a>5.3.4 TCP可靠传输（实现机制）</h3><ul><li><strong>序号机制</strong></li></ul><p>TCP首部的序号字段用来保证数据能有序提交给应用层，序号建立在传送的字节流之上。</p><ul><li><strong>确认号机制</strong></li></ul><p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。</p><p>TCP默认使用<strong>累计确认</strong>，即TCP只确认数据流中至第一个丢失字节为止的字节。</p><ul><li><strong>重传机制</strong></li></ul><ol><li><strong>超时</strong></li></ol><p>TCP每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文。</p><ol start="2"><li><strong>冗余ACK：</strong>再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认。</li></ol><p>当收到对于某个报文段的3个冗余ACK，可以认为该报文段已经丢失，这时发送方可以立即对该报文执行重传。</p><h3 id="5-3-5-TCP流量控制"><a href="#5-3-5-TCP流量控制" class="headerlink" title="5.3.5 TCP流量控制"></a>5.3.5 TCP流量控制</h3><p>匹配发送方的发送速率与接收方的读取速率。</p><ul><li><strong>流量控制机制：</strong>基于滑动窗口协议的流量控制机制</li></ul><p>接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小(<strong>接收窗口rwnd</strong>)，限制发送方向网络注入报文的速率。</p><p>发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<strong>拥塞窗口cwnd</strong>，其大小与网络的带宽和时延有关。</p><ul><li><strong>传输层和数据链路层流量控制的区别</strong></li></ul><p>传输层：定义端到端用户之间的流量控制</p><p>数据链路层：定义两个中间的相邻结点的流量控制</p><ul><li><strong>传输层和数据链路层窗口大小的区别</strong></li></ul><p>传输层：滑动窗口可以动态变化</p><p>数据链路层：滑动窗口不能动态变化</p><h3 id="5-3-4-TCP拥塞控制"><a href="#5-3-4-TCP拥塞控制" class="headerlink" title="5.3.4 TCP拥塞控制"></a>5.3.4 TCP拥塞控制</h3><p>拥塞控制：防止过多的数据注入网络,保证网络中的路由器或链路不致过载。</p><ul><li><strong>拥塞控制与流量控制的区别</strong></li></ul><ol><li><strong>相同点</strong></li></ol><p>它们都通过控制发送方发送数据的速率来达到控制效果。</p><ol start="2"><li><p><strong>不同点</strong></p></li><li><p>拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p></li><li><p>流量控制是点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</p></li></ol><ul><li><strong>窗口</strong></li></ul><ol><li>接收窗口rwnd：接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。</li><li>拥塞窗口cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。</li></ol><p>PS：发送窗口的上限值&#x3D;min[rwnd, cwnd]</p><ul><li><strong>实现机制</strong></li></ul><ol><li><strong>慢启动（“慢”指初始设置的cwnd小）</strong></li></ol><p>（1）在连接建立后，令拥塞窗口cwnd &#x3D; 1即一个最大报文段长度MSS（目的是试探一下网络的拥塞情况），然后<strong>每收到一个对新报文段的确认后，将cwnd加1</strong>，使分组注入网络的速率更加合理。<br>（2）如（1）所述，则每经过一个传输轮次(即往返时延RTT )，拥塞窗口cwnd就会加倍（指数增长）。</p><p>（3）慢开始一直把拥塞窗口cwnd增大到一个规定的慢开始门限ssthresh (阈值)，然后改用拥塞避免算法。</p><ol start="2"><li><strong>拥塞避免</strong></li></ol><p>（1）发送端的拥塞窗口cwnd每经过一个往返时延RTT，就增加一个MSS的大小，而不是加倍。<br>（2）cwnd按线性规律缓慢增长(即加法增大)，而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。</p><ol start="3"><li><strong>快重传</strong></li></ol><p>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</p><ol start="4"><li><strong>快恢复</strong></li></ol><p>（1）<strong>发送端收到连续三个冗余ACK ( 即重复确认)时，执行“乘法减小”算法。</strong>把慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半。</p><p>（2）把cwnd的值设置为慢开始门限ssthresh改变后的数值，<strong>然后开始执行拥塞避免算法</strong>(“加法增大” )，使拥塞窗口缓慢地线性增大。</p><ul><li><strong>网络拥塞的处理</strong></li></ul><p>发送方检测到超时事件的发生(未按时收到确认，重传计时器超时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2 )，然后把拥塞窗口cwnd重新设置为1执行慢开始算法。</p><p><img src="http://img.fdchen.host/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="image-20210815210102267"></p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6 应用层"></a>6 应用层</h1><h2 id="6-1-网络应用模型"><a href="#6-1-网络应用模型" class="headerlink" title="6.1 网络应用模型"></a>6.1 网络应用模型</h2><h3 id="6-1-1-客户-x2F-服务器模型-C-x2F-S"><a href="#6-1-1-客户-x2F-服务器模型-C-x2F-S" class="headerlink" title="6.1.1 客户&#x2F;服务器模型 C&#x2F;S"></a>6.1.1 客户&#x2F;服务器模型 C&#x2F;S</h3><ul><li><strong>概述</strong></li></ul><p>在客户&#x2F;服务器(C&#x2F;S)模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。</p><ul><li><strong>工作流程</strong></li></ul><ol><li>服务器处于接收请求的状态</li><li>客户机发出服务请求，井等待接收结果</li><li>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送始客户机</li></ol><ul><li><strong>主要特征</strong></li></ul><ol><li>客户是服务请求方，服务器是服务提供方</li><li>网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储&#x2F;删除数据，或进行其他受限的网络活动</li><li>客户机相互之间不直接通信</li><li>可扩展性不佳</li></ol><ul><li><strong>客户&#x2F;服务器模型的应用</strong></li></ul><ol><li>Web应用</li><li>文件传输协议(FTP)</li><li>远程登录</li><li>电子邮件</li></ol><h3 id="6-1-2-P2P模型"><a href="#6-1-2-P2P模型" class="headerlink" title="6.1.2 P2P模型"></a>6.1.2 P2P模型</h3><ul><li><strong>概述</strong></li></ul><p>各计算机没有固定的客户和服务器划分，任意一对计算机——称为**对等方( Peer)**，直接相互通信。每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p><ul><li><strong>P2P应用</strong></li></ul><p>PPive、Bittorrent、电驴等</p><ul><li><strong>优点</strong></li></ul><ol><li>减轻了服务器的计算压力，消除了对某个服务器的完全依赖，提高了系统效率和资源利用率</li><li>多个客户机之间可以直接共享文档</li><li>可扩展性好，传统服务器有响应和带宽的限制，只能接受一定数量的请求</li><li>网络健壮性强，单个结点的失效不会影响其他部分的结点</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>占用较多的内存，影响整机速度</li><li>P2P下载会对硬盘造成较大的损伤</li><li>使网络变得非常拥塞</li></ol><p>PS：各大ISP (互联网服务提供商，如电信、网通等)通常都对p2p应用持反对态度。</p><h2 id="6-2-域名系统（DNS）"><a href="#6-2-域名系统（DNS）" class="headerlink" title="6.2 域名系统（DNS）"></a>6.2 域名系统（DNS）</h2><h3 id="6-2-1-基本概述"><a href="#6-2-1-基本概述" class="headerlink" title="6.2.1 基本概述"></a>6.2.1 基本概述</h3><p>域名系统( DNS )是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名(如<a href="http://www.baidu.com/">www.baidu.com</a> )转换为便于机器处理的IP地址。</p><p>DNS系统采用客户&#x2F;服务器模型，协议运行在UDP之上，使用53号端口。</p><h3 id="6-2-2-层次域名空间"><a href="#6-2-2-层次域名空间" class="headerlink" title="6.2.2 层次域名空间"></a>6.2.2 层次域名空间</h3><p>因特网采用层次树状结构的命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名。</p><ul><li><strong>域名规则</strong></li></ul><ol><li>标号中的英文不区分大小写。</li><li>标号中除连字符( - )外不能使用其他的标点符号</li><li>每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符</li><li>级别最低的域名写在最左边，级别最高的顶级域名写在最右边</li></ol><ul><li><strong>顶级域名分类</strong></li></ul><ol><li>国家顶级域名( nTLD )：国家和某些地区的域名，如”.cn”表示中国，”.us” 表示美国，”.uk” 表示英国。</li><li>通用顶级域名( gTLD )：常见的有”.com’”(公司)，”.net” (网络服务机构) ，”.org” (非营利性组织)和”gov” (国家或政府部门)等。</li><li>基础结构域名：这种顶级域名只有一个，即arpa，用于反向域名解析，因此又称反向域名。</li></ol><h3 id="6-2-3-域名服务器"><a href="#6-2-3-域名服务器" class="headerlink" title="6.2.3 域名服务器"></a>6.2.3 域名服务器</h3><p>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户&#x2F;服务器模型。</p><ul><li><strong>分类</strong></li></ul><ol><li><strong>根域名服务器：</strong>是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的IP地址。</li><li><strong>顶级域名服务器：</strong>负责管理在该顶级域名服务器注册的所有二级域名。收到DNS查询请求时，就给出相应的回答(可能是最后的结果，也可能是下一步应当查找的城名服务器的P地址)。</li><li><strong>授权域名服务器(权限域名服务器)：</strong>每台主机都必须在授权域名服务器处登记，授权域名服务器总能将其管辖的主机名转换为该主机的IP地址。</li><li><strong>本地域名服务器：</strong>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。每个因特网服务提供者(ISP)，或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。</li></ol><h3 id="6-2-4-域名解析过程"><a href="#6-2-4-域名解析过程" class="headerlink" title="6.2.4 域名解析过程"></a>6.2.4 域名解析过程</h3><ul><li><p><strong>正向解析：</strong>把域名映射称为IP地址。</p></li><li><p><strong>反向解析：</strong>把IP地址映射成域名的过程。</p></li><li><p><strong>查询方式</strong></p></li></ul><ol><li><strong>递归查询：</strong>该方法給根域名服务造成的负载过大，所以在实际中几乎不使用。</li><li><strong>递归与迭代相结合的查询：</strong>主机向本地域名服务器的查询采用的是递归查询，本地域名服务器向根域名服务器的查询采用迭代查询。</li></ol><p><img src="http://img.fdchen.host/%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="image-20210816144157502"></p><ul><li><strong>域名解析过程</strong></li></ul><p>① 客户机向其本地域名服务器发出DNS请求报文</p><p>② 本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以DNS客户的身份向根域名服务器发出解析请求</p><p>③ 根域名服务器收到请求后，判断该域名属于域，将对应的顶级域名服务器dns.com的IP地址返回给本地域名服务器<br>④ 本地域名服务器向顶级域名服务器dns.com发出解析请求报文</p><p>⑤ 顶级域名服务器dns.com收到请求后，判断该域名属于abc.com域，因此将对应的授权域名服务器dns.abc.com的IP地返回给本地域名服务器</p><p>⑥ 本地域名服务器向授权域名服务器dns.abc.com发起解析请求报文</p><p>⑦ 授权域名服务器dns.abc.com收到请求后，将查询结果返回给本地域名服务器</p><p>⑧ 本地域名服务器将查询结果保存到本地缓存.同时返回给客户机</p><ul><li><strong>高速缓存</strong></li></ul><p>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速缓存中。</p><p>因为主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息。</p><h2 id="6-3-文件传输协议（FTP）"><a href="#6-3-文件传输协议（FTP）" class="headerlink" title="6.3 文件传输协议（FTP）"></a>6.3 文件传输协议（FTP）</h2><h3 id="6-3-1-FTP的工作原理"><a href="#6-3-1-FTP的工作原理" class="headerlink" title="6.3.1 FTP的工作原理"></a>6.3.1 FTP的工作原理</h3><ul><li><strong>概述</strong></li></ul><p>文件传输协议（File Transfer Protocol，FTP）是因特网上使用得最广泛得文件传输协议，FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件。FTP采用客户&#x2F;服务器的工作方式，它使用TCP可靠的传输服务。</p><ul><li><strong>FTP功能</strong></li></ul><ol><li>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力</li><li>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</li><li>以匿名FTP的方式提供公用文件共享的能力</li></ol><ul><li><strong>FTP进程组成</strong></li></ul><ol><li>主进程：负责接收新的请求</li><li>若干从属进程：处理单个请求</li></ol><ul><li><strong>工作步骤</strong></li></ul><ol><li>打开熟知端口21 ( 控制端口)，使客户进程形够连接上。</li><li>等待客户进程发连接请求。</li><li>启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。</li><li>回到等待状态，继续接收其他客户进程的请求。</li></ol><p>PS：FTP服务器必须在整个会话期间保留用户的状态信息。</p><h3 id="6-3-2-控制连接与数据连接"><a href="#6-3-2-控制连接与数据连接" class="headerlink" title="6.3.2 控制连接与数据连接"></a>6.3.2 控制连接与数据连接</h3><p><img src="http://img.fdchen.host/FTP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="image-20210816151311966"></p><ul><li><p><strong>特点：FTP在工作时使用两个并行的TCP连接</strong></p></li><li><p><strong>控制连接（端口号21）</strong></p></li></ul><ol><li>服务器监听21号端口，等待客户连接，建立在这个端口上的连接称为控制连接</li><li>控制连接用来传输控制信息（如连接请求、传送请求等），并且控制信息都以7位ASCII格式传送</li><li>控制连接在整个会话期间一直保持打开状态</li></ol><ul><li><strong>数据连接（端口号20）</strong></li></ul><ol><li>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建数据传送进程和数据连接。</li><li>传送完毕后关闭“数据传送连接”并结束运行。</li></ol><p>PS：使用两个不同的端口号可使协议更加简单和更容易实现。</p><h2 id="6-4-电子邮件"><a href="#6-4-电子邮件" class="headerlink" title="6.4 电子邮件"></a>6.4 电子邮件</h2><h3 id="6-4-1-电子邮件系统的组成结构"><a href="#6-4-1-电子邮件系统的组成结构" class="headerlink" title="6.4.1 电子邮件系统的组成结构"></a>6.4.1 电子邮件系统的组成结构</h3><ul><li><strong>主要组成</strong></li></ul><ol><li><strong>用户代理(User Agent)：</strong>用户与电子邮件系统的接口。</li><li><strong>邮件服务器：</strong>组成电子邮件系统的核心，负责发送和接收邮件，并向用户回报发送情况。</li><li><strong>邮件发送协议和读取协议：</strong></li></ol><p>（1）<strong>SMTP：邮件发送协议</strong>，用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件。</p><p>（2）<strong>POP3：邮件读取协议</strong>，用于用户代理从邮件服务器读取邮件。</p><h3 id="6-4-2-电子邮件的收发过程"><a href="#6-4-2-电子邮件的收发过程" class="headerlink" title="6.4.2 电子邮件的收发过程"></a>6.4.2 电子邮件的收发过程</h3><p><img src="http://img.fdchen.host/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E6%94%B6%E5%8F%91%E8%BF%87%E7%A8%8B.png" alt="image-20210816151357022"></p><ol><li>发信人调用用户代理来撰写和编辑要发送的邮件，用户代理用SMTP把邮件传送给发送方邮件服务器。</li><li>发送方邮件服务器将邮件放入邮件缓存队列中，等待发送。</li><li>运行在发送方邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收方邮件服务器的SMTP服务器进程发起建立TCP连接。</li><li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接。</li><li>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。</li><li>收信人打算收信时，调用用户代理，使用POP3（或IMAP）协议将自己的邮件从接收方邮件服务器的用户邮箱中取回(如果邮箱中有来信的话)</li></ol><h3 id="6-4-3-电子邮件格式与MIME"><a href="#6-4-3-电子邮件格式与MIME" class="headerlink" title="6.4.3 电子邮件格式与MIME"></a>6.4.3 电子邮件格式与MIME</h3><ul><li><strong>电子邮件格式</strong></li></ul><ol><li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。</li><li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。</li><li>From是必填的关键字，但它通常由邮件系统自动填入。</li></ol><ul><li><strong>典型的邮件内容</strong></li></ul><p><img src="http://img.fdchen.host/%E5%85%B8%E5%9E%8B%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="image-20210816151540372"></p><ul><li><strong>多用途网际邮件扩充（Multipurpose Internet Mail Extensions, MIME）</strong></li></ul><ol><li><strong>背景：</strong>SMTP只能传送一定长度的ASCII码 ,许多其他非英语国家的文字(如中文)就无法传送。无法传送可执行文件及其他二进制对象。</li><li>MIME继续使用目前的格式，增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。</li><li><strong>内容</strong></li></ol><p>（1）<strong>5个新的邮件首部字段</strong>，包括MIME版本、内容描述、内容标识、传送编码和内容类型。</p><p>（2）<strong>定义了许多邮件内容的格式</strong>，对多媒体电子邮件的表示方法进行了标准化。</p><p>（3）<strong>定义了传送编码</strong>，可对任何内容格式进行转换，而不会被邮件系统改变</p><h3 id="6-4-4-SMTP-和-POP3"><a href="#6-4-4-SMTP-和-POP3" class="headerlink" title="6.4.4 SMTP 和 POP3"></a>6.4.4 SMTP 和 POP3</h3><ul><li><strong>简单邮件传输协议（SMTP）</strong></li></ul><ol><li><strong>概述</strong></li></ol><p>SMTP是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的SMTP进程交换信息。使用客户&#x2F;服务器方式，发送邮件的SMTP进程是SMTP客户，而负责接收邮件的SMTP进程是SMTP服务器。它使用TCP连接，端口号为25。</p><ol start="2"><li><strong>通信阶段</strong></li></ol><p><strong>（1）连接建立</strong></p><p>发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定时间对邮件缓存扫描一次。</p><p>发现有邮件，就使用SMTP的熟知端口号（25）与接收方邮件服务器的SMTP服务器建立TCP连接。</p><p>SMTP不使用中间邮件服务器，TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立。</p><p><strong>（2）邮件发送</strong></p><p>连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL命令后面有发件人的地址。SMTP服务器已准备好接收邮件，则回答250 OK。</p><p>接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令。RCPT命令的作用是先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，避免浪费通信资源。</p><p>获得OK的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。</p><p><strong>（3）连接释放</strong></p><p>邮件发送完毕后，SMTP客户应发送QUIT命令。</p><p>SMTP服务器返回的信息是221 ( 服务关闭)，表示SMTP同意释放TCP连接。</p><ol start="3"><li><strong>缺点</strong></li></ol><p>（1）SMTP不能传送可执行文件或者其他进制对象。</p><p>（2）SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</p><p>（3）SMTP服务器会拒绝超过一定长度的邮件。</p><ul><li><strong>POP3</strong></li></ul><ol><li><strong>概述</strong></li></ol><p>邮局协议( POP )是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3。当用户读取邮件时，用户代理向邮件服务器发出请求，拉取用户邮箱中的邮件。它使用客户&#x2F;服务器的工作方式。在传输层使用TCP连接，端口号为110。</p><ol start="2"><li><strong>工作方式</strong></li></ol><p>（1）下载并保留：邮件仍保留在邮件服务器上，下次仍然可以读取。</p><p>（2）下载并删除：邮件不会保存在邮件服务器上，下次不能再次读取。</p><h3 id="6-4-5-因特网报文存取协议（IMAP）"><a href="#6-4-5-因特网报文存取协议（IMAP）" class="headerlink" title="6.4.5 因特网报文存取协议（IMAP）"></a>6.4.5 因特网报文存取协议（IMAP）</h3><p>IMAP是邮件接收协议，比POP复杂得多。为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此IMAP服务器维护了会话用户的状态信息。还允许用户代理只获取报文的某些部分。</p><h3 id="6-4-6-基于万维网的电子邮件"><a href="#6-4-6-基于万维网的电子邮件" class="headerlink" title="6.4.6 基于万维网的电子邮件"></a>6.4.6 基于万维网的电子邮件</h3><ul><li><strong>特点</strong></li></ul><ol><li>用户浏览器与Hotmail或Gmail的邮件服务器之间的邮件发送或接收使用HTTP协议。</li><li>在不同邮件服务器之间传送邮件时使用SMTP协议。</li></ol><h2 id="6-5-万维网（WWW）"><a href="#6-5-万维网（WWW）" class="headerlink" title="6.5 万维网（WWW）"></a>6.5 万维网（WWW）</h2><h3 id="6-5-1-万维网的概念"><a href="#6-5-1-万维网的概念" class="headerlink" title="6.5.1 万维网的概念"></a>6.5.1 万维网的概念</h3><ul><li><strong>概念</strong></li></ul><p>万维网(World Wide Web，WWW)是一个分布式、联机式的信息存储空间，在这个空间中，有用的事物称为“资源”，并由一个全域“统一资源定位符”( URL )标识。这些资源通过超文本传输协议 ( HTTP )传送给使用者，而使用者通过单击链接来获取资源。</p><ul><li><strong>内核部分标准构成</strong></li></ul><ol><li>统一资源定位符（URL)：负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL。</li><li>超文本传输协议(HTTP)：一个应用层协议，它使用TCP连接进行可靠的传输，HTTP是万维网客户程序和服务器程序之间交互所必须严格遵守的协议。</li><li>超文本标记语言(HTML)：一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息（包括文字、声音、图像、视频等格式）进行描述。</li></ol><ul><li><strong>工作流程</strong></li></ul><ol><li>Web用户使用浏览器(指定URL)与Web服务器建立连接，并发送浏览请求</li><li>Web服务器把URL转换为文件路径，并返回信息给Web浏览器</li><li>通信完成，关闭连接</li></ol><h3 id="6-5-2-超文本传输协议（HTTP）"><a href="#6-5-2-超文本传输协议（HTTP）" class="headerlink" title="6.5.2 超文本传输协议（HTTP）"></a>6.5.2 超文本传输协议（HTTP）</h3><ul><li><strong>概述</strong></li></ul><p>HTTP定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP是面向事务的应用层协议，规定了在浏览器和服务器之间的请求和响应的格式与规则。它是万维网上能够可靠地交换文件的重要基础。</p><ul><li><strong>HTTP的操作过程</strong></li></ul><ol><li>每个万维网站点都有一个服务器进程，它不断地监听TCP的端口80 (默认)</li><li>当监听到连接请求后便与浏览器建立连接</li><li>TCP连接建立后，浏览器就向服务路发送请求获取某个Web页面的HTTP请求</li><li>服务器收到HTTP请求后，将构建所请求Web页的必需信息，并通过HTTP响应返回给浏览器</li><li>浏览器再将信息进行解释，然后将Web页显示给用户</li><li>TCP连接释放</li></ol><ul><li><strong>HTTP报文</strong></li></ul><ol><li>请求报文</li><li>响应报文</li></ol><ul><li><strong>用户点击鼠标后发生的事件（按顺序）</strong></li></ul><ol><li>浏览器分析链接指向页面的URL</li><li>浏览器向DNS请求解析域名的IP地址</li><li>域名服务器DNS解析出IP地址</li><li>浏览器与该服务器建立TCP连接(默认端口号为80)</li><li>浏览器发出HTTP请求：GET &#x2F;chn&#x2F;index.html</li><li>服务器通过HTTP响应把文件index.htm发送给浏览器</li><li>TCP连接释放</li><li>浏览器解释文件index.htm，并将Web页显示给用户</li></ol><ul><li><strong>HTTP的特点</strong></li></ul><ol><li>HTTP是无状态的，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一-次被访问时的相同</li><li>HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求</li><li>使用Cookie加数据库的方式来跟踪用户的活动</li><li>HTTP采用TCP作为运输层协议，保证了数据的可靠传输</li><li>HTTP既可以使用非持久连接，也可以使用持久连接( HTTP&#x2F;1.1支持)</li></ol><ul><li><strong>持久连接与非持久连接</strong></li></ul><ol><li><strong>非持久连接：</strong>每个网页元素对象(如JPEG图形、Flash等)的传输都需要单独建立一个TCP连接。</li><li><strong>持久连接：</strong>万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文。</li></ol><p><strong>（1）非流水线：</strong>客户在收到前一个响应后才能发出下一个请求，服务器发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</p><p><strong>（2）流水线：</strong>客户每遇到一个对象引用，就立即发出一个请求，减少了TCP连接中的空闲时间，提高了效率，HTTP&#x2F;1.1默认方式就是流水线的持久连接。</p><ul><li><strong>HTTP报文结构</strong></li></ul><p>HTTP是面向文本的。报文分为<strong>从客户向服务器发送请求报文和从服务器给客户发送的响应报文</strong>。</p><p><img src="http://img.fdchen.host/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95.png" alt="image-20210816154912951"></p><center>HTTP请求报文中常用的几个方法</center><ul><li><strong>状态码</strong></li></ul><p>1xx表示通知信息的，如请求收到了或正在处理。<br>2xx表示成功,如接受或知道了。<br>3xx表示重定向，如要完成请求还必须采取进一步的行动。<br>4xx表示客户的差错，如请求中有错误的语法或不能完成。<br>5xx表示服务器的差错，如服务器失效无法完成请求。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2021/ji-suan-ji-ji-chu-ji-suan-ji-zu-cheng-yuan-li/"/>
      <url>/2021/ji-suan-ji-ji-chu-ji-suan-ji-zu-cheng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1 计算机系统概述"></a>1 计算机系统概述</h1><h2 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h2><h3 id="1-1-1-计算机的硬件发展"><a href="#1-1-1-计算机的硬件发展" class="headerlink" title="1.1.1 计算机的硬件发展"></a>1.1.1 计算机的硬件发展</h3><ul><li><strong>发展变化</strong></li></ul><ol><li>第一代：电子管时代</li></ol><p>特点：（1）使用机器语言编程；（2）容量小，体积大，成本高，性能低</p><ol start="2"><li>第二代：晶体管时代</li></ol><p>特点：（1）速度提升；（2）软件使用高级语言；（3）形成操作系统雏形</p><ol start="3"><li>第三代：中小规模集成电路时代</li></ol><p>特点：（1）使用半导体存储器；（2）操作系统继续发展，出现时分操作系统；（3）高级语言开始发展</p><ol start="4"><li>第四代：超大规模集成电路时代</li></ol><p>特点：（1）微处理器出现；（2）并行，流水线，高速缓存，虚拟存储器出现</p><ul><li><strong>元件的更新变化</strong></li></ul><ol><li>摩尔定律：每18个月集成电路上可容纳的晶体管翻一倍，性能也将提升一倍</li><li>半导体存储器不断发展</li><li>微处理器不断发展</li></ol><h3 id="1-1-2-计算机软件发展"><a href="#1-1-2-计算机软件发展" class="headerlink" title="1.1.2 计算机软件发展"></a>1.1.2 计算机软件发展</h3><ul><li><strong>面向机器</strong></li></ul><ol><li>机器语言</li><li>汇编语言</li></ol><ul><li><strong>面向问题的高级语言</strong></li></ul><p>FORTRAN –&gt; PASCAL –&gt; C++ –&gt; JAVA</p><h3 id="1-1-3-计算机的分类与发展方向"><a href="#1-1-3-计算机的分类与发展方向" class="headerlink" title="1.1.3 计算机的分类与发展方向"></a>1.1.3 计算机的分类与发展方向</h3><ul><li><strong>电子计算机</strong></li></ul><ol><li>电子模拟计算机</li><li>电子数字计算机</li></ol><ul><li><strong>数字计算机</strong></li></ul><ol><li>专用计算机</li><li>通用计算机</li></ol><ul><li><strong>通用计算机</strong></li></ul><ol><li>巨型机、大型机、中型机、小型机、微型机、单片机</li><li>体积、功耗、性能、数据存储量、指令复杂程度、价格  依次递减</li></ol><ul><li><strong>依照指令与数据流分类</strong></li></ul><ol><li>单指令流和单数据流（SISD）：冯诺依曼体系结构</li><li>单指令流和多数据流（SIMD）：阵列存储器和向量存储器</li><li>多指令流和单数据流（MISD）：不存在</li><li>多指令流和多数据流（MIMD）：多处理器和多计算机系统</li></ol><ul><li><strong>计算机的发展趋势</strong></li></ul><ol><li>微型计算机：体积小、高性能、多用途</li><li>巨型机：更大、超高速、并行处理、更智能</li></ol><h2 id="1-2-计算机系统结构"><a href="#1-2-计算机系统结构" class="headerlink" title="1.2 计算机系统结构"></a>1.2 计算机系统结构</h2><h3 id="1-2-1-计算机系统构成"><a href="#1-2-1-计算机系统构成" class="headerlink" title="1.2.1 计算机系统构成"></a>1.2.1 计算机系统构成</h3><ul><li><p>硬件、软件，硬件与软件在逻辑上是等效的。</p></li><li><p>功能实现上，使用频繁、硬件实现成本低的功能使用硬件实现；特点是硬件实现效率高于软件实现。</p></li></ul><h3 id="1-2-2-计算机硬件的基本组成"><a href="#1-2-2-计算机硬件的基本组成" class="headerlink" title="1.2.2 计算机硬件的基本组成"></a>1.2.2 计算机硬件的基本组成</h3><ul><li><strong>早期冯诺依曼机</strong></li></ul><p><img src="https://wiki.jsswsq.com/images/5/52/8.3.1.png" alt="早期冯诺依曼机"></p><ol><li>组成：运算器、存储器、控制器、输入设备、输出设备</li><li>指令与数据共存于存储器，按照地址访问</li><li>指令与数据以二进制代码构成</li><li>指令组成：操作码与地址码，操作码表示操作，地址码表示数据存储位置</li><li>指令顺序存放，顺序执行（特定条件可改变执行顺序）</li><li>运算器为中心（早期），输入输出设备通过运算器与存储器传送（现代以存储器为中心）</li><li>“存储程序”：存储程序原理是冯·诺依曼于1946年提出的将程序像数据一样存储到计算机内部存储器中的一种设计原理。 存储程序原理就是将我们为解决特定问题而编写的程序存放在计算机存储器中，然后按存储器存储程序的首地址执行程序的第一条指令。 以后就按照该程序的规定顺序执行其他指令，直至程序结束执行。（本质是一种思想）</li></ol><ul><li><strong>现代计算机结构</strong></li></ul><ol><li>存储器为中心</li><li>I&#x2F;O操作尽可能地绕开CPU（Central Processing Unit，中央处理器），直接在I&#x2F;O设备与存储器之间完成</li></ol><h3 id="1-2-3-计算机软件的分类"><a href="#1-2-3-计算机软件的分类" class="headerlink" title="1.2.3 计算机软件的分类"></a>1.2.3 计算机软件的分类</h3><ul><li><strong>以功能进行分类</strong></li></ul><ol><li><strong>系统软件：</strong>操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等</li><li><strong>应用软件：</strong>为用户解决某个问题的程序：科学计算类程序、工程设计类程序、数据统计与处理程序</li></ol><ul><li><strong>语言分类</strong>：最后一定会变成机器语言，因为机器语言是计算机唯一可以直接识别和执行的语言</li></ul><ol><li><strong>机器语言（二进制代码语言）：</strong>机器语言是计算机唯一可以直接识别和执行的语言</li><li><strong>汇编语言：</strong>利用英文单词代替二进制指令代码，有助于记忆（必须要经过汇编程序对其进行翻译）</li><li><strong>方便程序设计人员使用的语言：</strong>高级语言 –&gt; 汇编语言 –&gt; 机器语言或者高级语言 –&gt; 机器语言</li></ol><h3 id="1-2-4-计算机工作过程"><a href="#1-2-4-计算机工作过程" class="headerlink" title="1.2.4 计算机工作过程"></a>1.2.4 计算机工作过程</h3><ul><li><strong>具体步骤</strong></li></ul><ol><li>程序、数据转入主存</li><li>从程序起始地址开始运行</li><li>程序首地址取出指令  –&gt; 指令译码、指令执行 –&gt; 完成功能并计算下一条指令地址</li><li>新得到的指令地址读出下一条指令，直到程序结束</li></ol><ul><li><strong>信息流程</strong></li></ul><ol><li><strong>取指令：</strong>PC –&gt; MAR –&gt; 存储器M –&gt; MDR –&gt; IR</li><li><strong>分析指令：</strong>操作码OR (IR) –&gt; CU</li><li><strong>执行指令：</strong>地址码Ad (IR) –&gt; MAR –&gt; M –&gt; MDR –&gt; 累加器ACC</li></ol><p>取完指令，PC自动加一，自动形成下一条指令地址。</p><h3 id="1-2-5-计算机系统的多级层次结构"><a href="#1-2-5-计算机系统的多级层次结构" class="headerlink" title="1.2.5 计算机系统的多级层次结构"></a>1.2.5 计算机系统的多级层次结构</h3><ul><li><strong>虚拟机器（高级语言机器）</strong>：用汇编程序翻译成汇编语言程序</li><li><strong>虚拟机器（汇编语言机器）</strong>：汇编程序翻译成机器语言程序</li><li><strong>虚拟机器（操作系统机器）</strong>：机器语言解释操作系统</li><li>——软硬件交互界面———–</li><li><strong>传统机器（使用机器语言的机器）</strong>：微程序解释机器指令</li><li><strong>微程序机器（微指令系统）</strong>：硬件直接执行微指令</li></ul><h3 id="1-2-6-各硬部件"><a href="#1-2-6-各硬部件" class="headerlink" title="1.2.6 各硬部件"></a>1.2.6 各硬部件</h3><ul><li><strong>主存（主存储器）</strong></li></ul><p><img src="https://img2020.cnblogs.com/blog/1781524/202008/1781524-20200825180837553-1561312357.png" alt="主存储器逻辑图"></p><p>CPU能够直接访问的存储器是主存储器，辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为CPU访问。</p><p><strong>主存储器的工作方式</strong>是按照存储单元的地址进行存取，这种存取方式称为按地址存取方式（相联存储器是按内容访问的）。</p><p>存储体存放二进制信息，地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器（MDR）用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号。</p><ol><li><strong>存储元：</strong>存储元（Storage Unit）是存储器的最小存储单元，它的作用是用来存放一位二进制代码0或1。</li><li><strong>存储单元：</strong>在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。</li><li><strong>存储字：</strong>存储字是指存放在一个存储单元中的二进制代码组合。一个存储字可代表一个二进制数，也可代表一串字符，还可代表一条指令。</li><li><strong>存储字长：</strong>存储单元中的二进制代码（存储字）位数，存储字长可以是1B（8bit）或是字节的偶数倍。</li><li><strong>MAR</strong>：用于寻址，其位数对应着存储单元的个数，如MAR为10位，则有2^10&#x3D;1024个存储单元，记为1K。MAR的长度与PC的长度相等。</li><li><strong>MDR</strong>：位数与存储字长相等，一般为字节的整数倍。</li><li>MAR和MDR虽然是存储器的一部分，但是在现代CPU中却是存在于CPU中的；高速缓存（Cache）也是存在于CPU中。</li></ol><ul><li><strong>运算器</strong></li></ul><ol><li><strong>累加器Accumulator（ACC）：</strong>存放操作数、运算的结果</li><li><strong>乘商寄存器Multiple—Quotient Register（MQ）：</strong>进行乘、除法时用得到</li><li><strong>通用寄存器X：</strong>存放操作数</li><li><strong>算术逻辑单元Arithmetic and Logical Unit（ALU）：</strong>用电路实现各种算术运算、逻辑运算</li></ol><ul><li><strong>控制器</strong></li></ul><ol><li><strong>程序计数器Program Count（PC）：</strong>存放下一条指令的地址</li><li><strong>指令寄存器Instruction Register（IR）：</strong>存放当前执行的指令</li><li><strong>控制单元Control Unit（CU）：</strong>分析指令，给出控制信号</li></ol><ul><li><strong>工作过程</strong></li></ul><ol><li>初始：指令、数据存入主存，PC指向第一条指令</li><li>从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令</li></ol><h2 id="1-3-计算机性能指标"><a href="#1-3-计算机性能指标" class="headerlink" title="1.3 计算机性能指标"></a>1.3 计算机性能指标</h2><h3 id="1-3-1-计算机的主要性能指标"><a href="#1-3-1-计算机的主要性能指标" class="headerlink" title="1.3.1 计算机的主要性能指标"></a>1.3.1 计算机的主要性能指标</h3><ul><li><strong>机器字长</strong>：计算机进行一次整数运算可处理的二进制位数</li></ul><ol><li>受到CPU寄存器位数、加法器影响</li><li>一般情况下机器字长等于内部存储器大小</li><li>字长越长，表示范围越大，精度越高</li></ol><ul><li><strong>数据通路带宽</strong>：数据总线一次性所能传送信息的位数</li></ul><p>此数据通路是指外部数据总线宽度，与CPU内部的数据总线宽度可能不同。</p><ul><li><strong>主存容量</strong>：主存储器的最大容量</li></ul><p>MAR位数反应存储单元个数，反映最大寻址范围（最大寻址范围不等于实际寻址范围）</p><ul><li><strong>运算速度</strong></li></ul><ol><li><strong>吞吐量：</strong>单位时间内处理请求的数量，取决于主存的存取周期。</li><li><strong>响应时间：</strong>用户发送请求，然后系统对请求做出相应并且获得所希望结果的等待时间，CPU时间+等待时间（磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销）。</li><li><strong>CPU时钟周期：</strong>节拍脉冲或者是T周期，主频倒数，CPU的最小时间单位，每个动作至少需要一个时钟周期。</li><li><strong>主频：</strong>机器内部主时钟的频率，衡量机器速度的重要参数，主频倒数是CPU时钟周期。同一型号计算机，主频越高，执行指令速度越快。</li><li><strong>CPI：</strong>执行一条指令所需要的时钟周期数。</li><li><strong>CPU执行时间：</strong>运行一个程序所花时间，影响因素：主频、每条指令的执行周期、指令条数。CPU执行时间 &#x3D; CPU时钟周期数&#x2F;主频 &#x3D; （指令条数*CPI）&#x2F;主频。</li><li><strong>计算能力：</strong>浮点数运算能力可以用来衡量用于科学计算的计算机的系统性能。<ul><li>MIPS：每秒执行多少百万条指令</li><li>MFLOPS：每秒执行多少百万次浮点运算</li><li>GFLOPS：每秒执行多少十亿次浮点运算</li><li>TFLOPS：每秒执行多少万亿次浮点运算</li></ul></li></ol><h3 id="1-3-2-专业术语"><a href="#1-3-2-专业术语" class="headerlink" title="1.3.2 专业术语"></a>1.3.2 专业术语</h3><ul><li><strong>系列机</strong></li></ul><p>相同的体系结构，使用基本指令系统的多个不同型号的计算机组成的一个产品系列。</p><ul><li><strong>兼容</strong></li></ul><p>计算机软件与硬件的通用性。</p><ul><li><strong>软件可移植性</strong></li></ul><p>某个系列的计算机中软件，直接或者进行很少的修改然后运行在另一个系列计算机中的可能性。</p><ul><li><strong>固件</strong></li></ul><p>将程序固定在ROM（只读存储器）中组成的部分称为固件。</p><ol><li>拥有软件特性的硬件，性能介于硬件和软件之间，是软硬结合产物（段页表也是软硬件结合产物）</li><li>速度快于软件，灵活性高于硬件</li></ol><h1 id="2-数据表示和运算"><a href="#2-数据表示和运算" class="headerlink" title="2 数据表示和运算"></a>2 数据表示和运算</h1><h2 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h2><h3 id="2-1-1-进位计数制及其相互转换"><a href="#2-1-1-进位计数制及其相互转换" class="headerlink" title="2.1.1 进位计数制及其相互转换"></a>2.1.1 进位计数制及其相互转换</h3><ul><li><strong>基本概念</strong></li></ul><ol><li>常见种类：十进制、二进制、八进制、十六进制</li><li>特点：逢X进一（X进制）</li></ol><ul><li><strong>种类特点</strong></li></ul><ol><li>二进制：计算机使用最多，0、1组成</li><li>八进制：0-7组成，二进制的一种书写形式，<strong>二进制的3位数码编为一组就是八进制数码</strong>（3位二进制最大为7）</li><li>十六进制：二进制的4位数码编为一组就是十六进制数码（4位二进制最大为15）</li></ol><ul><li><strong>进制转换</strong></li></ul><ol><li>二进制转化为八进制&#x2F;十六进制：只需要将二进制的3&#x2F;4位编为一组即可</li><li>八进制与十六进制相互转换：先换成二进制再转换</li><li>任意进制转换为十进制：任意进制数码与权重相乘，然后再将乘积相加</li><li>十进制转换为任意进制：<ul><li>整数部分：除基取余，逆序排列（从下往上）</li><li>小数部分：乘基取整，顺序排列（从上往下）</li><li>任意二进制小数都可以用十进制表示，但是并不是每个十进制小数都能用二进制表示（如0.3）</li></ul></li></ol><h3 id="2-1-2-真值和机器数"><a href="#2-1-2-真值和机器数" class="headerlink" title="2.1.2 真值和机器数"></a>2.1.2 真值和机器数</h3><ul><li><strong>真值</strong>：带符号的数，如-1，2，-3</li><li><strong>机器数</strong>：常用最高位表示正负，0表示正，1表示负</li></ul><h3 id="2-1-3-BCD码"><a href="#2-1-3-BCD码" class="headerlink" title="2.1.3 BCD码"></a>2.1.3 BCD码</h3><p>二进制编码的十进制数（Binary-Coded Decimal，BCD）通常采用4位二进制数来表示一位十进制数中的0-9这10个数码。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但4位二进制数可以组合出16种代码，因此必有6种状态为冗余状态。</p><p>PS：<strong>用四位数表示一个十进制数，最高位的零可以省略</strong>，如 (10 1001)BCD代表29D，就是省略了最高位的两个0。</p><ul><li><strong>8421码（最常用）</strong></li></ul><p>8421码是一种有权码，权值由高到低分别为8，4，2，1，它表示的十进制数为 D &#x3D;8b3+4b2+2b1+1b0，如8-&gt;1000; 9-&gt;1001。</p><p>若两个8421码相加之和小于等于(1001)2，即(9)10，则不需要修正；若相加之和大于等于(1010)2，即(10)10，则要加6修正（从1010到1111这6个位无效码，当运算结果落于这个区间时，需要将运算结果加上6），并向高位进位，进位可以在首次相加或修正时产生。</p><ul><li><strong>余3码（无权码）</strong></li></ul><p>这是一种无权码，是在8421码的基础上加(0011)2形成的，因每个数都多余3，因此称为余3码。如8-&gt;1011; 9-&gt;1100。</p><ul><li><strong>2421码（有权码）</strong></li></ul><p>这是一种有权码，权值由高到低分别为2，4，2，1，特点是大于等于5的4位二进制数中最高位为1，小于5的最高位为0（由权值决定）。如5-&gt;1011而非0101。</p><h3 id="2-1-4-字符与字符串"><a href="#2-1-4-字符与字符串" class="headerlink" title="2.1.4 字符与字符串"></a>2.1.4 字符与字符串</h3><ul><li><strong>字符串编码ASCⅡ码</strong></li></ul><p>7位二进制编码，每个字节的最高位保持为0，可用于传输时的奇偶检验位。</p><p>编码值0-31为控制字符，用于通信控制或设备的功能控制；</p><p>编码值127是DEL码；</p><p>编码值32是空格SP；</p><p>编码值32-126共95个字符称为可印刷字符。</p><p>0-9的编码值为48（011 0000）- 57（011 1001），去掉高3位，只保留低4位，正好是二进制形式的0-9。</p><ul><li><strong>汉字的表示和编码</strong>：每个编码用两个字节表示</li></ul><ol><li>种类：输入编码（计算机输入）、汉字内码（计算机内部处理）、汉字字形码（计算机输出）。</li></ol><p>GB2312码是1981年实施的国家标准GB2312-1980中收录的汉字编码，目前最新的汉字编码是2000年公布的国家标准GB18023码，编码标准采用1B，2B，4B。</p><p>区位码是1980年国家公布的一个字符编码标准。每一个字符都有对应一个4位十进制数字码位表示，其中前两位为“区”，后两位为“位”。</p><p>区位码和国标码都是输入码，它们与汉字内码的关系（十六进制）如下：</p><p>国标码 &#x3D; (区位码)16+2020H，汉字内码 &#x3D; (国标码)16+8080H</p><ul><li><strong>字符串存放</strong></li></ul><ol><li>小端模式：将数据的<strong>最高有效位</strong>存放在<strong>高地址单元</strong>中</li><li>大端模式：将数据的<strong>最高有效位</strong>存放在<strong>低地址单元</strong>中</li></ol><p><img src="https://img-blog.csdnimg.cn/20190818201112130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215Z29kMjAwOG9r,size_16,color_FFFFFF,t_70" alt="小端模式与大端模式"></p><h3 id="2-1-5-校验码"><a href="#2-1-5-校验码" class="headerlink" title="2.1.5 校验码"></a>2.1.5 校验码</h3><ul><li><strong>概念</strong></li></ul><p>能够发现或者自动纠错的数据编码</p><ul><li><strong>原理</strong></li></ul><p>通过添加一些冗余码，实现检验或者纠错编码</p><ul><li><strong>码距</strong></li></ul><p>一个编码系统中任意两个合法编码（码字）之间不同的二进数位（bit）数叫这两个码字的码距，而整个编码系统中任意两个码字的的最小距离就是该编码系统的码距。</p><p>对于码距不小于2的数据校验码，开始具有检错能力，码距越大，检错、纠错的能力越强，而且检错能力总是大于等于纠错能力。</p><p>1100和1101 码距为1，只需翻转最后位，1001和0010的码距为3，需要翻转后三位。</p><ul><li><strong>奇偶校验码</strong></li></ul><p>在原编码上加一个校验位，它的码距等于2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，也不能纠错，增加的冗余位称为奇偶校验位。</p><ol><li>奇校验码：整个校验码（有效信息位和校验位）中1的个数为奇数</li><li>偶校验码：整个校验码（有效信息位和校验位）中1的个数为偶数</li><li>实现方法：通过增加一位校验位使得码字中”1”的个数恒为奇数或偶数</li></ol><ul><li><strong>海明校验码Hamming Code</strong></li></ul><p><strong>基本思想：</strong>海明码（也译为汉明码）是广泛采用的一种有效的校验码，它实际上是一种多重奇偶校验码。其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出出错位的位置，为自动纠错提供依据。</p><p><strong>纠错理论：</strong> L - 1 &#x3D; D+C, 且D ≥ C，L是指编码的码距，D是指检测错误的位数，C是指纠正错误的位数。编码的最小码距L越大，检测位数越多，纠错能力越强，但检错能力大于等于纠错能力。</p><p><strong>求海明码1010的步骤：</strong></p><p><strong>（1）确定海明码的位数</strong></p><p>设n为有效信息的位数，k为校验位的位数，则信息位n和校验位k应满足 n+k ≤ 2^k - 1（若要检测两位错，则需再增加1位校验位，即 k+1位），如 n+k &#x3D;7 ≤ 2^3 -1，确定海明码位数为7</p><p><strong>（2）确定校验位的分布</strong></p><p>规定<strong>校验位Pi在海明位号2^(i-1)的位置上</strong>，其余各位为信息位，得到海明码的分布如下</p><pre class="line-numbers language-none"><code class="language-none">H7 H6 H5 H4 H3 H2 H1D4 D3 D2 P3 D1 P2 P1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>（3）分组以形成校验关系</strong></p><p>每个数据位用多个校验位进行校验，但要满足条件：<strong>被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和</strong>。另外，校验位不需要再被校验。</p><pre class="line-numbers language-none"><code class="language-none">D1放在H3上，由P2P1校验；（P2为第2位，P1为第1位）D2放在H5上，由P3P1校验；（P3为第4位，P1为第1位）D3放在H6上，由P3P2校验；（P3为第4位，P2为第2位）D4放在H7上，由P3P2P1校验；（P3为第4位，P2为第2位，P1为第1位）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（4）校验位取值</strong></p><p>校验位Pi的值为第i组（由该校验位校验的数据位）所有位求异或</p><p>根据（3）中的分组得到</p><pre class="line-numbers language-none"><code class="language-none">P1 &#x3D; D1 ⊕ D2 ⊕ D4 &#x3D; 0 ⊕ 1 ⊕ 1 &#x3D; 0P2 &#x3D; D1 ⊕ D3 ⊕ D4 &#x3D; 0 ⊕ 0 ⊕ 1 &#x3D; 1P3 &#x3D; D2 ⊕ D3 ⊕ D4 &#x3D; 1 ⊕ 0 ⊕ 1 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到对应的海明码为 101<u><strong>0</strong></u>0<u><strong>10</strong></u>，下划线的为校验位，其他为信息位</p><p><strong>（5）海明码的校验原理</strong></p><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成k个校验方程：</p><pre class="line-numbers language-none"><code class="language-none">S1 &#x3D; P1 ⊕ D1 ⊕ D2 ⊕ D4S2 &#x3D; P2 ⊕ D1 ⊕ D3 ⊕ D4 S3 &#x3D; P3 ⊕ D2 ⊕ D3 ⊕ D4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若 S3S2S1的值位 000，代表没错；否则说明出错，且这个数的十进制表示就是错误位的位号，如S3S2S1&#x3D; 111，代表H7出错，直接将该位取反就达到了纠错的目的。</p><p><strong>补充：</strong>海明码有1位纠错能力，2位检错能力，为了区分1位错和2位错，还需添加”全校验位“对整体及逆行偶校验。</p><ul><li><strong>循环冗余校验码（Cyclic redundancy check，通称“CRC”）</strong></li></ul><p><strong>基本思想：</strong>在K位信息码后再拼接R位的校验码，整个编码长度为N位，因此，这种编码又称为（N,K）码。</p><p><strong>格式：</strong>信息位（K位）  校验位（R位）。</p><p><strong>具体做法：</strong>CRC码基于线性编码理论，在发送端，将要传送的K位二进制信息码左移R位，将它与多项式G(X)做模2出发，生成一个R位校验码，并附在信息码后，构成一个新的二进制码CRC码，共K+R位。在接受端，利用生成多项式对接收到的编码做模2除法，以检测和确定出错的位置，无错则整除，其中生成多项式是接收端和发送端的一个约定。</p><p><strong>多项式：</strong>任意一个二进制数码都可以用一个系数仅为0或1的多项式与其对应。生成多项式G(X)的最高次幂为R，转换成对应的二进制数有R+1位。例如 x^3+x^2+1对应的二进制数为1101。</p><p><strong>设生成多项式为G(X) &#x3D;  x^3+x^2+1，信息码为101001，求CRC码的步骤：</strong></p><p>R &#x3D; 生成多项式最高次幂 &#x3D; 3，K&#x3D;信息码长度 &#x3D; 6， N &#x3D; K+R &#x3D; 9</p><p>生成多项式G(X)对应的二进制码为1101.</p><p><strong>（1）移位</strong></p><p>将原信息码左移R位，低位补0</p><p>101001 –&gt; 101001 000</p><p><strong>（2）相除</strong></p><p>对移位后的信息码，用生成多项式进行模2除法，产生余数</p><p>模2除法：模2假发和剑法的结果相同，都是做异或运算。模2除法和算数除法类似，但每位除（减）的结果不影响其他位，即不借位，步骤如下：</p><p>① 用除数对被除数最高几位做模2减（异或），不借位。</p><p>② 除数右移一位，若余数最高位为1，商为1，并对余数做模2减，若余数最高位为0，商为0，除数继续右移一位。</p><p>③ 循环知道余数位数小于除数时，该余数为最终余数。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/f3d3572c11dfa9ecd22fa7b76fd0f703918fc109?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg" alt="模2除法"></p><p>最终得到余数 001，则CRC码为101001 **<u>001</u>**（下划线为校验位）</p><p><strong>（3）检错和纠错</strong></p><p>接收端收到的CRC码，用生成多项式G(X)做模2除法，若余数为0，则码字无错。</p><p>若接收端收到的CRC码为C9C8C7C6C5C4C3C2C1&#x3D;101001 011，将这个数据与1101进行模2除法，得到的余数为 010（2D），则说明C2出错，将C2取反即可。</p><p><strong>补充：</strong>可检测出所有奇数个错误，可检测出所有双比特（位号）的错误，可检测出所有小于等于校验位长度的连续错误，若选择合适的生成多项式，且 2^R ≥ K+R+1，则可纠正单比特错</p><h2 id="2-2-定点数的表示与运算"><a href="#2-2-定点数的表示与运算" class="headerlink" title="2.2 定点数的表示与运算"></a>2.2 定点数的表示与运算</h2><h3 id="2-2-1-定点数的表示"><a href="#2-2-1-定点数的表示" class="headerlink" title="2.2.1 定点数的表示"></a>2.2.1 定点数的表示</h3><ul><li><strong>真值零表示方式</strong></li></ul><ol><li><strong>两种表示法</strong></li></ol><p>原码：正零 00000 负零 10000</p><p>反码：正零 00000 负零 11111</p><ol start="2"><li><strong>唯一表示</strong></li></ol><p>补码、移码</p><ul><li><strong>有符号和无符号</strong></li></ul><p>无符号数：整个机器字长的全部二进制数均为数值位，没有符号位</p><p>有符号数：最高位的0&#x2F;1分别表示正&#x2F;负</p><ul><li><strong>机器数定点表示</strong></li></ul><ol><li>定点小数：<strong>定点小数是纯小数</strong>，约定小数点位置在符号位之后、有效数值部分最高位之前。</li></ol><p>符号位x0 .(隐含小数点位置) 数值部分x1-xn，除去符号位，其最大值的绝对值为 1-2^(-n)</p><ol start="2"><li>定点整数：定点整数是纯整数，小数点位置在有效数值部分的最低位之后。</li></ol><p>符号位x0 x1-xn .(隐含小数点位置)，除去符号位，其最大值的绝对值为 2^n-1</p><ul><li><strong>机器数表示方法</strong></li></ul><ol><li><strong>原码表示法</strong></li></ol><p><strong>最高位为符号位，其余各位为表示数的绝对值。</strong></p><p>纯小数的原码：字长为n+1，范围为 -(1-2^(-n)) ≤ X ≤ 1-2^(-n)，关于原点对称</p><p>纯整数的原码：字长为n+1，范围为 -(2^n-1) ≤ X ≤ 2^n-1，关于原点对称</p><ol start="2"><li><strong>补码表示法</strong></li></ol><p>由于原码表示中加减法计算复杂，补码表示法可以更好地去表示加减法。</p><p><strong>对于正数，补码与原码的表示相同；对于负数，原码符号位不变，数值部分按位取反，末位加1（即所谓的”取反加1“），此规则同样适用于又补码求原码。</strong></p><p>纯小数的补码：表示范围 -1 ≤  X ≤  1-2^(-n)，比原码多表示 -1</p><p>纯整数的补码：表示范围 -2^n ≤ X ≤ 2^n-1，比原码多表示-2^n</p><p>补码的算数移位：</p><p>（1）符号位与数值位一起右移，保持原符号位数值不变，可实现除2功能</p><p>（2）变形补码（模4补码）：正 00 负11，用在完成算数运算的ALU部件中。</p><ol start="3"><li><strong>反码表示法</strong></li></ol><p>原码与补码相互转化的过渡。</p><p><strong>对于正数，反码与原码的表示相同；对于负数，原码符号位不变，数值部分按位取反</strong>。</p><p>纯小数反码：表示范围 -(1-2^(-n)) ≤ X ≤ 1-2^(-n)，关于原点对称</p><p>纯整数反码：表示范围为 -(2^n-1) ≤ X ≤ 2^n-1，关于原点对称</p><ol start="4"><li><strong>移码表示法</strong></li></ol><p>常用来表示浮点数的阶码，它只能表示整数。</p><p>移码就是在真值X上加上一个常数（偏置值），通常这个常数取2^n，相当于X在数轴上向正方向偏移了若干单位，这就是”移码“一词的由来。定义为 [x]移 &#x3D; 2^n + x（2^n &gt; x ≥ -2^n，其中机器字长为n+1），如n+1&#x3D;5时，当X&#x3D;+3，则[X]移&#x3D;10011，当X&#x3D;-3，则[X]移&#x3D;01101</p><p>最小值 -2^n（全为0），最大值 2^n-1（全为1）</p><p>特点：</p><p>（1）移码中零的表示唯一：+0 &#x3D; 2^n+0 &#x3D; -0 &#x3D; x^n-0 &#x3D; 100（n个0）</p><p>（2）一个真值的移码和补码仅差一个符号位，[x]补的符号位取反即得[x]移</p><p>（3）移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小</p><h3 id="2-2-2-定点数的运算"><a href="#2-2-2-定点数的运算" class="headerlink" title="2.2.2 定点数的运算"></a>2.2.2 定点数的运算</h3><ul><li><strong>定点数移位运算</strong></li></ul><ol><li><strong>算数移位（数值含义上的移动，乘除法）</strong></li></ol><p>（1）正数：移位后补零</p><p>（2）负数：原码补零，补码左0右1，反码全部补1</p><p>（3）符号位不参与运算</p><ol start="2"><li><strong>逻辑移位（二进制表示码的移动）</strong></li></ol><p>（1）将操作数看作无符号数</p><p>（2）左移或者右移，都要补0</p><ol start="3"><li><strong>循环移位</strong>：适合将数据的低字节数据与高字节数据互换</li></ol><p>（1）带进位标志位CF的循环移位（大循环）</p><p>（2）不带进位标志位CF的循环移位（小循环）</p><p><img src="http://img.fdchen.host/%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D.png" alt="image-20210805143731276"></p><ul><li><strong>原码定点数的加减法运算</strong></li></ul><p><strong>加法准则：</strong></p><p>（1）符号相同，绝对值相加，符号不变</p><p>（2）符号不同：绝对值大的减去绝对值小的，符号取绝对值大的数</p><p><strong>减法准则：</strong></p><p>（1）减数的符号取反，将其与被减数做原码的加法运算</p><ul><li><strong>补码定点数加减法运算</strong></li></ul><ol><li>参与的操作数均为补码</li><li>按照二进制规则运算，逢二进一</li><li>符号位与数值位同时参与运算，符号位产生的进位丢掉，结果的符号位由运算得出</li><li>补码运算的结果仍然是补码</li></ol><ul><li><strong>符号扩展</strong>：把给定位数表示的数转换成具有不同位数的某种表示形式，如把8位数二进制数扩展成32位二进制数</li></ul><p><strong>正数：</strong>在原有的基础上，高位补0凑位数即可</p><p><strong>负数：</strong></p><p>（1）原码：将原有形式的符号移动到新形式的符号位上，新形式的新增位补0</p><p>（2）补码：高位加1处理</p><p>（3）反码：高位加1处理</p><ul><li><strong>溢出概念和判别方法</strong></li></ul><p><strong>上溢：</strong>大于最大可以表示的正数</p><p><strong>下溢：</strong>小于最小可以表示的负数</p><p><strong>补码判断溢出方法：</strong></p><p>（1）一位符号位：参加运算的两个数的符号相同，但是结果符号出现变化，则结果溢出</p><p>（2）双符号位：（模4补码）00 正数 无溢出，01 正溢出，10 负溢出，11 负数 无溢出</p><p>（3）一位符号位根据数据位进行判断，符号位进位与最高位进位相同，则无溢出 </p><ul><li><strong>定点数的乘法运算</strong></li></ul><ol><li><strong>原码一位乘法：符号位与数值位分开求得</strong></li></ol><p>（1）符号位：由两个数的符号位异或</p><p>（2）数值：两个数的绝对值相乘之积</p><p><strong>运算规则：</strong></p><p>① 被乘数和乘数均取绝对值参加运算，符号位为 Xs 和 Ys异或</p><p>② 部分积的长度等同于被乘数，取 n+1 位，以便存放乘法过程中绝对值大于等于1的值，初值为0</p><p>③ 从乘数的最低位yn开始判断：若yn &#x3D; 1，则部分积加上被乘数|x|，然后右移一位；若yn&#x3D;0，则部分积加上0，然后右移一位</p><p>④ 重复步骤③，判断n次。</p><p>由于乘积的数值部分是两数绝对值相乘的结果，因此原码一位乘法运算过程中的右移操作均为逻辑右移。且考虑大运算时可能出现绝对值大于1的情况（但此刻并非溢出），所以部<strong>分积和被乘数取双符号位</strong>。</p><p><strong>运算示例：</strong></p><p>① 设置部分积，被乘数与乘数的绝对值</p><p>A&#x3D;00.0000，B&#x3D;|X|&#x3D;00.1101，C&#x3D;.1011</p><p>② 若判断位（乘数C的最后一位）为0，则部分积+0000；若为1，部分积+B</p><p> <img src="http://img.fdchen.host/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.png" alt="原码一位乘法"></p><ol start="2"><li><strong>补码一位乘法（Booth算法）：一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积</strong></li></ol><p><strong>运算规则：</strong></p><p>① 符号位参与运算，运算的数均以补码表示</p><p>② 被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数可取单符号位</p><p>③ 乘数末位增设附加位 y(n+1)，且初值为0</p><p>④ 根据(yn, y(n+1))的取值来确定操作</p><table><thead><tr><th>yn高位</th><th>y(n+1)低位</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>部分积右移一位</td></tr><tr><td>0</td><td>1</td><td>部分积加[x]补，右移一位</td></tr><tr><td>1</td><td>0</td><td>部分积加[-x]补，右移一位</td></tr><tr><td>1</td><td>1</td><td>部分积右移一位</td></tr></tbody></table><p>⑤ 移位按补码右移规则进行（算数移位）</p><p>⑥ 按照上述算法进行n+1步操作，但第n+1步不再移位（共进行n+1次累加和n次右移），仅根据yn与y(n+1)，的比较结果做相应的运算。</p><p><strong>运算示例：</strong></p><p><img src="http://img.fdchen.host/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%E7%A4%BA%E4%BE%8B.png" alt="image-20210805154106942"></p><ul><li><strong>定点数的除法运算</strong></li></ul><ol><li><strong>原码除法运算（不恢复余数法）</strong></li></ol><p>原码除法主要采用原码不恢复余数法，也称原码加减交替法。特点是商符和商值是分开进行的，商符由两个操作数的符号位”异或“形成。</p><p><strong>求商值的规则如下：</strong></p><p>① 商的符号：Qs &#x3D; Xs ⊕ Ys</p><p>② 商的数值：Qs  &#x3D; |X|&#x2F;|Y|</p><p><strong>求|Q|的不恢复余数运算规则如下：</strong></p><p>① 符号位不参与运算</p><p>② 先用被除数减去除数，当余数为正时，商上1，余数和商左移一位，再减去除数；当余数为负时，商上0，余数和商左移一位，再加上除数。</p><p>③ 当第n+1步余数为负，需加上|Y|得到第n+1步正确的余数。</p><p><img src="http://img.fdchen.host/%E5%8E%9F%E7%A0%81%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E7%A4%BA%E4%BE%8B.png" alt="image-20210805162801929"></p><ul><li><strong>补码除法运算（加减交替法）</strong></li></ul><p><strong>加减交替法运算规则如下：</strong></p><p>① 符号位参加运算，除数和被除数均用补码表示，商和余数也用补码表示</p><p>② 若被除数（部分余数）与除数同号，则被除数（部分余数）减去除数；若被除数（部分余数）与除数异号，则被除数加上除数。</p><p>③ 若余数与除数同号，则商上1，余数左移一位减去除数；若余数与除数异号，则商上0，余数左移一位加上除数。</p><p>④ 重复执行第③步操作n次。</p><p>⑤ 若对商的精度没有特殊要求，则一般采用”末位恒置1“法。</p><p>运算示例：</p><p><img src="http://img.fdchen.host/%E8%A1%A5%E7%A0%81%E9%99%A4%E6%B3%95.png" alt="image-20210805163613368"></p><ul><li><strong>强制类型转换</strong></li></ul><ol><li>强制类型转换的结果时保持二进制码位值不变，仅改变解释这些位的方式。</li><li>对于不同字长的整数之间的数值转换，当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值，也是一种保持位值的处理方法；而短字长到长字长的转换，补位保证最终数值相等即可。</li></ol><h3 id="2-3-浮点数的表示和运算"><a href="#2-3-浮点数的表示和运算" class="headerlink" title="2.3 浮点数的表示和运算"></a>2.3 浮点数的表示和运算</h3><h3 id="2-3-1-浮点数的表示"><a href="#2-3-1-浮点数的表示" class="headerlink" title="2.3.1 浮点数的表示"></a>2.3.1 浮点数的表示</h3><ul><li><strong>表示格式</strong></li></ul><p>通常，浮点数表示为：N &#x3D; r^E * M，</p><p>r时浮点数阶码的低，与尾数的基数相同，通常r&#x3D;2。E和M都是有符号的定点数，E称为阶码，M称为尾数。可见，浮点数由阶码和尾数两部分组成。</p><p><img src="http://img.fdchen.host/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%A0%BC%E5%BC%8F.png" alt="image-20210805164740434"></p><ul><li><strong>规格化浮点数</strong></li></ul><p>为了提高运算的精度，需要充分利用尾数的有效位数，通常<strong>采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值。</strong></p><p>所谓<strong>规格化操作</strong>，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。</p><p><strong>左规：</strong>尾数算数左移一位，阶码减1（基数为2）</p><p><strong>右规：</strong>结果出现溢出（双符号位01或10），将尾数算数右移一位，阶码加1（基数为2）。</p><p>左规可以多次，右规只能一次。</p><ul><li><strong>规格化的原码和补码</strong></li></ul><p><img src="http://img.fdchen.host/%E8%A7%84%E6%A0%BC%E5%8C%96%E7%9A%84%E5%8E%9F%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81.png" alt="image-20210805170056643"></p><ul><li><strong>IEEE754标准</strong></li></ul><p><img src="http://img.fdchen.host/IEEE754.png" alt="image-20210805170217179"></p><p>偏置值是指用移码表示阶码，如float型为 2^(8-1)-1&#x3D;127。</p><ul><li><strong>定点数与浮点数的区别</strong></li></ul><ol><li>相同字长，浮点数范围更大</li><li>浮点数精度降低</li><li>浮点数运算复杂</li><li>浮点数只有规格化后阶码超出表示范围才发生溢出</li></ol><h3 id="2-3-2-浮点数的加减运算"><a href="#2-3-2-浮点数的加减运算" class="headerlink" title="2.3.2 浮点数的加减运算"></a>2.3.2 浮点数的加减运算</h3><ul><li><strong>运算步骤</strong></li></ul><ol><li><p><strong>对阶：</strong>小阶看齐大阶，阶码小的尾数右移1位（基数2），阶加1，直到阶码相等。尾数右移时，舍弃掉有效位会产生误差，影响精度。（牺牲尾数的位数增加阶码位数）</p></li><li><p><strong>尾数求和：</strong>尾数按照定点数加减规则运算</p></li><li><p><strong>规格化（补码）：</strong>最高数值位与符号位不同即为规格化形式</p></li><li><p><strong>舍入：</strong></p></li></ol><p>（1）0舍1入法：尾数右移时，被移去所有尾数末位的最高数值位为0，则舍去；被移去所有尾数末位的最高数值位为1，则尾数末位加1。可能会溢出，此时需要再一次右规。<br>（2）恒置1法：尾数右移，不论最高数值位丢掉的是1还是0，都将尾数末位恒置1.</p><ol start="5"><li><strong>溢出判断：</strong></li></ol><p>只有右规后，仍然溢出，此时才是真正溢出。</p><p>上溢出：进入中断处理</p><p>下溢出：按机器零处理</p><ol start="6"><li><strong>强制类型转换</strong></li></ol><p>char –&gt; int，在前面补0</p><p>int &lt;–&gt; unsigned，彼此都可能因为溢出丢失数据</p><p>int &lt;–&gt; float， float转换为int可能会出现精度损失和溢出，int转换为float可能会出现数据舍入</p><ul><li><strong>边界对齐</strong></li></ul><p>现代计算机通常是按字节编址，即每个字节对应1个地址。</p><p>通常也会支持按字、按半字、按字节寻址。</p><p><strong>32位计算机：1字&#x3D;32位&#x3D;4字节，64位计算机：1字&#x3D;64位&#x3D;8字节</strong></p><h2 id="2-4-算数逻辑单元ALU"><a href="#2-4-算数逻辑单元ALU" class="headerlink" title="2.4 算数逻辑单元ALU"></a>2.4 算数逻辑单元ALU</h2><p>运算器组成：算数逻辑单元、累加器、状态寄存器(status register, SR)、通用寄存器</p><h3 id="2-4-1-串行加法器和并行加法器"><a href="#2-4-1-串行加法器和并行加法器" class="headerlink" title="2.4.1 串行加法器和并行加法器"></a>2.4.1 串行加法器和并行加法器</h3><ul><li><strong>一位全加器FA</strong></li></ul><p>两个加数输入，以及低位进位输入，输出为本位结果和进位输出</p><ul><li><strong>串行加法器</strong></li></ul><p>只有一个全加器，数据逐位的送入加法器中运算，逐位送回寄存器。</p><p>操作数n位，则进行n次；成本低，但是速度慢。</p><ul><li><strong>并行加法器</strong></li></ul><p>多个加法器共同组成，每个全加器都有一个低位送来的进位输入，最终向高位输出进位。</p><p>进位方式：</p><p>（1）串行进位，将全加器接在一起，每级进位依赖于前一级进位</p><p>（2）并行进位，同时进位，各级进位信号同时形成，即将各级低位产生的本级G（进位产生函数）信号和P（进位传递函数）信号一次同时送到高位个全加器的输入，使它们同时形成进位信号。</p><h3 id="2-4-2-算术逻辑单元的功能和结构"><a href="#2-4-2-算术逻辑单元的功能和结构" class="headerlink" title="2.4.2 算术逻辑单元的功能和结构"></a>2.4.2 算术逻辑单元的功能和结构</h3><ul><li><p><strong>带标志加法器</strong>：无符号加法器只能用于两个无符号数相加，为了能进行带符号整数的加减运算，需要在无符号数加法器的基础上增加相应的逻辑门电路。</p></li><li><p><strong>ALU</strong>：算数运算和逻辑运算</p></li><li><p><strong>补码加减运算部件</strong></p></li></ul><h1 id="3-存储系统"><a href="#3-存储系统" class="headerlink" title="3 存储系统"></a>3 存储系统</h1><h2 id="3-1-存储器的层次结构"><a href="#3-1-存储器的层次结构" class="headerlink" title="3.1 存储器的层次结构"></a>3.1 存储器的层次结构</h2><h3 id="3-1-1-存储器分类"><a href="#3-1-1-存储器分类" class="headerlink" title="3.1.1 存储器分类"></a>3.1.1 存储器分类</h3><ul><li><strong>层次分类</strong></li></ul><ol><li><strong>主存储器，主存（内存储器，内存）</strong></li></ol><p>（1）存放计算机运行时的程序与数据</p><p>（2）可以被CPU直接访问，也可以与Cache和辅存进行交换数据</p><p>（3）容量小，速度快，价格高</p><ol start="2"><li><strong>辅助存储器，辅存（外存储器，外存）</strong></li></ol><p>（1）存储当前暂时不用的程序和数据，以及一些永久保留数据</p><p>（2）不可以与CPU直接交互</p><p>（3）容量大，速度慢，价格低</p><ol start="3"><li><strong>高速缓冲存储器（Cache）</strong></li></ol><p>（1）位于主存与CPU之间，缓解CPU与主存之间速度差距问题</p><p>（2）CPU可以直接访问</p><p>（3）容量小，速度与CPU相匹配，价格高，现代计算机将他们放在CPU中</p><ul><li><strong>存储介质分类</strong></li></ul><ol><li><strong>磁表面存储器</strong>：磁盘、磁带</li><li><strong>磁芯存储器半导体存储器</strong>：MOS（场效应管）型存储器、双极型存储器</li><li><strong>光存储器</strong>：光盘</li></ol><ul><li><strong>存取方式分类</strong></li></ul><ol><li><strong>随机存储器RAM</strong></li></ol><p>（1）随机存取，读写方便，使用灵活</p><p>（2）用途：主存、Cache</p><p>（3）类型：静态RAM（触发器原理）、动态RAM（电容充电原理）</p><ol start="2"><li><strong>只读存储器ROM</strong></li></ol><p>（1）只能读出不能写入</p><p>（2）用途：与随机存储器构成主存，存储固定不变的程序（甚至操作系统的固化）</p><p>（3）ROM也派生出可以反复重写的类型</p><ul><li><strong>信息可保存性</strong></li></ul><ol><li><strong>易失性存储器</strong>：如RAM，断电后存储信息就消失的存储器。</li><li><strong>非易失性存储器</strong>：如ROM、磁表面存储器、光存储器，断电后信息仍按保存在存储器中。</li></ol><p><strong>读出类型的分类：</strong></p><p>（1）破坏性读出：读出后，原存储信息被破坏，需要对存储信息再生</p><p>（2）非破坏性读出：读出后，不会对原存储信息造成破坏</p><h3 id="3-1-2-存储器的性能指标"><a href="#3-1-2-存储器的性能指标" class="headerlink" title="3.1.2 存储器的性能指标"></a>3.1.2 存储器的性能指标</h3><p>计算机追求的目标：大容量、低成本、高速度</p><ul><li><strong>存储容量</strong> &#x3D; 存储字数 * 字长</li><li><strong>单位成本</strong> &#x3D; 总成本 &#x2F; 容量</li><li><strong>存储速度</strong>：数据传输率 &#x3D; 数据宽度&#x2F;存储周期</li></ul><p>（1）<strong>存取时间</strong>：存储器启动到完成操作，分为读出时间和写入时间</p><p>（2）<strong>存取周期（读写周期、访问周期）</strong>：存储器进行一次完整读写操作所需要的时间</p><p>（3）<strong>主存带宽</strong>：数据传输率，每秒主存进出信息的最大数量</p><h2 id="3-2-存储器的层次化结构"><a href="#3-2-存储器的层次化结构" class="headerlink" title="3.2 存储器的层次化结构"></a>3.2 存储器的层次化结构</h2><p>上面的为<strong>三级存储系统层级结构</strong>，下面的为<strong>多级存储器结构</strong>。</p><p><img src="http://img.fdchen.host/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84.png" alt="image-20210805191706527"></p><h2 id="3-3-半导体随机存储器"><a href="#3-3-半导体随机存储器" class="headerlink" title="3.3 半导体随机存储器"></a>3.3 半导体随机存储器</h2><p><em>RAM</em> 一般指随机存取存储器。随机存取存储器（英语：Random Access Memory，缩写：<em>RAM</em>）。</p><h3 id="3-3-1-SRAM和DRAM"><a href="#3-3-1-SRAM和DRAM" class="headerlink" title="3.3.1 SRAM和DRAM"></a>3.3.1 SRAM和DRAM</h3><ul><li><strong>SRAM静态随机存储器</strong></li></ul><ol><li><p>使用双稳态触发器（六晶体管MOS）记忆信息</p></li><li><p>非破坏性读出，易失性存储器</p></li><li><p>存取速度快，集成度低，功耗大，成本高，常用来组成Cache</p></li><li><p>同时送行列地址</p></li></ol><ul><li><strong>DRAM动态随机存储器</strong></li></ul><ol><li>利用电荷存储信息</li><li>破坏性读出，易失性存储器</li><li>存取速度慢，集成度高，功耗大，容量大，成本低，常用来组成主存系统</li><li>分两次送行列地址</li><li>刷新方法（DRAM特有）：刷新单位是行</li></ol><p>（1）集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为”死时间“，又称访存”死区“。优点是读写操作时不收刷新工作影响；缺点是集中刷新期间（死区）不能访问存储器。</p><p>（2）分散刷新：把对每行的刷新分散到各个工作期中，这种刷新方式增加了系统的刷新周期。优点是没有死区；缺点是加长了系统的存取周期，降低了整机的速度。</p><p>（3）异步刷新：集中刷新和分散刷新结合，既缩短了死时间，又提高了整机速度。</p><p>注意事项：①刷新对CPU是透明的，即刷新不依赖于外部的访问；②刷新的单位是行；③刷新操作类似于读操作，但有所不同。另外刷新不需要选片，即整个存储器的所有芯片同时刷新。</p><ul><li><strong>存储器芯片的内部结构</strong></li></ul><p><img src="http://img.fdchen.host/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="image-20210805193753050"></p><ol><li><strong>存储体（存储矩阵）</strong>：存储体是存储单元的集合，它由行选择线（X）和列选择线（Y）来选择访问单位，存储体的相同行、列上的位被同时读出或写入。</li><li><strong>地址译码器：</strong>用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路。</li><li><strong>I&#x2F;O控制电路：</strong>用以控制被选中的单元的读出或写入，具有放大信息的作用。</li><li><strong>片选择信号：</strong>单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此要用一定数量的芯片进行存储器的扩展。在访问某个字时，必须”选中“该存储字所在的芯片，而其他芯片不被”选中“，因此需要有片选控制信号。</li><li><strong>读&#x2F;写控制信号：</strong>根据CPU给出的是读命令还是写命令，控制被选中大暖进行读或写。</li></ol><ul><li><strong>存储器的读写周期</strong></li></ul><ol><li><strong>RAM读周期</strong>：存储芯片<strong>进行两次连续读操作时，必须间隔的时间</strong>，读周期总是大于等于读出时间</li><li><strong>RAM写周期</strong>：数据总线上的信息<strong>能够可靠的写入存储器，必须间隔的时间</strong>。</li></ol><h3 id="3-3-2-只读存储器"><a href="#3-3-2-只读存储器" class="headerlink" title="3.3.2 只读存储器"></a>3.3.2 只读存储器</h3><ul><li><strong>ROM特点</strong></li></ul><ol><li>随机存取，非易失性存储器</li><li>结构简单，位密度比可读写存储器高</li></ol><ul><li><strong>ROM类型</strong></li></ul><ol><li>掩模式只读存储器（MROM）：可靠性高，集成度高，价格便宜，但是灵活性差</li><li>一次性可编程只读存储器（PROM）：写入内容无法修改</li><li>可擦除可编程只读存储器（EPROM）：可以对内容进行多次改写，通过紫外线或电擦除</li><li>闪速存储器（Flash Memory）：可长期保存信息，可重写，价格便宜，集成度高，擦写速度快。</li><li>固态硬盘（SSD）：可以长期保存信息，快速擦除，重写，相对于传统硬盘，读写速度快，低功耗，但是价格高。</li></ol><h2 id="3-4-主存储器和CPU的连接"><a href="#3-4-主存储器和CPU的连接" class="headerlink" title="3.4 主存储器和CPU的连接"></a>3.4 主存储器和CPU的连接</h2><ul><li><strong>连接原理</strong>：主存储器于CPU通过数据总线、地址总线、控制总线连接</li></ul><ol><li>数据总线的位数与工作频率的乘积正比于数据传输率</li><li>地址总线的位数决定了可寻址的最大内存空间</li><li>控制总线（读&#x2F;写）指出了总线周期的类型和本次输入&#x2F;输出完成的时刻。</li></ol><ul><li><strong>主存容量扩展</strong></li></ul><ol><li><strong>位扩展：将多个存储芯片并联</strong>，增加存储字长，8片 8K x 1位 –&gt; 8K x 8 位</li></ol><p><img src="http://img.fdchen.host/%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="image-20210805200912468"></p><ol start="2"><li><strong>字扩展：多个存储芯片串联</strong>，增加存储字数量，4片 16K x 8位 –&gt; 64K x 8 位</li></ol><p><img src="http://img.fdchen.host/%E5%AD%90%E6%89%A9%E5%B1%95.png" alt="image-20210805201045496"></p><p>其中，CS 为片选信号，WE 为读写信号。</p><ol start="3"><li><strong>字位同时扩展：增加存储字数量，增加存储字长</strong>，相当于并联与串联结合在一起</li></ol><p><img src="http://img.fdchen.host/%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95.png" alt="image-20210805201225864"></p><ul><li><strong>存储芯片的地址分配和片选</strong></li></ul><ol><li><strong>线选法</strong>：<br>（1）通过地址线直接对芯片进行选择，某地址线信息为0即为选中，假设有4片芯片，就需要4根地址线<br>（2）优点是不需要地址译码器线路简单<br>（3）缺点是地址空间不连续，不能充分利用系统存储空间，造成地址资源浪费</li><li><strong>译码片选法</strong>：<br>（1）通过使用地址译码器对芯片进行选择，每一个芯片对应一个片选信号，8个芯片需要8个译码信号，此时可以使用3根地址线表示8个片选信<br>（2）优点是每片芯片的地址范围是唯一确定的，而且是连续的，也便于扩展<br>（3）缺点是对译码电路要求过高</li></ol><ul><li><strong>存储器与CPU的连接</strong></li></ul><ol><li><strong>合理选择存储芯片</strong></li></ol><p>（1）RAM为用户编程设置的</p><p>（2）ROM存放系统程序</p><ol start="2"><li><strong>地址线的选择</strong>：芯片容量不同，地址线不同</li></ol><p>（1）CPU地址线低位与存储芯片的地址线连接（片内寻址，字选）</p><p>（2）CPU地址线高位用于扩展芯片使用（片选）</p><ol start="3"><li><strong>数据线的选择</strong></li></ol><p>（1）CPU数据线数与存储芯片线数相等时可以直接连接</p><p>（2）CPU数据线数与存储芯片线数不等时，必须对存储芯片进行扩位，使其相等</p><ol start="4"><li><strong>读&#x2F;写命令线的连接</strong></li></ol><p>高电平为读，低电平为写</p><ol start="5"><li><strong>片选线的连接</strong></li></ol><p>（1）片选线的作用在于选择哪一片存储芯片被选中，是CPU与存储芯片连接的关键。</p><p>（2）片选有效信号与CPU访存控制信号有关，因为只有当CPU访存时，才要求选中存储芯片，若CPU访问I&#x2F;O，表示不要求存储器工作。</p><h2 id="3-5-双端口RAM和多模块存储器"><a href="#3-5-双端口RAM和多模块存储器" class="headerlink" title="3.5 双端口RAM和多模块存储器"></a>3.5 双端口RAM和多模块存储器</h2><ul><li><strong>目的</strong></li></ul><p>为了提高CPU访问存储器的速度采用双端口存储器（空间并行）、多模块存储器（时间并行）</p><ul><li><strong>双端口RAM</strong></li></ul><ol><li>一个存储单元有左右两个独立端口，分别具有两组相互独立的地址线、数据线、读写控制线</li><li>冲突情况：对于同一地址单元，两个端口同时写入数据；或者对于同一个地址单元，一个端口写，一个端口读。<strong>解决方法：置”忙“信号为0，由判断逻辑决定暂时关闭一个端口。</strong></li><li>无冲突情况：对于同一个地址单元，两个端口同时读；或者对于同一个地质单元，两个端口不同时写。</li></ol><ul><li><strong>多模块存储器</strong></li></ul><p>目的：为了提高访问速度。</p><ol><li><strong>单体多字存储器</strong></li></ol><p>（1）按照地址顺序读出数据，存储单元存储m个字，总线宽度也为m个字，一次性并行读出m个字。</p><p>（2）优点：增大了存储器带宽，提高单体存储器工作速度</p><p>（3）缺点：指令和数据在主存内必须是连续存放的</p><ol start="2"><li><strong>多体并行存储器</strong></li></ol><p>（1）多个模块构成，每个模块有着相同的容量和存取速度，各模块既可并行工作也可交叉工作</p><p>（2）<strong>高位交叉编制：高位地址表示体号，低位地址表示体内地址</strong>，把低位的体内地址送到由高位体号确定的模块内进行译码。</p><p>访问一个连续主存块，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问（<strong>每个块内地址需要根据上一个的访问结果来确定</strong>），本质上仍然是顺序存储器，不能提高存储器的效率。</p><p>（3）<strong>低位交叉编制：低位地址表示体号，高位地址表示体内地址</strong>，把高位的体内地址送到由低位体号确定的模块内进行译码。</p><p>因为程序连续存放在相邻模块中，因此采用此编址方式的存储器为交叉存储器。可以在不改变每个模块的存取周期的前提下（<strong>块内地址已经提前知道</strong>），采用流水线的方式并行存储，可以提高存储器的带宽。</p><p><img src="http://img.fdchen.host/%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="image-20210805203905400"></p><h2 id="3-6-高速缓冲存储器"><a href="#3-6-高速缓冲存储器" class="headerlink" title="3.6 高速缓冲存储器"></a>3.6 高速缓冲存储器</h2><h3 id="3-6-1-程序访问的局部性原理"><a href="#3-6-1-程序访问的局部性原理" class="headerlink" title="3.6.1 程序访问的局部性原理"></a>3.6.1 程序访问的局部性原理</h3><ol><li><strong>时间局部性：</strong>最近的将要使用的信息可能是现在正在使用的信息，因为程序中存在循环。</li><li><strong>空间局部性：</strong>最近的将要使用的信息可能与正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚在一起的。</li></ol><p>高速缓冲技术就是利用程序访问你的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而大大提高程序的执行速度。</p><h3 id="3-6-2-Cache基本工作原理"><a href="#3-6-2-Cache基本工作原理" class="headerlink" title="3.6.2 Cache基本工作原理"></a>3.6.2 Cache基本工作原理</h3><ol><li>通常使用SRAM制造</li><li>Cache和主存都被划分为相等的块，Cache块又称Cache行，每块由若干字节组成，块的长度称为块长（Cache行长）。Cache中的块数远少于主存中的块数，仅存储主存中最为活跃的信息副本，按照某种策略将这些活跃的信息存入到Cache中。</li><li>CPU发出读请求：<ul><li>若访存地址在Cache中，命中：将访问地址转换成Cache地址，直接对Cache进行读操作</li><li>若访存地址不在Cache中，不命中：CPU访问主存操作，并且将访问数据所在的块一次性送入到Cache中。若此时Cache已满，需根据某种替换算法，用这个块替换Cache中原来的某块信息。</li></ul></li><li>CPU发出写请求：<ul><li>若CPU命中，有可能遇到Cache与主存中的内容不一致的访问问题。需按照一定的写策略处理，常见的处理方法有全写法和写回法。</li></ul></li></ol><p>CPU与Cache直接交换数据的基本单位是字，Cache与主存之间交换数据的基本单位是Cache块。</p><h3 id="3-6-3-Cache与主存的映射方式"><a href="#3-6-3-Cache与主存的映射方式" class="headerlink" title="3.6.3 Cache与主存的映射方式"></a>3.6.3 Cache与主存的映射方式</h3><p>按照一定的规则将主存中的某些数据存入到Cache中。</p><ul><li><strong>直接映射</strong></li></ul><ol><li><p><strong>主要原理：</strong>主存数据块只能装入Cache中的唯一位置，若这个位置已有内容，则产生块冲突，原来的块将无条件被替换出去（无须使用替换算法）。</p></li><li><p><strong>优缺点：</strong>直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。</p></li><li><p><strong>映射关系：</strong>主存块在Cache中的<strong>位置 &#x3D; 主存块号 % Cache总块数</strong></p></li><li><p><strong>直接映射的访问地址结构为：标志  Cache行号  块内地址</strong></p></li><li><p><strong>CPU访存过程：</strong></p></li></ol><p>首先根据访存地址（默认是主存地址）中间的c位（主存地址块号的低c位正好是Cache行号），找到对应的Cache行，将对应Cache行中的标记和主存地址的高t位进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或者有效位为0，则“不命中”，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高t位，同时将该地址中的内容送到CPU。</p><ul><li><strong>全相联映射</strong></li></ul><ol><li><strong>主要原理：</strong>主存的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块（主存地址），所以CPU访存时需要与所有Cache行的标记进行比较。</li><li><strong>优缺点：</strong>全相联映射方式的优点是比较灵活，Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的比较速度较慢，实现成本较高。</li><li><strong>全相联映射的访问地址结构为：标记（主存块号）  块内地址</strong></li></ol><ul><li><strong>组相联映射</strong></li></ul><ol><li><strong>主要原理：</strong>将Cache空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射。假设每组有r个Cache行，则称之为r路组相联映射。</li><li><strong>映射关系：Cache行的组号 &#x3D; 主存的块号 % Cache的组数</strong></li><li><strong>组相联映射的地址结构为：标记  组号  块内地址</strong></li><li><strong>优缺点：</strong>路数越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。</li><li><strong>CPU访存过程：</strong></li></ol><p>首先根据访存地址中间的组号找到对应的Cache组；将对应Cache组中的每个行的标记与主存地址的高位标记进行比较；若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息；若不相等或者有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲位中，将有效位置1，并设置标记，同时将该地址中的内容送到CPU。</p><h3 id="3-6-4-Cache中的替换算法"><a href="#3-6-4-Cache中的替换算法" class="headerlink" title="3.6.4 Cache中的替换算法"></a>3.6.4 Cache中的替换算法</h3><ul><li><strong>随机算法（RAND）</strong></li></ul><p>随机确定替换的Cache块。优点是实现简单，缺点是没有依据局部性原理，命中率低。</p><ul><li><strong>先进先出算法（FIFO）</strong></li></ul><p>选择最早调入的行进行替换。优点是实现简单，缺点是没有依据局部性原理，命中率低。</p><ul><li><strong>近期最少使用算法（LRU，Least Recently Used）</strong></li></ul><p>依据程序访问的局部性原理，选择近期内长久未访问过的Cache作为替换的行，平均命中率要比FIFO高，是堆栈类算法。</p><ol><li><strong>堆栈类算法：</strong>当一个新的进程访问某页面时，便将该页面号压入栈顶，其他的页面号往栈底移，如果内存不够，则将栈底的页面号移除。这样，栈顶始终是最新被访问的页面的编号，而栈底则是最近最久未访问的页面的页面号。</li><li><strong>LRU算法实现：</strong>对每个Cache设置一个计数器，用计数值来记录主存块的使用情况（计数值代表未被访问的次数），并根据计数值选择淘汰某个块（计数值最大的淘汰），计数值的位数与Cache组大小有关，2路时有一位LRU位，4路时，有两位LRU位。</li><li><strong>抖动：在更换页面时，如果更换页面是一个很快会被再次访问的页面，则再次缺页中断后又很快会发生新的缺页中断。整个系统的效率急剧下降——这种现象称为颠簸（抖动）</strong>。在这里指的是Cache反复加载和驱动Cache块相同的组。如访问块号序列为1 2 3 4 5 1 2 3 4 5，而路数为4，导致命中率为0。</li></ol><ul><li><strong>最不经常使用算法（LFU，Least Frequently Used）</strong></li></ul><p>将一段时间内被访问次数最少的Cache行换出。</p><ol><li><strong>LFU算法实现</strong>：每行设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。与LRU不同的是，此处是被访问行次数增加，换出计数值最小的行。</li></ol><h3 id="3-6-5-Cache写策略"><a href="#3-6-5-Cache写策略" class="headerlink" title="3.6.5 Cache写策略"></a>3.6.5 Cache写策略</h3><ul><li><strong>写命中</strong></li></ul><ol><li><strong>全写法（写直通法，write-through）：</strong>对Cache写命中后，数据同时写入Cache和主存。实现简单，随时保持主存数据正确性，但是增加了访存次数，降低了效率。</li><li><strong>写回法（write-back）：</strong>对Cache命中时，只修改Cache内容，不立即写入主存，只有当此块被换出时才写回主存。减少了访存次数，但是存在数据不一致的隐患，每个Cache行必须设置一个标志位（脏位），以此放映此块是否被CPU修改过。</li></ol><ul><li><strong>写不命中</strong></li></ul><ol><li><strong>写分配法（write-allocate）：</strong>加载主存中的块到Cache中，然后更新Cache块。试图使用空间局部性原理，缺点是每次不命中都需要从Cache主存中读取一块。</li><li><strong>非写分配法（not-write-allocate）：</strong>只写入主存，不进行调块。</li></ol><ul><li><strong>多级Cache（通常为3级）</strong></li></ul><p>现代计算机通常设置多级Cache，按离CPU的远近可各自取名为L1 Cache，L2 Cache，L3 Cache，离CPU越远，访问速度越慢，容量越大。指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与写回法合用。</p><p>多级Cache由于访问速度仍然大于主存，可以有效避免频繁写时造成的写缓冲饱和溢出。</p><h2 id="3-7-虚拟存储器"><a href="#3-7-虚拟存储器" class="headerlink" title="3.7 虚拟存储器"></a>3.7 虚拟存储器</h2><ul><li><strong>基本概念</strong></li></ul><p>将主存或者辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间中，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。</p><p>用户编程允许涉及的地址称为<strong>虚地址或逻辑地址</strong>，虚地址对应的存储空间称为<strong>虚拟空间或程序空间</strong>。实际的主存单元地址称为<strong>实地址或物理地址</strong>，实地址对应的时主存地址空间，也称实地址空间。虚拟地址要比实地址大很多。</p><p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；若不存在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。若主存已满，则采用替换算法置换主存中的一页或一段。</p><p>实际物理地址存储中，需要使用的程序和数据先送入主存，暂时不用的放在磁盘中。</p><h3 id="3-7-1-页式虚拟存储器"><a href="#3-7-1-页式虚拟存储器" class="headerlink" title="3.7.1 页式虚拟存储器"></a>3.7.1 页式虚拟存储器</h3><p>以页为基本单位的虚拟存储器称为页式虚拟存储器。</p><ul><li><strong>基本概念</strong></li></ul><p><img src="http://img.fdchen.host/%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E9%A1%B5%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="image-20210816204353736"></p><ol><li><strong>有效位也称装入位</strong>，用来表示对应页面是否在主存，若为1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号；若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。</li><li><strong>脏位也称修改位</strong>，用来表示页面是否被修改过，虚存机制中采用回写策略（写回法），利用脏位可判断替换时是否需要写回磁盘。</li><li><strong>引用位也称使用位</strong>，用来配合替换策略进行设置，例如是否实现最先调入(FIFO 位)或最近最少用(LRU位)策略等。</li></ol><ul><li><strong>页式虚拟存储器的地址变换过程</strong></li></ul><p><img src="http://img.fdchen.host/%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="image-20210816204621787"></p><ol><li>虚拟地址&#x3D;虚页号+页内地址</li><li>虚页号+页表起始地址&#x3D;页表地址</li><li>根据页表地址查找实页号</li><li>实页号+页内地址&#x3D;实地址</li></ol><ul><li><strong>优点</strong></li></ul><p>页面长度固定，调入方便。</p><ul><li><strong>缺点</strong></li></ul><p>由于程序不可能正好是页面的整数倍，最后一页的的零头浪费，并且页不是逻辑上的实体，对页的处理、保护、共享不是特别方便。</p><h3 id="3-7-2-段式虚拟存储器"><a href="#3-7-2-段式虚拟存储器" class="headerlink" title="3.7.2 段式虚拟存储器"></a>3.7.2 段式虚拟存储器</h3><p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。</p><ul><li><strong>基本概念：</strong>装入位。</li><li><strong>段式虚拟存储器的地址变换过程</strong></li></ul><p><img src="http://img.fdchen.host/%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="image-20210816205105298"></p><ol><li>虚地址&#x3D;段号+段内地址</li><li>段号+段表起始地址&#x3D;段表地址</li><li>查询段表数据（段表项）</li><li>实地址&#x3D;段表所得数据（段表项）+段内地址</li></ol><ul><li><strong>优点</strong></li></ul><p>段分界与程序分界相对应，易于编译、管理、修改、保护、共享。</p><ul><li><strong>缺点</strong></li></ul><p>段长分配不便存在段间碎片。</p><h3 id="3-7-3-段页式虚拟存储器"><a href="#3-7-3-段页式虚拟存储器" class="headerlink" title="3.7.3 段页式虚拟存储器"></a>3.7.3 段页式虚拟存储器</h3><ul><li><strong>基本思想</strong></li></ul><ol><li>先将程序按逻辑分段，再将每段分为固定大小页。</li><li>每个程序对应一个段表，每段对应一个页表。段长必须是页的整数倍，段的起点必须是某一页的起点。</li><li>虛地址&#x3D;段号+段内页号+页内地址。CPU根据虚地址访存时，首先根据段号得到段表地址，然后从段表中取出<strong>该段的页表起始地址</strong>，与虚地址段内页号合成，得到页表地址，最后从页表中取出实页号，与页内地址拼接形成主存实地址。</li></ol><ul><li><strong>优点</strong></li></ul><p>可以按段实现共享和保护，同时也有着页的调用方便。</p><ul><li><strong>缺点</strong></li></ul><p>地址变换要两次查表，开销较大。</p><h3 id="3-7-4-快表（TLB）"><a href="#3-7-4-快表（TLB）" class="headerlink" title="3.7.4 快表（TLB）"></a>3.7.4 快表（TLB）</h3><ul><li><strong>基本思想</strong></li></ul><p>根据局部性原理，将一些经常访问的页表项放入高速缓冲器中构成快表，可以极大提高查询的效率。</p><p>相应的在主存中的页表称为 慢表（Page）。</p><ul><li>通常采用全相联或组相联方式。</li><li><strong>访问顺序：</strong>TLB –&gt; Page –&gt; Cache –&gt; 主存</li><li><strong>具有TLB和Cache的多级存储系统</strong></li></ul><p><img src="http://img.fdchen.host/%E5%85%B7%E6%9C%89TLB%E5%92%8CCache%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt="image-20210816225429438"></p><p>如图是一个具有TLB和Cache的多级存储系统，其中Cache采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器。</p><ol><li>查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换。</li><li>若TLB未命中，则TLB缺失，需要访问主存去查页表。图<strong>中所示的是两级页表方式，虚页号被分成页目录索引和页表索引两部分</strong>，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB；若TLB已满，则还需要采用替换策略。</li><li>完成由虚拟地址到物理地址的转换后，Cache 机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache 行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。</li></ol><p>PS：查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。</p><ul><li><strong>TLB、Page、Cache三种缺失的可能组合</strong></li></ul><p><img src="http://img.fdchen.host/TLB%E3%80%81Page%E3%80%81Cache%E4%B8%89%E7%A7%8D%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%8F%AF%E8%83%BD%E7%BB%84%E5%90%88.png" alt="image-20210816230008145"></p><ul><li><strong>带TLB的虚拟存储器的CPU访存过程</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20201227220250350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FpeGlhb2xvbmd0aGw=,size_16,color_FFFFFF,t_70" alt="带TLB的虚拟存储器的CPU访存过程"></p><h2 id="3-8-虚拟存储器与Cache异同"><a href="#3-8-虚拟存储器与Cache异同" class="headerlink" title="3.8 虚拟存储器与Cache异同"></a>3.8 虚拟存储器与Cache异同</h2><ul><li><strong>相同之处</strong></li></ul><ol><li>目的都是为了提高系统性能</li><li>数据分为小信息块，作为基本的传递单位</li><li>都存在地址映射，替换算法，更新策略</li><li>按照局部性原理，将活跃的数据放到高速部件中</li></ol><ul><li><strong>不同之处</strong></li></ul><ol><li>Cache解决系统速度问题；虚拟存储器解决主存容量问题</li><li>Cache全部由硬件实现，是硬件存储器；虚拟存储器由OS和硬件共同实现，是逻辑上的存储器</li><li>Cache对所有程序员透明；虚拟存储器对应用程序员透明，对系统程序员不透明</li><li>虚拟存储器不命中对系统性能影响更大</li><li>CPU只能与Cache和主存直接交互；虚拟存储器只能先将数据从硬盘调入主存，不能与CPU直接通信</li></ol><h1 id="4-指令系统"><a href="#4-指令系统" class="headerlink" title="4 指令系统"></a>4 指令系统</h1><h2 id="4-1-指令格式"><a href="#4-1-指令格式" class="headerlink" title="4.1 指令格式"></a>4.1 指令格式</h2><h3 id="4-1-1-指令的基本格式（操作码-地址码）"><a href="#4-1-1-指令的基本格式（操作码-地址码）" class="headerlink" title="4.1.1 指令的基本格式（操作码+地址码）"></a>4.1.1 指令的基本格式（操作码+地址码）</h3><ul><li><strong>结构</strong></li></ul><ol><li><strong>操作码：</strong>指出指令中应该执行什么性质的操作和具有何种功能</li><li><strong>地址码：</strong>给出被操作的信息（指令或数据）的地址</li></ol><ul><li><strong>长度</strong></li></ul><ol><li><strong>单字长指令：</strong>长度等于机器字长</li><li><strong>双字长指令：</strong>长度等于两倍机器字长</li><li><strong>半字长指令：</strong>长度等于半个机器字长</li></ol><ul><li><strong>根据操作数地址数目分类</strong></li></ul><ol><li><strong>零地址指令：</strong>OP</li></ol><p>只有操作码OP，没有给出地址。</p><p><strong>指令用途：</strong></p><p>（1）空操作指令，停机指令，关中断指令</p><p>（2）零地址的运算类指令仅使用在堆栈计算机中</p><ol start="2"><li><strong>一地址指令：</strong>OP A1</li></ol><p><strong>指令用途：</strong></p><p>（1）只有目的操作数的单操作指令，加1、减1、求反、求补</p><p>（2）隐含约定目的地址的双操作数指令</p><ol start="3"><li><strong>二地址指令：</strong>OP A1 A2</li></ol><p><strong>指令用途：</strong></p><p>（1）算数和逻辑运算指令</p><p>（2）往往需要两个操作数,分别给出目的操作数和源操作数地址，目的操作数地址还用于保存本次的运算结果</p><ol start="4"><li><strong>三地址指令：</strong>OP A1 A2 A3（结果）</li></ol><p><strong>指令用途：</strong>算术和逻辑运算指令,相对于二地址指令,结果直接存放在A3中</p><p><strong>需要访问4次存储器：</strong>取指令( 1次)、取两个操作数 ( 2次)、存放结果(1次)</p><ol start="5"><li><strong>四地址指令：</strong>OP A1 A2 A3（结果） A4（下址）</li></ol><p><strong>指令用途：</strong>算术和逻辑运算指令，相对于三地址指令多了下一条执行命令的地址( A4 )</p><h3 id="4-1-2-定长操作码指令格式"><a href="#4-1-2-定长操作码指令格式" class="headerlink" title="4.1.2 定长操作码指令格式"></a>4.1.2 定长操作码指令格式</h3><ul><li><strong>优点</strong></li></ul><p>定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利</p><ul><li><strong>缺点</strong></li></ul><p>指令数量增加时会占用更多固定位，初始表示操作数地址的位数受限</p><h3 id="4-1-3-扩展操作码指令格式（变长）"><a href="#4-1-3-扩展操作码指令格式（变长）" class="headerlink" title="4.1.3 扩展操作码指令格式（变长）"></a>4.1.3 扩展操作码指令格式（变长）</h3><ul><li><strong>实现</strong></li></ul><p>全部指令的操作码字段位数不固定，分散在指令字的不同位置上</p><ul><li><strong>优点</strong></li></ul><p>丰富了指令的种类</p><ul><li><strong>缺点</strong></li></ul><p>增加了指令译码和分析难度，控制器设计变的复杂</p><p>PS：短码不能是长码的前缀；指令操作码不能重复。</p><h2 id="4-2-指令寻址方式"><a href="#4-2-指令寻址方式" class="headerlink" title="4.2 指令寻址方式"></a>4.2 指令寻址方式</h2><h3 id="4-2-1-指令寻址和数据寻址"><a href="#4-2-1-指令寻址和数据寻址" class="headerlink" title="4.2.1 指令寻址和数据寻址"></a>4.2.1 指令寻址和数据寻址</h3><ul><li><strong>指令寻址</strong></li></ul><ol><li><strong>顺序寻址：</strong>通过程序计数器( PC )加1，自动生成下一条指令的地址</li><li><strong>跳跃寻址：</strong>跳跃的结果是当前指令修改pc值</li></ol><p>（1）<strong>绝对地址：</strong>由标记符直接得到</p><p>（2）<strong>相对地址：</strong>相对于当前指地址的偏移量，</p><h3 id="4-2-2-常见的数据寻址方式"><a href="#4-2-2-常见的数据寻址方式" class="headerlink" title="4.2.2 常见的数据寻址方式"></a>4.2.2 常见的数据寻址方式</h3><ul><li><strong>隐含寻址：</strong>不访存</li></ul><p>不显式的给出操作数地址,在指令中隐含操作数地址。如累加器（ACC）对单地址指令格式来说就是隐含地址。</p><p><strong>优点：</strong>有利于缩短指令字长</p><p><strong>缺点：</strong>增加存储操作数或隐含地址的硬件</p><ul><li><strong>立即（数）寻址：</strong>不访存</li></ul><p>地址字段给出的不是操作数的地址，而是操作数本身，又称为立即数。</p><p><strong>优点：</strong>不需要访问主存，指令执行时间最短。</p><p><strong>缺点：</strong>位数限制了立即数的范围</p><ul><li><strong>直接寻址：</strong>访存1次</li></ul><p>指令字中的形式地址就是真实地址。</p><p><strong>优点：</strong>访问一次主存，不需要专门计算操作数的地址。</p><p><strong>缺点：</strong>形式地址的位数限制了寻址范围，操作数地址不易修改。</p><ul><li><strong>间接寻址：</strong>一般问到扩大寻址范围，通常指寄存器间接寻址，访存多次( 具体看几次间接寻址)</li></ul><p>指令的地址字段给出存储地址信息的地址（类似于嵌套访存）。</p><p><strong>优点：</strong>扩大了寻址范围，方便编制程序。</p><p><strong>缺点：</strong>需要多次访存,访问速度过慢,这种寻址方式不是特别常用。</p><ul><li><strong>寄存器寻址：</strong>不访存</li></ul><p>指令字中直接给出操作数所在的寄存器编号。</p><p><strong>优点：</strong>不访问主存，执行速度快，支持向量&#x2F;矩阵运算</p><p><strong>缺点：</strong>寄存器价格高昂，寄存器中的寄存器个数有限</p><ul><li><strong>寄存器间接寻址：</strong>访存多次（具体看几次间接寻址）</li></ul><p>寄存器间接寻址是指在寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址。</p><p><strong>特点：</strong>与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)。</p><ul><li><strong>相对寻址：</strong>访存1次</li></ul><p>相对寻址是把程序计数器(PC)的内容加上指令格式中的形式地址A（当前指令地址的位移量）而形成操作数的有效地址。</p><p><strong>优点：</strong>操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差-一个固定值，因此便于程序浮动。相对寻址广泛应用于转移指令。</p><ul><li><strong>基址寻址：</strong>访存1次</li></ul><p>基址寻址是指将CPU中基址寄存器(BR) 的内容加上指令格式中的形式地址A，而形成操<br>作数的有效地址，即EA&#x3D; (BR)+ A，其中基址寄存器既可采用专用寄存器，又可采用通用寄存。</p><p><strong>基址寄存器是面向操作系统的</strong>，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。<strong>在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)。</strong>采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。</p><p><strong>优点：</strong>可扩大寻址范围(基址寄存器的位数大于形式地址A的位数)；用户不必考虑自己的程序存于主存的哪个空间区城，因此有利于多道程序设计，并可用于编制浮动程序。</p><p><strong>缺点：</strong>形式地址A的位数较短。</p><ul><li><strong>变址寻址：</strong>访存1次</li></ul><p>变址寻址是指有效地址EA等于指令字中的形式地址A与变址寄存器 IX 的内容之和，即<br>EA&#x3D; (IX)+ A，其中IX为变址寄存器(专用)，也可用通用寄存器作为变址寄存器。</p><p><strong>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移量),形式地址A不变(作为基地址)。</strong></p><p><strong>优点：</strong>可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任一数据的地址， 特别适合编制循环程序。偏移量(变址寄存器IX)的位数足以表示整个存储空间。</p><ul><li><strong>堆栈寻址：</strong>硬堆栈不访存，软堆栈访存1次</li></ul><p>堆栈是存储器(或专用寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中读&#x2F;写单元的地址是用-一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。</p><ol><li><p>寄存器堆栈又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈；</p></li><li><p>从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。</p></li></ol><p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。 通常情况下，在读&#x2F;写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p><p><img src="http://img.fdchen.host/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E3%80%81%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E5%8F%8A%E8%AE%BF%E5%AD%98%E6%AC%A1%E6%95%B0.png" alt="image-20210817170000941"></p><h3 id="4-2-3-X86汇编指令入门"><a href="#4-2-3-X86汇编指令入门" class="headerlink" title="4.2.3 X86汇编指令入门"></a>4.2.3 X86汇编指令入门</h3><ul><li><strong>相关寄存器</strong></li></ul><p>X86处理器中有8个32位的通用寄存器，各寄存器及说明如图所示。为了向后兼容，EAX、EBX、ECX和EDX的高两位字节和低两位字节可以独立使用，E为Extended,表示32<br>位的寄存器。例如，EAX的低两位字节称为AX,而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。寄存器的名称与大小写无关，既可以用EAX，又可以用eax。除EBP和ESP外，其他几个寄存器的用途是比较任意的。</p><p><img src="http://img.fdchen.host/X86%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="image-20210817181758333"></p><ul><li><strong>寻址方式和内存分配</strong></li></ul><ol><li><strong>寻址模式</strong></li></ol><p>X86提供了一种灵活的内存寻址方式，这里以mov指令为例。mov用于在内存和寄存器之间移动数据，它有两个参数：第一个是目的地址，第二个是源地址。</p><p>汇编程序中常见的方式：</p><pre class="line-numbers language-none"><code class="language-none">mov eax, [ebx];将ebx值指示的内存地址中的4字节传送到eaxmov [var], ebx;将ebx值传送到var的值指示的内存地址中mov eax, [esi-4];将esi-4值指示的内容地址中的4字节传送到eaxmov [esi+eax], c1;将C1值传送到esi+eax值指示的内存地址中mov edx, [esi+4*ebxJ;将esi+4*ebx值指示的内存中的4字节传送到edx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最多只能利用两个32位寄存器和一个32位的有符号常数<strong>相加</strong>计算出一个内存地址。</p><ol start="2"><li><strong>数据类型长度规定</strong></li></ol><p>在汇编语言中声明内存大小时，一般显式地使用 DB (字母D表示Data，字母B表示<br>Byte)、DW (字母W表示Word，2Bytes) 和DD (第二个字母D表示Double Word，4Bytes)，这样就能很好地指导编译器分配内存空间。</p><p>对于 mov  [ebx], 2; 若无特殊标识，则不确定常数2是单字节、双字节还是双字。</p><p>对于这种情况，X86提供了三个指示规则标记，分别为BYTE PTR、WORD PTR和DWORD PTR，如将上例写成</p><pre class="line-numbers language-none"><code class="language-none">mov byte ptr [ebx], 2;将2以单字节形式传送到ebx值指示的内存地址中mov word ptr [ebx], 2;将2以双字节形式传送到ebx值指示的内存地址中mov dword ptr [ebx], 2;将2以四字节形式传送到ebx值指示的内存地址中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>常用指令</strong></li></ul><p>汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令，以下用于操作数的标记分别表示寄存器、内存和常数：&lt;reg&gt;表示任意寄存器，其后数字代表其位数；&lt;mem&gt;表示内存地址；&lt;con&gt;表示8位、16位或32位常数。</p><ol><li><strong>数据传送指令</strong></li></ol><p><strong>mov指令</strong></p><p>mov指令将第二个操作数(寄存器的内容、内存中的内容或常数值)复制到第一个操作数(寄存器或内存)。但不能用于直接从内存复制到内存，其语法如下：</p><pre class="line-numbers language-mov" data-language="mov"><div class="caption"><span><reg>, <reg></span></div><code class="language-mov">mov &lt;reg&gt;,&lt;mem&gt;mov &lt;mem&gt;,&lt;reg&gt;mov &lt;reg&gt;,&lt;con&gt;mov &lt;mem&gt;,&lt;con&gt;举例:mov eax, ebx;将ebx值复制到eaxmov byte ptr [var], 5;将5保存到var值指示的内存地址的-字节中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>push指令</strong></p><p>push指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前先将ESP值减4<br>(<strong>栈增长方向与内存地址增长方向相反</strong>)，然后将操作数压入ESP指示的地址。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">push &lt;reg32&gt;push &lt;mem&gt;push &lt;con32&gt;举例(注意，栈中元素固定为32位):push eax;将eax值压栈push [var];将var值指示的内存地址的4字节值压栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pop指令</strong></p><p>与push指令相反，pop指令执行的是出栈工作，出栈前先将ESP 指示的地址中的内容出<br>栈，然后将ESP值加4。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">pop edi;弹出栈顶元素送到edipop [ebx];弹出栈顶元素送到ebx值指示的内存地址的4字节中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><strong>算数和逻辑运算指令</strong></li></ol><p><strong>add&#x2F;sub指令</strong></p><p>add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub 指令用于两个操作数相减，相减的结果保存到第-一个操作数中。它们的语法格式类似，语法如下：</p><pre class="line-numbers language-none"><code class="language-none">add &lt;reg&gt;,&lt;reg&gt; &#x2F; sub &lt;reg&gt;,&lt;reg&gt;add &lt;reg&gt;,&lt;mem&gt; &#x2F; sub &lt;reg&gt;, &lt;mem&gt;add &lt;mem&gt;,&lt;reg&gt; &#x2F; sub &lt;mem&gt;, &lt;reg&gt;add &lt;reg&gt;,&lt;con&gt; &#x2F; sub &lt;reg&gt;,&lt;con&gt;add &lt;mem&gt;,&lt;con&gt; &#x2F; sub &lt;mem&gt;, ccon&gt;.举例:sub eax, 10;eax ⬅ eax-10add byte ptr [var], 10;10与var值指示的内存地址的一字节值相加，并将结果;保存在var值指示的内存地址字节中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>inc&#x2F;dec指令</strong></p><p>inc、dec 指令分别表示将操作数自加1、自减1，其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">inc &lt;reg&gt; &#x2F; dec. &lt;reg&gt;inc &lt;mem&gt; &#x2F; dec &lt;mem&gt;举例:dec eax;eax值自减1inc dword ptr [var];var值指示的内存地址的4字节值自加1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>imul指令</strong></p><p>带符号整数乘法指令，它有两种格式：①两个操作数，将两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器；②三个操作数，将第二个和第三个操作数相乘，并将结果保存在第一-个操作数中， 第一个操作数必须为寄存器。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">imul &lt;reg32&gt;,&lt;reg32&gt;imul &lt;reg32&gt;,&lt;mem&gt;imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;。imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;举例:imul eax, [var];eax ⬅ eax * [var]imul esi, edi, 25;esi ⬅ edi * 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乘法操作结果可能溢出，则编译器置溢出标志OF&#x3D;1，以使CPU调出溢出异常处理程序。</p><p><strong>idiv指令</strong></p><p>idiv是带符号整数除法指令，它只有一-个操作数，即除数，而被除数则为edx:eax 中的内容(64位整数)，操作结果有两部分：商和余数，商送到eax，余数则送到edx。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">idiv &lt;reg32&gt;idiv &lt;mem&gt;举例:idiv ebxidiv dword ptr [var]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>and&#x2F;or&#x2F;xor指令</strong></p><p>and、or、xor 指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">and &lt;reg&gt;,&lt;reg&gt; &#x2F; or &lt;reg&gt;,&lt;reg&gt; &#x2F; xor &lt;reg&gt;,&lt;reg&gt;and &lt;reg&gt;,&lt;mem&gt; &#x2F; or &lt;reg&gt;,&lt;mem&gt; &#x2F; xor &lt;reg&gt;,&lt;mem&gt;and &lt;mem&gt;,&lt;reg&gt; &#x2F; or &lt;mem&gt;,&lt;reg&gt; &#x2F; xor &lt;mem&gt;,&lt;reg&gt;and &lt;reg&gt;,&lt;con&gt; &#x2F; or &lt;reg&gt;,&lt;con&gt; &#x2F; xor &lt;reg&gt;,&lt;con&gt;and &lt;mem&gt;,&lt;con&gt; &#x2F; or &lt;mem&gt;,&lt;con&gt; &#x2F; xor &lt;mem&gt;,&lt;con&gt;举例:and eax, 0fH;将eax中的前28位全部置为0，最后4位保持不变xor edx, edx;置edx中的内容为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>not指令</strong></p><p>not指令是位翻转指令，将操作数中的每-位翻转， 即0➡1、 1➡0.其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">not &lt;reg&gt;not &lt;mem&gt;举例:not byte ptr [var];将var值指示的内存地址的一字节的所有位翻转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>shl&#x2F;shr指令</strong></p><p>shl、shr 是逻辑移位指令，shl 为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">sh1 &lt;reg&gt;,&lt;con8&gt; &#x2F; shr &lt;reg&gt;,&lt;con8&gt;shl &lt;mem&gt;,&lt;con8&gt; &#x2F; shr &lt;mem&gt;,&lt;con8&gt;shl &lt;reg&gt;,&lt;c1&gt; &#x2F; shr &lt;reg&gt;,&lt;cl&gt;shl &lt;mem&gt;,&lt;cl&gt; &#x2F; shr &lt;mem&gt;,&lt;cl&gt;举例:shl eax, 1;将eax值左移1位，相当于乘以2shr ebx, cl;将ebx值右移n位(n为cl中的值)，相当于除以2^n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>控制流指令</strong></li></ol><p>X86处理器维持着一个指示当前执行指令的指令指针(IP)，当一条指令执行后，此指针自<br>动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签(label)指示程序中的指令地址，在X86汇编代码中，可在任何指令前加入标签。例如，</p><pre class="line-numbers language-none"><code class="language-none">mov esi, [ebp+8]begin:xor ecx, ecxmov eax, [esi]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样就用begin指示了第二条指令，控制流指令通过标签就可以实现程序指令的跳转。</p><p><strong>jmp指令</strong></p><p>jmp指令控制IP转移到label所指示的地址(从label中取出指令执行)。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">jmp &lt;label&gt;举例:jmp begin;转跳到begin标记的指令执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>jcondition指令</strong></p><p>条件转移指令，它依据处理机状态字中的一系列条件状态转移。处理机状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等。其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">je &lt;labe1&gt; (jump when equal)jne &lt;labe1&gt; (jump when not equa1)jz &lt;label&gt; (Jump when last result was zero)jg &lt;label&gt; (jump when greater than)jge &lt;labe1&gt; (jump when greater than or equal to)j1 &lt;label&gt; (jump when less than)jle &lt;labe1&gt; (jump when less than or, equal to)举例:cmp eax, ebxjle done;如果eax的值小于等于ebx值，跳转到done指示的指令执行，否则执行下一;条指令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>cmp指令</strong></p><p>cmp指令用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码，其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">cmp &lt;reg&gt;,&lt;reg&gt;cmp &lt;reg&gt;,&lt;mem&gt;cmp &lt;mem&gt;,&lt;reg&gt;cmp &lt;reg&gt;,&lt;con&gt;cmp指令通常和jcondition指令搭配使用，举例:cmp dword ptr [var], 10jne 1oop;如果var指示的内存地址的4字节内容等于10,则继续执行下一条指 ;令；否则跳转到1oop指示的指令执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>call&#x2F;ret指令</strong></p><p>call和ret这两条指令分别实现子程序(过程、函数等)的调用及返回。<strong>call 指令首先将当</strong><br><strong>前执行指令地址入栈，然后无条件转移到由标签指示的指令。</strong>与其他简单的跳转指令不同，call指令保存调用之前的地址信息(当call 指令结束后，返回调用之前的地址)。<strong>ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。</strong>call和ret是函数调用中最关键的两条指令，其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">cal1 &lt;label&gt;ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-3-CISC-和-RISC"><a href="#4-3-CISC-和-RISC" class="headerlink" title="4.3 CISC 和 RISC"></a>4.3 CISC 和 RISC</h2><h3 id="4-3-1-复杂指令系统计算机（CISC）"><a href="#4-3-1-复杂指令系统计算机（CISC）" class="headerlink" title="4.3.1 复杂指令系统计算机（CISC）"></a>4.3.1 复杂指令系统计算机（CISC）</h3><ul><li><strong>CISC主要特点</strong></li></ul><ol><li>指令系统复杂庞大，指令数目一般为200条以上。</li><li>指令的长度不固定，指令格式多，寻址方式多。</li><li>可以访存的指令不受限制。</li><li>各种指令使用频度相差很大。</li><li>各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。</li><li>控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬布线控制</li><li>难以用优化编译生成高效的目标代码程序。</li></ol><h3 id="4-3-2-精简指令系统计算机（RISC）"><a href="#4-3-2-精简指令系统计算机（RISC）" class="headerlink" title="4.3.2 精简指令系统计算机（RISC）"></a>4.3.2 精简指令系统计算机（RISC）</h3><ul><li><strong>RISC主要特点</strong></li></ul><ol><li>选取使用频率较高的一些简单指令，复杂指令的功能由简单指令的组合来实现。</li><li>指令长度固定，指令格式种类少，寻址方式种类少。</li><li>只有Load&#x2F;Store (取数&#x2F;存数)指令访存，其余指令的操作都在寄存器之间进行。</li><li>CPU中通用寄存器的数量相当多。</li><li>RISC 一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li><li>以硬布线控制为主，不用或少用微程序控制。</li><li>特别重视编译优化工作，以减少程序执行时间。</li></ol><h3 id="4-3-3-CISC和RISC的比较"><a href="#4-3-3-CISC和RISC的比较" class="headerlink" title="4.3.3 CISC和RISC的比较"></a>4.3.3 CISC和RISC的比较</h3><p>和CISC相比，RISC 的优点主要体现在以下几点：</p><ol><li><strong>RISC更能充分利用CPU芯片的面积。</strong>CISC 的控制器大多采用微程序控制，其控制存<br>储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%左右。</li><li><strong>RISC更能提高运算速度。</strong>RISC 的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。</li><li><strong>RISC便于设计，可降低成本，提高可靠性。</strong>RISC指令系统简单，因此机器设计周期<br>短；其逻辑简单，因此可靠性高。</li><li><strong>RISC有利于编译程序代码优化。</strong>RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。</li></ol><ul><li><strong>CISC和RISC对比</strong></li></ul><table><thead><tr><th>对比项目</th><th>CISC</th><th>RISC</th></tr></thead><tbody><tr><td>指令系统</td><td>复杂，庞大</td><td>简单，精简</td></tr><tr><td>指令数目</td><td>一般不大于200条</td><td>一般小于100条</td></tr><tr><td>指令字长</td><td>不固定</td><td>定长</td></tr><tr><td>可访存指令</td><td>不加限制</td><td>只有Load&#x2F;Store指令</td></tr><tr><td>各种指令执行时间</td><td>相差较大</td><td>绝大多数在一个周期内完成</td></tr><tr><td>各种指令使用频度</td><td>相差很大</td><td>都比较常用</td></tr><tr><td>通用寄存器数量</td><td>较少</td><td>多</td></tr><tr><td>目标代码</td><td>难以用优化编译生成高效的目标代码程序</td><td>采用优化的便宜程序，生成代码较为高效</td></tr><tr><td>控制方式</td><td>绝大多数为微程序控制</td><td>绝大多数为组合逻辑控制</td></tr><tr><td>指令流水线</td><td>可以通过一定方式实现</td><td>必须实现</td></tr></tbody></table><h1 id="5-中央处理器"><a href="#5-中央处理器" class="headerlink" title="5 中央处理器"></a>5 中央处理器</h1><h2 id="5-1-CPU的功能和基本结构"><a href="#5-1-CPU的功能和基本结构" class="headerlink" title="5.1 CPU的功能和基本结构"></a>5.1 CPU的功能和基本结构</h2><h3 id="5-1-1-CPU的功能"><a href="#5-1-1-CPU的功能" class="headerlink" title="5.1.1 CPU的功能"></a>5.1.1 CPU的功能</h3><ul><li><strong>组成</strong></li></ul><ol><li><strong>控制器</strong></li></ol><p>协调并控制计算机各部件执行程序的指令序列，包括取指令，分析指令，执行指令。</p><ol start="2"><li><strong>运算器：</strong>对数据进行加工。</li></ol><ul><li><strong>具体功能</strong></li></ul><ol><li><strong>指令控制：</strong>完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</li><li><strong>操作控制：</strong>一条指令的功能往往由若干操作信号的组合来实现，CPU可以管理这些信号。</li><li><strong>时间控制：</strong>对各种操作加以时间上的控制，时间控制要为每条指令按时间顺序提供应有的控制信号。</li><li><strong>数据加工：</strong>对数据进行算术和逻辑运算。</li><li><strong>中断处理：</strong>对计算机运行过程中出现的异常情况和特殊请求进行处理。</li></ol><h3 id="5-1-2-CPU的基本结构"><a href="#5-1-2-CPU的基本结构" class="headerlink" title="5.1.2 CPU的基本结构"></a>5.1.2 CPU的基本结构</h3><ul><li><strong>运算器</strong></li></ul><ol><li><p><strong>算术逻辑单元：</strong>主要功能是进行算术&#x2F;逻辑运算。</p></li><li><p><strong>暂存寄存器：</strong>用于暂存从主存读来的数据，暂存寄存器对应用程序员是透明的。</p></li><li><p><strong>累加寄存器：</strong>它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</p></li><li><p><strong>通用寄存器组：</strong>用于存放操作数(源、目的操作数及中间结果)和各种地址信息等。</p></li><li><p><strong>程序状态字寄存器：</strong>保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息。例如：溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)。</p></li><li><p><strong>移位器：</strong>对操作数和运算结果进行移位运算。</p></li><li><p><strong>计数器：</strong>控制乘除运算的操作步数。</p></li></ol><ul><li><strong>控制器</strong></li></ul><ol><li><strong>程序计数器(pc)：</strong>用于指出下一条指令在主存中的存放地址。</li><li><strong>指令寄存器：</strong>用于保存当前正在执行的指令。</li><li><strong>指令译码器：</strong>仅对操作码字段进行译码，向控制器提供特定的操作信号。</li><li><strong>存储器地址寄存器：</strong>用于存放所要访问的主存单元的地址。</li><li><strong>存储器数据寄存器：</strong>用于存放向主存写入的信息或者从主存中读出的信息。</li><li><strong>时序系统：</strong>用于产生各种时序信号，他们由统一时钟( CLOCK)分频得到。</li><li><strong>微操作信号发生器：</strong>根据IR的内容(指令)、PSW的内容以及时序信号，产生控制整个计算机系统所需要的信号。</li></ol><h2 id="5-2-指令执行过程"><a href="#5-2-指令执行过程" class="headerlink" title="5.2 指令执行过程"></a>5.2 指令执行过程</h2><h3 id="5-2-1-指令周期"><a href="#5-2-1-指令周期" class="headerlink" title="5.2.1 指令周期"></a>5.2.1 指令周期</h3><ul><li><strong>概念</strong></li></ul><p>CPU从主存中每取出一条指令所需要的全部时间称为指令周期，即<strong>CPU完成一条指令的时间。</strong>一个指令周期包含多个机器周期，一个机器周期包含若千个时钟周期（CPU操作的基本单位）。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数可以不等。</p><ul><li><strong>基本组成</strong></li></ul><ol><li><strong>取指周期：</strong>取出指令</li><li><strong>间址周期：</strong>取出有效地址</li><li><strong>执行周期：</strong>取出操作數</li><li><strong>中断周期：</strong>保存程序断点</li></ol><ul><li><strong>不同指令的指令周期</strong></li></ul><ol><li><strong>无条件转移指令：</strong>不需要访存，所以只有取指周期、执行周期</li><li><strong>间接寻址的指令：</strong>首先要进行访存，取出有效地址，根据有效地址取出操作数，所以其具有间址周期。</li><li><strong>当CPU采用中断方式实现主机和I&#x2F;O设备的信息交换的时候</strong>，CPU在每次指令执行结束前都要发出中断查询信号，所以需要中断周期。</li></ol><h3 id="5-2-1-指令周期的数据流"><a href="#5-2-1-指令周期的数据流" class="headerlink" title="5.2.1 指令周期的数据流"></a>5.2.1 指令周期的数据流</h3><ul><li><strong>取指周期</strong></li></ul><p>取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。取指令的同时，PC加1。</p><p><img src="http://img.fdchen.host/%E5%8F%96%E5%80%BC%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20210818091652954"></p><p>取指周期的数据流向如下：</p><ol><li>PC①MAR②地址总线③主存。</li><li>CU发出控制信号④控制总线⑤主存。</li><li>主存⑧数据总线⑦MDR⑧IR (存放指令)。</li><li>CU发出读命令⑨PC内容加1。</li></ol><ul><li><strong>间址周期</strong></li></ul><p>间址周期的任务是取操作数有效地址。以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。</p><p><img src="http://img.fdchen.host/%E4%B8%80%E6%AC%A1%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20210818091945872"></p><p>间址周期的数据流向如下：</p><ol><li><p>Ad(IR) (或MDR)①MAR②地址总线③主存。</p></li><li><p>CU发出读命令④控制总线⑤主存。</p></li><li><p>主存⑥数据总线⑦MDR (存放有效地址)。</p></li></ol><p>其中，Ad(IR)表示取出IR中存放的指令字的地址字段。</p><ul><li><strong>执行周期</strong></li></ul><p>执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不<br>同指令的执行周期操作不同，因此没有统一的数据流向。</p><ul><li><strong>中断周期</strong></li></ul><p>中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且<strong>进栈操作是先修改栈顶指针</strong>（注意栈顶指针的增长方向与内存地址的增长方向相反）<strong>，后存入数据</strong>。</p><p><img src="http://img.fdchen.host/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="image-20210818092412749"></p><p>中断周期的数据流向如下:</p><ol><li>CU控制将SP减1, SP①MAR②地址总线③主存。</li><li>CU发出写命令④控制总线⑤主存。</li><li>PC⑥MDR⑦数据总线⑧主存(程序断点存入主存)。</li><li>CU (中断服务程序的入口地址)⑨PC。</li></ol><h3 id="5-2-3-指令执行方案"><a href="#5-2-3-指令执行方案" class="headerlink" title="5.2.3 指令执行方案"></a>5.2.3 指令执行方案</h3><ul><li><strong>单指令周期</strong></li></ul><p>所有指令完成时间相同。指令串行执行，指令周期取决于最长指令执行时间。降低了系统整体运行速度。</p><ul><li><strong>多指令周期</strong></li></ul><p>不同类型的指令选用不同的执行步骤完成。指令串行执行，对于不同指令分配不同的周期。</p><ul><li><strong>流水线方案</strong></li></ul><p>指令之间并行，将每个时钟周期都利用起来，尽量让多个指令并行运行。</p><p>PS：CISC可以通过优化实现流水线，RISC必须要实现流水线。</p><h2 id="5-3-数据通路的功能和基本结构"><a href="#5-3-数据通路的功能和基本结构" class="headerlink" title="5.3 数据通路的功能和基本结构"></a>5.3 数据通路的功能和基本结构</h2><h3 id="5-3-1-数据通路的功能"><a href="#5-3-1-数据通路的功能" class="headerlink" title="5.3.1 数据通路的功能"></a>5.3.1 数据通路的功能</h3><ul><li><strong>概念：</strong>数据在功能部件之间传送的路径。路径上的部件称为<strong>数据通路部件</strong>。</li><li><strong>功能：</strong>实现CPU内部的运算器与寄存器之间的数据交换。</li></ul><h3 id="5-3-2-数据通路的基本结构"><a href="#5-3-2-数据通路的基本结构" class="headerlink" title="5.3.2 数据通路的基本结构"></a>5.3.2 数据通路的基本结构</h3><p><img src="http://img.fdchen.host/CPU%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7.png" alt="image-20210818102900936"></p><ul><li><strong>基本结构分类</strong></li></ul><ol><li><strong>CPU内部单总线方式</strong></li></ol><p>将所有寄存器的输入输出端连接在同一 条公共通路上。<br><strong>优点：</strong>结构简单<br><strong>缺点：</strong>存在冲突现象，性能较低。</p><ol start="2"><li><strong>CPU内部三总线方式</strong></li></ol><p>将所有寄存器的输入输出端连接在多个公共通路上。<br><strong>优点：</strong>执行效率高。<br><strong>缺点：</strong>实现复杂。</p><ol start="3"><li><strong>专用数据通路方式</strong></li></ol><p>减少使用共享线路，专线专用。<br><strong>优点：</strong>性能高<br><strong>缺点：</strong>实现复杂,硬件量大</p><ul><li><strong>数据传送</strong></li></ul><p><strong>寄存器之间的数据传送：</strong>寄存器之间的数据传送可以通过CPU内部总线完成。</p><p><strong>主存与CPU之间的数据传送：</strong>主存与CPU之间的数据传送也需要借助CPU内部总线完成。</p><p><strong>执行算数或逻辑运算：</strong>由于ALU本身没有内部存储功能的组合电路，所以相加的操作数,必须在ALU两端时有效。</p><h2 id="5-4-控制器的功能和工作原理"><a href="#5-4-控制器的功能和工作原理" class="headerlink" title="5.4 控制器的功能和工作原理"></a>5.4 控制器的功能和工作原理</h2><h3 id="5-4-1-控制器的结构和功能"><a href="#5-4-1-控制器的结构和功能" class="headerlink" title="5.4.1 控制器的结构和功能"></a>5.4.1 控制器的结构和功能</h3><ul><li><strong>计算机硬件系统和控制器部件的组成</strong></li></ul><p><img src="http://img.fdchen.host/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%83%A8%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90.png" alt="image-20210818103239200"></p><ol><li>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。</li><li>输入设备和输出设备通过接口电路与总线相连接。</li><li>内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。</li><li>控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。</li></ol><ul><li><strong>控制器功能</strong></li></ul><ol><li>从主存中取出一条指令，并指出下一条指令在主存中的位置。</li><li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</li><li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</li></ol><ul><li>根据产生微操作信号的方式不同，存在硬布线控制器和微程序控制器。</li></ul><h3 id="5-4-2-硬布线控制器"><a href="#5-4-2-硬布线控制器" class="headerlink" title="5.4.2 硬布线控制器"></a>5.4.2 硬布线控制器</h3><p>根据指令要求、当前的时序以及外部和内部的状态，按照时间的顺序发送一些微操作控制信号。又称为组合逻辑控制器。</p><ul><li><strong>控制单元（CU）信号来源</strong></li></ul><ol><li>指令译码器产生的指令信息。</li><li>时序系统产生的机器周期信号和节拍信号。</li><li>来自执行单元的反馈信息，即标志。</li><li>控制单元还接收来自系统总线的控制信号：中断请求、DMA请求</li></ol><p>PS：DMA，全称Direct Memory Access，即直接存储器访问。</p><ul><li><strong>硬布线控制器的时序系统及微操作</strong></li></ul><ol><li><p><strong>时钟周期：</strong>用时钟信号控制节拍发生器，每个节拍的宽度正好对应一个时钟周期。每个节拍内机器可以完成或几个需要同时执行的操作。</p></li><li><p><strong>机器周期：</strong>机器周期可视为所有指令执行过程中的一个基准时间。<strong>通常我们以存取周期作为基准时间，即从内存中读取一个指令字的最短时间作为机器周期。</strong>在存储字长等于指令字长的前提下，取指周期可以作为机器周期.</p></li><li><p><strong>指令周期：</strong>取指周期，间址周期，执行周期，中断周期。</p></li><li><p><strong>微操作命令分析：</strong>控制单元发出各种操作序列，这些命令必须要按照一定的次序才能使得机器有序的工作。执行程序的过程中，对于不同的指令，控制单元需发出各种不同的微操作命令。</p></li></ol><ul><li><strong>CPU控制方式</strong></li></ul><ol><li><p><strong>同步控制：</strong>使用统一的时钟<br>优点：控制电路简单<br>缺点：运行速度慢</p></li><li><p><strong>异步控制：</strong>不存在基准时标信号，每个部件按照自身的速度工作</p><p>优点：速度快<br>缺点：电路复杂</p></li><li><p><strong>联合控制：</strong>同步和异步结合，大部分部件同步，小部分由异步。</p></li></ol><ul><li><strong>硬布线控制器设计</strong></li></ul><ol><li>列出微操作命令时间表</li><li>对微操作信号综合</li><li>画出微操作命令的逻辑图</li></ol><h3 id="5-4-3-微程序控制器"><a href="#5-4-3-微程序控制器" class="headerlink" title="5.4.3 微程序控制器"></a>5.4.3 微程序控制器</h3><p>微程序控制器采用存储逻辑实现，将微操作信号代码化，控制存储器存储微程序，微操作控制信号由微指令产生。</p><ul><li><strong>基本概念</strong></li></ul><p>微程序设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p><ol><li><strong>微命令与微操作</strong></li></ol><p>一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。</p><p>在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。</p><p>微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。</p><ol start="2"><li><strong>微指令与微周期</strong></li></ol><p>微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含两大部分信息：</p><p>① <strong>操作控制字段</strong>，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。<br>② <strong>顺序控制字段</strong>，又称微地址码字段，用于控制产生下一条要执行的微指令地址。</p><p>微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p><ol start="3"><li><strong>主存储器和控制存储器</strong></li></ol><p>主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器(CM)用于存放微程序，在CPU内部，用ROM实现。</p><ol start="4"><li><strong>程序与微程序</strong></li></ol><p>程序是指令的有序集合，用于完成特定的功能；微程序是微指令的有序集合，一条指令的功能由一段微程序来实现。</p><ol start="5"><li><strong>微程序和机器指令</strong></li></ol><p><strong>通常，一条机器指令对应一个微程序。</strong>由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。</p><p>此外，也可编出对应间址周期的微程序和中断周期的微程序。这样，<strong>控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数。</strong></p><p>PS：<strong>微程序（信号：机器指令） &gt; 微指令（微指令周期 &lt;&#x3D;&gt; 微周期） &gt; 微操作（控制信号：微命令）</strong></p><p>PS：注意区分以下存储器</p><p>① **地址寄存器(MAR)**。用于存放主存的读&#x2F;写地址。<br>② **微地址寄存器(CMAR)**。用于存放控制存储器的读&#x2F;写微指令的地址。<br>③ **指令寄存器(IR)**。 用于存放从主存中读出的指令。<br>④ **微指令寄存器(CMDR或μIR)**。用于存放从控制存储器中读出的微指令。</p><ul><li><strong>微程序控制器的组成和工作过程</strong></li></ul><ol><li><strong>基本组成</strong></li></ol><p><strong>控制存储器：</strong>存放指令对应的微程序，ROM构成。</p><p><strong>微指令寄存器：</strong>存放微指令。</p><p><strong>微地址形成部件：</strong>产生初始微地址和后继微地址。</p><p><strong>微地址寄存器：</strong>接收微地址。</p><ol start="2"><li><strong>工作过程</strong></li></ol><p>（1）执行取值微程序公共操作。<strong>在机器开始运行时</strong>，自动将<strong>取指微程序入口地址</strong>送入CMAR，并从CM中读出微指令送入CMDR。取指微程序的入口地址一般为CM的0号单元，<strong>当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中</strong>。</p><p>（2）机器指令操作码字段通过微地址形成部件产生微程序的入口地址，井将其送入CMAR。</p><p>（3）从CM中逐条取出对应的微指令井执行。</p><p>（4）执行完后，继续从头循环往复。</p><ul><li><strong>微指令编码方式</strong></li></ul><ol><li><strong>直接编码法</strong></li></ol><p>直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。</p><p><strong>优点：</strong>简单直观不需要译码，速度快，操作并行性好。</p><p><strong>缺点：</strong>对控制存储器容量有要求。</p><ol start="2"><li><strong>字段直接编码法</strong></li></ol><p>微命令字段分段的原则：<br>① 互斥性微命令分在同一段内，相容性微命令分在不同段内。</p><p>② 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。</p><p>③ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。</p><p><strong>优点：</strong>缩短指令的字长</p><p><strong>缺点：</strong>需要进行译码</p><ol start="3"><li><strong>字段间接编码法</strong></li></ol><p>一个字段的微指令由另一个字段中的微指令解释，又称隐式编码。</p><p><strong>优点：</strong>进一步缩短指令字长</p><p><strong>缺点：</strong>削弱了并行控制能力，该方法只是作为字段直接编码的辅助手段。</p><ul><li><strong>微指令地址形成方式</strong></li></ul><ol><li><strong>直接由微指令的下地址字段指出。</strong>微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称断定方式。</li><li><strong>根据机器指令的操作码形成。</strong>机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</li></ol><p>实际上，微指令序列地址的形成方式还有以下几种：</p><p>① 增量计数器法，即(CMAR)+ 1➡CMAR，适用于后继微指令的地址连续的情况。</p><p>② 根据各种标志决定微指令分支转移的地址。</p><p>③ 通过网络测试形成。</p><p>④ 由硬件直接产生微程序入口地址。</p><p>电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p><ul><li><strong>微指令的格式</strong></li></ul><ol><li><strong>水平微指令</strong></li></ol><p>从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。水平型微指令的基本指令格式如图所示，指令字中的一位对应一个控制信号，有输出时为1, 否则为0。<strong>一条水平型微指令定义并执行几种并行的基本操作。</strong></p><p><img src="http://img.fdchen.host/%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="image-20210818115850298"></p><p><strong>优点：</strong>微程序短，执行速度快，并行能力强，灵活性高</p><p><strong>缺点：</strong>微指令长，编写微程序麻烦</p><ol start="2"><li><strong>垂直微指令</strong></li></ol><p>垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能，其基本的指令格式如图所示。<strong>一条垂直型微指令只能定义并执行一种基本操作。</strong></p><p><img src="http://img.fdchen.host/%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="image-20210818120043086"></p><p><strong>优点：</strong>微指令短，简单，规整，便于编写微程序</p><p><strong>缺点：</strong>微程序长，执行速度慢，效率低下</p><ol start="3"><li><strong>混合型微指令</strong></li></ol><p>在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度加快。</p><ul><li><strong>微程序控制单元的设计步骤</strong></li></ul><ol><li><strong>写出对应机器指令的微操作命令及节拍安排</strong></li><li><strong>确定微指令格式</strong></li><li><strong>编写微指令码点</strong></li></ol><ul><li><strong>动态微程序设计和毫微程序设计</strong></li></ul><ol><li><strong>动态微程序设计。</strong>在一台微程序控制的计算机中，假如能<strong>根据用户的要求改变微程序</strong>，则这台机器就具有动态微程序设计功能。<br>动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容。实现动态微程序设计可**采用可擦除可编程只读存储器(EPROM)**。</li><li><strong>毫微程序设计。</strong>在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。若<strong>硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是亳微微指令。</strong></li></ol><h3 id="5-4-4-硬布线和微程序控制器的特点"><a href="#5-4-4-硬布线和微程序控制器的特点" class="headerlink" title="5.4.4 硬布线和微程序控制器的特点"></a>5.4.4 硬布线和微程序控制器的特点</h3><p><img src="http://img.fdchen.host/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="image-20210818121334401"></p><h2 id="5-5-指令流水线"><a href="#5-5-指令流水线" class="headerlink" title="5.5 指令流水线"></a>5.5 指令流水线</h2><h3 id="5-5-1-指令流水线的基本概念"><a href="#5-5-1-指令流水线的基本概念" class="headerlink" title="5.5.1 指令流水线的基本概念"></a>5.5.1 指令流水线的基本概念</h3><ul><li><strong>概念</strong></li></ul><p>把一个重复的过程分解成若干个子过程，每个子过程可以与其他子过程并行执行。</p><ul><li><strong>优点</strong></li></ul><p>只需要增加少量的硬件就能把计算机的运算速度提高几倍。</p><ul><li><strong>指令流水的定义</strong></li></ul><ol><li><strong>一条指令的执行可以分为多个阶段</strong></li></ol><p><strong>取指：</strong>根据PC从主存中取出指令送入IR。<br><strong>分析：</strong>对指令操作码进行译码，按照寻址方式和地址段内容形成有效地址EA，并从有效地址中取出操作数。<br><strong>执行：</strong>根据操作码字段，完成指令规定功能，将运算结果写到通用寄存器或者主存中。</p><ol start="2"><li><strong>多条指令的处理方式</strong></li></ol><p><strong>（1）顺序执行方式</strong></p><p>一条接一条指令执行，传统冯诺依曼机顺序执行方式。假设取值、分析、执行三个阶段的时间都相等，用t表示，T&#x3D;3nt。</p><p>优点：控制简单，硬件代价小</p><p>缺点：执行指令速度慢，各功能部件的利用率很低</p><p><strong>（2）流水线执行方式</strong></p><p>为了提高指令的执行速度，可以把取k + 1条指令提前到分析第k条指令的期间完成，而将分析第k + 1条指令与执行第k条指令同时进行。执行时间为 T &#x3D; (2+n)t。</p><p>优点：程序执行时间缩短了近2&#x2F;3，各功能部件利用率提高了</p><p>缺点：硬件开销代价较大，控制过程也比顺序执行复杂</p><p><img src="http://img.fdchen.host/%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F.png" alt="image-20210818122338602"></p><p>PS：流水线最重要的是一定要流动起来，如果经常出现断流情况，那么就无法体现流水线的优越性。</p><ul><li><strong>流水线方式的特点</strong></li></ul><ol><li><p>一个任务分解成多个子任务</p></li><li><p>每个功能部件后面都要有个锁存器，用于保存本流水段的结果</p></li><li><p>流水线中的各功能段的时间应尽量相等，否则将会堵塞、断流</p></li><li><p>流水线需要装入时间和排空时间</p></li></ol><p>（1）<strong>装入时间：</strong>第一个任务进入流水线到输出流水线的时间</p><p>（2）<strong>排空时间：</strong>最后-一个任务进入流水线到输出流水线的时间</p><h3 id="5-5-2-流水线的分类"><a href="#5-5-2-流水线的分类" class="headerlink" title="5.5.2 流水线的分类"></a>5.5.2 流水线的分类</h3><ul><li><strong>按照流水级别分类</strong></li></ul><p><strong>部件功能级流水线：</strong>将<strong>复杂的算术逻辑运算</strong>组成流水线的工作方式。</p><p><strong>处理机级流水线：</strong>一条<strong>指令</strong>解释成多个子过程。</p><p><strong>处理机间流水线：</strong>是一种<strong>宏流水，每个处理机专门完成一个任务</strong> ，各个处理机得到的结果存放在与下一个处理机共享的存储器中。</p><ul><li><strong>按照功能分类</strong></li></ul><p><strong>单功能流水线：</strong>完成单一功能的流水线。</p><p><strong>多功能流水线：</strong>各个流水段之间通过组合可以实现多种功能。</p><ul><li><strong>按照连接方式分类</strong></li></ul><p><strong>静态流水线：</strong>同一时间内，流水线的各段只能按照<strong>同一种功能的连接方式</strong>工作。</p><p><strong>动态流水线：</strong>同一时间内，<strong>不同的段完成的运算可能不一样（分属不同功能）</strong>，可以提高效率，但是流水线控制变得很复杂。</p><ul><li><strong>按照是否存在反馈信号分类</strong></li></ul><p><strong>线性流水线：</strong>从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</p><p><strong>非线性流水线：</strong>存在反馈回路。非常适合线性递归运算。</p><h3 id="5-5-3-影响流水线的因素"><a href="#5-5-3-影响流水线的因素" class="headerlink" title="5.5.3 影响流水线的因素"></a>5.5.3 影响流水线的因素</h3><ul><li><strong>资源冲突（结构冒险）：</strong>同一时刻争抢统一资源。</li></ul><ol><li><strong>解决办法：</strong></li></ol><p>（1）前一指令访存时，使后一条相关指令(以及其后续指令)<strong>暂停一个时钟周期</strong>。</p><p>（2）<strong>单独设置数据存储器和指令存储器</strong>，使取数和取指令操作各自在不同的存储器中进行。</p><ul><li><strong>数据冲突（数据冒险）：</strong>一个指令的执行必须要等待前一个指令的结果。</li></ul><ol><li><strong>分为三类：</strong></li></ol><p>（1）<strong>写后读(Read After Write，RAW)相关：</strong>表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误(旧)数据。</p><p>（2）<strong>读后写(Write After Read，WAR) 相关：</strong>表示当前指令读出数据后，下一条指令才能写<br>该寄存器。否则，先写后读，读到的就是错误(新)数据。</p><p>（3）<strong>写后写(Write After Write，WAW)相关：</strong>表示当前指令写入寄存器后，下一条指令才<br>能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。</p><ol start="2"><li><strong>解决办法：</strong></li></ol><p>（1）<strong>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期</strong>，直到数据相关问题消失<br>后再继续执行，可分为<strong>硬件阻塞(stall) 和软件插入“NOP”指令</strong>两种方法。</p><p>（2）<strong>设置相关专用通路</strong>，即不等前一条指令把计算结果写回寄存器组，下一 条指令也不再读<br>寄存器组，而直接把前一条指令的ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，<strong>这称为数据旁路技术</strong>。</p><p>（3）通过编译器对数据相关的指令编译优化的方法，<strong>调整指令顺序来解决数据相关</strong>。</p><ul><li><strong>控制冲突（控制冒险）：</strong>:出现转移指令或者其他改变PC值的指令造成断流。</li></ul><ol><li><strong>解决办法：</strong></li></ol><p>（1）<strong>对转移指令进行分支预测，尽早生成转移目标地址。</strong>分支预测<strong>分为简单(静态)预测和动态预测。</strong>静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。</p><p>（2）<strong>预取转移成功和不成功两个控制流方向上的目标指令。</strong></p><p>（3）<strong>加快和提前形成条件码。</strong></p><p>（4）<strong>提高转移方向的猜准率。</strong></p><h3 id="5-5-4-流水线的性能指标"><a href="#5-5-4-流水线的性能指标" class="headerlink" title="5.5.4 流水线的性能指标"></a>5.5.4 流水线的性能指标</h3><ul><li><strong>吞吐率：</strong>单位时间内流水线完成的任务数量。</li></ul><p>TP&#x3D;n&#x2F;Tk，其中，n是任务数，Tk是处理完n个任务的时间。</p><p>当连续输入的任务n趋向于无穷时，此时为最大吞吐率。</p><ul><li><strong>流水线的加速比：</strong>不使用流水线与使用流水线的时间比值。</li></ul><p>S &#x3D; T0 &#x2F; Tk，其中T0表示不使用流水线的执行时间，Tk表示使用流水线的时间。</p><p>若流水线各段执行的时间相等，可进一步推导得</p><p><img src="http://img.fdchen.host/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%BE%97%E5%8A%A0%E9%80%9F%E6%AF%94.png" alt="image-20210818145713833"></p><p>连续输入的任务数n→∞时，最大加速比为Smax&#x3D; k。</p><ul><li><strong>流水线的效率：</strong>流水线的利用率，在时空图上代表完成n个任务使用的时空区的面积与n个任务所用的时间及k个流水段所围成的时空区总面积比。</li></ul><p><img src="http://img.fdchen.host/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="image-20210818145927760"></p><p>连续输入任务n趋向于无穷时，最高效率为1。</p><h3 id="5-5-5-超标量流水线的基本概念"><a href="#5-5-5-超标量流水线的基本概念" class="headerlink" title="5.5.5 超标量流水线的基本概念"></a>5.5.5 超标量流水线的基本概念</h3><ul><li><strong>超标量流水线技术</strong></li></ul><p><strong>每个时钟周期内可以并发多条独立指令</strong>，通过编译优化，把可并行执行的指令搭配起来，挖<strong>掘指令并行性</strong>。</p><ul><li><strong>超流水线技术</strong></li></ul><p><strong>在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次</strong>，通过编译程序解决优化问题。</p><ul><li><strong>超长指令字</strong></li></ul><p>使用多个功能部件，利用编译程序<strong>挖掘出指令之间的并行性，然后将并行指令组成超长指令字</strong>。</p><h2 id="5-6-指令周期执行模板-各周期的微操作命令"><a href="#5-6-指令周期执行模板-各周期的微操作命令" class="headerlink" title="5.6 指令周期执行模板(各周期的微操作命令)"></a>5.6 指令周期执行模板(各周期的微操作命令)</h2><h3 id="5-6-1-取指令周期"><a href="#5-6-1-取指令周期" class="headerlink" title="5.6.1 取指令周期"></a>5.6.1 取指令周期</h3><pre class="line-numbers language-none"><code class="language-none">PC--&gt; MAR现行指令地址---&gt; MAR1 --&gt; R命令存储器读M(MAR) --&gt; MDR  现行指令从存储器中读至MDRMDR--&gt;IR        现行指令--&gt;IROP(IR)--&gt;CU指令的操作码--&gt; CU译码(PC)+1--&gt; PC形成下一条指令的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-2-间址周期"><a href="#5-6-2-间址周期" class="headerlink" title="5.6.2 间址周期"></a>5.6.2 间址周期</h3><pre class="line-numbers language-none"><code class="language-none">Ad ( IR)--&gt; MAR将指令字中的地址码(形式地址) --&gt; MAR1--&gt; R命令存储器读M(MAR)--&gt; MDR将有效地址从存储器读至MDR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-6-3-指令执行周期"><a href="#5-6-3-指令执行周期" class="headerlink" title="5.6.3 指令执行周期"></a>5.6.3 指令执行周期</h3><ul><li><strong>非访存指令</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">CLA清ACC  0--&gt;ACCCOM取反    ^ACC--&gt;ACCSHR算数右移L(ACC)--&gt; R(ACC), ACC0--&gt;ACC0CSL循环左移R(ACC)--&gt;L(ACC), ACCn--&gt;ACCnSTP停机指令0--&gt;G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>访存指令</strong></li></ul><ol><li><strong>加法指令</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">ADD X加法指令Ad(IR)--&gt; MAR1 --&gt; RM(MAR)--&gt; MDR(ACC)+(MDR)--&gt; ACC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>存数指令</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">STA X存数指令Ad ( IR)--&gt; MAR .1 --&gt; WACC --&gt; MDRMDR --&gt; M(MAR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>取数指令</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">LDA X取数指令Ad ( IR)--&gt; MAR .1--&gt; RM(MAR)--&gt; MDRMDR--&gt; ACC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>转移指令</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">JMP X无条件转移Ad(IR) --&gt; PCBAN X条件转移(负则转) A0*Ad(IR) + ^A0*(PC) --&gt; PC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="6-总线"><a href="#6-总线" class="headerlink" title="6 总线"></a>6 总线</h1><h2 id="6-1-总线概述"><a href="#6-1-总线概述" class="headerlink" title="6.1 总线概述"></a>6.1 总线概述</h2><h3 id="6-1-1-总线基本概念"><a href="#6-1-1-总线基本概念" class="headerlink" title="6.1.1 总线基本概念"></a>6.1.1 总线基本概念</h3><ul><li><strong>总线的定义</strong></li></ul><p>总线是一组能为多个部件分时共享的公共信息传送线路。</p><p><strong>分时：</strong>同一时刻只允许有一个部件向总线发送信息。</p><p><strong>共享：</strong>总线上可以挂接多个部件，各个部件之间互相交换的信息可以通过这组线路分时共享。</p><ul><li><strong>总线设备</strong></li></ul><p><strong>主设备：</strong>总线的主设备是指获得总线控制权的设备。</p><p><strong>从设备：</strong>总线的从设备是指被主设备访问的设备，只能响应从主设备发来的各种总线命令</p><ul><li><strong>总线特性</strong></li></ul><p>总线特性是指机械特性(尺寸、形状)、电气特性(传输方向和有效的电平范围)、功能特性(每根传输线的功能)和时间特性(信号和时序的关系)。</p><ul><li><strong>总线的猝发传输</strong></li></ul><p>一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传输。</p><h3 id="6-1-2-总线的分类"><a href="#6-1-2-总线的分类" class="headerlink" title="6.1.2 总线的分类"></a>6.1.2 总线的分类</h3><ul><li><strong>片内总线</strong></li></ul><p>芯片内部的总线,是CPU芯片内部寄存器与寄存器之间，寄存器与ALU之间的公共连接线。</p><ul><li><strong>系统总线：</strong>各个功能部件之间相互连接的总线。</li></ul><ol><li><strong>数据总线</strong></li></ol><p>传输各功能部件之间的数据信息，是双向传输总线，位数与机器字长、存储字长有关。</p><ol start="2"><li><strong>地址总线</strong></li></ol><p>数据总线上的源数据或目的数据所在的主存单元或I&#x2F;O端口的地址，是单向传输总线，地址总线的位数与主存地址空间的大小有关。</p><ol start="3"><li><strong>控制总线</strong></li></ol><p>传输控制信息CPU送出的控制命令和主存返回CPU的反馈信号。</p><p>PS：注意区分数据通路和数据总线。各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。<strong>数据通路表示的是数据流经的路径，而数据总线是承载的媒介。</strong></p><ul><li><strong>通信总线：</strong>计算机系统之间或计算机系统与其他系统之间传送信息的总线，也被称为外部总线。</li></ul><ol><li><strong>根据时序控制方式分类：</strong>同步总线和异步总线。</li><li><strong>数据传输格式分类：</strong>并行总线和串行总线。</li></ol><h3 id="6-1-3-系统总线的结构"><a href="#6-1-3-系统总线的结构" class="headerlink" title="6.1.3 系统总线的结构"></a>6.1.3 系统总线的结构</h3><ul><li><strong>单总线结构：</strong>将CPU、主存、I&#x2F;O设备都挂载到一组总线上。</li></ul><p><strong>优点：</strong>结构简单成本低容易接入新设备。</p><p><strong>缺点：</strong>带宽低负载重多个部件只能争用唯一的总线，并且不支持并发传送操作。</p><p>PS：注意，<strong>单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</strong></p><ul><li><strong>双总线结构：</strong>一条是主存总线，用于CPU、主存和通道之间传送数据；另一条是I&#x2F;O总线用于在多个外部设备和通道之间传送数据。</li></ul><p><strong>优点：</strong>将低速I&#x2F;O设备从单总线上分离出来，实现了存储总线和I&#x2F;O总线分离。</p><p><strong>缺点：</strong>需要增加通道等硬件设备。</p><ul><li><strong>三总线结构：</strong>计算机系统各部件之间采用三条独立总线来构成信息通路，分别为主存总线、I&#x2F;O总线和直接内存访问(DMA)总线。</li></ul><p><strong>优点：</strong>提高了I&#x2F;O设备的性能，使其更快的响应命令，提高系统的吞吐量。</p><p><strong>缺点：</strong>系统工作效率较低</p><h3 id="6-1-4-总线的性能指标"><a href="#6-1-4-总线的性能指标" class="headerlink" title="6.1.4 总线的性能指标"></a>6.1.4 总线的性能指标</h3><ul><li><strong>总线的传输周期</strong></li></ul><p>一次总线操作所需要的时间(申请阶段、寻址阶段、传输阶段和结束阶段)， 总线传输周期由若干个总线时钟周期构成。</p><ul><li><strong>总线时钟周期</strong></li></ul><p>即机器的时钟周期。</p><ul><li><strong>总线的工作频率</strong></li></ul><p>总线周期的倒数。</p><ul><li><strong>总线的时钟频率</strong></li></ul><p>时钟周期的倒数。</p><ul><li><strong>总线带宽</strong></li></ul><p>单位时间内总线可以传输的数据位数。</p><ul><li><strong>总线复用</strong></li></ul><p>一种信号线在不同时间传输不同的信息，节约了空间和成本。</p><ul><li><strong>信号线数</strong></li></ul><p>地址总线、数据总线、控制总线，三种总线数的总和称为信号线数。</p><ul><li><strong>总线带宽</strong></li></ul><p>总线本身的最大传输率，是衡量性能的重要指标。</p><h2 id="6-2-总线仲裁"><a href="#6-2-总线仲裁" class="headerlink" title="6.2 总线仲裁"></a>6.2 总线仲裁</h2><h3 id="6-2-1-集中仲裁方式"><a href="#6-2-1-集中仲裁方式" class="headerlink" title="6.2.1 集中仲裁方式"></a>6.2.1 集中仲裁方式</h3><ul><li><strong>链式查询方式</strong></li></ul><p>总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线BG串行地从一个部件传送到下一个部件，依次查询。若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件；若响应信号到达的部件有总线请求，则信号被截住，不再传下去。</p><p>越靠近总线控制器的部件优先级越高；离总线控制器越远优先级越低。</p><p><strong>优点：</strong>优先级固定，结构简单，扩充容易。</p><p><strong>缺点：</strong>对于电路故障敏感，优先级不可变。</p><p><img src="http://img.fdchen.host/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="image-20210818154046025"></p><ul><li><strong>计数器定时查询方式</strong></li></ul><p>计数器定时查询方式采用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线BG。它仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</p><p><strong>优点：</strong>计数可从“0”开始，此时一旦设备的优先次序被固定，设备的优先级就按0,1, ,n的顺序降序排列，而且固定不变；计数也可从上一次的终点开始，即采用一种循环方法， 此时设备使用总线的优先级相等；计数器的初值还可由程序设置，因此优先次序可以改变。</p><p><strong>缺点：</strong>增加了控制线数(若设备有n个，则大致需要[logn] + 2条控制线)，控制较为复杂。</p><p><img src="http://img.fdchen.host/%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="image-20210818154759641"></p><ul><li><strong>独立请求方式</strong></li></ul><p>每个设备均有一对总线请求线BR,和总线允许线BG。当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</p><p><strong>优点：</strong>响应速度快，总线允许信号BG直接从控制器发送到有关设备，而不必在设备间传递或查询，而且对优先次序的控制相当灵活。</p><p><strong>缺点：</strong>控制线数量多(设备有n个，需要2n+ 1条控制线，其中加的那条控制线为BS线，基作用是让设备向总线控制部件反馈已使用完总线)，总线控制逻辑更复杂。</p><p><img src="http://img.fdchen.host/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt="image-20210818154915700"></p><ul><li><strong>三种总裁方式的对比</strong></li></ul><p><img src="http://img.fdchen.host/%E4%B8%89%E7%A7%8D%E4%BB%B2%E8%A3%81%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="image-20210818155053603"></p><h3 id="6-2-2-分布仲裁方式"><a href="#6-2-2-分布仲裁方式" class="headerlink" title="6.2.2 分布仲裁方式"></a>6.2.2 分布仲裁方式</h3><p>不需要中央仲裁器，每个潜在主模块都有自己的仲裁号和仲裁器，然后进行仲裁号比较，获胜者仲裁号保留在仲裁总线上。</p><h2 id="6-3-总线操作和定时"><a href="#6-3-总线操作和定时" class="headerlink" title="6.3 总线操作和定时"></a>6.3 总线操作和定时</h2><h3 id="6-3-1-总线传输的4个阶段"><a href="#6-3-1-总线传输的4个阶段" class="headerlink" title="6.3.1 总线传输的4个阶段"></a>6.3.1 总线传输的4个阶段</h3><ul><li><strong>申请分配阶段：</strong>设备提出申请</li><li><strong>寻址阶段：</strong>获得使用权的主设备，发出要访问模块的地址以及相关命令，启动本次传输的从模块</li><li><strong>传输阶段：</strong>主模块与从模块，进行双向或者单向数据传送</li><li><strong>结束阶段：</strong>主模块有关信息均从系统总线上撤除，让出总线使用权</li></ul><h3 id="6-3-2-同步定时方式"><a href="#6-3-2-同步定时方式" class="headerlink" title="6.3.2 同步定时方式"></a>6.3.2 同步定时方式</h3><p>系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。</p><p><strong>优点：</strong>传送速度快，拥有较高的传输速率，总线控制逻辑简单。</p><p><strong>缺点：</strong>主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差。</p><p>适用于总线长度较短以及总线所接部件的存取时间比较接近的系统。</p><h3 id="6-3-3-异步定时方式"><a href="#6-3-3-异步定时方式" class="headerlink" title="6.3.3 异步定时方式"></a>6.3.3 异步定时方式</h3><p>没有统一的时钟，完全按照传送双方相互制约的握手信号实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p><p><strong>优点：</strong>总线周期长度可变可以保证两个速度相差较大部件或设备的信息传输。</p><p><strong>缺点：</strong>控制相对复杂并且速度相对较慢。</p><ul><li><strong>分类</strong></li></ul><p><strong>不互锁方式：</strong>主设备发送请求信号，不必等待从设备信号回答，一段时间便撤销请求信号。<br><strong>半互锁方式：</strong>主设备发送请求信号，必须接到从设备应答信号才能撤销请求信号。<br><strong>全互锁方式：</strong>主设备发送请求信号，从设备应答，主设备撤销请求信号，从设备知晓主设备获得应答信号后撤销应答信号。（类似两次挥手）</p><h2 id="6-4-总线标准"><a href="#6-4-总线标准" class="headerlink" title="6.4 总线标准"></a>6.4 总线标准</h2><ul><li><strong>系统总线</strong></li></ul><p>ISA( Industry Standard Architecture，工业标准体系结构 )：最早出现的微型计算机总线</p><p>EISA( Extended Industry Standard Architecture，扩展的ISA )：ISA的扩展形式</p><ul><li><strong>局部总线</strong></li></ul><p>VESA( Video Electronics Standards Association，视频电子标准协会 )：针对系统高速传送活动图像的大量数据的局部总线。</p><p>PCI(Peripheral Component Interconnect，外部设备互连)：为外围设备使用的总线，即插即用，采用桥连接。</p><p>PCI- Express：最新的总线和接口标准用于代替PCI和AGP。</p><p>AGP(Accelerated Graphiecs Port，加速图形接口)：视频接口标准用于连接主存和图型存储器。</p><ul><li><strong>设备总线</strong></li></ul><p>RS-232C( Recommended Standard，RS )：应用于串行二进制交换的数据终端设备( DTE )和数据通信设备( DCE )。</p><p>USB(Universal Serial Bus，通用串行总线)：连接外部设备的I&#x2F;O总线，即插即用，采用热插拔，串行传输，具有很强的连接能力和很好的可扩充性。</p><ul><li>PCMCIA(Personal Computer Memory Card International Association)：用于扩展功能的小型插槽即插即用</li><li>IDE(Integrated Drive Electronics，集成设备电路)：集成设备电路,又称ATA，是一种IDE接口磁盘驱动器接口类型</li><li>SCSI(Small Computer System Interface，小型计算机系统接口)：用于计算机和智能设备之间系统级接口的独立处理器标准，是一种智能的通用接口标准。</li><li>SATA(Serial Advanced Technology Attachment，串行高级技术附件)：是一-种基于行业标准的串行硬件驱动器接口</li></ul><h1 id="7-I-x2F-O系统"><a href="#7-I-x2F-O系统" class="headerlink" title="7 I&#x2F;O系统"></a>7 I&#x2F;O系统</h1><h2 id="7-1-I-x2F-O系统基本概念"><a href="#7-1-I-x2F-O系统基本概念" class="headerlink" title="7.1 I&#x2F;O系统基本概念"></a>7.1 I&#x2F;O系统基本概念</h2><h3 id="7-1-1-输入-x2F-输出系统"><a href="#7-1-1-输入-x2F-输出系统" class="headerlink" title="7.1.1 输入&#x2F;输出系统"></a>7.1.1 输入&#x2F;输出系统</h3><ul><li><p><strong>外部设备：</strong>包括输入&#x2F;输出设备以及通过输入&#x2F;输出接口才能访问的外存储设备。</p></li><li><p><strong>接口：在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件</strong>。</p></li><li><p><strong>输入设备：</strong>用于向计算机系统输入命令和文本、数据等信息的部件。</p></li><li><p><strong>输出设备：</strong>用于将计算机系统中的信息输出到计算机外部进行显示的部件。</p></li><li><p><strong>外存设备：</strong>除计算机内存及CPU缓存等外的存储器。</p></li><li><p><strong>I&#x2F;O系统：</strong></p></li></ul><ol><li><strong>I&#x2F;O软件：</strong>驱动程序、用户程序、管理程序、升级补丁。通常采用I&#x2F;O指令和通道指令实现CPU与I&#x2F;O设备的交互。</li><li><strong>I&#x2F;O硬件：</strong>包括外部设备、设备控制器和接口、 I&#x2F;O总线等。</li></ol><h3 id="7-1-2-I-x2F-O控制方式"><a href="#7-1-2-I-x2F-O控制方式" class="headerlink" title="7.1.2 I&#x2F;O控制方式"></a>7.1.2 I&#x2F;O控制方式</h3><ul><li><strong>程序查询方式：</strong>CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息</li><li><strong>程序中断方式：</strong>只在I&#x2F;O设备准备就绪并向CPU发出中断请求时才予以响应</li></ul><p><strong>以上两种方式主要用于数据传输率较低的外设。</strong></p><ul><li><strong>DMA方式：</strong>主存和I&#x2F;O设备之间有一条直接数据通络，当主存和I&#x2F;O设备交换信息时无须调用中断服务程序。</li><li><strong>通道方式：</strong>在系统中设有通道控制部件，每个通道挂接若干外设，主机在执行I&#x2F;O指令时，只需要启动有关通道，通道执行通道程序，完成I&#x2F;O操作。</li></ul><p><strong>以上两种方式主要用于数据传输率较高的外设。</strong></p><h2 id="7-2-外部设备"><a href="#7-2-外部设备" class="headerlink" title="7.2 外部设备"></a>7.2 外部设备</h2><h3 id="7-2-1-输入设备"><a href="#7-2-1-输入设备" class="headerlink" title="7.2.1 输入设备"></a>7.2.1 输入设备</h3><ul><li><strong>键盘</strong></li></ul><p><strong>运作方式：</strong></p><ol><li>查出按下的是哪个键；</li><li>将该键翻译成能被主机接收的键码(如ASCII码)；</li><li>将编码送给主机。</li></ol><ul><li><strong>鼠标</strong></li></ul><p><strong>运行方式：</strong>鼠标在平面上移动，底部传感器将移动距离与方向检测出来，从而控制光标的移动。</p><p>常见的鼠标有机械式与光电式。</p><h3 id="7-2-2-输出设备"><a href="#7-2-2-输出设备" class="headerlink" title="7.2.2 输出设备"></a>7.2.2 输出设备</h3><ul><li><strong>显示器</strong></li></ul><ol><li><strong>显示器件分类</strong></li></ol><p><strong>（1）阴极射线管(CRT)显示器</strong></p><p><strong>组成：</strong>电子枪，偏转线圈，萌罩、高压石墨电极，荧光粉涂层和玻璃外壳。</p><p><strong>优点：</strong>可视角度大，无坏点，色彩还原度高，色度均匀，可调节的多分辨率模式，响应时间短。</p><p><strong>分类：</strong></p><p>① <strong>字符显示器：显示字符的方法以点阵为基础</strong>。</p><p>② <strong>图形显示器：将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中的显示文件传送给矢量产生器，产生相应的模拟电压，直接控制电子束在屏幕上移动。</strong></p><p>优点：分辨率高且显示的曲线平滑。</p><p>缺点：显示复杂图形时，会有闪烁感。</p><p><strong>（2）液晶显示器（LCD）</strong></p><p><strong>原理：</strong>利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再简介控制液晶分子的光学特性来实现图像的显示。</p><p><strong>特点：</strong>体积小，重量轻，省电，无辐射，绿色环保，画面柔和，不伤眼。</p><p><strong>（3）发光二极管(LED )显示器</strong></p><p><strong>原理：</strong>通过控制半导体发光二极管来显示文字、图形、图像等各种信息。</p><p><strong>特点：</strong>亮度、功耗、可视角度和刷新速率等方面优于LCD。</p><ol start="2"><li><strong>按照显示信息分类</strong></li></ol><p><strong>（1）字符显示器</strong></p><p><strong>（2）图形显示器</strong></p><p><strong>（3）图像显示器</strong></p><ol start="3"><li><strong>主要参数</strong></li></ol><p>（1）屏幕大小：对角线长度。</p><p>（2）分辨率：所能显示的像素个数，宽与高的乘积。</p><p>（3）灰度级：黑白显示器中所显示的像素点的亮暗差别，彩色显示器中颜色的不同。灰度级越高，图形越清晰越逼真。</p><p>（4）刷新：光点只能保持极短的时间就会消失，必须在其消失前重新扫描一遍。</p><p>（5）显示存储器(VRAM )：也称为刷新存储器，将一帧的图像存储在刷新存储器中，从而提高刷新图像的信号。</p><p>分辨率越高，灰度级越多，刷新存储器容量越大，显示效果越好</p><p>VRAM容量&#x3D;分辨率X灰度级位数</p><p>VRAM带宽&#x3D;分辨率X灰度级位数X帧频</p><ul><li><strong>打印机</strong></li></ul><ol><li><strong>针式打印机</strong></li></ol><p><strong>原理：</strong>主机发出打印命令，经过接口、 检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带打印内容。</p><p><strong>优点：</strong>擅长多层复写打印，实现各种票据和蜡纸等打印，工作原理简单，造价低廉，耗材便宜。</p><p><strong>缺点：</strong>打印分辨率和打印速度不够高。</p><ol start="2"><li><strong>喷墨式打印机</strong></li></ol><p><strong>原理：</strong>带电的喷墨雾点经过电极偏转后，直接在纸上形成所需要的字形。</p><p><strong>优点：</strong>打印噪声小，实现高质量彩色打印，打印速度比针式打印机快。</p><p><strong>缺点：</strong>防水性打印成本高需要专用打印纸。</p><ol start="3"><li><strong>激光打印机</strong></li></ol><p><strong>原理：</strong>计算机输出二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，经过显影、转印和定影，在纸上得到所需的字符或图像。</p><p><strong>优点：</strong>打印质量高，速度快，噪音小，处理能力强。</p><p><strong>缺点：</strong>耗材多，价格贵，不能复写打印多份，对纸张要求高。</p><h3 id="7-2-3-磁表面存储器"><a href="#7-2-3-磁表面存储器" class="headerlink" title="7.2.3 磁表面存储器"></a>7.2.3 磁表面存储器</h3><p><strong>优点：</strong>存储容量大，价格低，非破坏性读出，记录信息可以长久保存。</p><p><strong>缺点：</strong>存取速度慢，机械机构复杂，对工作环境要求高。</p><ul><li><strong>磁盘存储器</strong></li></ul><p><img src="http://media4.open.com.cn/L603/fushi/0903/jisuanjzcyl/web/lesson/char4/image/s59.gif" alt="磁盘存储器"></p><ol><li><strong>组成</strong></li></ol><p><strong>（1）存储区域</strong></p><p>一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区(也称块)是磁盘读写的最小单位，即磁盘按块存取。</p><p><strong>磁头（Heads）：</strong>用于读取&#x2F;写入盘片上的记录面信息，一个记录面对应一个磁头。<br><strong>柱面数（Cylinders）：</strong>表示硬盘每个盘片上有多少磁道。<br><strong>扇片数（Sectors）：</strong>表示每条磁道上有多少个扇区。</p><p>下图为一个记录面示意图，</p><p><img src="https://bkimg.cdn.bcebos.com/pic/cf1b9d16fdfaaf51f82f37c88e5494eef11f7afc?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_auto" alt="磁盘存储器记录面"></p><p><strong>（2）磁盘存储器</strong></p><p><strong>磁盘驱动器：</strong>核心部件是磁头组件和盘片组件。</p><p><strong>磁盘控制器：</strong>硬盘存储器和主机的接口，IDE、SCSI、SATA等。</p><ol start="2"><li><strong>磁记录原理</strong></li></ol><p><strong>原理：</strong>磁头和磁性记录介质相对运动，通过电转磁完成读&#x2F;写操作。</p><p><strong>编码方法：</strong>按照某种方案把一连串二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读&#x2F;写控制电路容易、可靠的实现变换。</p><p><strong>磁记录方式：</strong>通常采用**调频制( FM )和改进型调频制( MFM )**的记录方式。</p><ol start="3"><li><strong>磁盘的性能</strong></li></ol><p>（1）<strong>磁盘的容量：</strong>存储字节的数量。</p><p><strong>格式化容量：</strong>按照某种特定记录方式可以记录信息的总量。</p><p><strong>非格式化容量：</strong>可以利用的磁化单元总数，由道密度和位密度计算而来。</p><p>PS：格式化后的容量比非格式化容量要小。</p><p>（2）<strong>记录密度：</strong>盘片单位面积上记录的二进制信息量。</p><p><strong>道密度：</strong>沿磁盘半径方向单位长度上的磁道数</p><p><strong>位密度：</strong>磁道单位长度上能记录得二进制代码位数</p><p><strong>面密度：</strong>位密度和道密度的乘积</p><p>（3）<strong>平均存储时间</strong></p><p><strong>寻道时间</strong>(磁头移动到目的磁道的时间) +<strong>旋转延迟时间</strong>(磁头定位到所在扇区的时间，取旋转一周时间的一半) +<strong>传输时间</strong>(传输数据所花费的时间)。由于寻道和找扇区的距离远近不一，因此前两部分通常取平均值。</p><p>（4）<strong>数据传输率</strong></p><p>磁盘存储器在单位时间内向主机传送数据的字节数。设磁盘转数为 r 转&#x2F;秒，每条磁道容量为N字节，则数据传输率为 D &#x3D; rN。</p><ol start="4"><li><strong>磁盘地址</strong></li></ol><p>按照二进制对其对应个数进行编码。若系统中有4个驱动器，每个驱动器带-一个磁盘， 每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码，其格式如图所示。</p><p><img src="http://img.fdchen.host/%E7%A3%81%E7%9B%98%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F.png" alt="image-20210818182423116"></p><ol start="5"><li><strong>硬盘工作过程</strong></li></ol><p>（1）硬盘的主要操作是<strong>寻址、读盘、写盘</strong>。每个操作都对应一个控制字，硬盘工作时，<strong>第一步</strong><br><strong>是取控制字，第二步是执行控制字。</strong></p><p>（2）<strong>读写操作是串行的，不能既读又写</strong>。</p><ul><li><strong>磁盘阵列</strong></li></ul><p>RAID (Redundant Arrays of Inexpensive Disks，廉价冗余磁盘阵列)是<strong>指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问</strong>，具有更好的存储性能、可靠性和安全性。</p><ol><li><strong>RAID分级</strong></li></ol><p>RAID0：无冗余和无校验的磁盘阵列</p><p>RAID1：镜像磁盘阵列</p><p>RAID2：采用纠错的海明码的磁盘阵列</p><p>RAID3：位交叉奇偶校验的磁盘阵列</p><p>RAID4：块交叉奇偶校验的磁盘真理</p><p>RAID5：无独立校验的就校验磁盘阵列</p><p>RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。</p><ul><li><strong>光盘存储器</strong></li></ul><p><strong>原理：</strong>利用光学原理读&#x2F;写信息的存储装置，采用聚集激光束对盘式介质以非接触方式记录信息。</p><p><strong>特点：</strong>具有高存储密度，携带方便，成本低，容量大，存储期限长，容易保存。</p><p><strong>分类：</strong></p><p>（1）CD-ROM：只读型光盘。</p><p>（2）CD-R：只能写入一次信息之后不可修改。</p><p>（3）CD-RW：可读可写光盘，可以重复读写。</p><p>（4）DVD-ROM：高容量CD-ROM，<strong>DVD表示通用数字化多功能光盘</strong>。</p><ul><li><strong>固态硬盘：</strong>常用于高档笔记本电脑。</li></ul><h2 id="7-3-I-x2F-O接口"><a href="#7-3-I-x2F-O接口" class="headerlink" title="7.3 I&#x2F;O接口"></a>7.3 I&#x2F;O接口</h2><h3 id="7-3-1-接口功能"><a href="#7-3-1-接口功能" class="headerlink" title="7.3.1 接口功能"></a>7.3.1 接口功能</h3><ul><li><p><strong>实现主机和外设之间的通信联络控制。</strong>( 时序配合问题,协调相互速度问题)保证计算机系统更能够统一协调的工作。</p></li><li><p><strong>进行地址译码和设备选择</strong>。</p></li><li><p><strong>实现数据的缓冲。</strong>消除CPU和外设之间的速度差异。</p></li><li><p><strong>信号格式转换。</strong>消除主机与外设之间的电平、数据格式等差异。</p></li><li><p><strong>传送控制命令和状态信息</strong>。协调外设的运作状态。</p></li></ul><ol><li>如启动时CPU向外设发送启动命令，外设准备好后想CPU发送准备好命令。</li><li>外设向CPU提出中断请求和DMA请求时，CPU也有相应的响应信号反馈给外设。</li></ol><h3 id="7-3-2-I-x2F-O接口的基本结构"><a href="#7-3-2-I-x2F-O接口的基本结构" class="headerlink" title="7.3.2 I&#x2F;O接口的基本结构"></a>7.3.2 I&#x2F;O接口的基本结构</h3><p><img src="http://img.fdchen.host/IO%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="image-20210819001016298"></p><ul><li><strong>内部接口</strong></li></ul><p>内部接口与系统总线相连(实质是与内存、CPU相连)。数据传输方式只能是并行传输。</p><ul><li><strong>外部接口</strong></li></ul><p>外部接口通过接口电缆和外设相连。</p><p>PS：</p><p>外部接口可能是串行结构，所以<strong>I&#x2F;O接口要有串&#x2F;并转换功能</strong>。</p><p>对数据缓冲寄存器、状态&#x2F;控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为<strong>I&#x2F;O指令</strong>，I&#x2F;O指令只能在操作系统内核的底层I&#x2F;O软件中使用，它们是一种特权指令。</p><p><strong>接口和端口是两个不同的概念。</strong>端口是指接口电路中可以进行读&#x2F;写的寄存器，若干<br>端口加上相应的控制逻辑才可以组成接口。</p><h3 id="7-3-3-I-x2F-O接口类型"><a href="#7-3-3-I-x2F-O接口类型" class="headerlink" title="7.3.3 I&#x2F;O接口类型"></a>7.3.3 I&#x2F;O接口类型</h3><ul><li><strong>数据传输方式</strong></li></ul><ol><li><strong>并行接口：</strong>一个字节或者一个字的所有位同时传送。</li><li><strong>串行接口：</strong>一位一位传输。</li></ol><ul><li><strong>控制方式分类</strong></li></ul><ol><li>程序查询接口</li><li>中断接口</li><li>DMA接口</li></ol><ul><li><strong>按照功能分类</strong></li></ul><ol><li>可编程接口</li><li>不可编程接口</li></ol><h3 id="7-3-4-I-x2F-O端口及其编址"><a href="#7-3-4-I-x2F-O端口及其编址" class="headerlink" title="7.3.4 I&#x2F;O端口及其编址"></a>7.3.4 I&#x2F;O端口及其编址</h3><ul><li><strong>统一编址</strong></li></ul><p>又称<strong>存储器映射方式</strong>，将I&#x2F;O端口当做存储器单元进行地址分配。</p><p><strong>优点：</strong>不需要设置专门输入输出指令，CPU访问存储器更灵活，端口编址空间较大。</p><p><strong>缺点：</strong>端口占用存储器地址，数据输入输出的时候，执行速度较慢。</p><ul><li><strong>独立编址</strong></li></ul><p>又称<strong>I&#x2F;O映射方式</strong>，I&#x2F;O端口地址与存储器地址无关。</p><p><strong>优点：</strong>程序编址清晰，便于理解。</p><p><strong>缺点：</strong>需要设置专门的输入&#x2F;输出指令访存，增加了控制的复杂性。</p><h2 id="7-4-I-x2F-O方式"><a href="#7-4-I-x2F-O方式" class="headerlink" title="7.4 I&#x2F;O方式"></a>7.4 I&#x2F;O方式</h2><h3 id="7-4-1-程序查询方式"><a href="#7-4-1-程序查询方式" class="headerlink" title="7.4.1 程序查询方式"></a>7.4.1 程序查询方式</h3><ul><li><strong>原理</strong></li></ul><p>信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器(数据端口)和一个设备状态寄存器(状态端口)。主机进行I&#x2F;O操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</p><ul><li><strong>优点</strong></li></ul><p>设计简单且设备量小。</p><ul><li><strong>缺点</strong></li></ul><p>CPU需要花费大量时间进行查询和等待，一段时间内只能和一台外设交互信息效率。</p><p>CPU存在原地踏步现象。</p><h3 id="7-4-2-程序中断方式"><a href="#7-4-2-程序中断方式" class="headerlink" title="7.4.2 程序中断方式"></a>7.4.2 程序中断方式</h3><ul><li><strong>异常和中断</strong></li></ul><ol><li><strong>异常</strong></li></ol><p>异常是指由CPU内部异常引起的意外事件，分为<strong>硬故障中断和程序性异常</strong>。<strong>硬故障中断是由硬连线出现异常引起的</strong>，如电源掉电、存储器线路错等。<strong>程序性异常也称软中断，是指在CPU内部因执行指令而引起的异常事件</strong>。如整除0、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页、分时系统中的时间片中断及用户态到核心态的切换等。<strong>按发生异常的报告方式和返回方式不同，内部异常可分为故障(Fault)、 自陷(Trap) 和终止(Abort)三类。</strong></p><p><strong>（1） 故障（Fault）</strong></p><p><strong>指在引起故障等指令启动后、执行结束前被检测到的异常事件。</strong>例如，指令译码时，出现<strong>“非法操作码”</strong>；取数据时，发生<strong>“缺段”或“缺页”</strong>；执行整数除法指令时，发现<strong>“除数为0”</strong>等。</p><p>对于“缺段”“缺页”等异常处理后，已将所需的段或页面从磁盘调入主存，可回到发生故障的指令继续执行，断点为当前发生故障的指令；对于“非法操作码”“除数为0”等，因为无法通过异常处理程序恢复故障，因此不能回到原断点执行，必须终止进程的执行。</p><p><strong>（2）自陷（Trap）</strong></p><p><strong>自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，</strong>就像预先设定的“陷阱”一样。通常的做法是：事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。</p><p><strong>（3）终止（Abort）</strong></p><p><strong>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如电源掉电、线路故障等，那么程序将无法继续执行，只能终止，此时，调出中断服务程序来重启系统。</strong>这种异常与故障和自陷不同，不是由特定指令产生的，而是随机发生的。</p><ol start="2"><li><strong>外部中断</strong></li></ol><p><strong>外中断是指来自CPU外部、与CPU执行指令无关的事件引起的中断，</strong>包括I&#x2F;O设备发出的I&#x2F;O中断(如键盘输入、打印机缺纸等)、外部信号中断(如用户按Esc键)，以及各种定时器引起的时钟中断等。外中断在狭义上一般称为中断(若未说明，一般是指外中断)。</p><p><strong>外中断与内部异常的对比：</strong></p><p>（1）“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</p><p>（2）异常的检测是由CPU自身完成的，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过总线获取中断源的标识信息，才能获知哪个设备发生了何种中断。</p><ul><li><strong>中断的基本概念</strong></li></ul><p>当计算机出现异常情况或者特殊请求，CPU暂时中止当前程序，转去处理异常或者特殊情况。</p><p><strong>作用：</strong></p><ol><li>实现CPU与I&#x2F;O并行工作</li><li>处理硬件故障和软件错误</li><li>实现人机交互，用户干预机器需要用到中断系统</li><li>实现多道程序、分时操作。多道程序的切换需借助于中断系统</li><li>实时处理需要借助中断系统来实现快速响应</li><li>实现应用程序和操作系统(管态程序)的切換，称为”软中断”</li><li>多处理器系统中各处理器之间的信息交流和任务切换</li></ol><p><img src="http://img.fdchen.host/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20210819091019160"></p><ul><li><strong>工作流程</strong></li></ul><ol><li><strong>中断请求</strong></li></ol><p><strong>中断源是请求CPU中断的设备或事件，一台计算机允许有多个中断源。</strong>每个中断源向CPU发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统等对每个中断源设置中断请求标记触发器INTR，当其状态为“1”时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。</p><p>（1）<strong>内&#x2F;外中断</strong></p><p><strong>内中断：</strong>内中断主要是指在处理器和内存内部产生的中断。包括程序运算引起的各种错误,如地址非法、校验错等。</p><p><strong>外中断：</strong>外中断是指来自处理器和内存以外的部件引起的中断。包括I&#x2F;O设备发出的I&#x2F;O中断等。</p><p>（2）<strong>硬件中断与软件中断</strong></p><p><strong>硬件中断：</strong>通过外部的硬件产生的中断，硬件中断属于外中断。</p><p><strong>软件中断：</strong>通过某条指令产生的中断，这种中断是可以编程实现的，软件中断是内中断。</p><p>（3）<strong>非屏蔽与可屏蔽中断</strong></p><p><strong>非屏蔽中断：</strong>非屏蔽中断是一种硬件中断，不受中断标志位IF的影响，即使在关中断(IF &#x3D; 0)的情况下也会被响应。</p><p><strong>可屏蔽中断：</strong>可屏蔽中断也是一种硬件中断，受中断标志位IF的影响 ，在关中断情况下不接受中断请求。</p><ol start="2"><li><strong>中断判优</strong></li></ol><p>中断系统在任一瞬间只能响应-一个中断源的请求。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需<strong>通过中断判优逻辑确定响应哪个中断源的请求</strong>，例如故障中断的优先级别较高，然后是I&#x2F;O中断。</p><p><strong>（1）硬件实现</strong></p><p>硬件实现是通过硬件排队器实现的，它既可以设置在CPU中，又可以分散在各个中断源中。</p><p><strong>（2）软件实现</strong></p><p>软件实现是通过查询程序实现的。</p><p><strong>（3）一般逻辑</strong></p><p>一般来说，<strong>硬件故障中断属于最高级，其次是软件中断</strong>，不可屏蔽中断优于可屏蔽中断，DMA请求优于I&#x2F;O设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备等。</p><ol start="3"><li><strong>CPU响应中断的条件</strong></li></ol><p>（1）中断源有中断请求</p><p>（2）CPU允许中断及开中断</p><p>（3）一条指令执行完毕，且没有更紧迫的任务</p><p>PS：CPU 响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</p><ol start="4"><li><strong>中断响应</strong></li></ol><p><strong>CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为中断隐指令。</strong>中断隐指令并不是指令系统中的一条真正的指令，它没有操作，所以<strong>中断隐指令是一种不允许也不可能为用户使用的特殊指令</strong>。它所完成的操作如下：</p><p><strong>（1）关中断。</strong>CPU响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过程中，CPU不能响应更高级中断源的中断请求。</p><p><strong>（2）保存断点。</strong>为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点(指令无法直接读取的PC和PSWR等的内容)保存起来。</p><p><strong>（3）引出中断服务程序。</strong>实质是取出中断服务程序的入口地址并传送给程序计数器(PC)。</p><ol start="5"><li><strong>中断向量</strong></li></ol><p><strong>每个中断都有一个类型号，每个中断类型号都对应一个中断服务程序， 每个中断服务程序都有一个入口地址，CPU必须找到入口地址，即中断向量，</strong>把系统中的全部中断向量集中存放到存储器的某个区域内，这个<strong>存放中断向量的存储区就称为中断向量表</strong>。</p><p><strong>CPU响应中断后，中断硬件会自动将中断向量地址传送到CPU，由CPU实现程序的切换，这种方法称为中断向量法，采用中断向量法的中断称为向量中断。</strong></p><ol start="6"><li><strong>中断处理过程</strong></li></ol><p><img src="http://img.fdchen.host/%E5%8F%AF%E5%B5%8C%E5%A5%97%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image-20210819092514309"></p><p>PS：<strong>现场和断点，这两类信息都不能被中断服务程序破坏。</strong>现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现；而断点信息由CPU在中断响应开始时自动保存到栈或专门的寄存器中，即由硬件实现。</p><ul><li><strong>多重中断和中断屏蔽技术</strong></li></ul><ol><li><strong>多重中断</strong></li></ol><p>若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而<strong>CPU对</strong><br><strong>新的中断请求不予响应，则这种中断称为单重中断。若CPU暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为多重中断，又称中断嵌套。</strong></p><p><img src="http://img.fdchen.host/%E5%8D%95%E9%87%8D%E4%B8%AD%E6%96%AD%E5%92%8C%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png" alt="image-20210819092852515"></p><ol start="2"><li><strong>中断屏蔽技术</strong></li></ol><p>中断屏蔽技术主要用于多重中断。CPU要具备多重中断的功能，必须满足下列条件：</p><p>① 在中断服务程序中提前设置开中断指令。</p><p>② 优先级别高的中断源有权中断优先级别低的中断源。</p><p>每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</p><h3 id="7-4-3-DMA方式"><a href="#7-4-3-DMA方式" class="headerlink" title="7.4.3 DMA方式"></a>7.4.3 DMA方式</h3><ul><li><strong>概述</strong></li></ul><p>DMA方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。DMA方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU,降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。</p><p>这种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。</p><ul><li><strong>特点</strong></li></ul><p>① 它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。</p><p>② 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现.</p><p>③ 主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p><p>④ DMA传送速度快，CPU和外设并行工作，提高了系统效率。</p><p>⑤ DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><ul><li><strong>DMA控制器的组成</strong></li></ul><p>在DMA方式中，<strong>对数据传送过程进行控制的硬件称为DMA控制器(DMA接口)<strong>。当I&#x2F;O设备需要进行数据传送时，</strong>通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送</strong>。其主要功能如下：</p><p>（1）接受外设发出的DMA请求，并向CPU发出总线请求。</p><p>（2）CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。</p><p>（3）确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数。</p><p>（4）规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</p><p>（5）向CPU报告DMA操作的结束。</p><p><strong>组成结构：</strong></p><p>（1）<strong>主存地址计数器：</strong>存放要交换数据的主存地址。</p><p>（2）<strong>传送长度计数器：</strong>记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</p><p>（3）<strong>数据寄存器：</strong>暂存每次传送的数据。</p><p>（4）<strong>DMA请求触发器：</strong>每当I&#x2F;O设备准备好数据后，给出一个控制信号，使DMA请求触发器置位。</p><p>（5）<strong>“控制&#x2F;状态” 逻辑：</strong>由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。</p><p>（6）<strong>中断机构：</strong>当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</p><ul><li><strong>传送方式</strong></li></ul><p>主存和IO设备之间交换信息时，不通过CPU.但当I&#x2F;O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存：</p><ol><li><strong>停止CPU访问主存：</strong>CPU放弃地址线、数据线和有关控制线的使用权, DMA接口获得总线控制权。</li><li><strong>周期挪用：</strong></li></ol><p>（1）CPU不在访存，I&#x2F;O的访存请求与CPU未发生冲突。</p><p>（2）CPU正在访存，此时必须待存取周期结束后，CPU再将总线占有权让出。</p><p>（3）I&#x2F;O和CPU同时请求访存，出现访存冲突，此时CPU要暂时放弃总线占有权，由I&#x2F;O设备挪用一个或几个存取周期，传送完一个数据后立即释放总线，是一种单字传送方式。</p><ol start="3"><li><strong>DMA与CPU交替访存：</strong>这种方式适用于CPU的工作周期比主存存取周期长的情况。</li></ol><p>例如，若CPU的工作周期是1.2μs, 主存的存取周期小于0.6μs， 则可将一个 CPU周期<br>分为C1和C2两个周期，其中C1专供DMA访存，C2专供CPU访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时控制的。</p><ul><li><strong>传送过程</strong></li></ul><ol><li><strong>预处理：</strong>由CPU完成一些必要的准备工作(寄存器置初值、设置传送方向、启动该设备)。</li><li><strong>数据传送：</strong>DMA的数据传输可以以单字节(或字)为基本单位，也可以以数据块为基本单位，数据传送阶段完全由DMA (硬件)控制。</li><li><strong>后处理：</strong>DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理。</li></ol><ul><li><strong>DMA方式和中断方式的重要区别</strong></li></ul><p>① 中断方式是程序的切换，需要保护和恢复现场；而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。</p><p>② 对中断请求的响应只能发生在每条指令执行完毕时(即指令的执行周期后)；而对DMA请求的响应可以发生在每个机器周期结束时(在取指周期、间址周期、执行周期后均可)，只要CPU不占用总线就可被响应。</p><p>③ 中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</p><p>④ DMA请求的优先级高于中断请求。</p><p>⑤ 中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I&#x2F;O操作。</p><p>⑥ 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2021/shu-xue-xian-xing-dai-shu/"/>
      <url>/2021/shu-xue-xian-xing-dai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-矩阵"><a href="#1-矩阵" class="headerlink" title="1 矩阵"></a>1 矩阵</h1><h2 id="1-1-正定矩阵"><a href="#1-1-正定矩阵" class="headerlink" title="1.1 正定矩阵"></a>1.1 正定矩阵</h2><ul><li>正定矩阵是所有特征值均为正的对称矩阵。</li><li>详见<a href="https://baike.baidu.com/item/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5">百度百科-正定矩阵</a></li></ul><h2 id="1-2-满秩矩阵"><a href="#1-2-满秩矩阵" class="headerlink" title="1.2 满秩矩阵"></a>1.2 满秩矩阵</h2><ul><li>设A是n阶矩阵, 若r(A) &#x3D; n, 则称A为满秩矩阵。但满秩不局限于n阶矩阵。</li><li>若矩阵秩等于行数，称为行满秩；若矩阵秩等于列数，称为列满秩。</li><li>既是行满秩又是列满秩则为n阶矩阵即n阶方阵。</li><li>行满秩矩阵就是行向量线性无关，列满秩矩阵就是列向量线性无关；所以如果是方阵,行满秩矩阵与列满秩矩阵是等价的。</li></ul><h2 id="1-3-正交矩阵"><a href="#1-3-正交矩阵" class="headerlink" title="1.3 正交矩阵"></a>1.3 正交矩阵</h2><p>如果AAT&#x3D;E（E为单位矩阵，AT表示“矩阵A的转置矩阵”）或ATA&#x3D;E，则n阶实矩阵A称为正交矩阵</p><h1 id="2-矩阵运算"><a href="#2-矩阵运算" class="headerlink" title="2 矩阵运算"></a>2 矩阵运算</h1><h2 id="2-1-奇异值分解"><a href="#2-1-奇异值分解" class="headerlink" title="2.1 奇异值分解"></a>2.1 奇异值分解</h2><p><img src="http://img.fdchen.host//SVD-1.png" alt="image-20210622114034909"></p><p><img src="http://img.fdchen.host//SVD-2.png" alt="image-20210622114110735"></p><h2 id="2-2-矩阵求导"><a href="#2-2-矩阵求导" class="headerlink" title="2.2 矩阵求导"></a>2.2 矩阵求导</h2><p>详见博客：<a href="https://fei-wang.github.io/matrix.html">矩阵求导</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学</title>
      <link href="/2021/shu-xue-gao-deng-shu-xue/"/>
      <url>/2021/shu-xue-gao-deng-shu-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="1-条件概率及链式法则"><a href="#1-条件概率及链式法则" class="headerlink" title="1. 条件概率及链式法则"></a>1. 条件概率及链式法则</h1><h2 id="1-1-条件概率"><a href="#1-1-条件概率" class="headerlink" title="1.1 条件概率"></a>1.1 条件概率</h2><p>条件概率是指事件A在事件B发生的条件下发生的概率。条件概率表示为：P（A|B），读作“A在B发生的条件下发生的概率”。若只有两个事件A，B，那么，x&#x3D;x 事件发生时 y&#x3D;y 事件发生的概率: P(y&#x3D;y|x&#x3D;x) &#x3D; P(x&#x3D;x,y&#x3D;y) &#x2F; P(x&#x3D;x)。</p><h2 id="1-2-条件概率的链式法则"><a href="#1-2-条件概率的链式法则" class="headerlink" title="1.2 条件概率的链式法则"></a>1.2 条件概率的链式法则</h2><p>也称为条件概率的乘法法则，P(a,b,c)&#x3D;P(a|b,c) P(b,c) &#x3D; P(a|b,c) P(b|c) P(c)。</p><h2 id="1-3-推广到一般情况"><a href="#1-3-推广到一般情况" class="headerlink" title="1.3 推广到一般情况"></a>1.3 推广到一般情况</h2><p>P(x(1),x(2),⋯,x(n))&#x3D;P(x(n)|x(n−1),⋯,x(1))P(x(1),⋯,x(n−1))&#x3D;P(x(n)|x(n−1),⋯,x(1))P(x(n−1)|x(n−2),⋯,x(1))P(x(1),⋯,x(n−2))&#x3D;P(x(n)|x(n−1),⋯,x(1))P(x(n−1)|x(n−2),⋯,x(1))⋯P(x(2)|x(1))P(x(1))&#x3D;P(x(1))∏2nP(x(i))|x(1)⋯x(i−1))</p><p>条件概率的链式法则可以如下理解：<br>以 P(x(1),x(2),⋯,x(n))P(x(1),x(2),⋯,x(n)) 为例，可以看作 P(x(1))P(x(1)) 发生后，P(x(2)|x(1))P(x(1))P(x(2)|x(1))P(x(1)) 是x(1),x(2)x(1),x(2) 同时发生的概率，P(x(3)|x(1),x(2))P(x(2)|x(1))P(x(1))P(x(3)|x(1),x(2))P(x(2)|x(1))P(x(1)) 是 x(1),x(2),x(3)x(1),x(2),x(3) 同时发生的概率，依次类推下去，便可以得到条件概率的链式法则公式。</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/NXHYD/article/details/104772086">https://blog.csdn.net/NXHYD/article/details/104772086</a></p></blockquote><h1 id="2-极大似然估计"><a href="#2-极大似然估计" class="headerlink" title="2. 极大似然估计"></a>2. 极大似然估计</h1><ul><li>见<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1">百度百科-极大似然估计</a></li></ul><h1 id="3-Softmax函数-x2F-归一化指数函数"><a href="#3-Softmax函数-x2F-归一化指数函数" class="headerlink" title="3. Softmax函数&#x2F;归一化指数函数"></a>3. Softmax函数&#x2F;归一化指数函数</h1><blockquote><p>注意概率函数中分子里的W的位置应该在e的指数上</p></blockquote><p><img src="http://img.fdchen.host/softmax%E5%87%BD%E6%95%B0.png" alt="image-20210730075235880"></p><ul><li>见<a href="https://baike.baidu.com/item/%E5%BD%92%E4%B8%80%E5%8C%96%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0/22660782?fromtitle=Softmax%E5%87%BD%E6%95%B0&fromid=22772270">百度百科-归一化指数函数</a></li></ul><h1 id="4-平均数"><a href="#4-平均数" class="headerlink" title="4. 平均数"></a>4. 平均数</h1><h2 id="4-1-调和平均"><a href="#4-1-调和平均" class="headerlink" title="4.1 调和平均"></a>4.1 调和平均</h2><ul><li>调和平均数（harmonic mean）又称倒数平均数，是总体各统计变量倒数的算术平均数的倒数。</li><li>分为<strong>普通调和平均数</strong>和<strong>加权调和平均数</strong></li><li>详见<a href="https://baike.baidu.com/item/%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87%E6%95%B0">百度百科-调和平均数</a></li></ul><h2 id="4-2-算数平均"><a href="#4-2-算数平均" class="headerlink" title="4.2 算数平均"></a>4.2 算数平均</h2><ul><li>avge &#x3D; ( a+b ) &#x2F; 2</li></ul><h2 id="4-3-几何平均"><a href="#4-3-几何平均" class="headerlink" title="4.3 几何平均"></a>4.3 几何平均</h2><ul><li>avge &#x3D; ( a+b )^(1&#x2F;2)   (根号下 a+b)</li></ul><h1 id="5-闭式解与数值解"><a href="#5-闭式解与数值解" class="headerlink" title="5 闭式解与数值解"></a>5 闭式解与数值解</h1><h2 id="5-1-闭式解-x2F-解析解"><a href="#5-1-闭式解-x2F-解析解" class="headerlink" title="5.1 闭式解&#x2F;解析解"></a>5.1 闭式解&#x2F;解析解</h2><ul><li>就是给出解的具体函数形式，从解的表达式中就可以算出任何对应值</li></ul><p><img src="http://img.fdchen.host//%E9%97%AD%E5%BC%8F%E8%A7%A3%E4%BE%8B%E5%AD%90.png" alt="image-20210509134130816"></p><h2 id="5-2-数值解"><a href="#5-2-数值解" class="headerlink" title="5.2 数值解"></a>5.2 数值解</h2><ul><li>就是用数值方法求出解，给出一系列对应的自变量和解。</li></ul><h1 id="6-神经网络中的激活函数"><a href="#6-神经网络中的激活函数" class="headerlink" title="6. 神经网络中的激活函数"></a>6. 神经网络中的激活函数</h1><h2 id="6-1-双曲正切函数tanh"><a href="#6-1-双曲正切函数tanh" class="headerlink" title="6.1 双曲正切函数tanh"></a>6.1 双曲正切函数tanh</h2><ul><li><p>详见博客：<a href="https://www.jianshu.com/p/7409c8f1cdca">神经网络中的激活函数-tanh</a></p></li><li><p>特点</p><ul><li>函数：y&#x3D;tanh x；</li><li>定义域：R</li><li>值域：(-1,1)。</li><li>y&#x3D;tanh x是一个奇函数，其函数图像为过原点并且穿越Ⅰ、Ⅲ象限的严格单调递增曲线，其图像被限制在两水平渐近线y&#x3D;1和y&#x3D;-1之间。</li></ul></li><li><p>图像</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1531909-3ee8d5d56395220c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/637/format/webp" alt="img"></p><h2 id="6-2-maxout-激活函数"><a href="#6-2-maxout-激活函数" class="headerlink" title="6.2 maxout 激活函数"></a>6.2 maxout 激活函数</h2><p><img src="http://img.fdchen.host//maxout%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.png" alt="image-20210615022611321"></p><p>Maxout 激活函数特点：maxout激活函数并不是一个固定的函数，不像Sigmod、Relu、Tanh等函数，是一个固定的函数方程.它是一个可学习的激活函数，因为我们 W 参数是学习变化的。它是一个分段线性函数：</p><p><strong>优点</strong>：Maxout的拟合能力非常强，可以拟合任意的凸函数。Maxout具有ReLU的所有优点，线性、不饱和性。同时没有ReLU的一些缺点。如：神经元的死亡。</p><p><strong>缺点</strong>：从上面的激活函数公式中可以看出，每个神经元中有两组(w,b)参数，那么参数量就增加了一倍，这就导致了整体参数的数量激增。</p><h2 id="6-3-ReLU-整流线性单位函数"><a href="#6-3-ReLU-整流线性单位函数" class="headerlink" title="6.3 ReLU 整流线性单位函数"></a>6.3 ReLU 整流线性单位函数</h2><p><strong>整流线性单位函数</strong>（Rectified Linear Unit, <strong>ReLU</strong>）,又称<strong>修正线性单元</strong>, 是一种<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">人工神经网络</a>中常用的激励函数（activation function），通常指代以<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E5%9D%A1%E5%87%BD%E6%95%B0">斜坡函数</a>及其变种为代表的非线性函数。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Ramp_function.svg/1920px-Ramp_function.svg.png" alt="img"></p><center>整流线性单位函数</center><h2 id="6-4-ELU"><a href="#6-4-ELU" class="headerlink" title="6.4 ELU"></a>6.4 ELU</h2><p><img src="http://img.fdchen.host//ELUpng" alt="image-20210626024139815"></p><ul><li>融合了sigmoid和ReLU，左侧具有软饱和性，右侧无饱和性。</li><li>右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱能够让ELU对输入变化或噪声更鲁棒。</li><li>ELU的输出均值接近于零，所以收敛速度更快。</li><li>在 ImageNet上，不加 Batch Normalization 30 层以上的 ReLU 网络会无法收敛，PReLU网络在MSRA的Fan-in （caffe ）初始化下会发散，而 ELU 网络在Fan-in&#x2F;Fan-out下都能收敛。</li></ul><h1 id="7-Bootstrapping自助抽样法"><a href="#7-Bootstrapping自助抽样法" class="headerlink" title="7. Bootstrapping自助抽样法"></a>7. Bootstrapping自助抽样法</h1><p>在<strong>统计学</strong>中，<strong>自助法</strong>（Bootstrap Method，Bootstrapping，或<strong>自助抽样法</strong>、<strong>拔靴法</strong>）是一种从给定训练集中有放回的均匀抽样，也就是说，每当选中一个样本，它等可能地被再次选中并被再次添加到训练集中。自助法由Bradley Efron于1979年在《Annals of Statistics》上发表。当<a href="https://zh.wikipedia.org/wiki/%E6%A8%A3%E6%9C%AC_(%E7%B5%B1%E8%A8%88%E5%AD%B8)">样本</a>来自能以<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83">正态分布</a>来描述的总体，其<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8A%BD%E6%A8%A3%E5%88%86%E5%B8%83&action=edit&redlink=1">抽样分布</a>为正态分布；但当样本来自的总体无法以正态分布来描述，则以<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BC%B8%E9%80%B2%E5%88%86%E6%9E%90%E6%B3%95&action=edit&redlink=1">渐进分析法</a>、自助法等来分析。采用随机可置换抽样（random sampling with replacement）。对于小数据集，自助法效果很好。</p><p>最常用的一种是.632自助法，假设给定的数据集包含d个样本。该数据集有放回地抽样d次，产生d个样本的训练集。这样原数据样本中的某些样本很可能在该样本集中出现多次。没有进入该训练集的样本最终形成检验集（测试集）。 显然每个样本被选中的概率是1&#x2F;d，因此未被选中的概率就是(1-1&#x2F;d)，这样一个样本在训练集中没出现的概率就是d次都未被选中的概率，即(1-1&#x2F;d)^d。当d趋于无穷大时，这一概率就将趋近于e^-1&#x3D;0.368，所以留在训练集中的样本大概就占原来数据集的63.2%。</p><h1 id="8-马尔可夫模型"><a href="#8-马尔可夫模型" class="headerlink" title="8. 马尔可夫模型"></a>8. 马尔可夫模型</h1><p>TODO</p><p>当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔可夫性质。马尔可夫假设（Markov assumption）则是用来假设描述一个模型具有马尔可夫性质，比如隐马尔可夫模型。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《开放域语义解析》总结</title>
      <link href="/2021/nlp-kai-fang-yu-yu-yi-jie-xi-zong-jie/"/>
      <url>/2021/nlp-kai-fang-yu-yu-yi-jie-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文章所属Github项目链接：<a href="https://github.com/casnlu/Semantic-Parsing">https://github.com/casnlu/Semantic-Parsing</a></p></blockquote><h1 id="1-语义解析简介"><a href="#1-语义解析简介" class="headerlink" title="1 语义解析简介"></a>1 语义解析简介</h1><ul><li>自然语言多样，具有歧义，其理解依赖世界知识和情境。</li><li>计算机能理解的语言时统一语义、显式结构、无歧义的。</li></ul><span id="more"></span><h2 id="1-1-研究意义"><a href="#1-1-研究意义" class="headerlink" title="1.1 研究意义"></a>1.1 研究意义</h2><p>语义解析是实现自然语言理解的关键技术之一，目的在于<strong>建立自然语言到计算机可以理解的形式化语义表示</strong>的映射。</p><h2 id="1-2-任务介绍"><a href="#1-2-任务介绍" class="headerlink" title="1.2 任务介绍"></a>1.2 任务介绍</h2><ul><li>任务定义</li></ul><p>将自然语言句子转换成计算机可识别的、可计算的、完全的语义表示，如lambda-表达式（λ演算）、SQL、语义图等。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%AF%E8%AF%86%E5%88%AB%E8%AF%AD%E8%A8%80.jpg" alt="自然语言到计算机可识别语言"></p><ul><li>自然语言的四大层次<ul><li>词法：词语的起源，以及词与词之间的关联</li><li>语法：句子的语法和结构</li><li>语义：句子表达的是什么意思</li><li>语用：句子背后的用意</li></ul></li><li>语言到语义由浅入深的表示方法<ul><li>语义角色标注（SRL）</li><li>框架语义解析（Frame-SP）</li><li>语义解析（SP）</li></ul></li><li>任务场景<ul><li>语言到结构化查询语言（language to query）</li><li>语言到代码（language to code）</li><li>语言到机器操作指令（language to instruction）</li></ul></li></ul><h2 id="1-3-重要组件"><a href="#1-3-重要组件" class="headerlink" title="1.3 重要组件"></a>1.3 重要组件</h2><ul><li>核心组件<ul><li>语义表示</li><li>解析模型</li><li>学习算法</li></ul></li></ul><h3 id="1-3-1-语义表示"><a href="#1-3-1-语义表示" class="headerlink" title="1.3.1 语义表示"></a>1.3.1 语义表示</h3><ul><li>框架语义表示：工业界常用<ul><li>优势：结构性表示，语义明确</li><li>劣势：人工定义框架，覆盖性有限</li></ul></li><li>分布式语义表示：一种文本表示的形式，指的是低维、稠密的连续向量。<ul><li>优势：应用性好，对机器友好</li><li>劣势：整体表示，细粒度区分不好</li></ul></li><li>模型理论-组合语义表示：学术界常用<ul><li>优势：表达能力强，机器可直接利用</li><li>劣势：难以生成</li></ul></li></ul><h3 id="1-3-2-解析模型"><a href="#1-3-2-解析模型" class="headerlink" title="1.3.2 解析模型"></a>1.3.2 解析模型</h3><p>句子转换为语义表示的建模</p><ul><li>基于规则的模型</li><li>基于统计的模型</li><li>基于神经网络的模型</li></ul><h3 id="1-3-3-学习算法"><a href="#1-3-3-学习算法" class="headerlink" title="1.3.3 学习算法"></a>1.3.3 学习算法</h3><p>如何学习转换过程</p><ul><li>目的</li></ul><p>让解析模型从一个句子的多种候选语义表示中选择争取的语义表示</p><ul><li>监督学习算法</li></ul><p>输入：&lt;句子，语义表示&gt; 标注对</p><p>目标：最大似然估计——p(语义表示|句子)</p><ul><li>弱监督学习算法</li></ul><p>输入：弱监督信号，如&lt;句子，知识库，答案&gt; ，&lt;句子，候选，点击&gt; 标注</p><p>目标：最大边界似然估计，语义表示当作潜变量</p><ul><li>相关资源：语义解析工具包<ul><li><a href="https://github.com/percyliang/sempre">Sempre</a></li><li><a href="https://github.com/lil-lab/spf">Cornell SPF</a></li><li><a href="https://github.com/allenai/allennlp">AllenNLP</a></li></ul></li></ul><h2 id="1-4-发展历程"><a href="#1-4-发展历程" class="headerlink" title="1.4 发展历程"></a>1.4 发展历程</h2><h3 id="1-4-1-基于规则的语义解析方法"><a href="#1-4-1-基于规则的语义解析方法" class="headerlink" title="1.4.1 基于规则的语义解析方法"></a>1.4.1 基于规则的语义解析方法</h3><ul><li>STUDENT系统 [Bobrow, 1964]：基于规则的线性代数求解</li><li>规则系统：错误可控可溯源、起步容易&#x2F;自助构建、增量式模型</li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95.jpg" alt="基于规则的语义解析方法"></p><h3 id="1-4-2-基于统计的语义解析方法"><a href="#1-4-2-基于统计的语义解析方法" class="headerlink" title="1.4.2 基于统计的语义解析方法"></a>1.4.2 基于统计的语义解析方法</h3><ul><li>代表性方法：基于词典-组合文法的语义解析<ul><li>CCG和DCS</li><li>核心组件：词典（lexicon）、组合文法（grammar）、概率模型</li><li>核心思想：层层递进组合词典</li></ul></li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E5%9F%BA%E4%BA%8E%E7%BB%9F%E8%AE%A1%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95.jpg" alt="基于统计的语义解析方法"></p><h3 id="1-4-3-基于语义图的语义解析方法"><a href="#1-4-3-基于语义图的语义解析方法" class="headerlink" title="1.4.3 基于语义图的语义解析方法"></a>1.4.3 基于语义图的语义解析方法</h3><p>构建语义图，而后基于知识图谱进行语义解析。</p><ul><li>用语义图来表示句子的语义</li><li>语义解析转换为语义图构建&#x2F;生成的问题</li><li>优势：<ul><li>不需要提前学习词典</li><li>不需要定义组合文法</li><li>可充分利用知识库的约束</li></ul></li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E5%9F%BA%E4%BA%8E%E8%AF%AD%E4%B9%89%E5%9B%BE%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95.jpg" alt="基于语义图的语义解析方法"></p><h3 id="1-4-4-基于神经网络的语义解析方法"><a href="#1-4-4-基于神经网络的语义解析方法" class="headerlink" title="1.4.4 基于神经网络的语义解析方法"></a>1.4.4 基于神经网络的语义解析方法</h3><ul><li>将逻辑表达式序列化</li><li>语义解析转换为<strong>词语序列到逻辑表达式序列</strong>的翻译过程（Seq2Seq）</li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E5%9F%BA%E4%BA%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95.jpg" alt="基于神经网络的语义解析方法"></p><h1 id="2-基于词典-组合文法的语义解析"><a href="#2-基于词典-组合文法的语义解析" class="headerlink" title="2 基于词典-组合文法的语义解析"></a>2 基于词典-组合文法的语义解析</h1><h2 id="2-1-组合语义的基本准则"><a href="#2-1-组合语义的基本准则" class="headerlink" title="2.1 组合语义的基本准则"></a>2.1 组合语义的基本准则</h2><p>复杂表达式的意义由<strong>其子表达式的意义以及意义如何组合的规则</strong>共同决定。</p><ul><li>关键组件<ul><li>词典：存储自然语言词语到词语语义的映射；语义组合的基本单元</li><li>组合文法：将小语义单元组合成更大的语义单元；组合语义基本准则中的combining rule</li></ul></li></ul><h2 id="2-2-代表性方法"><a href="#2-2-代表性方法" class="headerlink" title="2.2 代表性方法"></a>2.2 代表性方法</h2><h3 id="2-2-1-基于CCG的语义解析"><a href="#2-2-1-基于CCG的语义解析" class="headerlink" title="2.2.1 基于CCG的语义解析"></a>2.2.1 基于CCG的语义解析</h3><ul><li>CCG (Combinatory Categorial Grammar，组合范畴文法)，由ACL终身成就奖获得者Steedman教授提出</li><li>早期用于句法分析，后期由Zettlemoyer &amp; Collins(05)应用于语义解析：可以捕捉句子长距离依赖</li><li>核心组件：<ul><li>词典：使用CCG Category 来表示词汇语义</li><li>组合文法：CCG组合算子（combinators）</li><li>句子语义：使用lambda表达式表示句子语义</li></ul></li><li>语义表示：Lambda表达式<ul><li>常量Constants&#x2F;变量Var</li><li>谓词Predicate</li><li>逻辑连接词：与、或、非、蕴含</li><li>量词</li><li>额外函数：Count, argmax, average</li></ul></li><li>词典Lexicon：词语到范畴（category）的映射（范畴同时包含句法信息和语义信息）</li></ul><table>   <tr>      <td rowspan="2" align="center">词语</td>      <td colspan="2" align="center">范畴（category）</td>   </tr>   <tr>      <td>句法部分</td>      <td>语义部分</td>   </tr>   <tr>      <td>Texas(德州)</td>      <td>NP</td>      <td>texas</td>   </tr>   <tr>      <td>borders</td>      <td>(S\NP)/NP</td>      <td>𝜆𝑥. 𝜆𝑦. 𝑏𝑜𝑟𝑑𝑒𝑟(𝑦, 𝑥)</td>   </tr>   <tr>      <td>Kansas(堪萨斯州)</td>      <td>NP</td>      <td>kansas</td>   </tr>   <tr>      <td>Kansas city(堪萨斯城)</td>      <td>NP</td>      <td>kansas_city_mo(密苏里州堪萨斯城)</td>   </tr></table><p>其中<em>S</em>，<em>NP</em>是CCG里面的基本类型（还有<em>N</em>） ：</p><p>（1）S 表示一个完整的句子</p><p>（2）NP 表示一个专有名词（实体词汇）</p><p>（3）N 表示一个普通名词（类型词汇）</p><p>（S\NP)&#x2F;NP是一种复合类型（二元谓词词汇）：</p><p>（1）右向的slash(&#x2F;)表示右侧可以接受一个参数（ NP ），接受之后得到左侧的类型（S\NP） </p><p>（2）左向的slash(\)表示左侧可以接收一个参数（ NP ），接受之后得到左侧的类型（<em>S</em>）</p><p>（3）在此处得出的信息是border是一个语法上的连接词</p><ul><li>组合算子combinators，连接符（前三个为核心连接符）</li></ul><p>（1）Application conbinators应用连接符（前向 &lt; 和 后向 &gt;）</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/CCG_%E5%BA%94%E7%94%A8%E8%BF%9E%E6%8E%A5%E7%AC%A6.jpg" alt="CCG-应用连接符"></p><p>举例说明：A&#x2F;B 代表 <strong>往右（后向）找一个B形成A的一种函数关系f</strong>，即得到 A: f(g)</p><p>（2）Composition combinators组合连接符（前向 &lt;B 和后向 &gt;B，前后向找B）</p><p>类似于组合两个函数，得到一个新函数同时保留函数的功能，多用于串联两个条件短语（如示例中的 the latest 和 one way）。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/CCG-%E7%BB%84%E5%90%88%E8%BF%9E%E6%8E%A5%E7%AC%A6.jpg" alt="image-20210714161445215"></p><p>举例说明：A&#x2F;B 代表 <strong>往右（后向）找到一个B形成A的一种函数关系f</strong>，B&#x2F;C 代表往右（后向）找到一个C形成B的一个函数关系g，即得到：A: f(g(x))</p><p>（3）Type-raising combinators类型提升连接符(T)（前向 &lt;T 和 后向 &gt;T，意味着前&#x2F;后向找T）</p><p>类似于参数变为函数，函数的功能取决于新增的 T。</p><p>并列：刘德华和陈奕迅的歌曲</p><p>省略：播放刘德华（需要把刘德华提升为Song类型）</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/CCG_%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%E7%AC%A6.jpg" alt="CCG-类型提升符"></p><p>举例说明：在例子中，border Texas and Idaho 所组成的是 (S\NP)&#x2F;NP NP and NP，假如不进行类型提升，即变成 (S\NP) and NP，无法表示并列关系，后续的NP无法解析。因而需要类型提升，把NP变为函数，其类型符取决于border的转换结果 (S\NP)，Texas, Idaho 的 NP类型变为函数后，即可利用并列 ^，将border与Texas 和 Idaho进行组合连接。</p><ul><li>解析过程中的歧义</li></ul><p>（1）Lexicon层（主要）</p><p>一个词语可以映射到多个的category，比如Mississippi 既可以映射为 state: Mississippi，又可以映射为river: Mississippi。</p><p>（2）组合层（可忽略）</p><p>存在多种组合的可能性，但往往会得到相同的lambda-表达式。</p><ul><li>PCCG：估计每一个lambda-表达式的概率</li></ul><p>对数线性模型：S为句子，L为lambda-表达式，T为解析的过程， θ 为模型参数，f(L,T,S)为<strong>该解析的特征函数</strong>（作为一种评价指标），一个句子为解析为L的概率为：</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/PCCG%E6%A8%A1%E5%9E%8B.jpg" alt="PCCG模型"></p><p>原理：一个句子为解析为L的概率为，所有解析过程中，解析出为同一个Lambda-表达式的概率之和。每个过程解析成表达式的概率进行了归一化。</p><p><strong>重要特征</strong>：使用词汇、使用的组合文法</p><p><strong>参数学习</strong>：基于标注好的&lt;S, L&gt;对、最大化似然</p><ul><li>松弛的CCG文法</li></ul><p><strong>原因</strong>：CCG的文法过于严格，使得模型比较脆弱，特别是当面向口语化的文本的时候，会有大量词序错乱，省略的现象。</p><p>（1）Relaxed Application（允许词序的变化，slash方向可变，使用 ^ 符号组合）</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E6%9D%BE%E5%BC%9B%E7%9A%84CCG_RelaxedApplication.jpg" alt="松弛的CCG-RelaxedApplication"></p><p>（2）Relaxed Composition（允许短语的前置或者后置，slash方向可变，使用 ^ 符号组合）</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E6%9D%BE%E5%BC%9B%E7%9A%84CCG_RelaxedComposition.jpg" alt="松弛的CCG-RelaxedComposition"></p><p>（3）Type-shifting（允许省略）</p><p>将实体名词NP变为 N\N 类型的名词，在例子中省略了from。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E6%9D%BE%E5%BC%9B%E7%9A%84CCG_Type_shifting.jpg" alt="松弛的CCG-Type-shifting"></p><ul><li>因子化词汇</li></ul><p><strong>问题</strong>：词典在CCG parsing中至关重要，而词典稀疏，难以学习</p><p><strong>现象</strong>：一个词语可以映射到多个类型，一个类型又会在多个词汇中共享</p><p><strong>方法</strong>：因子化词汇，用参数表示的式子表示类型，以表达多种词汇到类型的映射</p><h3 id="2-2-2-基于DCS的语义解析"><a href="#2-2-2-基于DCS的语义解析" class="headerlink" title="2.2.2 基于DCS的语义解析"></a>2.2.2 基于DCS的语义解析</h3><p>DCS (Dependency-based compositional semantics，依存组合语义文法)由Percy Liang于2011年提出。DCS是一种语义表示体系，同时包含了从句子到语义表示所需的词典和组合文法。与CCG类似，基于组合语义的思想，依赖于<strong>词典</strong>和<strong>组合文法</strong>。</p><ul><li>DCS的特点</li></ul><p>（1）表示能力强：需要与lambda-表达式具备等价的语义表示能力</p><p>（2）简洁：与lambda-表达式相比，DCS的表示更加简洁</p><p>（3）结构清晰：保有与自然语言类似的结构</p><ul><li>语义</li></ul><p>（1）集合论：一个语义表示的语义是符合其语义约束的所有值的集合。</p><p>-  山东省 → {山东省} (山东) </p><p>− PlaceOfBirth → {&lt;莫言，山东&gt;，&lt;秦琼，山东&gt;，&lt;居里，法国&gt;, …} </p><p>− Profession→ {&lt;莫言，作家&gt;， &lt;秦琼，武将&gt;，&lt;居里，科学家&gt;}</p><p>− PlaceOfBirth.山东→ {莫言，秦琼, …} (山东出生) </p><p>− PlaceOfBirth.山东 ^ Profession.作家 → {莫言…} (山东出生的作家)</p><ul><li>词典</li></ul><p><strong>Unary case (u)<strong>：其语义为</strong>实体集合</strong></p><p>− 实体:“Texas”→ texas {texas} </p><p>− 类型：“state”→ state {纽约州、华盛顿州、密西西比州…}</p><p><strong>Binary case (b)</strong>: 其语义为符合关系的<strong>元组集合</strong></p><p>− 二元谓词（predicate）: “born”→ PlaceOfBirth {&lt;莫言，山东&gt;， &lt;秦琼，山东&gt;，&lt;居里，法国&gt;, …}</p><ul><li>组合文法-集合和集合之间的组合和转换</li></ul><p>（1）Join（合并）</p><p>− binary (Join) unary → unary</p><p>− unary (Join) binary → unary</p><p>− 山东 出生 → 出生.山东</p><p>− {山东} (Join) {&lt;莫言，山东&gt;，&lt;秦琼，山东&gt;，&lt;居里，法国&gt;, …} → {莫言，秦琼， …}</p><p>（2）Intersection（交集）</p><p>− unary (Intersection) unary → unary</p><p>− 流行歌手 → 流行 AND 歌手</p><p>（3）Union（并集）</p><p>− unary (Union) unary → unary</p><p>− 周杰伦或刘德华 → 周杰伦 OR 刘德华</p><p>（4）高阶函数</p><p>− Count (计数)：Count unary → unary</p><p>− argmax, argmin, max, min等</p><p>− 周杰伦的歌曲 数目 → Count(周杰伦的歌曲)</p><ul><li>解析例子（从下往上组合）</li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/DCS_%E8%A7%A3%E6%9E%90%E4%BE%8B%E5%AD%90.jpg" alt="DCS-解析例子"></p><h2 id="2-3-从限定域到开放域"><a href="#2-3-从限定域到开放域" class="headerlink" title="2.3 从限定域到开放域"></a>2.3 从限定域到开放域</h2><p>关键问题：词典覆盖不足、结构不匹配、标注语料成本过高。</p><h3 id="2-3-1-词典扩充学习"><a href="#2-3-1-词典扩充学习" class="headerlink" title="2.3.1 词典扩充学习"></a>2.3.1 词典扩充学习</h3><p>词典覆盖不足。</p><ul><li>使用实体对共现（Reference），核心是知识库的建立</li></ul><p>基本假设：文本中的三元组与知识库中的三元组若<strong>有多个共同的实体对</strong>，则文本中</p><p>的关系（词语）映射到知识库中的关系（词语语义）</p><ul><li>使用标签传播算法，核心是语义相似度的度量</li></ul><p>基本假设：意思相近的词语应该映射到相同的语义</p><h3 id="2-3-2-复述-x2F-重写"><a href="#2-3-2-复述-x2F-重写" class="headerlink" title="2.3.2 复述&#x2F;重写"></a>2.3.2 复述&#x2F;重写</h3><p>由自然语言多样性引起的本体不匹配问题。</p><ul><li>复述</li></ul><p>原理：将语义解析反过来，先得到句子的语义表示，然后生成新的句子，利用复述模型判断</p><p>新句子与原句子是否构成复述关系。</p><ul><li>重写</li></ul><p>原理：一个句子存在另外一种表达，该表达与原句子具有相同的语义，并且其结构与目标语义表示的结构一致</p><h3 id="2-3-3-弱监督学习"><a href="#2-3-3-弱监督学习" class="headerlink" title="2.3.3 弱监督学习"></a>2.3.3 弱监督学习</h3><p>语义表示难以标注。</p><ul><li>利用语义表示的执行结果（如问题的答案）来监督模型的学习</li></ul><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><ul><li><strong>核心组件</strong>：词典+组合文法+学习算法</li><li><strong>代表性方法</strong>：CCG，DCS</li><li><strong>从限定域到开放域</strong>：词典补充学习、复述&#x2F;重写、弱监督学习</li><li><strong>优点</strong>：<ul><li>基于组合语义的思想</li><li>有词典和组合规则，整个解析过程可见，可解释性强</li></ul></li><li><strong>缺点</strong>：<ul><li>太依赖词典，若有词典未覆盖的词语，就无法解析</li><li>脆弱，依赖组合文法，有些复杂的语言现象，文法也无法覆盖</li></ul></li></ul><h1 id="3-基于语义图的语义解析"><a href="#3-基于语义图的语义解析" class="headerlink" title="3 基于语义图的语义解析"></a>3 基于语义图的语义解析</h1><ul><li><p>关键组件：</p><ul><li>语义图表示</li><li>语义图构建</li></ul></li><li><p>使用语义图作为目标语义表示</p><ul><li>优点：语义图的结构与自然语言句子的结构具有类似性</li></ul></li><li><p>语义解析过程由组合文法转换为语义图构建</p><ul><li>优点：可以充分使用知识库知识的约束，，从而有效减少搜索空间</li></ul></li><li><p>语义图：</p><ul><li>可以看作知识库的一个子图</li><li>基本组成：<ul><li>节点，如实体、变量或者类型</li><li>边，表示关系</li><li>操作符，如count，argmax等</li></ul></li></ul></li><li><p>语义图构建代表性方法</p><ul><li>DepLambda [Reddy et al, 2016]：依存树到语义图转换文法</li><li>STAGG [Yih, et al., 2015]: 分步骤构建方法</li><li>Template [Bast &amp; Haussmann, 2015]: 基于模板的语义图生成</li></ul></li></ul><h2 id="3-1-DepLambda：依存树到语义图转换"><a href="#3-1-DepLambda：依存树到语义图转换" class="headerlink" title="3.1 DepLambda：依存树到语义图转换"></a>3.1 DepLambda：依存树到语义图转换</h2><ul><li>原理：依存树与目标逻辑表达式具有类似的结构。</li></ul><p>（0）预处理：依存关系解析，句子→依存树</p><p>（1）Dependencies to Logical Forms，利用依存关系组合词汇，依存树→Ungrounded lambda-表达式，<strong>类似CCG方法的解析过程</strong></p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/DepLambda_DependenciestoLogicalForms.jpg" alt="DepLambda-DependenciestoLogicalForms"></p><p>（2）Map Logical Form to Ungrounded Graph，Ungrounded lambda-表达式→Ungrounded graph</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/DepLambda_lambda_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0UngroundedGraph.jpg" alt="DepLambda-lambda-表达式到UngroundedGraph"></p><p>（3）Map Ungrounded Graph to Semantic Graph，Ungrounded graph→Grounded graph（语义图）</p><p>−实体词 链接到知识库中的实体，如<em>Titanic</em> → TITANIC</p><p>−关系词 链接到知识库中的关系，如<em>directed</em> → film.directed_by</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/DepLambda_Grounding.jpg" alt="DepLambda-Grounding"></p><h2 id="3-2-STAGG：分步搭建语义图"><a href="#3-2-STAGG：分步搭建语义图" class="headerlink" title="3.2 STAGG：分步搭建语义图"></a>3.2 STAGG：分步搭建语义图</h2><ul><li>分步搭建语义图的好处：</li></ul><p>（1）每一步都可以使用最好的技术</p><p>（2）每进行一步都可以利用知识库的约束来减少搜索空间</p><ul><li>基本概念</li></ul><p>（1）中心链</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/STAGG_%E4%B8%AD%E5%BF%83%E9%93%BE.jpg" alt="STAGG-中心链"></p><p>（2）约束</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/STAGG_%E7%BA%A6%E6%9D%9F.jpg" alt="STAGG-约束"></p><ul><li>主要步骤：</li></ul><p>（1）中心实体链接：识别实体</p><p>识别出句子中的所有实体，特别是找到中心链上的中心实体</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/STAGG_%E4%B8%AD%E5%BF%83%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5.jpg" alt="STAGG-中心实体链接"></p><p>（2）关系链匹配</p><p>要求：与中心实体连接的长度不能超过2的所有关系链作为候选。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/STAGG_%E5%85%B3%E7%B3%BB%E9%93%BE%E5%8C%B9%E9%85%8D.jpg" alt="STAGG-关系链匹配"></p><p>在求出关系链后，可以通过不同的方法，如以最大似然估计为目标函数的Deep Convolutional Neural Networks，来从知识库中找到对应的目标实体集（问题答案的集合）。</p><p>（3）添加约束条件</p><p>最后通过将约束条件作用于目标实体集，缩小或者找到对应的目标实体（最终的问题答案）。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/STAGG_%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6.jpg" alt="STAGG-添加约束条件"></p><ul><li>性能：具有高召回率。</li></ul><p>（1）并不需要词典，也不受限于词典的覆盖率；<br>（2）可以通过神经网络模型来建模软匹配过程，能处理模拟匹配的情况，解决OOV问题(out of vocabulary words)</p><h2 id="3-3-Template：基于模板的语义图构建"><a href="#3-3-Template：基于模板的语义图构建" class="headerlink" title="3.3 Template：基于模板的语义图构建"></a>3.3 Template：基于模板的语义图构建</h2><ul><li>出发点：查询往往都具有固定的若干模板(template)，可通过设计有限的模板来覆盖绝大部分的查询。基于template的方法可以把语义图构建转换为模板匹配问题，能够大大简化此问题。</li><li>关键：<ul><li>模板的定义</li><li>模板的匹配</li></ul></li><li>模板的定义</li></ul><p>3个模板覆盖Webquestions和Free917数据集中绝大部分查询。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Template_%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt="Template-模板的定义"></p><p>其中，m是虚实体，为了关系连接而虚构的实体，需要注意的是company, film这种表示类型的词汇也属于一种关系。</p><ul><li>模板匹配</li></ul><p>（1）实体链接，识别句子中的实体</p><p>（2）匹配模板，匹配上述的三个模板</p><p>（3）关系匹配，根据关系在知识库中进行匹配，找到目标实体</p><ul><li>性能：高召回率</li></ul><p>模板能够覆盖大部分的问题，简化了语义图构建的过程。</p><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h2><ul><li><p><strong>核心：</strong>语义图的语义表示、语义图的构建</p></li><li><p><strong>代表性方法：</strong>DepLambda、STAGG、Template </p></li><li><p><strong>优点</strong>：</p><ul><li>不需要词典和组合文法</li><li>语义图的结构与句子的依存结构具有相似性</li><li>与知识库紧密联系，可充分利用知识库知识的约束</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>往往依赖于一些启发式的方法来构建语义图</li></ul></li></ul><h1 id="4-基于神经网络的语义解析"><a href="#4-基于神经网络的语义解析" class="headerlink" title="4 基于神经网络的语义解析"></a>4 基于神经网络的语义解析</h1><ul><li><p>出发点：之前的模型都很复杂，模块很多</p></li><li><p>代表性方法：</p><ul><li><strong>Seq2Seq</strong> [Dong &amp; Lapata, 2016; Jia &amp; Liang, 2016],</li><li><strong>Seq2Tree</strong>[Dong &amp; Lapata, 2016]</li><li><strong>Seq2Act</strong> [Chen et al., 2018]</li></ul></li></ul><h2 id="4-1-Seq2Seq-AND-Seq2Tree"><a href="#4-1-Seq2Seq-AND-Seq2Tree" class="headerlink" title="4.1 Seq2Seq AND Seq2Tree"></a>4.1 Seq2Seq AND Seq2Tree</h2><ul><li><strong>Seq2Seq</strong>：把语义解析看作是机器翻译的问题。</li></ul><p>（1）将逻辑表达式序列化，看作一系列token，从而将语义解析转化为Seq2Seq问题。</p><p>（2）语义解析中的目标语言（语义表示）具有层次结构，而Seq2Seq模型仅把语义表示扁平序列化，从而忽略了层次结构信息，导致在解码过程中需要考虑更多的长距离依赖。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Seq.jpg" alt="Seq2Seq"></p><ul><li><strong>Seq2Tree</strong>：弥补Seq2Seq扁平化表示的不足</li></ul><p>（1）层次化的decoder，不生成扁平化的语义表示序列，而是生成层次结构化的语义表示（tree） ，用&lt;n&gt;来表示树结构中的非终结符</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Tree.jpg" alt="Seq2Tree"></p><p>（2）在神经网络中的表示：占位符&lt;n&gt;都存放在一个队列里，直到队列为空才终止，遇到占位符&lt;n&gt;即进入下一层。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Tree_%E5%9C%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="Seq2Tree-在神经网络中的表示"></p><ul><li>在Seq2Seq&#x2F;Seq2Tree中可以加入注意力机制：注意力机制相当于让模型学习了词语到词语的语义表示之间的软对齐。</li><li>性能评估：</li></ul><p>（1）层次结构的decoder使得模型学习到了目标语义表示的结构，这些结构信息能够帮助生成整个语义表示</p><p>（2）Attention机制让模型学习了词语到词语的语义表示之间的软对齐，起到了类似于词典的效果</p><h2 id="4-2-Seq2Act"><a href="#4-2-Seq2Act" class="headerlink" title="4.2 Seq2Act"></a>4.2 Seq2Act</h2><ul><li>端到端的语义图生成。</li></ul><p>端到端：一端输入原始数据，一端输出期望得到的结果，只关心输入和输出，中间的步骤全部都不管，形成了一个黑箱。</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Act_%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E8%AF%AD%E4%B9%89%E7%94%9F%E6%88%90.jpg" alt="Seq2Act-端到端的语义生成"></p><ul><li>模型框架</li></ul><p>（1）根据Sequence-to-Action RNN Model生成动作序列</p><p><strong>动作集类型</strong>有：Add variable node,  Add entity node, Add type node, Add edge, Operation action, Argument action</p><p><strong>Encoder-Decoder model</strong>：bi-LSTM with attention（基于注意力机制的双向LSTM模型）</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Act_encoder_decoderModel.jpg" alt="Seq2Act-encoder-decoderModel"></p><p>经典模型有encoder层包含双向LSTM的bi-LSTM模型，其中，输入是Action embedding。</p><p><strong>Action embedding包含句法部分和结构部分</strong>，分别编码，一定程度上缓解动作的稀疏性（类似因子化词汇）。</p><p>（2）根据动作序列搭建语义图</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Act_%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6.jpg" alt="Seq2Act-模型框架5"></p><ul><li>性能：</li></ul><p>（1）动作编码更加的紧凑，一定程度解决长距离依赖的问题</p><p>（2）可扩展性强，更容易在解码过程中加入知识库的约束信息，来保证解码时生成符合句法、符合语义的语义表示</p><h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h2><ul><li><p><strong>Seq2Seq</strong>: 直接把目标语义表示序列化</p></li><li><p><strong>Seq2Tree</strong>: 考虑到目标语义表示的结构性</p></li><li><p><strong>Seq2Act</strong>: 用语义图表示语义，用动作序列编码语义图的构建</p></li></ul><h2 id="4-4-基于神经网络模型的扩展"><a href="#4-4-基于神经网络模型的扩展" class="headerlink" title="4.4 基于神经网络模型的扩展"></a>4.4 基于神经网络模型的扩展</h2><ul><li>Constrained decoder：跟知识结合</li></ul><p>（1）<strong>理由</strong>：由于<strong>目标语言是形式化语言，需符合严格的条件约束</strong>，因此对比机器翻译里面的decoder，语义解析中的decoder可以使用严格的约束条件。</p><p>（2）<strong>主要部分</strong>：句法条件和语义条件</p><p>− 句法条件：如”(λa $0 e (and (flight $0) ) from $0 “ 下一个token应该是一个参数（实体或者变量）。</p><p>− 语义条件：“(λa $0 e (and (flight $0) ) from $0 ”下一个token应该是一个城市或者机场。</p><p>（3）<strong>作用</strong>：避免生成明显错误的token，从而提高最终生成准确语义表示的概率。</p><p>（4）<strong>适用性</strong>：在所有的基于神经网络的语义解析方法中都可以使用。</p><p>（5）<strong>Constrained decoder in Seq2Act</strong>：</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/ConstrainedDecoderInSeq2Act.jpg" alt="ConstrainedDecoderInSeq2Act"></p><p>（6）<strong>Grammar constrained decoder</strong>：</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/GrammerConstrainedDecoder.jpg" alt="GrammerConstrainedDecode"></p><ul><li>Coarse-to-fine：“通用结构”+“微调”</li></ul><p>（1）<strong>理由</strong>：自然语言与语义表示之间的gap太大</p><p>（2）<strong>方案</strong>：先生成sketch，再进行grounding，简而言之，先生成大致框架，再依据句子补充实体</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Act_Corse_to_fine.jpg" alt="Seq2Act-Corse-to-fine"></p><p>（3）<strong>先生成sketch的好处</strong>：</p><p>− 相比完整的语义表示，先生成sketch要容易很多</p><p>− sketch具有一定的泛化性，很多句子具有相同的sketch</p><p>− 使用sketch之后，生成的序列长度大大缩减</p><p>− sketch可以为后面的decoding提供帮助</p><p>（4）<strong>建模Coarse-to-fine的过程</strong>：先生成sketch，在利用sketch指导输出decoding</p><p><img src="https://github.com/CCSemicircle/img/blob/main/images/Seq2Act_%E5%BB%BA%E6%A8%A1Coarse_to_fine%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="Seq2Act-建模Coarse-to-fine的过程"></p><p>（5）<strong>sketch指导后面的decoding的方法</strong>：辅助判断是否缺失实体，提示类型信息等</p><h1 id="5-总结和展望"><a href="#5-总结和展望" class="headerlink" title="5 总结和展望"></a>5 总结和展望</h1><h2 id="5-1-现有方法总结"><a href="#5-1-现有方法总结" class="headerlink" title="5.1 现有方法总结"></a>5.1 现有方法总结</h2><table><thead><tr><th>方法</th><th>核心</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>基于词典-组合文法的方法</td><td>词典<br />组合文法</td><td>基于组合语义思想，解析过程清晰可见，可解释性强</td><td>需要学习词典和语义组合文法，且容易受限于词典的覆盖度</td></tr><tr><td>基于语义图的方法</td><td>语义图表示<br />语义图的构建</td><td>语义图与自然语言句子具有类似的结构；与知识库联系紧密，可充分利用知识库的知识来指导语义图的构建</td><td>往往依赖于特定的手段来构建语义图，缺乏一定的通用性</td></tr><tr><td>基于神经网络的方法</td><td>Decoding中的token形式<br />Decoding中的constrains</td><td>端到端，充分利用神经网络模型的表示能力和拟合能力</td><td>可解释性差</td></tr></tbody></table><h2 id="5-2-展望"><a href="#5-2-展望" class="headerlink" title="5.2 展望"></a>5.2 展望</h2><h3 id="5-2-1-低成本的模型构建"><a href="#5-2-1-低成本的模型构建" class="headerlink" title="5.2.1 低成本的模型构建"></a>5.2.1 低成本的模型构建</h3><ul><li><p>思路：Transfer、弱监督&#x2F;无监督学习、预训练</p></li><li><p><strong>Transfer：领域迁移</strong></p><ul><li>关键：<strong>解耦合结构和词典</strong></li><li>假设：结构在不同领域下具有通用性</li></ul></li></ul><h3 id="5-2-2-符号与神经网络融合的语义解析"><a href="#5-2-2-符号与神经网络融合的语义解析" class="headerlink" title="5.2.2 符号与神经网络融合的语义解析"></a>5.2.2 符号与神经网络融合的语义解析</h3><ul><li>现象：两类方法各有优势，<strong>基于符号的方法长于推理和利用知识</strong>，<strong>神经网络的方法长于表示和计算</strong>，如何在语义解析中有效融合两类方法也将成为研究者探索的点。</li><li>挑战：符号在神经网络中的表示形式，以及计算方式（往往不可导）。</li><li>当前方法：<strong>Neural Symbolic Machines (NSM，神经符号机)</strong><ul><li>以memory的形式在neural network中引入symbolic representation。</li><li>利用强化学习算法来训练模型（symbolic部分不可导）</li></ul></li></ul><h3 id="5-2-3-上下文感知的语义解析"><a href="#5-2-3-上下文感知的语义解析" class="headerlink" title="5.2.3 上下文感知的语义解析"></a>5.2.3 上下文感知的语义解析</h3><ul><li>问题：当前句子解析需要利用之前句子的信息，如对话理解、代码生成等。</li><li>关键挑战：指代、省略、如何复用信息</li><li>当前解决办法：<ul><li><strong>基于CCG的方法（针对指代、省略）</strong>：增加新词汇（用!&lt;e, t&gt;表示待插入的新词汇）和文法（基于Type-shifting，同时利用!&lt;e, t&gt;表示被省略的词汇）来处理指代和省略等现象</li><li><strong>基于神经网络的方法</strong>：<ul><li>turn-level encoder：编码上下文信息</li><li>query segment copying：用copy机制来复用信息（多用于问题复用）</li></ul></li></ul></li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A3%E6%9E%90.jpg" alt="上下文感知的语义解析"></p><h3 id="5-2-4-与物理世界交互的语义解析"><a href="#5-2-4-与物理世界交互的语义解析" class="headerlink" title="5.2.4 与物理世界交互的语义解析"></a>5.2.4 与物理世界交互的语义解析</h3><ul><li>问题：解析执行一系列指令，状态随着指令的执行而发生变化，如机器人执行指令。</li><li>关键挑战：如何建模之前的指令（同样有指代和省略的现象），如何建模当前环境的状态变化。</li><li>当前的解决办法：<ul><li><strong>基于注意力机制的encoder-decoder模型</strong>：根据特定任务定义System Action、Encoder中建模之前命令以及当前的状态（包括当前命令、之前命令、初始状态、当前状态等）</li></ul></li></ul><h1 id="6-个人理解总结"><a href="#6-个人理解总结" class="headerlink" title="6 个人理解总结"></a>6 个人理解总结</h1><ol><li>基于词典-组合文法的语义解析从原理上看，更加适用于限定域，扩展到开放域的成本较高，主要是过于依赖词典和组合规则。</li><li>基于语义图的语义解析可以基于知识库得到较为准确的结果，但是如何构建语义图是一个比较困难的问题，而且求解必须依赖知识库，不过有向开放域扩展的可能性，而且目前各类知识库在逐步建立，或许会有较好的前景。</li><li>基于神经网络的语义解析中，虽然可解释性差，如果模型比较好，效果也应该比较好，比较适合完成非解释性的任务，像端到端的任务。</li><li>展望的四个角度事实上都是自然语义理解可以发展的方向，第二个比较偏向基于目前方法进行改进，其余三个是具体的应用场景或任务层面的发展方向。</li></ol>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 语义解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative</title>
      <link href="/2021/qian-duan-kai-fa-reactnative/"/>
      <url>/2021/qian-duan-kai-fa-reactnative/</url>
      
        <content type="html"><![CDATA[<h1 id="0-搭建环境"><a href="#0-搭建环境" class="headerlink" title="0 搭建环境"></a>0 搭建环境</h1><ol><li><p>安装原生Android环境，<a href="https://reactnative.cn/docs/environment-setup">官方文档</a> + <a href="https://segmentfault.com/a/1190000018323652">博客</a></p></li><li><p>下载React-Native</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install -g react-native-cli# 进入项目文件夹的父目录下打开cmd，输入以下命令react-native init myProjec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li><a href="https://blog.csdn.net/yinxing2008/article/details/89250436">打开安卓模拟器的开发者选项</a></li></ol><h1 id="1-开发工具"><a href="#1-开发工具" class="headerlink" title="1 开发工具"></a>1 开发工具</h1><ul><li>WebStorm</li></ul><h1 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2 创建项目"></a>2 创建项目</h1><h2 id="2-1-New-Project"><a href="#2-1-New-Project" class="headerlink" title="2.1 New Project"></a>2.1 New Project</h2><ul><li>注意使用电脑上已经安装的react-native包，例如：</li><li>C:\Program Files\nodejs\node_global\node_modules\react-native-cli</li></ul><h2 id="2-2-设置快捷启动"><a href="#2-2-设置快捷启动" class="headerlink" title="2.2 设置快捷启动"></a>2.2 设置快捷启动</h2><ul><li>详见博客：<a href="https://www.jianshu.com/p/85d8e5e1c22d">https://www.jianshu.com/p/85d8e5e1c22d</a></li></ul><h2 id="2-3-设置Debugger"><a href="#2-3-设置Debugger" class="headerlink" title="2.3 设置Debugger"></a>2.3 设置Debugger</h2><ul><li>下载react-native-debugger –  <a href="https://github.com/jhen0409/react-native-debugger/releases/tag/v0.11.7">https://github.com/jhen0409/react-native-debugger/releases/tag/v0.11.7</a></li><li>启动react-native-debugger.exe</li><li>在模拟器中按下CTRL+M，启用Debug，即可成功</li></ul><h2 id="2-4-启动代码补全"><a href="#2-4-启动代码补全" class="headerlink" title="2.4 启动代码补全"></a>2.4 启动代码补全</h2><ul><li>详见博客：<a href="https://blog.csdn.net/aa330233789/article/details/103134580">https://blog.csdn.net/aa330233789/article/details/103134580</a></li></ul><h2 id="2-5-启动模板"><a href="#2-5-启动模板" class="headerlink" title="2.5 启动模板"></a>2.5 启动模板</h2><ul><li>详见博客：<a href="https://blog.csdn.net/weixin_38080573/article/details/88315159">https://blog.csdn.net/weixin_38080573/article/details/88315159</a></li><li>一般来说，WebStorm自带许多模板，已经足够了，上述是自定义模板</li></ul><h2 id="2-6-WebStorm常用快捷键"><a href="#2-6-WebStorm常用快捷键" class="headerlink" title="2.6 WebStorm常用快捷键"></a>2.6 WebStorm常用快捷键</h2><ul><li>详见博客：<a href="https://www.cnblogs.com/wanglexueshilengde/p/8390730.html">https://www.cnblogs.com/wanglexueshilengde/p/8390730.html</a></li></ul><h2 id="2-7-关闭ESlint检查"><a href="#2-7-关闭ESlint检查" class="headerlink" title="2.7 关闭ESlint检查"></a>2.7 关闭ESlint检查</h2><p><img src="https://github.com/CCSemicircle/img/blob/main/images/WebStorm%E5%85%B3%E9%97%ADESlint%E6%A3%80%E6%9F%A5.jpg" alt="WebStorm关闭ESlint检查"></p><h1 id="3-编码问题汇总"><a href="#3-编码问题汇总" class="headerlink" title="3 编码问题汇总"></a>3 编码问题汇总</h1><h2 id="3-1-样式规范编写"><a href="#3-1-样式规范编写" class="headerlink" title="3.1 样式规范编写"></a>3.1 样式规范编写</h2><ul><li>详见博客：<a href="https://segmentfault.com/a/1190000013332489">https://segmentfault.com/a/1190000013332489</a></li></ul><h2 id="3-2-开源复用组件"><a href="#3-2-开源复用组件" class="headerlink" title="3.2 开源复用组件"></a>3.2 开源复用组件</h2><ul><li>UI组件库：<a href="https://reactnativeelements.com/docs/">https://reactnativeelements.com/docs/</a></li><li>icon库：<a href="https://oblador.github.io/react-native-vector-icons/">https://oblador.github.io/react-native-vector-icons/</a></li></ul><h1 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4 常见用法"></a>4 常见用法</h1><h2 id="4-1统一获取表单输入框值"><a href="#4-1统一获取表单输入框值" class="headerlink" title="4.1统一获取表单输入框值"></a>4.1统一获取表单输入框值</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function-variable function">saveInputData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">dataType</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// console.log(dataType,"dataType");</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// console.log(event,"event");</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token punctuation">[</span>dataType<span class="token punctuation">]</span><span class="token operator">:</span> event<span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-圆角按钮属性"><a href="#4-2-圆角按钮属性" class="headerlink" title="4.2 圆角按钮属性"></a>4.2 圆角按钮属性</h2> <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">borderRadius<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-3-动态修改组件样式"><a href="#4-3-动态修改组件样式" class="headerlink" title="4.3 动态修改组件样式"></a>4.3 动态修改组件样式</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">state <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">buttonColor</span><span class="token operator">:</span> Color<span class="token punctuation">.</span>font<span class="token punctuation">.</span>alleviate<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>Button  buttonStyle<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>styles<span class="token punctuation">.</span>button<span class="token punctuation">,</span> <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>buttonColor <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-TouchableOpacity取消点击后的透明度变化"><a href="#4-4-TouchableOpacity取消点击后的透明度变化" class="headerlink" title="4.4 TouchableOpacity取消点击后的透明度变化"></a>4.4 TouchableOpacity取消点击后的透明度变化</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// activeOpacity=&#123;1&#125;</span><span class="token comment">// 注意不是样式属性，不能写在样式里</span><span class="token operator">&lt;</span>CheckBox  center  containerStyle<span class="token operator">=</span><span class="token punctuation">&#123;</span>styles<span class="token punctuation">.</span>checkBox<span class="token punctuation">&#125;</span>  activeOpacity<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>  title<span class="token operator">=</span><span class="token string">"请阅读同意"</span>  textStyle<span class="token operator">=</span><span class="token punctuation">&#123;</span>styles<span class="token punctuation">.</span>tipsFont<span class="token punctuation">&#125;</span>  iconType<span class="token operator">=</span><span class="token string">"material-icons"</span>  checkedIcon<span class="token operator">=</span><span class="token string">"check-circle"</span>  checkedColor<span class="token operator">=</span><span class="token punctuation">&#123;</span>Color<span class="token punctuation">.</span>font<span class="token punctuation">.</span>alleviate<span class="token punctuation">&#125;</span>  uncheckedIcon<span class="token operator">=</span><span class="token string">"radio-button-unchecked"</span>  onPress<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>checkAgreement<span class="token punctuation">&#125;</span>  checked<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>agreementChecked<span class="token punctuation">&#125;</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5-alignSelf属性值"><a href="#4-5-alignSelf属性值" class="headerlink" title="4.5 alignSelf属性值"></a>4.5 alignSelf属性值</h2><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">auto</td><td align="left">默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。</td></tr><tr><td align="left">stretch</td><td align="left">元素被拉伸以适应容器。</td></tr><tr><td align="left">center</td><td align="left">元素位于容器的中心。</td></tr><tr><td align="left">flex-start</td><td align="left">元素位于容器的开头。</td></tr><tr><td align="left">flex-end</td><td align="left">元素位于容器的结尾。</td></tr><tr><td align="left">baseline</td><td align="left">元素位于容器的基线上。</td></tr><tr><td align="left">initial</td><td align="left">设置该属性为它的默认值。请参阅 <a href="https://techbrood.com/cssref?p=css-initial"><em>initial</em></a>。</td></tr><tr><td align="left">inherit</td><td align="left">从父元素继承该属性。请参阅 <a href="https://techbrood.com/cssref?p=css-inherit"><em>inherit</em></a>。</td></tr></tbody></table><h2 id="4-6-控制Flex子元素在主轴上的比例"><a href="#4-6-控制Flex子元素在主轴上的比例" class="headerlink" title="4.6 控制Flex子元素在主轴上的比例"></a>4.6 控制Flex子元素在主轴上的比例</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 属性名</span>flexGrow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-7-文本自动换行"><a href="#4-7-文本自动换行" class="headerlink" title="4.7 文本自动换行"></a>4.7 文本自动换行</h2><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span></span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>styles<span class="token punctuation">.</span>infoFont<span class="token punctuation">&#125;</span></span> <span class="token attr-name">selectable</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span></span>                  <span class="token attr-name">textBreakStrategy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>balanced<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Text</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-8-原生组件官方文档"><a href="#4-8-原生组件官方文档" class="headerlink" title="4.8 原生组件官方文档"></a>4.8 原生组件官方文档</h2><ul><li>API文档：<a href="https://reactnative.cn/docs/text">https://reactnative.cn/docs/text</a></li></ul><h2 id="4-9-Navigation使用"><a href="#4-9-Navigation使用" class="headerlink" title="4.9 Navigation使用"></a>4.9 Navigation使用</h2><ul><li>官方中文文档：<a href="https://www.reactnavigation.org.cn/docs/tabnavigator">TabNavigator · React Navigation中文网</a></li></ul><h2 id="4-10-组件自动换行"><a href="#4-10-组件自动换行" class="headerlink" title="4.10 组件自动换行"></a>4.10 组件自动换行</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">flexWrap</span><span class="token operator">:</span><span class="token string">"wrap"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-11-FlatList用法"><a href="#4-11-FlatList用法" class="headerlink" title="4.11 FlatList用法"></a>4.11 FlatList用法</h2><ul><li>详见博客：<a href="https://www.jianshu.com/p/31e3cb511c73">React-native FlatList的基本用法 - 简书 (jianshu.com)</a></li></ul><h2 id="4-12-导航栏使用"><a href="#4-12-导航栏使用" class="headerlink" title="4.12 导航栏使用"></a>4.12 导航栏使用</h2><ul><li>详见博客：<a href="https://blog.csdn.net/LJFPHP/article/details/77940284"> React Native 的顶部导航栏和底部导航栏目_铁柱的博客-CSDN博客</a></li></ul><h2 id="4-13-TabNative-5-0"><a href="#4-13-TabNative-5-0" class="headerlink" title="4.13 TabNative 5.0"></a>4.13 TabNative 5.0</h2><ul><li>官方文档：<a href="https://www.npmjs.com/package/react-native-tab-navigator">https://www.npmjs.com/package/react-native-tab-navigator</a></li></ul><h2 id="4-14-Android项目gradle包下载目录"><a href="#4-14-Android项目gradle包下载目录" class="headerlink" title="4.14 Android项目gradle包下载目录"></a>4.14 Android项目gradle包下载目录</h2><ul><li>示例：<strong>C:\Users\用户.gradle\caches\modules-2\files-2.1\com.alexvasilkov\foldable-layout\1.0.1\59a9dd35f8d31de01991ee56b741e9e992914895\foldable-layout-1.0.1-sources.jar</strong></li></ul><h2 id="4-15-报错-app-mergeDexDebug-FAILED解决方法："><a href="#4-15-报错-app-mergeDexDebug-FAILED解决方法：" class="headerlink" title="4.15 报错:app:mergeDexDebug FAILED解决方法："></a>4.15 报错:app:mergeDexDebug FAILED解决方法：</h2><ul><li>在android&#x2F;app&#x2F;build.gradle文件中添加如下代码:</li></ul><pre class="line-numbers language-none"><code class="language-none">dependencies &#123;  implementation &#39;com.android.support:multidex:1.0.3&#39; &#x2F;&#x2F;enter the latest version,&#125;android &#123;    defaultConfig &#123;        multiDexEnabled true    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>latest version：<a href="https://developer.android.google.cn/studio/build/multidex?hl=zh-cn">https://developer.android.google.cn/studio/build/multidex?hl=zh-cn</a></li></ul><h2 id="4-16-WebStorm中js文件被识别为txt文件"><a href="#4-16-WebStorm中js文件被识别为txt文件" class="headerlink" title="4.16 WebStorm中js文件被识别为txt文件"></a>4.16 WebStorm中js文件被识别为txt文件</h2><ul><li>详见博客：<a href="https://blog.csdn.net/lansura/article/details/52756614">https://blog.csdn.net/lansura/article/details/52756614</a></li><li>如果没有解决，可以手动加入index.js文件，apply之后再删除，再apply。</li></ul><h2 id="4-17-Style-详细说明"><a href="#4-17-Style-详细说明" class="headerlink" title="4.17 Style 详细说明"></a>4.17 Style 详细说明</h2><ul><li>详见博客：<a href="https://www.jianshu.com/p/2b4368569c03">https://www.jianshu.com/p/2b4368569c03</a></li></ul><h2 id="4-18-查看项目无法启动的错误报告"><a href="#4-18-查看项目无法启动的错误报告" class="headerlink" title="4.18 查看项目无法启动的错误报告"></a>4.18 查看项目无法启动的错误报告</h2><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token operator">/</span><span class="token operator">/</span> 控制台下android>gradlew assembleDebug <span class="token operator">--</span>info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-19-无法将类-JMessageReactPackage中的构造器-JMessageReactPackage应用到给定类型"><a href="#4-19-无法将类-JMessageReactPackage中的构造器-JMessageReactPackage应用到给定类型" class="headerlink" title="4.19 无法将类 JMessageReactPackage中的构造器 JMessageReactPackage应用到给定类型"></a>4.19 无法将类 JMessageReactPackage中的构造器 JMessageReactPackage应用到给定类型</h2><ul><li>使用<strong>“探花APP” React-Native教程的plugin.md文档</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 将Project根目录下react-native.comfig.js文件中的代码改为如下</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">dependencies</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string-property property">'jmessage-react-plugin'</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">platforms</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">android</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 原来是packageInstance: 'new JMessageReactPackage(false)'</span>          <span class="token literal-property property">packageInstance</span><span class="token operator">:</span> <span class="token string">'new JMessageReactPackage()'</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-20-报错INSTALL-FAILED-INSUFFICIENT-STORAGE"><a href="#4-20-报错INSTALL-FAILED-INSUFFICIENT-STORAGE" class="headerlink" title="4.20 报错INSTALL_FAILED_INSUFFICIENT_STORAGE"></a>4.20 报错INSTALL_FAILED_INSUFFICIENT_STORAGE</h2><pre class="line-numbers language-none"><code class="language-none">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; package&#x3D;&quot;xxx&quot; android:installLocation&#x3D;&quot;preferExternal&quot; &#x2F;&#x2F;增加这行代码！ android:versionCode&#x3D;&quot;1&quot; android:versionName&#x3D;&quot;1.0&quot; &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-21-样式问题Debug"><a href="#4-21-样式问题Debug" class="headerlink" title="4.21 样式问题Debug"></a>4.21 样式问题Debug</h2><ul><li>设置border或者backgroundColor</li><li>设置flex:1可以使得左右各占一半。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2021/qian-duan-kai-fa-react/"/>
      <url>/2021/qian-duan-kai-fa-react/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h1><h2 id="1-1-搭建React-Native"><a href="#1-1-搭建React-Native" class="headerlink" title="1.1 搭建React Native"></a>1.1 搭建React Native</h2><h3 id="1-1-1-搭建-Node"><a href="#1-1-1-搭建-Node" class="headerlink" title="1.1.1 搭建 Node"></a>1.1.1 搭建 Node</h3><ol><li><a href="https://blog.csdn.net/weixin_49279236/article/details/111031150">npm安装失败，解决方法</a></li></ol><h3 id="1-1-2-下载Android-Studio"><a href="#1-1-2-下载Android-Studio" class="headerlink" title="1.1.2 下载Android Studio"></a>1.1.2 下载Android Studio</h3><ol><li>Android Studio 里的Cannot resolve symbol XXX：<ul><li><a href="https://www.jianshu.com/p/91cfa8df3128">https://www.jianshu.com/p/91cfa8df3128</a></li><li><a href="https://blog.csdn.net/m0_37292262/article/details/81395369">https://blog.csdn.net/m0_37292262/article/details/81395369</a></li><li><a href="https://blog.csdn.net/godcok/article/details/82463984">https://blog.csdn.net/godcok/article/details/82463984</a></li></ul></li></ol><h3 id="1-1-3-安装react-native-cli"><a href="#1-1-3-安装react-native-cli" class="headerlink" title="1.1.3 安装react-native-cli"></a>1.1.3 安装react-native-cli</h3><ol><li><a href="https://blog.csdn.net/qq_32114025/article/details/88638045">https://blog.csdn.net/qq_32114025/article/details/88638045</a></li></ol><h3 id="1-1-4-npm下载package失败，切换-管理员身份运行cmd"><a href="#1-1-4-npm下载package失败，切换-管理员身份运行cmd" class="headerlink" title="1.1.4 npm下载package失败，切换 管理员身份运行cmd"></a>1.1.4 npm下载package失败，切换 管理员身份运行cmd</h3><ul><li><a href="https://www.cnblogs.com/ClassNotFoundException/p/6737164.html">https://www.cnblogs.com/ClassNotFoundException/p/6737164.html</a></li></ul><h1 id="2-工具使用"><a href="#2-工具使用" class="headerlink" title="2 工具使用"></a>2 工具使用</h1><h2 id="2-1-使用WebStorm"><a href="#2-1-使用WebStorm" class="headerlink" title="2.1 使用WebStorm"></a>2.1 使用WebStorm</h2><h3 id="2-1-1-配置WebStorm辅助编程"><a href="#2-1-1-配置WebStorm辅助编程" class="headerlink" title="2.1.1 配置WebStorm辅助编程"></a>2.1.1 配置WebStorm辅助编程</h3><ul><li><a href="https://www.jianshu.com/p/85d8e5e1c22d">https://www.jianshu.com/p/85d8e5e1c22d</a></li></ul><h3 id="2-1-2-使用代码模板"><a href="#2-1-2-使用代码模板" class="headerlink" title="2.1.2 使用代码模板"></a>2.1.2 使用代码模板</h3><ul><li><a href="https://blog.csdn.net/weixin_38080573/article/details/88315159">https://blog.csdn.net/weixin_38080573/article/details/88315159</a></li></ul><h3 id="2-1-3-代码补全"><a href="#2-1-3-代码补全" class="headerlink" title="2.1.3 代码补全"></a>2.1.3 代码补全</h3><ul><li><a href="https://blog.csdn.net/aa330233789/article/details/103134580">https://blog.csdn.net/aa330233789/article/details/103134580</a></li></ul><h3 id="2-1-4-格式化代码快捷键"><a href="#2-1-4-格式化代码快捷键" class="headerlink" title="2.1.4 格式化代码快捷键"></a>2.1.4 格式化代码快捷键</h3><ul><li>CTRL+ALT+&#x2F;</li></ul><h3 id="2-1-5-取消ESLint"><a href="#2-1-5-取消ESLint" class="headerlink" title="2.1.5 取消ESLint"></a>2.1.5 取消ESLint</h3><ul><li><a href="https://blog.csdn.net/fuck487/article/details/84147778">https://blog.csdn.net/fuck487/article/details/84147778</a></li></ul><h3 id="2-1-6-Debugger"><a href="#2-1-6-Debugger" class="headerlink" title="2.1.6 Debugger"></a>2.1.6 Debugger</h3><ul><li>react-native-debugger – <a href="https://github.com/jhen0409/react-native-debugger/releases/tag/v0.11.7">https://github.com/jhen0409/react-native-debugger/releases/tag/v0.11.7</a></li></ul><h2 id="2-2-Mobx"><a href="#2-2-Mobx" class="headerlink" title="2.2 Mobx"></a>2.2 Mobx</h2><h3 id="2-2-1-配置mobx"><a href="#2-2-1-配置mobx" class="headerlink" title="2.2.1 配置mobx"></a>2.2.1 配置mobx</h3><ul><li><a href="https://www.jianshu.com/p/b4856b84b64e">https://www.jianshu.com/p/b4856b84b64e</a></li></ul><p><img src="http://img.fdchen.host//Text.png" alt="image-20210305193041326"></p><h1 id="3-常见用法"><a href="#3-常见用法" class="headerlink" title="3 常见用法"></a>3 常见用法</h1><h2 id="3-1-map和reduce"><a href="#3-1-map和reduce" class="headerlink" title="3.1 map和reduce"></a>3.1 map和reduce</h2><ul><li>map：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> filteredNumbers <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> num<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//index goes from 0,so the filterNumbers are 1,2,3 and undefined.</span><span class="token comment">// filteredNumbers is [1, 2, 3, undefined]</span><span class="token comment">// numbers is still [1, 2, 3, 4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>reduce：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">accumulator<span class="token punctuation">,</span> currentValue<span class="token punctuation">,</span> currentIndex<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> accumulator <span class="token operator">+</span> currentValue<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 10 为 initialValue，相当于给accumulator赋初值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left"><code>callback</code></th><th align="left"><code>accumulator</code></th><th align="left"><code>currentValue</code></th><th align="left"><code>currentIndex</code></th><th align="left"><code>array</code></th><th align="left">return value</th></tr></thead><tbody><tr><td align="left">first call</td><td align="left"><code>10</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>10</code></td></tr><tr><td align="left">second call</td><td align="left"><code>10</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>11</code></td></tr><tr><td align="left">third call</td><td align="left"><code>11</code></td><td align="left"><code>2</code></td><td align="left"><code>2</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>13</code></td></tr><tr><td align="left">fourth call</td><td align="left"><code>13</code></td><td align="left"><code>3</code></td><td align="left"><code>3</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>16</code></td></tr><tr><td align="left">fifth call</td><td align="left"><code>16</code></td><td align="left"><code>4</code></td><td align="left"><code>4</code></td><td align="left"><code>[0, 1, 2, 3, 4]</code></td><td align="left"><code>20</code></td></tr></tbody></table><h2 id="3-2-获取当前时间"><a href="#3-2-获取当前时间" class="headerlink" title="3.2 获取当前时间"></a>3.2 获取当前时间</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> myDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myDate<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取当前年份(2位)</span>myDate<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取完整的年份(4位,1970-????)</span>myDate<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//获取当前月份(0-11,0代表1月)</span>myDate<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取当前日(1-31)</span>myDate<span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//获取当前星期X(0-6,0代表星期天)</span>myDate<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取当前时间(从1970.1.1开始的毫秒数)</span>myDate<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//获取当前小时数(0-23)</span>myDate<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//获取当前分钟数(0-59)</span>myDate<span class="token punctuation">.</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//获取当前秒数(0-59)</span>myDate<span class="token punctuation">.</span><span class="token function">getMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取当前毫秒数(0-999)</span>myDate<span class="token punctuation">.</span><span class="token function">toLocaleDateString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//获取当前日期</span><span class="token keyword">var</span> mytime<span class="token operator">=</span>myDate<span class="token punctuation">.</span><span class="token function">toLocaleTimeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//获取当前时间</span>myDate<span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取日期与时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>获取当前时间：<a href="https://momentjs.com/">https://momentjs.com/</a></li></ul><h2 id="3-3-在Form中使用DatePicker"><a href="#3-3-在Form中使用DatePicker" class="headerlink" title="3.3 在Form中使用DatePicker"></a>3.3 在Form中使用DatePicker</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>Item label<span class="token operator">=</span><span class="token string">"走失时间"</span><span class="token operator">></span>                          <span class="token punctuation">&#123;</span>                              <span class="token function">getFieldDecorator</span><span class="token punctuation">(</span><span class="token string">'lostTime'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>                                  <span class="token comment">// 在DatePicker中使用getFieldDecorator需要设置initialValue，而不能用defaulValue</span>                                  <span class="token literal-property property">initialValue</span><span class="token operator">:</span> <span class="token function">moment</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>incident<span class="token punctuation">.</span>lostTime<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">,</span>                                  <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>                                      <span class="token punctuation">&#123;</span><span class="token literal-property property">required</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'必须输入走失时间'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                                  <span class="token punctuation">]</span>                              <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>DatePicker                                  locale<span class="token operator">=</span><span class="token punctuation">&#123;</span>Locale<span class="token punctuation">&#125;</span>                                  placeholder<span class="token operator">=</span><span class="token string">"请输入走失时间"</span>                                  format<span class="token operator">=</span><span class="token punctuation">&#123;</span>format<span class="token punctuation">&#125;</span>                                  showTime<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token literal-property property">format</span><span class="token operator">:</span> formatTime<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>                              <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span>                          <span class="token punctuation">&#125;</span>                      <span class="token operator">&lt;</span><span class="token operator">/</span>Item<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-DatePicker设置成中文"><a href="#3-4-DatePicker设置成中文" class="headerlink" title="3.4 DatePicker设置成中文"></a>3.4 DatePicker设置成中文</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 注意导入正确包名才能生效import locale from &#39;antd&#x2F;es&#x2F;date-picker&#x2F;locale&#x2F;zh_CN&#39;;&lt;DatePicker locale&#x3D;&#123;locale&#125; &#x2F;&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-按pageNum获取数据"><a href="#3-5-按pageNum获取数据" class="headerlink" title="3.5 按pageNum获取数据"></a>3.5 按pageNum获取数据</h2><ul><li>设置了onChange就不要设置current，否则会导致跳转失灵。</li></ul><h3 id="6-快速生成数组"><a href="#6-快速生成数组" class="headerlink" title="6. 快速生成数组"></a>6. 快速生成数组</h3><ul><li>详见博客：<a href="https://www.cnblogs.com/fuzitu/p/10723869.html">https://www.cnblogs.com/fuzitu/p/10723869.html</a></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> timeSpan<span class="token operator">=</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">length</span><span class="token operator">:</span><span class="token constant">N</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span><span class="token operator">=></span>index<span class="token operator">+</span>start <span class="token operator">+</span> <span class="token string">'月'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-在字符串中使用占位符"><a href="#7-在字符串中使用占位符" class="headerlink" title="7. 在字符串中使用占位符"></a>7. 在字符串中使用占位符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">近</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">N</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">个月任务完成情况统计</span><span class="token template-punctuation string">`</span></span> <span class="token comment">// 反引号`+$</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-报错Import-in-body-of-module-reorder-to-top"><a href="#8-报错Import-in-body-of-module-reorder-to-top" class="headerlink" title="8. 报错Import in body of module; reorder to top"></a>8. 报错Import in body of module; reorder to top</h3><ul><li>如果您在两次<code>variable</code>导入之间声明了in，则会收到此错误，</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">URL</span> <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">REACT_APP_API_BASE</span><span class="token punctuation">;</span><span class="token keyword">import</span> demoXLXSFile <span class="token keyword">from</span> <span class="token string">'../../assets/others/Demo.xlsx'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'./student.list.styles.scss'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>variables</code>导入所有内容后进行声明，</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span><span class="token keyword">import</span> demoXLXSFile <span class="token keyword">from</span> <span class="token string">'../../assets/others/Demo.xlsx'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'./student.list.styles.scss'</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">URL</span> <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">REACT_APP_API_BASE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-引入-less文件可以在路由文件中直接映入，对该路由组件中的所有路由页面生效"><a href="#9-引入-less文件可以在路由文件中直接映入，对该路由组件中的所有路由页面生效" class="headerlink" title="9. 引入.less文件可以在路由文件中直接映入，对该路由组件中的所有路由页面生效"></a>9. 引入.less文件可以在路由文件中直接映入，对该路由组件中的所有路由页面生效</h3><h3 id="10-npm和yarn缓存清理"><a href="#10-npm和yarn缓存清理" class="headerlink" title="10. npm和yarn缓存清理"></a>10. npm和yarn缓存清理</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm cache clean --forceyarn cache clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="11-【node-js】项目启动与关闭"><a href="#11-【node-js】项目启动与关闭" class="headerlink" title="11. 【node.js】项目启动与关闭"></a>11. 【node.js】项目启动与关闭</h3><ol><li>查看当前服务器端口占用情况</li></ol><pre class="line-numbers language-none"><code class="language-none">netstat -ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://img.fdchen.host//%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5.png" alt="img"></p><p> 2、关闭被占用端口的服务</p><pre class="line-numbers language-none"><code class="language-none">tskill 5728<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://img.fdchen.host//%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B%E5%8F%B7.png" alt="img"></p><p>3、启动服务</p><pre class="line-numbers language-none"><code class="language-none">node app.js -p 18080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://img.fdchen.host//%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E8%BF%90%E8%A1%8C.png" alt="img"></p><p>4.如果要服务后台运行的话，可以用forever进行管理</p><pre class="line-numbers language-none"><code class="language-none">npm install -g foreverforever start app.js   &#x2F;&#x2F;启动forever stop app.js   &#x2F;&#x2F;关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.用自带的服务nohub</p><pre class="line-numbers language-none"><code class="language-none">nohup node index.js &gt; myLog.log 2&gt;&amp;1 &amp;      &#x2F;&#x2F;启动pkill node   &#x2F;&#x2F;关闭 node 服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="12-antd-Cascader省市级联"><a href="#12-antd-Cascader省市级联" class="headerlink" title="12. antd-Cascader省市级联"></a>12. antd-Cascader省市级联</h3><ul><li>详见博客：<a href="https://www.jianshu.com/p/0278aade294d">https://www.jianshu.com/p/0278aade294d</a></li></ul><h3 id="13-报错’React’-must-be-in-scope-when-using-JSX-react-x2F-react-in-jsx-scope"><a href="#13-报错’React’-must-be-in-scope-when-using-JSX-react-x2F-react-in-jsx-scope" class="headerlink" title="13. 报错’React’ must be in scope when using JSX  react&#x2F;react-in-jsx-scope"></a>13. 报错’React’ must be in scope when using JSX  react&#x2F;react-in-jsx-scope</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> react<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>Component<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>react 应该大写，这里小写导致错误；</li></ul><h3 id="14-导入一个组件目录下的所有-js文件"><a href="#14-导入一个组件目录下的所有-js文件" class="headerlink" title="14. 导入一个组件目录下的所有.js文件"></a>14. 导入一个组件目录下的所有.js文件</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> moduleFiles <span class="token operator">=</span> require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token string">'./module'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="15-数组倒序排序"><a href="#15-数组倒序排序" class="headerlink" title="15. 数组倒序排序"></a>15. 数组倒序排序</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 正序</span>array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span> <span class="token number">230</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">218</span><span class="token punctuation">,</span> <span class="token number">135</span><span class="token punctuation">,</span> <span class="token number">147</span><span class="token punctuation">,</span> <span class="token number">260</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 倒序</span>array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span> <span class="token number">230</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">218</span><span class="token punctuation">,</span> <span class="token number">135</span><span class="token punctuation">,</span> <span class="token number">147</span><span class="token punctuation">,</span> <span class="token number">260</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="16-日期区间选择"><a href="#16-日期区间选择" class="headerlink" title="16. 日期区间选择"></a>16. 日期区间选择</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span><span class="token class-name">DatePicker</span><span class="token punctuation">&#125;</span> from <span class="token string">"antd"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">moment</span> from <span class="token string">"moment"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>formatDate<span class="token punctuation">&#125;</span> from <span class="token string">"../../../utils/dateUtils"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token class-name">Locale</span> from 'antd<span class="token operator">/</span>es<span class="token operator">/</span>date<span class="token operator">-</span>picker<span class="token operator">/</span>locale<span class="token operator">/</span>zh_CN'<span class="token punctuation">;</span><span class="token keyword">import</span> 'moment<span class="token operator">/</span>locale<span class="token operator">/</span>zh<span class="token operator">-</span>cn'<span class="token punctuation">;</span>moment<span class="token punctuation">.</span><span class="token function">locale</span><span class="token punctuation">(</span><span class="token char">'zh-cn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token class-name">RangePicker</span> <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token class-name">DatePicker</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="17-发布及部署React项目"><a href="#17-发布及部署React项目" class="headerlink" title="17. 发布及部署React项目"></a>17. 发布及部署React项目</h3><ul><li>详见博客：<a href="https://m.html.cn/qa/react/14488.html">https://m.html.cn/qa/react/14488.html</a></li></ul><h3 id="18-表格column属性的dataIndex支持嵌套写法"><a href="#18-表格column属性的dataIndex支持嵌套写法" class="headerlink" title="18. 表格column属性的dataIndex支持嵌套写法"></a>18. 表格column属性的dataIndex支持嵌套写法</h3><ul><li>支持a.b.c 和 a[0],b[0]写法</li></ul><h1 id="2-数据可视化"><a href="#2-数据可视化" class="headerlink" title="2 数据可视化"></a>2 数据可视化</h1><h3 id="1-echarts饼图自动显示数据"><a href="#1-echarts饼图自动显示数据" class="headerlink" title="1. echarts饼图自动显示数据"></a>1. echarts饼图自动显示数据</h3><ul><li>详见博客：<a href="https://blog.csdn.net/kai_wei/article/details/51788355">https://blog.csdn.net/kai_wei/article/details/51788355</a></li></ul><h3 id="2-设置柱状颜色"><a href="#2-设置柱状颜色" class="headerlink" title="2. 设置柱状颜色"></a>2. 设置柱状颜色</h3><ul><li>详见博客：<a href="https://blog.csdn.net/t876587201/article/details/70159076">https://blog.csdn.net/t876587201/article/details/70159076</a></li></ul><h3 id="3-设置两张图并列"><a href="#3-设置两张图并列" class="headerlink" title="3. 设置两张图并列"></a>3. 设置两张图并列</h3><pre class="line-numbers language-less" data-language="less"><code class="language-less"><span class="token selector">.chart-left</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 40%<span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">padding-left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.chart-right</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>  <span class="token property">padding-right</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如下是react代码</span>&lt;span className=<span class="token string">'chart-left'</span>>&lt;LostDay<span class="token operator">/</span>>&lt;<span class="token operator">/</span>span>&lt;span className=<span class="token string">'chart-right'</span>>&lt;LostTime<span class="token operator">/</span>>&lt;<span class="token operator">/</span>span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-导入城市区县图"><a href="#4-导入城市区县图" class="headerlink" title="4. 导入城市区县图"></a>4. 导入城市区县图</h3><ul><li>github项目：<a href="https://github.com/echarts-maps/echarts-china-cities-js">https://github.com/echarts-maps/echarts-china-cities-js</a></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token string">'echarts/map/js/province/chongqing'</span><span class="token keyword">import</span> <span class="token string">"echarts/map/js/province/xianggang"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-导入全国地图或者省市图"><a href="#5-导入全国地图或者省市图" class="headerlink" title="5. 导入全国地图或者省市图"></a>5. 导入全国地图或者省市图</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token string">'echarts/map/js/province/chongqing'</span><span class="token keyword">import</span> <span class="token string">"echarts/map/js/province/xianggang"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-生成地图热力图"><a href="#6-生成地图热力图" class="headerlink" title="6. 生成地图热力图"></a>6. 生成地图热力图</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> option <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'香港18区人口密度 （2011）'</span><span class="token punctuation">,</span>        <span class="token literal-property property">subtext</span><span class="token operator">:</span> <span class="token string">'人口密度数据来自Wikipedia'</span><span class="token punctuation">,</span>        <span class="token literal-property property">sublink</span><span class="token operator">:</span> <span class="token string">'http://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF%E8%A1%8C%E6%94%BF%E5%8D%80%E5%8A%83#cite_note-12'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">tooltip</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">trigger</span><span class="token operator">:</span> <span class="token string">'item'</span><span class="token punctuation">,</span>        <span class="token literal-property property">formatter</span><span class="token operator">:</span> <span class="token string">'&#123;b&#125;&lt;br/>&#123;c&#125; (p / km2)'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">toolbox</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token literal-property property">orient</span><span class="token operator">:</span> <span class="token string">'vertical'</span><span class="token punctuation">,</span>        <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token string">'right'</span><span class="token punctuation">,</span>        <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>        <span class="token literal-property property">feature</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">dataView</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">readOnly</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token literal-property property">restore</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token literal-property property">saveAsImage</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">visualMap</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">min</span><span class="token operator">:</span> <span class="token number">800</span><span class="token punctuation">,</span>        <span class="token literal-property property">max</span><span class="token operator">:</span> <span class="token number">50000</span><span class="token punctuation">,</span>        <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'High'</span><span class="token punctuation">,</span> <span class="token string">'Low'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token literal-property property">realtime</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token literal-property property">calculable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token literal-property property">inRange</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'lightskyblue'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token string">'orangered'</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">series</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'香港18区人口密度'</span><span class="token punctuation">,</span>            <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'map'</span><span class="token punctuation">,</span>            <span class="token literal-property property">mapType</span><span class="token operator">:</span> <span class="token string">'重庆'</span><span class="token punctuation">,</span> <span class="token comment">// 自定义扩展图表类型，注意城镇要用中文</span>            <span class="token literal-property property">label</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'中西区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">20057.34</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'湾仔区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">15477.48</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'东区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">31686.1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'南区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">6992.6</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'油尖旺'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">44045.49</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'深水埗'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">40689.64</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'九龙城'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">37659.78</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'黄大仙'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">45180.97</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'观塘区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">55204.26</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'葵青区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">21900.9</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'荃湾区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">4918.26</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'屯门区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">5881.84</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'元朗区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">4178.01</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'北区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">2227.92</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'大埔区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">2180.98</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'沙田区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">9172.94</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'西贡区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">3368</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token punctuation">&#123;</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'离岛区'</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">806.98</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token comment">// 自定义名称映射</span>            <span class="token literal-property property">nameMap</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token string-property property">'Central and Western'</span><span class="token operator">:</span> <span class="token string">'中西区'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Eastern'</span><span class="token operator">:</span> <span class="token string">'东区'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Islands'</span><span class="token operator">:</span> <span class="token string">'离岛'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Kowloon City'</span><span class="token operator">:</span> <span class="token string">'九龙城'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Kwai Tsing'</span><span class="token operator">:</span> <span class="token string">'葵青'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Kwun Tong'</span><span class="token operator">:</span> <span class="token string">'观塘'</span><span class="token punctuation">,</span>                <span class="token string-property property">'North'</span><span class="token operator">:</span> <span class="token string">'北区'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Sai Kung'</span><span class="token operator">:</span> <span class="token string">'西贡'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Sha Tin'</span><span class="token operator">:</span> <span class="token string">'沙田'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Sham Shui Po'</span><span class="token operator">:</span> <span class="token string">'深水埗'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Southern'</span><span class="token operator">:</span> <span class="token string">'南区'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Tai Po'</span><span class="token operator">:</span> <span class="token string">'大埔'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Tsuen Wan'</span><span class="token operator">:</span> <span class="token string">'荃湾'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Tuen Mun'</span><span class="token operator">:</span> <span class="token string">'屯门'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Wan Chai'</span><span class="token operator">:</span> <span class="token string">'湾仔'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Wong Tai Sin'</span><span class="token operator">:</span> <span class="token string">'黄大仙'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Yau Tsim Mong'</span><span class="token operator">:</span> <span class="token string">'油尖旺'</span><span class="token punctuation">,</span>                <span class="token string-property property">'Yuen Long'</span><span class="token operator">:</span> <span class="token string">'元朗'</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-React生成词云"><a href="#7-React生成词云" class="headerlink" title="7. React生成词云"></a>7. React生成词云</h3><p>1.安装</p><blockquote><p>yarn add react-wordcloud</p><p>npm install  react-wordcloud –save</p></blockquote><p>2.使用</p><blockquote><p>import * as React from “react”;</p><p>import ReactWordcloud from “react-wordcloud”;</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> Component <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactWordcloud <span class="token keyword">from</span> <span class="token string">"react-wordcloud"</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CiYun</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>       <span class="token punctuation">&#125;</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> wordsJsonList <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">12.5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">"github"</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token operator">&lt;</span>ReactWordcloud words<span class="token operator">=</span><span class="token punctuation">&#123;</span>wordsJsonList<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> CiYun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-调整legend位置"><a href="#8-调整legend位置" class="headerlink" title="8. 调整legend位置"></a>8. 调整legend位置</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">legend</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'进行中'</span><span class="token punctuation">,</span> <span class="token string">'暂缓'</span><span class="token punctuation">,</span> <span class="token string">'已完成'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token literal-property property">top</span><span class="token operator">:</span><span class="token number">30</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛总结</title>
      <link href="/2021/sui-bi-mei-sai-zong-jie/"/>
      <url>/2021/sui-bi-mei-sai-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>纪念人生中唯一一次美赛</p><p>2021年D题——S奖</p></blockquote><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>当时参加美赛可以说是临时起意，先是朋友问我有没有兴趣打数模，但是我考虑到自己更喜欢本专业（软件）竞赛，就没有答应。但是，在从学校回家的路上，想了很多——每每坐在车上，看着窗外的风景，人就喜欢胡思乱想，自己虽然可以保研，但是好像竞赛的经历还是少了一点，万一老师问为什么没有打过数模，岂不是没话可说。然后凑巧的是，刚好在表白墙上看到了美赛招募队友（也可能是天意？那为什么不让我获奖，问号脸）虽然，看看最后的成绩，照样没什么好说的，但是这毕竟是第一次，也可能是最后一次，还是写点东西纪念一下。</p><p>PS：这种方式挺好的，属于自己一方小天地，写下自己的一点小感悟，以后应该也会写一些东西纪念一下。希望以后多看看书，提升一下文化素养。</p><span id="more"></span><h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><h2 id="1-1-更早"><a href="#1-1-更早" class="headerlink" title="1.1 更早"></a>1.1 更早</h2><h3 id="1-1-1-问题"><a href="#1-1-1-问题" class="headerlink" title="1.1.1 问题"></a>1.1.1 问题</h3><ol><li>没有学习并掌握相关模型，不能灵活运用</li><li>没有掌握基础技能，常用操作不能记住，编程时总是要百度效率低下</li></ol><h3 id="1-1-2-解决方案"><a href="#1-1-2-解决方案" class="headerlink" title="1.1.2 解决方案"></a>1.1.2 解决方案</h3><ol><li>数学模型是长时间累计，如果专注于数模竞赛，就需要平时多多了解。</li><li>每一次用到常用的语法或技巧，都亲自写一遍，记录下来，以加强记忆。</li></ol><h2 id="1-2-前几天"><a href="#1-2-前几天" class="headerlink" title="1.2 前几天"></a>1.2 前几天</h2><p>看优秀论文，学习文笔、思路、图表表示，比如每一题大概做成什么样子之类。</p><h1 id="2-选题"><a href="#2-选题" class="headerlink" title="2. 选题"></a>2. 选题</h1><p>选题可以说是非常重要了，这次我们的选题不太好说，不好也不坏把，题目不太常规，但是大部分方向对了，所以也不好怎么发表意见。不过始终建议好好讨论一下，而且是需要在充分了解每题内容的前提下。</p><h1 id="3-解决问题"><a href="#3-解决问题" class="headerlink" title="3. 解决问题"></a>3. 解决问题</h1><h2 id="3-1-问题"><a href="#3-1-问题" class="headerlink" title="3.1 问题"></a>3.1 问题</h2><ol><li>我们小组的解决方案在讨论方面有很大问题，基本上由我主导，但是这种方式很容易造成先入为主的情况，容易让队友跑偏，导致思维不能充分发散。</li><li>讨论太少，团队交流太少，一方面后面基本只靠两个人讨论确定，另一方面，线上讨论终归是限制了一点，不能随心所欲。</li><li>对题目研读不够，查找资料没有效率。</li></ol><h2 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h2><ol><li>不能过于强调自己的观点，不要一次性输出，很容易出问题。因为一个方案如果全盘托出，大家比较难找方案的漏洞，然后就造成大家觉得这个方案目前听上去可行，那就这么做。但是事实上可能存在很多漏洞。因此，如果一步一步提出来，先说想法，然后让大家针对想法提问，自己回答，大家针对回答再提问，一步一步这么往下走，每一步都会受到批判，这样的话，方案才会打磨得比较好。</li><li>线下讨论比线上讨论要方便很多，尽量线下一起做，效率更高，沟通成本更少，也能相互鼓励支持。</li><li>查找资料之前应该讨论一下基本的解题思路，确定一个大概的成员都认可的思路，避免做无用功。</li><li>查找的文献应该按信息进行记录，方便反复查看。</li></ol><h1 id="4-实施"><a href="#4-实施" class="headerlink" title="4. 实施"></a>4. 实施</h1><ol><li><p>实施过程中的问题主要是前期准备工作的问题，模型知识与相关编码知识的缺乏，导致效率低下，方法也比较贫瘠。</p></li><li><p>但是还有一个问题，那就是不够专注，容易分神，虽然看上去很多时间都在忙，但是不一会就分神了，好不容易进入状态，然后又要重新进入，没有真正的沉浸其中，难以高效，也难以有更好的灵感。</p></li><li><p>确定大概框架时应该也确定模型的实现过程，避免无法实现模型而浪费时间。</p></li></ol><h1 id="5-写论文"><a href="#5-写论文" class="headerlink" title="5. 写论文"></a>5. 写论文</h1><p>这一部分主要问题是对图表的了解不够，不能灵活运用图表表示信息，很明显的一点就是明明用图很清晰，但是用了表格表示很多的数据，效果很差。</p><p><img src="http://img.fdchen.host//%E7%BE%8E%E8%B5%9B%E6%95%B0%E6%A8%A1%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC.png" alt="数据表示例"></p><p><img src="http://img.fdchen.host//%E7%BE%8E%E8%B5%9B%E6%95%B0%E6%8D%AE%E5%9B%BE.png" alt="数据图示例"></p><h1 id="6-整体而言"><a href="#6-整体而言" class="headerlink" title="6. 整体而言"></a>6. 整体而言</h1><p>整个过程最大的问题应该是队员的不和睦与沟通不够，中间只能依靠队长连接，线上讨论本就不太方便，如此一来，沟通成本更高。大家的想法也不能很好交流，很大程度上影响解决方案的产出。</p><h1 id="7-题解（to-do）"><a href="#7-题解（to-do）" class="headerlink" title="7. 题解（to do）"></a>7. 题解（to do）</h1><blockquote><p>大概就这些了，虽然可能还有一些问题没有说明，但是时间过去两个月了，大抵不太记得清了，能记住，应该都是重点！而且，至少写出来的都应该会记在心里。</p></blockquote><h1 id="8-备战资料"><a href="#8-备战资料" class="headerlink" title="8 备战资料"></a>8 备战资料</h1><h2 id="8-1-学习资料"><a href="#8-1-学习资料" class="headerlink" title="8.1 学习资料"></a>8.1 学习资料</h2><p>链接：<a href="https://pan.baidu.com/s/1MiOAudqxvF5nCpAryn0O-w">https://pan.baidu.com/s/1MiOAudqxvF5nCpAryn0O-w</a><br>提取码：w916 </p><h2 id="8-2-数据网站"><a href="#8-2-数据网站" class="headerlink" title="8.2 数据网站"></a>8.2 数据网站</h2><ul><li><p>美国交通部数据：<a href="https://www.bts.gov/">https://www.bts.gov/</a></p></li><li><p>美国政府官网：<a href="https://www.state.gov/">https://www.state.gov/</a></p></li><li><p>美国管家环境信息中心：<a href="https://www.ncei.noaa.gov/">https://www.ncei.noaa.gov/</a></p></li><li><p>中国气象科学数据中心：<a href="http://data.cma.cn/site/index.html">http://data.cma.cn/site/index.html</a></p></li><li><p>世界数据银行：<a href="https://databank.worldbank.org/reports.aspx?source=world-development-indicators&amp;Type=TABLE&amp;preview=on">https://databank.worldbank.org/reports.aspx?source=world-development-indicators&amp;Type=TABLE&amp;preview=on</a></p></li><li><p>欧洲环境机构：<a href="https://www.eea.europa.eu/">https://www.eea.europa.eu/</a></p></li><li><p><a href="https://blog.csdn.net/Garyboyboy/article/details/113398455?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase">美赛常用数据库网站大全</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美赛 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>答辩经验</title>
      <link href="/2021/sui-bi-da-bian-jing-yan/"/>
      <url>/2021/sui-bi-da-bian-jing-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="1-PPT制作"><a href="#1-PPT制作" class="headerlink" title="1 PPT制作"></a>1 PPT制作</h1><h2 id="1-1-一般规范"><a href="#1-1-一般规范" class="headerlink" title="1.1 一般规范"></a>1.1 一般规范</h2><ol><li>图片大小要合适，要让大家看得清</li><li>每一个符号或表示都应该是有解释的</li><li>表格需要统一格式：都三线表或都格子表</li><li>当遇到一张PPT下多图时，图片叠加+动画依次展示</li><li>行间距1.3-1.5</li><li>PPT尽可能少用动画，一定不要用切换动画</li><li>一般PPT 15-18页为宜</li><li>最后一页可以不用谢谢观看，并无实质作用</li><li>字体一般21号以上</li><li>整体配色同样需要考虑</li><li>多用数据和图表，数据醒目，图表清晰</li></ol><span id="more"></span><h2 id="1-2-制作技巧"><a href="#1-2-制作技巧" class="headerlink" title="1.2 制作技巧"></a>1.2 制作技巧</h2><h3 id="1-2-0-Office官方教程"><a href="#1-2-0-Office官方教程" class="headerlink" title="1.2.0 Office官方教程"></a>1.2.0 Office官方教程</h3><ul><li>链接：<a href="https://www.office26.com/powerpoint/">https://www.office26.com/powerpoint/</a></li></ul><h3 id="1-2-1-PPT目录制作技巧"><a href="#1-2-1-PPT目录制作技巧" class="headerlink" title="1.2.1 PPT目录制作技巧"></a>1.2.1 PPT目录制作技巧</h3><ul><li>详见文章：<a href="https://www.office26.com/powerpoint/powerpoint_10843.html">PPT目录设计制作教程</a></li></ul><h1 id="2-答辩"><a href="#2-答辩" class="headerlink" title="2 答辩"></a>2 答辩</h1><p>答辩，只不过是从与一个人交流变成与多个人交流。</p><ol><li>注意跟观众眼神交流</li><li>注意不是每个人都了解你的技术细节，每一个部分起码都要讲一下，不能因为自己觉得简单就不讲</li><li>整体应该有详略，每部分讲多长根据详略判定</li><li>答辩并非演讲，忌讳朗诵，自信讲述即可</li><li>注意使用故事性讲述，比如讲述项目痛点时用故事引入</li><li>可以适当用设问引起注意</li><li>控制语速，不快不慢，吐字清晰</li><li>答辩第一遍讲稿可以是提纲，也可以是讲稿，总之不能直接背记，应该反复模拟答辩，然后逐步修改讲稿</li><li>答辩时站直，注意精气神</li><li>多用数据和图标展示内容</li><li>可以用设问引起听众注意</li><li>团队成员简单介绍即可，可以放在开始部分</li><li>答辩看重个人魅力，一定要自信向上，以及整个团队成员的魅力</li><li>在业务场景里需要介绍业务流程，在产品介绍里明确并强调产品定位，立场也不仅仅在当下，而在未来的发展趋势，总而言之，先说清楚要干啥，再讲清楚怎么干，是否确确实实做得好</li></ol><h1 id="3-提问"><a href="#3-提问" class="headerlink" title="3 提问"></a>3 提问</h1><p>重要的是随机应变+先思考再回答</p><ol><li>不确定该回答什么的问题，一定要阐述自己的理解进行确认，不要担心评委厌烦，答非所问更严重</li><li>每个问题都尽量展示自己的优秀、亮点和努力，比如未完成的工作，但是已经在做了也要说出来，甚至可以说说做到哪一步了，然后再说说后续会继续完成，如果可以提交文档，就说会补充在文档中，又比如说，软件的实现，可以说我们已经在部署服务器，准备发布软件</li><li>提问环节，等待评委说完再回答，可适当停1-3秒</li><li>深入理解自己的创新，哪些地方超越了赛题，在答辩或者回答的过程中，可以不断有意无意地提到</li><li>回答的套路：你好老师，这个问题由我回答，·······(就问题回答的同时适当延展)，感谢评委老师的提问，我的回答不知道是否让您满意。注意每个问题至少20-40秒。</li><li>不要逞强，承认不足，感谢指点，不反问评委老师，可以说后续深入思考</li><li>项目的算法、数据、设计等部分，可以分人准备应答，要相信队友</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 与 GitHub 速成教程</title>
      <link href="/2021/yuan-ji-chu-git-yu-github-su-cheng-jiao-cheng/"/>
      <url>/2021/yuan-ji-chu-git-yu-github-su-cheng-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文字版教程"><a href="#1-文字版教程" class="headerlink" title="1 文字版教程"></a>1 文字版教程</h1><ul><li><p>阿里云教程：<a href="https://edu.aliyun.com/course/489?spm=5176.10731542.0.0.7ed26fd5p4fG9U">版本控制工具Git</a> </p></li><li><p>转载自“夕小瑶的卖萌屋”：<a href="https://mp.weixin.qq.com/s/z_zFveiiLu9vLvWuBcsaIg">Git从入门到进阶，你想要的全在这里</a></p></li></ul><h1 id="2-视频教程"><a href="#2-视频教程" class="headerlink" title="2 视频教程"></a>2 视频教程</h1><p>转载：<a href="https://www.bilibili.com/video/av10475153/?p=1">《【教程】学会Git玩转Github【全】》</a></p><span id="more"></span><h1 id="3-常用Git命令"><a href="#3-常用Git命令" class="headerlink" title="3 常用Git命令"></a>3 常用Git命令</h1><p><img src="https://img-blog.csdnimg.cn/20200309104945998.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="4-常见用法"><a href="#4-常见用法" class="headerlink" title="4 常见用法"></a>4 常见用法</h1><h2 id="4-1-建立SSH连接后，利用Git-提交文件至远程仓库"><a href="#4-1-建立SSH连接后，利用Git-提交文件至远程仓库" class="headerlink" title="4.1 建立SSH连接后，利用Git 提交文件至远程仓库"></a>4.1 建立SSH连接后，利用Git 提交文件至远程仓库</h2><p><font color="green">&#x2F;&#x2F; 删除文件需要单独使用 git rm xxx(文件名)，一一删除</font></p><ul><li>**git config –global user.name “username” **  &#x2F;&#x2F;配置用户名 </li><li>**git config –global user.email “<a href="mailto:&#x78;&#120;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#120;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a>“ ** &#x2F;&#x2F;配置邮箱</li><li><strong>git init</strong>  &#x2F;&#x2F;初始化生成一个本地仓库</li><li>**git add . ** &#x2F;&#x2F;添加到暂存区</li><li><strong>git commit –m “message”</strong>  &#x2F;&#x2F;提交到本地仓库 </li><li><strong>git remote add origin url</strong> &#x2F;&#x2F;关联到远程仓库 </li><li><strong>git push origin master</strong> &#x2F;&#x2F;推送本地 master 分支到远程 master 分支 </li><li><strong>git checkout -b dev</strong> &#x2F;&#x2F;创建一个开发分支并切换到新分支</li><li><strong>git push ogigin dev</strong> &#x2F;&#x2F;推送本地 dev 分支到远程 dev 分支 </li><li><strong>git pull origin dev</strong> &#x2F;&#x2F;从远程 dev 分支拉取到本地 dev 分支 </li><li><strong>git clone url</strong> &#x2F;&#x2F;将远程仓库克隆下载到本地</li><li><strong>git log</strong>  &#x2F;&#x2F; 查看历史版本</li><li><strong>git reset –hard commit_id</strong>  &#x2F;&#x2F; 将本地仓库回退到某个版本</li></ul><h2 id="4-2-未建立SSH连接，利用Git提交代码"><a href="#4-2-未建立SSH连接，利用Git提交代码" class="headerlink" title="4.2 未建立SSH连接，利用Git提交代码"></a>4.2 未建立SSH连接，利用Git提交代码</h2><ol><li><strong>登录</strong></li></ol><p><strong>git config –global user.name “你的GitHub登陆名”</strong></p><p><strong>git config –global user.email “你的GitHub注册邮箱”</strong> </p><ol start="2"><li><strong>连接本地仓库与远程仓库</strong></li></ol><p><strong>git remote add origin <a href="https://github.com/userName/yourProject.git">https://github.com/userName/yourProject.git</a></strong></p><ol start="3"><li>之后与 <a href="#4.1">4.1</a> 内容一致</li></ol><h2 id="4-3-git-clone中https与ssh区别"><a href="#4-3-git-clone中https与ssh区别" class="headerlink" title="4.3 git clone中https与ssh区别"></a>4.3 git clone中https与ssh区别</h2><ul><li><strong>相同点</strong></li></ul><p>https与ssh下的git都可以直接进行git clone 操作</p><ul><li><strong>不同点</strong></li></ul><ol><li>https 是git clone 到本地，进行了一些文件的修改，当再次提交到github远程服务器的时候，都会进行账号与密码的输入</li><li>ssh git到本地之后，首次需要进行账号密码的设置，当再次push 到远程github上面的时候就不需要进行账号密码的输入了</li></ol><p>原文链接：<a href="https://blog.csdn.net/xudailong_blog/article/details/78697628">https://blog.csdn.net/xudailong_blog/article/details/78697628</a></p><h2 id="4-4-初始化本地仓库，git-init"><a href="#4-4-初始化本地仓库，git-init" class="headerlink" title="4.4 初始化本地仓库，git init"></a>4.4 初始化本地仓库，git init</h2><ul><li>git init会清除本地仓库的信息，慎用</li></ul><h2 id="4-5-撤回上一次commit，git-reset-HEAD"><a href="#4-5-撤回上一次commit，git-reset-HEAD" class="headerlink" title="4.5 撤回上一次commit，git reset HEAD^"></a>4.5 撤回上一次commit，git reset HEAD^</h2><pre class="line-numbers language-none"><code class="language-none">git reset HEAD^            # 回退所有内容到上一个版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-6-合并分支代码，git-merge-sub-branch"><a href="#4-6-合并分支代码，git-merge-sub-branch" class="headerlink" title="4.6 合并分支代码，git merge sub_branch"></a>4.6 合并分支代码，git merge sub_branch</h2><p>切换到主分支后即可执行该代码以合并分支代码</p><h1 id="5-Debug"><a href="#5-Debug" class="headerlink" title="5 Debug"></a>5 Debug</h1><h2 id="5-1-fatal-Not-a-valid-object-name-‘master’"><a href="#5-1-fatal-Not-a-valid-object-name-‘master’" class="headerlink" title="5.1 fatal: Not a valid object name: ‘master’"></a>5.1 fatal: Not a valid object name: ‘master’</h2><ul><li>要先commit一次才会真正建立master分支，此时就可以新建立分支了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 猿基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 常见用法 </tag>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试</title>
      <link href="/2021/cqu-ruan-jian-ce-shi/"/>
      <url>/2021/cqu-ruan-jian-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-测试概述"><a href="#1-测试概述" class="headerlink" title="1 测试概述"></a>1 测试概述</h1><h2 id="1-1-PIE模型"><a href="#1-1-PIE模型" class="headerlink" title="1.1 PIE模型"></a>1.1 PIE模型</h2><h3 id="1-1-1-缺陷，错误，失败-fault-error-failure"><a href="#1-1-1-缺陷，错误，失败-fault-error-failure" class="headerlink" title="1.1.1 缺陷，错误，失败(fault, error,failure)"></a>1.1.1 缺陷，错误，失败(fault, error,failure)</h3><ul><li>软件缺陷：软件中的静态故障（一般指错误代码）</li><li>软件错误：错误的内部状态（中间状态），是某些缺陷的表现（比如<strong>中间变量</strong>显示与预期不同的值）</li><li>软件失败：与需求或预期结果的不同的外部的、不正确的结果</li></ul><h3 id="1-1-2-PIE模型"><a href="#1-1-2-PIE模型" class="headerlink" title="1.1.2 PIE模型"></a>1.1.2 PIE模型</h3><p>概念：使用户或测试人员观测到failure的过程。</p><p>三个必要条件：</p><ul><li>执行&#x2F;可达Execution&#x2F;Reachability：必须到达程序中包含缺陷的一个或多个位置（必须执行到fault位置）</li><li>感染Infection：程序的状态必须不正确（必须出现error）</li><li>传播Propagation：感染状态必须传播，以导致程序的某些输出不正确（必须出现failure）</li></ul><h3 id="1-1-3-讨论"><a href="#1-1-3-讨论" class="headerlink" title="1.1.3 讨论"></a>1.1.3 讨论</h3><p>Q：是否存在没有被任何测试用例发现的缺陷？</p><p>A: 存在。因为可能所有测试用例到无法执行到含缺陷的位置。</p><p>Q：如何判断缺陷？</p><p>A：缺陷的判断具有主观性，某位置修改后可以使测试用例通过的，都可视为缺陷。</p><h2 id="1-2-术语"><a href="#1-2-术语" class="headerlink" title="1.2 术语"></a>1.2 术语</h2><h3 id="1-2-1-测试用例Test-case"><a href="#1-2-1-测试用例Test-case" class="headerlink" title="1.2.1 测试用例Test case"></a>1.2.1 测试用例Test case</h3><p><strong>PS:  测试用例一定包含输出，除非只要求测试输入。</strong></p><ul><li>测试输入Test Input：测试数据</li><li>测试输出Test Oracle：预期输出</li><li>其他：测试环境Environment</li></ul><h3 id="1-2-2-测试夹具Test-fixture"><a href="#1-2-2-测试夹具Test-fixture" class="headerlink" title="1.2.2 测试夹具Test fixture"></a>1.2.2 测试夹具Test fixture</h3><p>测试执行所需要的固定环境。</p><h3 id="1-2-3-测试套件Test-suite"><a href="#1-2-3-测试套件Test-suite" class="headerlink" title="1.2.3 测试套件Test suite"></a>1.2.3 测试套件Test suite</h3><p>测试用例的集合。</p><ul><li>通常这些测试用例共享类似的先决条件和配置</li><li>通常可以按顺序一起运行</li><li>不同的测试套件用于不同的目的：特定的平台，特定的功能，性能…</li></ul><h3 id="1-2-4-测试脚本Test-script"><a href="#1-2-4-测试脚本Test-script" class="headerlink" title="1.2.4 测试脚本Test script"></a>1.2.4 测试脚本Test script</h3><p>自动运行一系列测试用例或测试套件的脚本。</p><h3 id="1-2-5-测试驱动Test-driver"><a href="#1-2-5-测试驱动Test-driver" class="headerlink" title="1.2.5 测试驱动Test driver"></a>1.2.5 测试驱动Test driver</h3><p>可以加载一组测试用例或测试套件的软件框架。</p><ul><li>它还可以处理预期输出和实际输出之间的配置和比较。</li></ul><h3 id="1-2-6-测试充分性Test-adequacy"><a href="#1-2-6-测试充分性Test-adequacy" class="headerlink" title="1.2.6 测试充分性Test adequacy"></a>1.2.6 测试充分性Test adequacy</h3><p>判断测试是否可以停止。</p><ul><li>充分性标准：让我们判断一款软件的一组测试数据是否充分性的规则。</li><li>举例：测试覆盖Test coverage</li></ul><h3 id="1-2-7-测试Testing-与-调试Debugging"><a href="#1-2-7-测试Testing-与-调试Debugging" class="headerlink" title="1.2.7 测试Testing 与 调试Debugging"></a>1.2.7 测试Testing 与 调试Debugging</h3><ul><li>测试发现bug</li><li>调试修改bug</li></ul><h3 id="1-2-8-验证Verification-与-确认validation"><a href="#1-2-8-验证Verification-与-确认validation" class="headerlink" title="1.2.8 验证Verification 与 确认validation"></a>1.2.8 验证Verification 与 确认validation</h3><ul><li>验证：从开发者的角度（内部）来验证产品的需求、架构设计等方面和用户要求的一致。即开发的产品是否正确。</li><li>确认：从用户的角度（外部）来验证产品和自己想要的一致。即是否开发出正确的产品。</li></ul><h3 id="1-2-9-静态测试Static-Testing-与-动态测试Dynamic-Testing"><a href="#1-2-9-静态测试Static-Testing-与-动态测试Dynamic-Testing" class="headerlink" title="1.2.9 静态测试Static Testing 与 动态测试Dynamic Testing"></a>1.2.9 静态测试Static Testing 与 动态测试Dynamic Testing</h3><ul><li>静态测试：不执行程序</li><li>动态测试：执行程序</li></ul><h3 id="1-2-10-黑盒测试Black-box-Testing-与-白盒测试White-box-Testing"><a href="#1-2-10-黑盒测试Black-box-Testing-与-白盒测试White-box-Testing" class="headerlink" title="1.2.10 黑盒测试Black-box Testing 与 白盒测试White-box Testing"></a>1.2.10 黑盒测试Black-box Testing 与 白盒测试White-box Testing</h3><ul><li>黑盒测试：不使用源码</li><li>白盒测试：使用源码</li><li>灰盒测试Gray-box Testing：黑盒测试+白盒测试</li></ul><h3 id="1-2-11-测试级别Testing-level"><a href="#1-2-11-测试级别Testing-level" class="headerlink" title="1.2.11 测试级别Testing level"></a>1.2.11 测试级别Testing level</h3><ul><li>V模型：单元测试、集成测试、子系统测试、系统测试、验收测试</li></ul><p><img src="http://img.fdchen.host//%E6%B5%8B%E8%AF%95V%E6%A8%A1%E5%9E%8B.png" alt="image-20210525141618533"></p><h3 id="1-2-12-测试过程Test-process"><a href="#1-2-12-测试过程Test-process" class="headerlink" title="1.2.12 测试过程Test process"></a>1.2.12 测试过程Test process</h3><p><img src="http://img.fdchen.host//%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B.png" alt="image-20210525142207752"></p><h2 id="1-3-缺陷复查"><a href="#1-3-缺陷复查" class="headerlink" title="1.3 缺陷复查"></a>1.3 缺陷复查</h2><h3 id="1-3-1-Bug"><a href="#1-3-1-Bug" class="headerlink" title="1.3.1 Bug"></a>1.3.1 Bug</h3><p>出现failure代表存在bug。</p><h3 id="1-3-2-缺陷判定"><a href="#1-3-2-缺陷判定" class="headerlink" title="1.3.2 缺陷判定"></a>1.3.2 缺陷判定</h3><p>缺陷判定原则是修改之后原本失败的测试用例可以通过。</p><ul><li>即便只有一个用例通过或者即便仍然存在缺陷可能导致其他测试用例不通过。</li><li>一个缺陷对应一个测试用例，而不是一行代码（代码行数）。</li></ul><h3 id="1-3-3-bug修复判定"><a href="#1-3-3-bug修复判定" class="headerlink" title="1.3.3 bug修复判定"></a>1.3.3 bug修复判定</h3><p>bug是否修复的标准是测试用例是否全部通过。</p><h3 id="1-3-4-缺陷干扰"><a href="#1-3-4-缺陷干扰" class="headerlink" title="1.3.4 缺陷干扰"></a>1.3.4 缺陷干扰</h3><p>不同缺陷之间相互干扰，造成部分测试用例通过的假象。</p><h1 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2 单元测试"></a>2 单元测试</h1><h2 id="2-1-测试粒度Granularity-of-Testing"><a href="#2-1-测试粒度Granularity-of-Testing" class="headerlink" title="2.1 测试粒度Granularity of Testing"></a>2.1 测试粒度Granularity of Testing</h2><ul><li>单元测试：测试每一个单独的模块</li><li>集成测试：测试不同组件之间的相互作用</li><li>系统测试：开发者测试整个系统</li><li>验收测试：用户基于需求进行系统的确认。</li></ul><h2 id="2-2-单元测试范围"><a href="#2-2-单元测试范围" class="headerlink" title="2.2 单元测试范围"></a>2.2 单元测试范围</h2><ul><li>软件的基本模块：一个函数或一个类或一个组件。</li><li>典型的问题出现在：本地数据结构、算法、边界条件、错误处理。</li></ul><h2 id="2-3-为什么单元测试？"><a href="#2-3-为什么单元测试？" class="headerlink" title="2.3 为什么单元测试？"></a>2.3 为什么单元测试？</h2><p>分而治之的方法。</p><ul><li>将系统拆分为多个单元</li><li>单独调试单元</li><li>缩小可能存在错误的地方</li><li>不想追逐其他单元的错误</li></ul><h2 id="2-4-如何单元测试？"><a href="#2-4-如何单元测试？" class="headerlink" title="2.4 如何单元测试？"></a>2.4 如何单元测试？</h2><p>分层构建系统：</p><ul><li>从不依赖其他部分的类开始。</li><li>在已经测试过的类上继续测试。</li></ul><p>好处：</p><ul><li>避免编写模拟类。</li><li>在测试模块时，它所依赖的模块是可靠的。</li></ul><h2 id="2-5-单元测试框架"><a href="#2-5-单元测试框架" class="headerlink" title="2.5 单元测试框架"></a>2.5 单元测试框架</h2><ul><li>xUnit</li><li>JUnit</li></ul><h1 id="3-白盒测试"><a href="#3-白盒测试" class="headerlink" title="3 白盒测试"></a>3 白盒测试</h1><h2 id="3-1-测试中的图形"><a href="#3-1-测试中的图形" class="headerlink" title="3.1 测试中的图形"></a>3.1 测试中的图形</h2><h3 id="3-1-1-图的基本概念"><a href="#3-1-1-图的基本概念" class="headerlink" title="3.1.1 图的基本概念"></a>3.1.1 图的基本概念</h3><h4 id="3-1-1-1-图的一般定义"><a href="#3-1-1-1-图的一般定义" class="headerlink" title="3.1.1.1 图的一般定义"></a>3.1.1.1 图的一般定义</h4><p>图一般用G &#x3D; (V, E)表示</p><ul><li>V：一组有限的非空顶点。<ul><li>V0：初始顶点的集合。</li><li>Vf：最终顶点的集合。</li></ul></li><li>E：一组变（成对的顶点）。</li></ul><h4 id="3-1-1-2-讨论"><a href="#3-1-1-2-讨论" class="headerlink" title="3.1.1.2 讨论"></a>3.1.1.2 讨论</h4><p>Q：单独的顶点是图吗？</p><p>A：是的。</p><p>Q：E（边集合）可不可以无限。</p><p>A：不可以，因为顶点是有限的。</p><h4 id="3-1-1-3-路径Path"><a href="#3-1-1-3-路径Path" class="headerlink" title="3.1.1.3 路径Path"></a>3.1.1.3 路径Path</h4><p>一组连通的顶点集合，每对顶点都是一条边。</p><p><img src="http://img.fdchen.host//%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95path.png" alt="image-20210525170441304"></p><ul><li><p>长度：边的数目（顶点数-1），如上为3</p></li><li><p>子路径：含有父路径中部分顶点的一条路径（一定要是路径）。</p><ul><li>V2, V4, V6可，V1, V2, V6不可</li></ul></li><li><p>测试路径：从初始顶点开始，终止最终顶点的一条路径。</p><ul><li>如上，共有4条测试路径。</li></ul></li></ul><h4 id="3-1-1-4-测试和测试路径"><a href="#3-1-1-4-测试和测试路径" class="headerlink" title="3.1.1.4 测试和测试路径"></a>3.1.1.4 测试和测试路径</h4><p>术语表示：</p><ul><li>path(t)：执行测试用例 t 的测试路径。</li><li>path(T)：执行测试用例集 T 的测试路径集。</li><li><strong>每一个测试用例有且只有一条测试路径。</strong></li></ul><p>测试路径可以代表测试用例的执行。</p><ul><li>一些测试路径可以执行多个测试用例。</li></ul><h2 id="3-2-图覆盖准则"><a href="#3-2-图覆盖准则" class="headerlink" title="3.2 图覆盖准则"></a>3.2 图覆盖准则</h2><h3 id="3-2-1-可达Reach"><a href="#3-2-1-可达Reach" class="headerlink" title="3.2.1 可达Reach"></a>3.2.1 可达Reach</h3><ul><li><p>当存在一条路径从v1开始到v2结束时，称v1可达v2。</p></li><li><p>当存在一条路径从v1开始到图G‘的其中一个顶点时，称v1可达G’。</p></li><li><p>语法可达Syntactic reach：在图中存在一条路径。</p></li><li><p>语义可达Semantic reach：存在可以执行该路径的测试用例。。</p></li><li><p>if(true) {}</p><p> else { }  &#x2F;&#x2F; 此处语义不可达，语法可达。</p></li></ul><h3 id="3-2-2-覆盖Cover"><a href="#3-2-2-覆盖Cover" class="headerlink" title="3.2.2 覆盖Cover"></a>3.2.2 覆盖Cover</h3><ul><li>顶点v在路径p中：p覆盖v</li><li>边e在路径p中：p覆盖e</li><li>子路径p‘在路径p中：p覆盖p’</li></ul><h3 id="3-2-3-测试标准"><a href="#3-2-3-测试标准" class="headerlink" title="3.2.3 测试标准"></a>3.2.3 测试标准</h3><ul><li>测试需求Test Requirements(TR)：描述测试路径的属性。</li><li>测试标准Test Criterion(TC)：定义测试需求的规则。</li><li>满足Satisfaction：给定标准C的一组测试需求TR，当且仅当对于TR中的每个测试需求tr，在path(T)中存在满足该测试需求的测试路径p时，称一组测试T在图形上满足标准C。</li></ul><h2 id="3-3-结构覆盖Structural-Coverage"><a href="#3-3-结构覆盖Structural-Coverage" class="headerlink" title="3.3 结构覆盖Structural Coverage"></a>3.3 结构覆盖Structural Coverage</h2><p>在图上仅根据顶点和边定义。</p><h3 id="3-3-1-顶点覆盖Vertex-Coverage-VC"><a href="#3-3-1-顶点覆盖Vertex-Coverage-VC" class="headerlink" title="3.3.1 顶点覆盖Vertex Coverage(VC)"></a>3.3.1 顶点覆盖Vertex Coverage(VC)</h3><p>当且仅当对于V中的每个语法上可达的顶点v，在path(T)中存在一条路径p覆盖v时，测试集T满足图G上的顶点覆盖。即测试需求集TR包含G中的每个可达顶点。</p><h3 id="3-3-2-边覆盖Edge-Coverage-EC"><a href="#3-3-2-边覆盖Edge-Coverage-EC" class="headerlink" title="3.3.2 边覆盖Edge Coverage(EC)"></a>3.3.2 边覆盖Edge Coverage(EC)</h3><p>当且仅当对于E中每个语法可达的边e，在path(T)中存在一条路径p覆盖e时，测试集T满足图G的边覆盖。即测试需求集TR包含G中的每个可达边。</p><p><img src="http://img.fdchen.host//VC%E4%B8%8EEC.png" alt="image-20210525180335164"></p><h3 id="3-3-3-多边覆盖"><a href="#3-3-3-多边覆盖" class="headerlink" title="3.3.3 多边覆盖"></a>3.3.3 多边覆盖</h3><ul><li>**边对覆盖Edge-Pair coverage(EPC)**：TR包含图G内每条可达的长度不超过2的路径。</li><li>**n路径覆盖范围n-Path Coverage(nPC)**：TR包含图G内每条可达的长度不超过n的路径。</li><li>**完全路径覆盖Complete Path Coverage(CPC)**：TR包含G中的所有路径。</li><li>VC(n&#x3D;0), EC(n&#x3D;1), EPC(n&#x3D;2), CPC(n&#x3D;∞)</li></ul><h3 id="3-3-4-讨论"><a href="#3-3-4-讨论" class="headerlink" title="3.3.4 讨论"></a>3.3.4 讨论</h3><p>Q：当一个图只有长度为n2的路径时，怎么求n1PC，且n1 ≥ n2。</p><p>A：没有长度大于n2的路径。举例：只有孤立顶点的图没有边覆盖。只有只有一条边的图的EPC没有长度为2的路径。</p><h3 id="3-3-5-包含Subsume"><a href="#3-3-5-包含Subsume" class="headerlink" title="3.3.5 包含Subsume"></a>3.3.5 包含Subsume</h3><ul><li><p>C1包含C2，用C1≥C2表示，且对于任何T，如果T满足C1则意味着T满足C2。</p></li><li><p>当 n1≧n2，n1PC≧ n2PC</p></li><li><p>注意：C1≥C2并不意味着满足C1的T1可以检测到满足C2的T2检测到的任何故障。</p></li></ul><h3 id="3-3-6-结构覆盖例子"><a href="#3-3-6-结构覆盖例子" class="headerlink" title="3.3.6 结构覆盖例子"></a>3.3.6 结构覆盖例子</h3><p><img src="http://img.fdchen.host//%E7%BB%93%E6%9E%84%E8%A6%86%E7%9B%96%E4%BE%8B%E5%AD%90.png" alt="image-20210525181913478"></p><ul><li>TR和Test Path都不包含重复路径（包括父路径和子路径）。</li></ul><h2 id="3-4-控制流图与其覆盖"><a href="#3-4-控制流图与其覆盖" class="headerlink" title="3.4 控制流图与其覆盖"></a>3.4 控制流图与其覆盖</h2><h3 id="3-4-1-代码覆盖率"><a href="#3-4-1-代码覆盖率" class="headerlink" title="3.4.1 代码覆盖率"></a>3.4.1 代码覆盖率</h3><ul><li>语句覆盖Statement coverage</li><li>分支覆盖Branch coverage</li><li>路径覆盖Path coverage</li></ul><h3 id="3-4-2-控制流图Control-Flow-Graph"><a href="#3-4-2-控制流图Control-Flow-Graph" class="headerlink" title="3.4.2 控制流图Control Flow Graph"></a>3.4.2 控制流图Control Flow Graph</h3><p>顶点：</p><ul><li>语句</li><li>基本块：只有一个入口和一个出口的语句</li><li>函数</li><li>模块</li></ul><p>边：</p><ul><li>流</li><li>跳转</li><li>回调</li></ul><h4 id="3-4-2-1-CFG-if"><a href="#3-4-2-1-CFG-if" class="headerlink" title="3.4.2.1 CFG: if"></a>3.4.2.1 CFG: if</h4><p><img src="http://img.fdchen.host//CFG%20if.png" alt="image-20210525184024994"></p><h4 id="3-4-2-2-CFG-if-return"><a href="#3-4-2-2-CFG-if-return" class="headerlink" title="3.4.2.2 CFG: if-return"></a>3.4.2.2 CFG: if-return</h4><p><img src="http://img.fdchen.host//CFG%20if-return.png" alt="image-20210525184052021"></p><h4 id="3-4-2-3-CFG-while"><a href="#3-4-2-3-CFG-while" class="headerlink" title="3.4.2.3 CFG: while"></a>3.4.2.3 CFG: while</h4><p><img src="http://img.fdchen.host//CFG%20while.png" alt="image-20210525184206603"></p><h4 id="3-4-2-4-CFG-do"><a href="#3-4-2-4-CFG-do" class="headerlink" title="3.4.2.4 CFG: do"></a>3.4.2.4 CFG: do</h4><p><img src="http://img.fdchen.host//CFG%20do.png" alt="image-20210525184318467"></p><h4 id="3-4-2-5-CFG-for"><a href="#3-4-2-5-CFG-for" class="headerlink" title="3.4.2.5 CFG: for"></a>3.4.2.5 CFG: for</h4><p><img src="http://img.fdchen.host//CFG%20for.png" alt="image-20210525184427027"></p><h4 id="3-4-2-6-CFG-break-and-continue"><a href="#3-4-2-6-CFG-break-and-continue" class="headerlink" title="3.4.2.6 CFG: break and continue"></a>3.4.2.6 CFG: break and continue</h4><p><img src="http://img.fdchen.host//CFG:%20break%20and%20continue.png" alt="image-20210525184647596"></p><h4 id="3-4-2-7-CFG-switch"><a href="#3-4-2-7-CFG-switch" class="headerlink" title="3.4.2.7 CFG: switch"></a>3.4.2.7 CFG: switch</h4><p><img src="http://img.fdchen.host//CFG:%20switch.png" alt="image-20210525184725035"></p><h4 id="3-4-2-8-CFG举例"><a href="#3-4-2-8-CFG举例" class="headerlink" title="3.4.2.8 CFG举例"></a>3.4.2.8 CFG举例</h4><p><img src="http://img.fdchen.host//CFG%E4%B8%BE%E4%BE%8B.png" alt="image-20210525184807598"></p><h3 id="3-4-3-基于控制流图的覆盖率"><a href="#3-4-3-基于控制流图的覆盖率" class="headerlink" title="3.4.3 基于控制流图的覆盖率"></a>3.4.3 基于控制流图的覆盖率</h3><h4 id="3-4-3-1-语句覆盖"><a href="#3-4-3-1-语句覆盖" class="headerlink" title="3.4.3.1 语句覆盖"></a>3.4.3.1 语句覆盖</h4><p>测试涵盖的语句百分比。</p><h4 id="3-4-3-2-分支覆盖"><a href="#3-4-3-2-分支覆盖" class="headerlink" title="3.4.3.2 分支覆盖"></a>3.4.3.2 分支覆盖</h4><p>测试覆盖的分支百分比。</p><ul><li>考虑每个条件语句的false和true分支。</li></ul><p><img src="http://img.fdchen.host//%E5%88%86%E6%94%AF%E8%A6%86%E7%9B%96.png" alt="image-20210525185217134"></p><h4 id="3-4-3-3-路径覆盖"><a href="#3-4-3-3-路径覆盖" class="headerlink" title="3.4.3.3 路径覆盖"></a>3.4.3.3 路径覆盖</h4><p>测试覆盖的路径百分比。</p><ul><li>考虑所有可能的程序执行路径</li></ul><h4 id="3-4-3-4-比较"><a href="#3-4-3-4-比较" class="headerlink" title="3.4.3.4 比较"></a>3.4.3.4 比较</h4><p><img src="http://img.fdchen.host//%E8%AF%AD%E5%8F%A5%20%E5%88%86%E6%94%AF%20%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%AF%94%E8%BE%83.png" alt="image-20210525185734980"></p><ul><li><p>如果可以实现100%的分支覆盖，可以实现100%的语句覆盖。</p></li><li><p>如果可以实现100%的路径覆盖，可以实现100%的分支覆盖。</p></li><li><p>但是路径覆盖对于实际程序可能是不可行的。</p></li></ul><h4 id="3-4-3-5-效率"><a href="#3-4-3-5-效率" class="headerlink" title="3.4.3.5 效率"></a>3.4.3.5 效率</h4><ul><li>大约65％的错误可以在<strong>单元测试</strong>中发现</li><li>单元测试以<strong>控制流测试</strong>方法为主导</li><li><strong>语句和分支测试</strong>在控制流测试中占主导地位</li></ul><h4 id="3-4-3-6-局限性"><a href="#3-4-3-6-局限性" class="headerlink" title="3.4.3.6 局限性"></a>3.4.3.6 局限性</h4><p>即便达到100%覆盖，仍然可能存在bug。</p><h2 id="3-5-主路径覆盖Prime-Path-Coverage"><a href="#3-5-主路径覆盖Prime-Path-Coverage" class="headerlink" title="3.5 主路径覆盖Prime Path Coverage"></a>3.5 主路径覆盖Prime Path Coverage</h2><h3 id="3-5-1-简单路径Simple-Path"><a href="#3-5-1-简单路径Simple-Path" class="headerlink" title="3.5.1 简单路径Simple Path"></a>3.5.1 简单路径Simple Path</h3><p>除了第一个和最后一个顶点可能相同，如果其他没有顶点出现多次，则从顶点ni到nj的路径是简单的。</p><ul><li>没有内部循环</li><li>循环是一条简单的路径</li></ul><h3 id="3-5-2-主路径Prime-Path"><a href="#3-5-2-主路径Prime-Path" class="headerlink" title="3.5.2 主路径Prime Path"></a>3.5.2 主路径Prime Path</h3><p>一种简单路径，它不是任何其他简单路径的子路径。</p><ul><li>最长简单路径</li><li>一定不包括单顶点路径，除非是单点图</li></ul><h4 id="3-5-2-1-主路径覆盖Prime-Path-Coverage-PPC"><a href="#3-5-2-1-主路径覆盖Prime-Path-Coverage-PPC" class="headerlink" title="3.5.2.1 主路径覆盖Prime Path Coverage(PPC)"></a>3.5.2.1 主路径覆盖Prime Path Coverage(PPC)</h4><p>TR包含G中的每个主路径。</p><ul><li>PPC不包含EPC，因为EPC中存在单顶点循环路径（以一个顶点为开始和结束的循环路径）。</li></ul><h4 id="3-5-2-2-往返Round-Trip"><a href="#3-5-2-2-往返Round-Trip" class="headerlink" title="3.5.2.2 往返Round Trip"></a>3.5.2.2 往返Round Trip</h4><p> 往返路径Round-Trip Path：在同一顶点上开始和结束的主要路径。</p><ul><li>简单往返覆盖（SRTC）：TR包含G中每个可达顶点至少一条往返路径，该顶点从往返路径开始并结束。</li><li>完全往返覆盖（CRTC）：TR包含G中每个可达顶点的所有往返路径。</li></ul><p>这些条件会忽略不在往返中的顶点和边，也就是说，它们不包含边对，边或顶点覆盖率。</p><h3 id="3-5-3-简单路径和主路径举例"><a href="#3-5-3-简单路径和主路径举例" class="headerlink" title="3.5.3 简单路径和主路径举例"></a>3.5.3 简单路径和主路径举例</h3><ul><li>简单路径</li></ul><p><img src="http://img.fdchen.host//%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84.png" alt="image-20210525200240988"></p><ul><li>主路径</li></ul><p><img src="http://img.fdchen.host//%E4%B8%BB%E8%B7%AF%E5%BE%84.png" alt="image-20210525200313516"></p><h3 id="3-5-4-讨论"><a href="#3-5-4-讨论" class="headerlink" title="3.5.4 讨论"></a>3.5.4 讨论</h3><p>Q：如何生成测试覆盖所有主路径？</p><p>A：符号执行或者可以控制程序运行路径。</p><p>Q：部分主路径都是不可行的吗?</p><p>A：是，比如一些循环路径。</p><ul><li>控制流图练习</li></ul><p><img src="http://img.fdchen.host//%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E7%BB%83%E4%B9%A0-1.png" alt="image-20210525200638366"></p><p><img src="http://img.fdchen.host//%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE%E7%BB%83%E4%B9%A0-2.png" alt="image-20210525200653805"></p><h2 id="3-6-基本路径覆盖Basic-Path-Coverage"><a href="#3-6-基本路径覆盖Basic-Path-Coverage" class="headerlink" title="3.6 基本路径覆盖Basic Path Coverage"></a>3.6 基本路径覆盖Basic Path Coverage</h2><ul><li><strong>针对单入口，单出口控制流图</strong></li><li>在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。</li></ul><h3 id="3-6-1-独立路径Independent-Path"><a href="#3-6-1-独立路径Independent-Path" class="headerlink" title="3.6.1 独立路径Independent Path"></a>3.6.1 独立路径Independent Path</h3><p>通过系统的路径仅在其包含的某些顶点或边未被其他路径覆盖的情况下才与其他路径无关。</p><ul><li>和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。</li></ul><h3 id="3-6-2-线性独立路径Linearly-Independent-Path"><a href="#3-6-2-线性独立路径Linearly-Independent-Path" class="headerlink" title="3.6.2 线性独立路径Linearly Independent Path"></a>3.6.2 线性独立路径Linearly Independent Path</h3><p>线性独立路径数：线性独立路径的数量是该矩阵的秩。</p><ul><li><p><strong>该矩阵的秩恰好是图的圈复杂度</strong>。</p></li><li><p>麦凯布的环复杂性McCabe’s Cyclomatic Complexity(CC)：CC &#x3D; E-V+2</p></li></ul><h3 id="3-6-3-McCabe的基础路径测试"><a href="#3-6-3-McCabe的基础路径测试" class="headerlink" title="3.6.3 McCabe的基础路径测试"></a>3.6.3 McCabe的基础路径测试</h3><ol><li>生成控制流程图</li><li>计算圈复杂度</li><li>选择一组基本路径</li><li>生成基本路径的测试</li></ol><ul><li>基本测试覆盖练习</li></ul><p><img src="http://img.fdchen.host//%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E7%BB%83%E4%B9%A0.png" alt="image-20210525202010293"></p><ul><li>0或1代表是否经过边。</li><li>下面的式子表示为什么要去除set2的第三个。</li><li>最终结果表示存在三条基本路径</li></ul><p>所有路径测试 ≥ 基本路径测试 ≥ 分支测试。</p><h2 id="3-7-数据流覆盖Data-Flow-Coverage"><a href="#3-7-数据流覆盖Data-Flow-Coverage" class="headerlink" title="3.7 数据流覆盖Data Flow Coverage"></a>3.7 数据流覆盖Data Flow Coverage</h2><p>目标：尝试确保计算或使用的值正确。</p><h3 id="3-7-1-Data-Flow"><a href="#3-7-1-Data-Flow" class="headerlink" title="3.7.1 Data Flow"></a>3.7.1 Data Flow</h3><ul><li><p>定义Define(def)：变量的值存入内存（赋值）的地方。</p></li><li><p>使用Use：变量的值被访问（读取）的地方。</p></li><li><p>defs中给出的值应至少达到一种，某些或所有变量才可能使用。</p></li></ul><h3 id="3-7-2-def集和use集"><a href="#3-7-2-def集和use集" class="headerlink" title="3.7.2 def集和use集"></a>3.7.2 def集和use集</h3><ul><li>def (n) or def (e) ：由顶点n或边e定义的变量集。</li><li>use (n) or use (e) ：顶点n或边e使用的变量集。</li></ul><h3 id="3-7-3-读写配对DU-Pair"><a href="#3-7-3-读写配对DU-Pair" class="headerlink" title="3.7.3 读写配对DU Pair"></a>3.7.3 读写配对DU Pair</h3><p>一对位置（li，lj），使得变量v在li处定义并在lj处使用。</p><h3 id="3-7-4-清晰路径Def-clear"><a href="#3-7-4-清晰路径Def-clear" class="headerlink" title="3.7.4 清晰路径Def-clear"></a>3.7.4 清晰路径Def-clear</h3><ul><li>Def-clear：如果v在路径中的任何顶点或边上均未赋予其他值，则对于变量v，从li到lj的路径是清晰的。</li><li>可达Reach：如果存在从li到lj的相对于v的清晰路径，则li处的v的def可达lj处的use。</li></ul><h3 id="3-7-5-DU路径"><a href="#3-7-5-DU路径" class="headerlink" title="3.7.5 DU路径"></a>3.7.5 DU路径</h3><p>从v的定义到v的使用，相对于v而言清晰的简单子路径。</p><ul><li><p>du (ni, nj, v) ： 从ni到nj的DU路径的集合。</p></li><li><p>du (ni, v) ： 从ni开始的DU路径的集合。</p></li></ul><h3 id="3-7-6-数据覆盖标准Data-Flow-Coverage-Criteria"><a href="#3-7-6-数据覆盖标准Data-Flow-Coverage-Criteria" class="headerlink" title="3.7.6 数据覆盖标准Data Flow Coverage Criteria"></a>3.7.6 数据覆盖标准Data Flow Coverage Criteria</h3><ul><li><p>全定义覆盖All-defs coverage(ADC)：对于<strong>每组</strong>DU路径S &#x3D; du（n，v），TR在S中至少包含<strong>一条路径</strong>d。</p></li><li><p>全使用覆盖All-uses coverage(AUC)：对于<strong>每组</strong>DU路径S &#x3D; du（ni，nj，v）的每组du路径，TR至少包含S中的<strong>一条路径</strong>d。</p></li><li><p>全du路径覆All-du-paths coverage(ADUPC)：对于<strong>每个集合</strong>S &#x3D; du（ni，nj，v），TR包含S中的每个路径d。</p></li><li><p>数据流测试举例</p></li></ul><p><img src="http://img.fdchen.host//%E6%95%B0%E6%8D%AE%E6%B5%81%E6%B5%8B%E8%AF%95%E4%B8%BE%E4%BE%8B.png" alt="image-20210525204513725"></p><h2 id="3-8-事件流图-Event-Flow-Graph"><a href="#3-8-事件流图-Event-Flow-Graph" class="headerlink" title="3.8 事件流图(Event Flow Graph)"></a>3.8 事件流图(Event Flow Graph)</h2><p>定义：事件流图（EFG）是一个三元组M &#x3D;⟨V，I，E⟩，其中：</p><ul><li>V是代表对象所有事件的一组顶点。</li><li>I⊆V是一组初始顶点。</li><li>E⊆V×V是顶点之间的一组边。 （vi，vj）∈E 当且仅当 <strong>vj可以在vi之后立即执行</strong>。</li></ul><h3 id="3-8-1-覆盖标准"><a href="#3-8-1-覆盖标准" class="headerlink" title="3.8.1 覆盖标准"></a>3.8.1 覆盖标准</h3><ul><li>事件覆盖</li><li>事件对覆盖</li><li>路径覆盖</li></ul><h3 id="3-8-1-事件流图例子"><a href="#3-8-1-事件流图例子" class="headerlink" title="3.8.1 事件流图例子"></a>3.8.1 事件流图例子</h3><p><img src="http://img.fdchen.host//%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%9B%BE%E4%BE%8B%E5%AD%90.png" alt="image-20210525205735012"></p><ul><li>对于界面而言，只考虑事件是否可以连续执行（点击），可以即连通，不考虑功能隐含逻辑（如必须先复制再粘贴，事实上可以不复制直接粘贴，只是值为空）。</li></ul><h2 id="3-9-变异测试Mutation-Testing"><a href="#3-9-变异测试Mutation-Testing" class="headerlink" title="3.9 变异测试Mutation Testing"></a>3.9 变异测试Mutation Testing</h2><h3 id="3-9-1-等价变异体"><a href="#3-9-1-等价变异体" class="headerlink" title="3.9.1 等价变异体"></a>3.9.1 等价变异体</h3><p>可能存在尚无法杀死的突变体（意思是通过所有测试用例），这些被称为等价突变体。尽管在语法上有所不同，但通过测试无法区分这些突变体。因此，必须“手动”检查它们。</p><h3 id="3-9-2-变异评分Mutation-Score"><a href="#3-9-2-变异评分Mutation-Score" class="headerlink" title="3.9.2 变异评分Mutation Score"></a>3.9.2 变异评分Mutation Score</h3><p>一组测试用例的突变评分是测试数据杀死的非等价突变体的百分比。<br>变异分数&#x3D; 100 * K &#x2F; T<br>K &#x3D;被杀死的突变体数量<br>T &#x3D;突变体总数<br>E &#x3D;等效突变体的数量<br>如果一组测试用例的突变得分为100％，则这组测试用例具有足够的变异性。</p><h3 id="3-9-3-变异测试基于的假设"><a href="#3-9-3-变异测试基于的假设" class="headerlink" title="3.9.3 变异测试基于的假设"></a>3.9.3 变异测试基于的假设</h3><ul><li>称职程序员假设Competent Programmer Hypothesis(CPH)<br>被测模块已经由称职的程序员或设计师编写。 因此，如果模块不正确，则与正确模块的区别最多为几个小故障。</li><li>耦合效应Coupling Effect(CE)<br>一个简单的错误产生往往是由于一个单一的变异（例如句法错误），而一个庞大复杂的错误往往是由于多处变异所导致。复杂变异体往往是由诸多简单变异体组合而成。</li></ul><h3 id="3-9-4-结论"><a href="#3-9-4-结论" class="headerlink" title="3.9.4 结论"></a>3.9.4 结论</h3><ul><li>突变是单个语法（单语句）。</li><li>变异测试用于<strong>评估测试用例的充分性</strong>。</li></ul><h2 id="3-10-逻辑覆盖"><a href="#3-10-逻辑覆盖" class="headerlink" title="3.10 逻辑覆盖"></a>3.10 逻辑覆盖</h2><h3 id="3-10-1-判定覆盖Decision-Coverage"><a href="#3-10-1-判定覆盖Decision-Coverage" class="headerlink" title="3.10.1 判定覆盖Decision Coverage"></a>3.10.1 判定覆盖Decision Coverage</h3><p>覆盖判定的正确与错误。</p><h3 id="3-10-2-条件覆盖Condition-Coverage"><a href="#3-10-2-条件覆盖Condition-Coverage" class="headerlink" title="3.10.2 条件覆盖Condition Coverage"></a>3.10.2 条件覆盖Condition Coverage</h3><p>覆盖每个条件的对与错（每个条件的正确与错误至少取一次）。</p><h3 id="3-10-3-包含关系"><a href="#3-10-3-包含关系" class="headerlink" title="3.10.3 包含关系"></a>3.10.3 包含关系</h3><p>C1 包含 C2, 表示为 C1 ≥ C2</p><ul><li>DC ≥ SC</li><li>CC not ≥ SC</li><li>DC not ≥ CC， CC not ≥ DC</li></ul><h3 id="3-10-4-条件判定覆盖Condition-x2F-Decision-Coverage-C-x2F-DC"><a href="#3-10-4-条件判定覆盖Condition-x2F-Decision-Coverage-C-x2F-DC" class="headerlink" title="3.10.4 条件判定覆盖Condition&#x2F;Decision Coverage (C&#x2F;DC)"></a>3.10.4 条件判定覆盖Condition&#x2F;Decision Coverage (C&#x2F;DC)</h3><p>结合 DC and CC，既覆盖判定的正确与错误，又覆盖所有条件的对与错。</p><ul><li>C&#x2F;DC ≥ CC</li><li>C&#x2F;DC ≥ DC</li></ul><h3 id="3-10-5-多条件覆盖Multiple-Condition-Coverage"><a href="#3-10-5-多条件覆盖Multiple-Condition-Coverage" class="headerlink" title="3.10.5 多条件覆盖Multiple Condition Coverage"></a>3.10.5 多条件覆盖Multiple Condition Coverage</h3><ul><li><p>多条件覆盖（MCC）：设计足够多的测试用例，使得<strong>每个判定中条件的各种可能组合</strong>都至少出现一次。</p></li><li><p>完全覆盖一个布尔表达式的多条件覆盖测试用例基本上由该表达式的逻辑运算符真值表给出。</p></li><li><p>如果有n个condition，则有2^n种测试用例。</p></li></ul><h3 id="3-10-6-修正条件判定覆盖Modified-Condition-x2F-Decision-Coverage"><a href="#3-10-6-修正条件判定覆盖Modified-Condition-x2F-Decision-Coverage" class="headerlink" title="3.10.6 修正条件判定覆盖Modified Condition&#x2F;Decision Coverage"></a>3.10.6 修正条件判定覆盖Modified Condition&#x2F;Decision Coverage</h3><p>在一个程序中每一种输入输出至少得出现一次，在<strong>程序中的每一个条件必须产生所有可能的输出结果至少一次</strong>，并且<strong>每一个判定中的每一个条件必须能够独立影响一个判定的输出</strong>，即在其他条件不变的前提下仅改变这个条件的值，而使判定结果改变。</p><ul><li>每一个条件产生所有可能的输出结果：<ul><li>A可以取到T和F</li></ul></li><li>独立影响结果：<ul><li>A的取值相反，结果相反。</li><li>A为T，des为T&#x2F;F</li><li>A为F，des为F&#x2F;T</li></ul></li></ul><p>MC&#x2F;DC被设计用于不包含短路特性的逻辑运算符的语言。C，C ++和Java中的短路逻辑运算符仅在其结果会影响包围决策时评估条件。MC &#x2F; DC将受到程序中决策结构的影响。</p><p><img src="http://img.fdchen.host//MC/DC%E4%BE%8B%E5%AD%90.png" alt="image-20210525221812537"></p><ul><li>如果将MC&#x2F;DC用于含短路特性的语言中，需要分解语句。</li></ul><h3 id="3-10-7-讨论"><a href="#3-10-7-讨论" class="headerlink" title="3.10.7 讨论"></a>3.10.7 讨论</h3><p>Q：请构造一个条件，其中条件没有独立的结果。</p><p>A：a &lt; 0 &amp;&amp; a&gt; 0</p><p>Q：测试用例一般的个数？n代表条件个数</p><p>A：DC——2，CC——2*n，MC&#x2F;DC——2*n，MCC——2^n</p><h1 id="5-黑盒测试"><a href="#5-黑盒测试" class="headerlink" title="5 黑盒测试"></a>5 黑盒测试</h1><h2 id="5-1-等价类划分Equivalence-Partitioning"><a href="#5-1-等价类划分Equivalence-Partitioning" class="headerlink" title="5.1 等价类划分Equivalence Partitioning"></a>5.1 等价类划分Equivalence Partitioning</h2><p>分区必须满足两个属性：</p><ul><li>块必须成对不相交（无重叠）</li><li>这些块一起覆盖了域D（完整）</li></ul><h3 id="5-1-2-基于接口的方法Interface-based-approach"><a href="#5-1-2-基于接口的方法Interface-based-approach" class="headerlink" title="5.1.2 基于接口的方法Interface-based approach"></a>5.1.2 基于接口的方法Interface-based approach</h3><ul><li><p>直接从各个输入参数开发特性</p></li><li><p>机械地考虑每个参数的分割</p></li><li><p>这是一种简单的建模技术，主要依靠语法</p></li><li><p>忽略参数之间的关系</p></li><li><p>示例：TriTyp 判断三角形类型程序的输入域划分</p></li></ul><p><img src="http://img.fdchen.host//TriTyp-0.png" alt="image-20210525234752257"></p><p><img src="http://img.fdchen.host//TriTyp-2.png" alt="image-20210525233207479"></p><h3 id="5-1-3-基于功能的方法Functionality-based-approach"><a href="#5-1-3-基于功能的方法Functionality-based-approach" class="headerlink" title="5.1.3 基于功能的方法Functionality-based approach"></a>5.1.3 基于功能的方法Functionality-based approach</h3><ul><li><p>识别与预期功能相对应的特征</p></li><li><p>需要测试人员进行更多的设计工作</p></li><li><p>可以合并领域和语义知识</p></li><li><p>可以使用参数之间的关系</p></li><li><p>建模可以基于需求而不是实现</p></li><li><p>相同的参数可能会出现在多个特征中，因此很难将值转换为测试用例</p></li><li><p>示例：TriTyp 判断三角形类型程序的输入域划分</p><ul><li>前两个表征基于<strong>语法参数及其类型</strong></li><li>语义级别的表征可以使用以下事实：三个整数代表一个三角形</li></ul></li></ul><p><img src="http://img.fdchen.host//TriType-Funcation-Based-1.png" alt="image-20210525234135785"></p><p><img src="http://img.fdchen.host//TriTyp-Funcation-Based-2.png" alt="image-20210525234209631"></p><ul><li>scalene[‘skeɪli:n]不等边，Isosceles[aɪ‘sɒsɪli:z]等腰，equilateral[ˌi:kwɪ‘lætərəl]等边</li></ul><h2 id="5-2-边界值分析-Boudary-Value-Analysis"><a href="#5-2-边界值分析-Boudary-Value-Analysis" class="headerlink" title="5.2 边界值分析 Boudary-Value Analysis"></a>5.2 边界值分析 Boudary-Value Analysis</h2><h3 id="5-2-1-选择边界值"><a href="#5-2-1-选择边界值" class="headerlink" title="5.2.1 选择边界值"></a>5.2.1 选择边界值</h3><p>具有等效类[Min，Max]的输入变量：</p><ul><li>Min</li><li>Min+</li><li>Nom</li><li>Max-</li><li>Max</li></ul><h3 id="5-2-2-弱边界分析Weak-Boundary-Analysis"><a href="#5-2-2-弱边界分析Weak-Boundary-Analysis" class="headerlink" title="5.2.2 弱边界分析Weak Boundary Analysis"></a>5.2.2 弱边界分析Weak Boundary Analysis</h3><h4 id="5-2-2-1-弱一般边界分析"><a href="#5-2-2-1-弱一般边界分析" class="headerlink" title="5.2.2.1 弱一般边界分析"></a>5.2.2.1 弱一般边界分析</h4><p><img src="http://img.fdchen.host//%E5%BC%B1%E4%B8%80%E8%88%AC%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90.png" alt="image-20210526001536543"></p><h4 id="5-2-2-2-弱健壮边界分析"><a href="#5-2-2-2-弱健壮边界分析" class="headerlink" title="5.2.2.2 弱健壮边界分析"></a>5.2.2.2 弱健壮边界分析</h4><p>考虑无效值，具有等价类[Min，Max]的输入变量：</p><ul><li>Min-</li><li>Min</li><li>Min+</li><li>Nom</li><li>Max-</li><li>Max</li><li>Max+</li></ul><p><img src="http://img.fdchen.host//%E5%BC%B1%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90%E5%9B%BE%E7%A4%BA.png" alt="image-20210526000209811"></p><p><img src="http://img.fdchen.host//%E5%BC%B1%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B.png" alt="image-20210526000303444"></p><ul><li>例题</li></ul><p><img src="http://img.fdchen.host//%E5%BC%B1%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90%E4%BE%8B%E9%A2%98.png" alt="image-20210526000657475"></p><h3 id="5-2-3-强边界分析StrongBoundary-Analysis"><a href="#5-2-3-强边界分析StrongBoundary-Analysis" class="headerlink" title="5.2.3 强边界分析StrongBoundary Analysis"></a>5.2.3 强边界分析StrongBoundary Analysis</h3><h4 id="5-2-3-1-强一般边界分析"><a href="#5-2-3-1-强一般边界分析" class="headerlink" title="5.2.3.1 强一般边界分析"></a>5.2.3.1 强一般边界分析</h4><p><img src="http://img.fdchen.host//%E5%BC%BA%E4%B8%80%E8%88%AC%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90.png" alt="image-20210526001750886"></p><p><img src="http://img.fdchen.host//%E5%BC%BA%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90%E4%B8%BE%E4%BE%8B.png" alt="image-20210526000510493"></p><h4 id="5-2-3-2-强健壮边界分析"><a href="#5-2-3-2-强健壮边界分析" class="headerlink" title="5.2.3.2 强健壮边界分析"></a>5.2.3.2 强健壮边界分析</h4><p><img src="http://img.fdchen.host//i%E5%BC%BA%E5%81%A5%E5%A3%AE%E6%80%A7%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90.png" alt="image-20210526001719192"></p><ul><li>例题</li></ul><p><img src="http://img.fdchen.host//%E5%BC%BA%E5%81%A5%E5%A3%AE%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90%E4%BE%8B%E9%A2%98.png" alt="image-20210526003017607"></p><h3 id="5-2-4-总结边界值分析"><a href="#5-2-4-总结边界值分析" class="headerlink" title="5.2.4 总结边界值分析"></a>5.2.4 总结边界值分析</h3><p><strong>弱”是指含单缺陷假设</strong>（失效极少是由两个或两个以上的缺陷同时引起的）<strong>，“强”是指含多缺陷假设</strong>（失效是由两个或两个以上的缺陷同时引起的）；<strong>“一般”是指不考虑无效值。“健壮是指考虑无效值”</strong>。<strong>弱一般等价类测试用例</strong>通过使用一个测试用例中的每个有效等价类（区间）的代表值来实现（<strong>常以对称方式来标识这些测试用例，且注意单边假设作用，即每次只在一个变量中取边界值，其余变量取一般值</strong>）；<strong>强一般等价类测试用例通过每个独立变量的有效等价类的笛卡尔积来实现。</strong></p><h2 id="5-3-组合测试Combinatorial-Testing"><a href="#5-3-组合测试Combinatorial-Testing" class="headerlink" title="5.3 组合测试Combinatorial Testing"></a>5.3 组合测试Combinatorial Testing</h2><h3 id="5-3-1等价类测试"><a href="#5-3-1等价类测试" class="headerlink" title="5.3.1等价类测试"></a>5.3.1等价类测试</h3><ul><li>弱等价类测试</li></ul><p><img src="http://img.fdchen.host//%E5%BC%B1%E7%AD%89%E4%BB%B7%E7%B1%BB%E6%B5%8B%E8%AF%95.png" alt="image-20210526013654239"></p><ul><li>强等价类测试</li></ul><p><img src="http://img.fdchen.host//%E5%BC%BA%E7%AD%89%E4%BB%B7%E7%B1%BB%E6%B5%8B%E8%AF%95.png" alt="image-20210526013717703"></p><h3 id="5-3-2-成本效益测试Cost-Effective-Testing"><a href="#5-3-2-成本效益测试Cost-Effective-Testing" class="headerlink" title="5.3.2 成本效益测试Cost Effective Testing"></a>5.3.2 成本效益测试Cost Effective Testing</h3><h4 id="5-3-2-1-组合测试"><a href="#5-3-2-1-组合测试" class="headerlink" title="5.3.2.1 组合测试"></a>5.3.2.1 组合测试</h4><ul><li>全排列组合测试</li></ul><p><img src="http://img.fdchen.host//%E5%85%A8%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%B5%8B%E8%AF%95.png" alt="image-20210526020211344"></p><ul><li>成对测试（2-wise）</li></ul><p><img src="http://img.fdchen.host//%E6%88%90%E5%AF%B9%E6%B5%8B%E8%AF%95.png" alt="image-20210526020246697"></p><p>其中，A和C配对全排列组合（笛卡尔积），B和D配对全排列组合（笛卡尔积），因为B和D配对的排列组合更多，以B和D的排列组合个数为总的用例个数。</p><ul><li>t-wise&#x2F;t-ways 组合测试</li></ul><p><img src="http://img.fdchen.host//t-wise%E7%BB%84%E5%90%88%E6%B5%8B%E8%AF%95.png" alt="image-20210526020429657"></p><p>其中，A、B、C配对全排列组合（笛卡尔积），B、C、D配对全排列组合（笛卡尔积），因为B、C、D配对的排列组合更多，以B、C、D的排列组合个数为总的用例个数。</p><h4 id="5-3-2-2-组合测试分析"><a href="#5-3-2-2-组合测试分析" class="headerlink" title="5.3.2.2 组合测试分析"></a>5.3.2.2 组合测试分析</h4><ul><li><p>固定强度组合测试：</p><ul><li><p>成对测试</p></li><li><p>t-ways组合测试</p></li></ul></li><li><p>可变强度组合测试</p></li><li><p>关键问题</p><ul><li>所有组合采样</li><li>不考虑输入的特殊信息</li></ul></li></ul><h2 id="5-4-测试中的缺省选项"><a href="#5-4-测试中的缺省选项" class="headerlink" title="5.4 测试中的缺省选项"></a>5.4 测试中的缺省选项</h2><h3 id="5-4-1-基本选项"><a href="#5-4-1-基本选项" class="headerlink" title="5.4.1 基本选项"></a>5.4.1 基本选项</h3><p><img src="http://img.fdchen.host//%E7%BC%BA%E7%9C%81-%E5%9F%BA%E6%9C%AC%E9%80%89%E9%A1%B9.png" alt="image-20210526021842542"></p><ul><li>缺省值可以按照等价类划分法选取</li><li>每一个测试用例只修改一个变量值为非缺省值（标红位置），其他变量仍为缺省值，加上均为缺省值的用例，一共5 + 1 &#x3D; 6 个测试用例。</li></ul><h3 id="5-4-2-多基本选项"><a href="#5-4-2-多基本选项" class="headerlink" title="5.4.2 多基本选项"></a>5.4.2 多基本选项</h3><p><img src="http://img.fdchen.host//%E7%BC%BA%E7%9C%81-%E5%A4%9A%E5%9F%BA%E6%9C%AC%E9%80%89%E9%A1%B90.png" alt="image-20210526022152540"></p><ul><li>缺省值可以按照等价类划分法选取，可以为多个。</li><li>每一个测试用例只修改一个变量值为非缺省值（标红位置，<strong>注意当前的缺省值默认为1个，即D3虽然属于D的缺省值，但是在上部分的测试用例中已经选定了一个缺省值，因而在上半部分D3暂时归为非缺省值</strong>），其他变量仍为缺省值，加上均为缺省值的用例，但是因为存在部分变量有多个缺省值，需要进行缺省值的全排列组合（笛卡尔积），一共 （5 + 1）*2 &#x3D; 12 个测试用例。公式推导：测试用例个数 &#x3D; （（变量取值个数 - 变量个数）+1）* 缺省值的全排列组合个数。</li></ul><h2 id="5-5-测试约束"><a href="#5-5-测试约束" class="headerlink" title="5.5 测试约束"></a>5.5 测试约束</h2><p>约束指的是不能出现的变量取值组合。以下是解决测试约束的方法。</p><h3 id="5-5-1-合并输入变量"><a href="#5-5-1-合并输入变量" class="headerlink" title="5.5.1 合并输入变量"></a>5.5.1 合并输入变量</h3><p><img src="http://img.fdchen.host//%E5%90%88%E5%B9%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.png" alt="image-20210526022916828"></p><h3 id="5-5-2-约简输入域"><a href="#5-5-2-约简输入域" class="headerlink" title="5.5.2 约简输入域"></a>5.5.2 约简输入域</h3><p><img src="http://img.fdchen.host//%E7%BA%A6%E7%AE%80%E8%BE%93%E5%85%A5%E5%9F%9F.png" alt="image-20210526023035222"></p><h3 id="5-5-3-修改测试用例"><a href="#5-5-3-修改测试用例" class="headerlink" title="5.5.3 修改测试用例"></a>5.5.3 修改测试用例</h3><p><img src="http://img.fdchen.host//%E4%BF%AE%E6%94%B9%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png" alt="image-20210526023212700"></p><ul><li>将不能出现的测试用例化为其他测试用例。</li></ul><h2 id="5-6-决策表"><a href="#5-6-决策表" class="headerlink" title="5.6 决策表"></a>5.6 决策表</h2><h3 id="5-6-1-决策表组成"><a href="#5-6-1-决策表组成" class="headerlink" title="5.6.1 决策表组成"></a>5.6.1 决策表组成</h3><ul><li>条件桩—列出问题的所有条件</li><li>条件项—针对条件桩中条件列出所有可能的取值</li><li>动作桩—列出问题规定的可能采取的操作</li><li>动作项—指出条件项各取值情况下应采取的动作</li></ul><p>任何一个<strong>条件组合的特定取值及相应要执行的动作</strong>为一条规则。在决策表中<strong>贯穿条件项和动作项的一列</strong>是一条规则。</p><h3 id="5-6-2-决策表的生成"><a href="#5-6-2-决策表的生成" class="headerlink" title="5.6.2 决策表的生成"></a>5.6.2 决策表的生成</h3><ul><li>有n个条件的决策表有2^n个规则（每个条件取真、假值）</li><li>若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并</li><li>合并后的条件项用符号“-”表示，说明执行的动作与该条件的取值无关，称为无关条件</li></ul><h3 id="5-6-3-例题—三角形类型决策表"><a href="#5-6-3-例题—三角形类型决策表" class="headerlink" title="5.6.3 例题—三角形类型决策表"></a>5.6.3 例题—三角形类型决策表</h3><p><img src="http://img.fdchen.host//%E4%B8%89%E8%A7%92%E5%BD%A2%E7%B1%BB%E5%9E%8B%E5%86%B3%E7%AD%96%E8%A1%A8.png" alt="image-20210526023642786"></p><h3 id="5-6-4-练习题"><a href="#5-6-4-练习题" class="headerlink" title="5.6.4 练习题"></a>5.6.4 练习题</h3><p>前一日函数DPreate是NextDate的逆函数，即给定一个月份、日期、年，会返回前一天的日期。</p><ul><li>年的取值在1812年到2017年</li><li>日的取值在1日到31日之间</li><li>月的取值在1到12月之间</li></ul><p><img src="http://img.fdchen.host//%E5%86%B3%E7%AD%96%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98-1.png" alt="image-20210526023737811"></p><p><img src="http://img.fdchen.host//%E5%86%B3%E7%AD%96%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98-2.png" alt="image-20210526023754123"></p><p><img src="http://img.fdchen.host//%E5%86%B3%E7%AD%96%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98-3.png" alt="image-20210526023813990"></p><h2 id="5-7-测试输出-x2F-测试预言Test-Oracle"><a href="#5-7-测试输出-x2F-测试预言Test-Oracle" class="headerlink" title="5.7 测试输出&#x2F;测试预言Test Oracle"></a>5.7 测试输出&#x2F;测试预言Test Oracle</h2><h3 id="5-7-1-蜕变测试Metamorphic-Testing"><a href="#5-7-1-蜕变测试Metamorphic-Testing" class="headerlink" title="5.7.1 蜕变测试Metamorphic Testing"></a>5.7.1 蜕变测试Metamorphic Testing</h3><p><img src="http://img.fdchen.host//%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image-20210526024457613"></p><ul><li><p>如果新的测试用例输出f(t(x))符合预期，不一定正确。</p></li><li><p>但是，如果f(t(x))与预期不符，则f(x)或f(t(x))或两者都是错的。</p></li><li><p>蜕变测试示例1</p></li></ul><p><img src="http://img.fdchen.host//%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B1.png" alt="image-20210526024702050"></p><ul><li>蜕变测试示例2</li></ul><p><img src="http://img.fdchen.host//%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B2.png" alt="image-20210526024734109"></p><ul><li>蜕变测试课后作业习题</li></ul><p><img src="http://img.fdchen.host//%E8%9C%95%E5%8F%98%E6%B5%8B%E8%AF%95%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E4%B9%A0%E9%A2%98.png" alt="image-20210526024853160"></p><h2 id="5-8-测试用例集约简Test-Suite-Reduction"><a href="#5-8-测试用例集约简Test-Suite-Reduction" class="headerlink" title="5.8 测试用例集约简Test Suite Reduction"></a>5.8 测试用例集约简Test Suite Reduction</h2><p>目标：获得满足所有测试需求tr的最小测试用例子集。</p><h3 id="5-8-1-贪心法"><a href="#5-8-1-贪心法" class="headerlink" title="5.8.1 贪心法"></a>5.8.1 贪心法</h3><ul><li>每次取满足测试需求最多的测试用例t</li></ul><p><img src="http://img.fdchen.host//%E8%B4%AA%E5%BF%83%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E9%9B%86%E7%BA%A6%E7%AE%80.png" alt="image-20210526025228009"></p><h3 id="5-8-2-添加额外信息的贪心法"><a href="#5-8-2-添加额外信息的贪心法" class="headerlink" title="5.8.2 添加额外信息的贪心法"></a>5.8.2 添加额外信息的贪心法</h3><ul><li>每次取满足的测试需求增加最多的测试用例t</li></ul><p><img src="http://img.fdchen.host//%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF%E7%9A%84%E8%B4%AA%E5%BF%83%E6%B3%95-%E6%B5%8B%E8%AF%95%E7%BA%A6%E7%AE%80.png" alt="image-20210526025444861"></p><h3 id="5-8-3-距离最大贪心法"><a href="#5-8-3-距离最大贪心法" class="headerlink" title="5.8.3 距离最大贪心法"></a>5.8.3 距离最大贪心法</h3><ul><li>前提：不知道每个用例满足的对应需求是什么</li></ul><p><img src="http://img.fdchen.host//%E8%B7%9D%E7%A6%BB%E8%B4%AA%E5%BF%83-%E5%89%8D%E6%8F%90.png" alt="image-20210526030049260"></p><ul><li>每次取与之前已选测试用例的汉明距离最大的测试用例t</li></ul><p><img src="http://img.fdchen.host//%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E8%B4%AA%E5%BF%83-%E6%B5%8B%E8%AF%95%E7%BA%A6%E7%AE%80.png" alt="image-20210526025944959"></p><h2 id="5-9-测试用例排序Test-Case-Prioritization"><a href="#5-9-测试用例排序Test-Case-Prioritization" class="headerlink" title="5.9 测试用例排序Test Case Prioritization"></a>5.9 测试用例排序Test Case Prioritization</h2><p>让“预计失败”用例提前测试，从而使发现bug时间提前。</p><h3 id="5-9-1目标函数APFD-T"><a href="#5-9-1目标函数APFD-T" class="headerlink" title="5.9.1目标函数APFD(T)"></a>5.9.1目标函数APFD(T)</h3><p><img src="http://img.fdchen.host//%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%8E%92%E5%BA%8F%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0.png" alt="image-20210526030744027"></p><ul><li><p>k：被测程序P中包含的故障数。</p></li><li><p>m：测试用例总数。</p></li><li><p>tfi：在测试集T中暴露出故障 i 的第一个测试的位置。</p></li><li><p>例题</p></li></ul><p><img src="http://img.fdchen.host//APFD%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98.png" alt="image-20210526031049223"></p><p><img src="http://img.fdchen.host//APFD%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98%E7%AD%94%E6%A1%88.png" alt="image-20210526031125428"></p><ul><li>普通贪心是每次选择满足tr最多的用例</li><li>含附加信息的贪心是每次选择新增满足tr最多的用例</li></ul><h2 id="5-10-缺陷定位Fault-Loaction"><a href="#5-10-缺陷定位Fault-Loaction" class="headerlink" title="5.10 缺陷定位Fault Loaction"></a>5.10 缺陷定位Fault Loaction</h2><h3 id="5-10-1-利用PIE模型"><a href="#5-10-1-利用PIE模型" class="headerlink" title="5.10.1 利用PIE模型"></a>5.10.1 利用PIE模型</h3><p>fault语句激发failure，利用2个单缺陷测试用例（一个测试用例只含一个failure）的fault语句求交，定位fault。</p><h3 id="5-10-2-基于频谱的缺陷定位Spectrum-based-Fault-Localization"><a href="#5-10-2-基于频谱的缺陷定位Spectrum-based-Fault-Localization" class="headerlink" title="5.10.2 基于频谱的缺陷定位Spectrum-based Fault Localization"></a>5.10.2 基于频谱的缺陷定位Spectrum-based Fault Localization</h3><p>使用程序频谱执行过程中程序行为的表示。</p><p><img src="http://img.fdchen.host//%E5%9F%BA%E4%BA%8E%E9%A2%91%E8%B0%B1%E7%9A%84%E7%BC%BA%E9%99%B7%E5%AE%9A%E4%BD%8D%E4%B8%BE%E4%BE%8B.png" alt="image-20210526031849071"></p><ul><li><p>在失败的测试案例中经常发生的程序元素可能包含错误。</p></li><li><p>在通过的测试用例中经常发生的程序元素很可能不包含任何错误。</p></li><li><p>目标函数计算公式，本质是求aef</p></li></ul><p><img src="http://img.fdchen.host//%E5%9F%BA%E4%BA%8E%E9%A2%91%E8%B0%B1%E7%9A%84%E7%BC%BA%E9%99%B7%E5%AE%9A%E4%BD%8D%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="image-20210526032142240"></p><ul><li>举例</li></ul><p><img src="http://img.fdchen.host//%E5%9F%BA%E4%BA%8E%E9%A2%91%E8%B0%B1%E7%9A%84%E7%BC%BA%E9%99%B7%E5%AE%9A%E4%BD%8D%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E4%B8%BE%E4%BE%8B.png" alt="image-20210526032237405"></p><ul><li>最后按可能性排序，得出fault最有可能存在的位置</li></ul><p><img src="http://img.fdchen.host//%E5%9F%BA%E4%BA%8E%E9%A2%91%E8%B0%B1%E7%9A%84%E7%BC%BA%E9%99%B7%E5%AE%9A%E4%BD%8D%E4%BE%8B%E9%A2%98-2.png" alt="image-20210526155107835"></p><h1 id="7-集成测试与系统测试"><a href="#7-集成测试与系统测试" class="headerlink" title="7 集成测试与系统测试"></a>7 集成测试与系统测试</h1><h2 id="7-1-系统集成的模式与方法"><a href="#7-1-系统集成的模式与方法" class="headerlink" title="7.1 系统集成的模式与方法"></a>7.1 系统集成的模式与方法</h2><h3 id="7-1-1-集成测试的模式"><a href="#7-1-1-集成测试的模式" class="headerlink" title="7.1.1 集成测试的模式"></a>7.1.1 集成测试的模式</h3><ul><li><strong>非渐增式测试模式</strong>：先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li><li><strong>渐增式测试模式</strong>：把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。</li></ul><table><thead><tr><th></th><th>测试开销</th><th>发现模块间接口错误</th><th>诊断难易</th></tr></thead><tbody><tr><td>非渐增式</td><td>小</td><td>晚</td><td>难</td></tr><tr><td>渐增式</td><td>大</td><td>早</td><td>易</td></tr></tbody></table><h3 id="7-1-2-自顶向下和自底向上集成方法（渐增式集成）"><a href="#7-1-2-自顶向下和自底向上集成方法（渐增式集成）" class="headerlink" title="7.1.2 自顶向下和自底向上集成方法（渐增式集成）"></a>7.1.2 自顶向下和自底向上集成方法（渐增式集成）</h3><ul><li><strong>驱动程序&#x2F;驱动模块（driver）</strong>，用以模拟被测模块的上级模块。</li><li><strong>桩程序&#x2F;桩模块（stub）</strong>,也有人称为存根程序，用以模拟被测模块工作过程中所调用的模块（下级模块）。</li></ul><h4 id="7-1-2-1-自顶向下方法"><a href="#7-1-2-1-自顶向下方法" class="headerlink" title="7.1.2.1 自顶向下方法"></a>7.1.2.1 自顶向下方法</h4><p><img src="http://img.fdchen.host//%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95.png" alt="image-20210526090959165"></p><ul><li>主要优点是不需要测试驱动程序，能够在测试阶段的早期实现并验证系统的主要功能，而且能在早期发现上层模块的接口错误。</li><li>主要缺点是需要存根程序，可能遇到与此相联系的测试困难，低层关键模块中的错误发现较晚，而且用这种方法在早期不能充分展开人力。</li></ul><h4 id="7-1-2-2-自底向上方法"><a href="#7-1-2-2-自底向上方法" class="headerlink" title="7.1.2.2 自底向上方法"></a>7.1.2.2 自底向上方法</h4><p><img src="http://img.fdchen.host//%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95.png" alt="image-20210526091135320"></p><ul><li>与自顶向下方法的优缺点相反。</li></ul><h4 id="7-1-2-3-混合策略集成方法"><a href="#7-1-2-3-混合策略集成方法" class="headerlink" title="7.1.2.3 混合策略集成方法"></a>7.1.2.3 混合策略集成方法</h4><p><img src="http://img.fdchen.host//%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5.png" alt="image-20210526091413096"></p><ul><li>对软件结构中较上层，使用的是“自顶向下”法；对软件结构中较下层，使用的是“自底向上”法，两者相结合。如三明治集成方法（主要缺点是：在真正集成之前每一个独立的模块没有完全测试过）。</li></ul><h3 id="7-1-3-大棒集成方法"><a href="#7-1-3-大棒集成方法" class="headerlink" title="7.1.3 大棒集成方法"></a>7.1.3 大棒集成方法</h3><p><img src="http://img.fdchen.host//%E5%A4%A7%E6%A3%92%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95.png" alt="image-20210526091607262"></p><ul><li>采用大棒集成方法，先是对每一个子模块进行测试（单元测试阶段），然后将所有模块一次性的全部集成起来进行集成测试 。</li><li>因为所有的模块一次集成的，所以很难确定出错的真正位置、所在的模块、错误的原因。</li><li>非渐增式集合。</li></ul><h3 id="7-1-4-持续集成"><a href="#7-1-4-持续集成" class="headerlink" title="7.1.4 持续集成"></a>7.1.4 持续集成</h3><p>通常系统集成都会采用持续集成的策略，软件开发中各个模块不是同时完成，根据进度将完成的模块尽可能早的进行集成，有助于尽早发现Bug，避免集成中大量Bug涌现。</p><p>而且容易定位Bug、修正Bug，最终提高软件开发的质量与效率</p><h2 id="7-2-功能测试"><a href="#7-2-功能测试" class="headerlink" title="7.2 功能测试"></a>7.2 功能测试</h2><p>根据产品特性和设计需求，验证一个产品的特性和行为是否满足设计需求。</p><h3 id="7-2-1-相关测试类型"><a href="#7-2-1-相关测试类型" class="headerlink" title="7.2.1 相关测试类型"></a>7.2.1 相关测试类型</h3><ul><li>正确性：产品功能是否与需求和设计文档一致</li><li>可靠性：用户交互是否引发软件崩溃和其它异常</li><li>易用性：软件产品完成特定任务的难易程度</li></ul><h2 id="7-3-回归测试"><a href="#7-3-回归测试" class="headerlink" title="7.3 回归测试"></a>7.3 回归测试</h2><h3 id="7-3-1-回归测试的目的"><a href="#7-3-1-回归测试的目的" class="headerlink" title="7.3.1 回归测试的目的"></a>7.3.1 回归测试的目的</h3><ul><li>所做的修改达到了预定的目的，如错误得到了改正，新功能得到了实现，能够适应新的运行环境等；</li><li>不影响软件原有功能的正确性。</li></ul><h3 id="7-3-2-回归测试的方法"><a href="#7-3-2-回归测试的方法" class="headerlink" title="7.3.2 回归测试的方法"></a>7.3.2 回归测试的方法</h3><ul><li>再测试全部用例</li><li>基于风险选择测试</li><li>基于操作剖面选择测试</li><li>再测试修改的部分</li></ul><h2 id="7-4-非功能性测试"><a href="#7-4-非功能性测试" class="headerlink" title="7.4 非功能性测试"></a>7.4 非功能性测试</h2><h3 id="7-4-1-性能测试"><a href="#7-4-1-性能测试" class="headerlink" title="7.4.1 性能测试"></a>7.4.1 性能测试</h3><h4 id="7-4-1-1-目的和需求"><a href="#7-4-1-1-目的和需求" class="headerlink" title="7.4.1.1 目的和需求"></a>7.4.1.1 目的和需求</h4><ul><li>目的：为了验证系统是否达到用户提出的性能指标，同时发现系统中存在的性能瓶颈，起到优化系统的目的。</li><li>需求：用户对各项指标提出的明确需求；如果用户没有提出性能指标则根据用户需求、测试设计人员的经验来设计各项测试指标。（需求+经验）</li></ul><h4 id="7-4-1-2-性能指标"><a href="#7-4-1-2-性能指标" class="headerlink" title="7.4.1.2 性能指标"></a>7.4.1.2 性能指标</h4><ul><li>不同的关注对象采用不同的性能的度量方法</li><li>服务端性能采用CPU、内存等使用率来度量</li><li>客户端性能通常根据系统处理特定用户请求的响应时间来度量</li></ul><ol><li><p>响应时间：</p><ul><li><strong>服务端响应时间</strong>是指从请求发出开始到客户端接收到最后一个字节数据所消耗的时间。</li><li><strong>客户端响应时间</strong>是指客户端收到响应数据后呈现&#x2F;响应用户所消耗的时间。</li></ul></li><li><p>并发用户数：</p><ul><li><p>先确定业务场景，然后基于场景采用某些相应方法计算并发用户数</p></li><li><p>在线用户数：用户同时在一定时间段的在线数量</p><p>并发用户数：某一时刻同时向服务器发送请求的用户数</p></li></ul></li><li><p>吞吐量：</p><ul><li>单位时间内处理的用户请求数量</li><li>访问人数&#x2F;天，页面数&#x2F;秒，请求数&#x2F;秒，处理业务数&#x2F;小时，等等</li></ul></li><li><p>性能计数器：</p><ul><li>描述系统性能的一些数据指标</li><li>例如，内存使用率、CPU使用率、进程时间等都是常见服务器性能计数器</li></ul></li></ol><h3 id="7-4-2-压力测试"><a href="#7-4-2-压力测试" class="headerlink" title="7.4.2 压力测试"></a>7.4.2 压力测试</h3><p><strong>压力测试</strong>(Stress test)，也称为强度测试、负载测试。压力测试是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。目标是<strong>找出性能瓶颈</strong>，从本质上来说，测试者是想要破坏程序。</p><ul><li>并发性能测试</li><li>疲劳强度测试（采用系统稳定运行情况下能够支持的最大并发用户数或者日常运行用户数，持续执行一段时间业务）</li><li>大数据量测试<ul><li>独立的数据量测试</li><li>综合数据量测试（与其他压力测试相结合）</li></ul></li></ul><h3 id="7-4-3-容量测试"><a href="#7-4-3-容量测试" class="headerlink" title="7.4.3 容量测试"></a>7.4.3 容量测试</h3><p>容量测试目的是通过测试预先分析出反映软件系统应用特征的某项指标的极限值（如最大并发用户数、数据库记录数等），系统在其极限值状态下还能保持主要功能正常运行。容量测试还将确定测试对象在给定时间内能够持续处理的最大负载或工作量。</p><h3 id="7-4-4-安全性测试"><a href="#7-4-4-安全性测试" class="headerlink" title="7.4.4 安全性测试"></a>7.4.4 安全性测试</h3><p>安全性测试是检查系统对非法侵入的防范能力。安全测试期间，测试人员假扮非法入侵者，采用各种办法试图突破防线。</p><h3 id="7-4-5-可靠性测试"><a href="#7-4-5-可靠性测试" class="headerlink" title="7.4.5 可靠性测试"></a>7.4.5 可靠性测试</h3><p>可靠性（Reliability）是产品在规定的条件下和规定的时间内完成规定功能的能力，它的概率度量称为可靠度。</p><p>三要素：</p><ul><li>规定的时间</li><li>规定的环境条件</li><li>规定的功能</li></ul><p>成熟性度量可以通过错误发现率DDP（Defect Detection Percentage）来表现。在测试中查找出来的错误越多，实际应用中出错的机会就越小，软件也就越成熟。</p><p><strong>DDP&#x3D;测试发现的错误数量&#x2F;已知的全部错误数量</strong>。</p><h3 id="7-4-6-容错性测试"><a href="#7-4-6-容错性测试" class="headerlink" title="7.4.6 容错性测试"></a>7.4.6 容错性测试</h3><p>容错性测试是检查软件在异常条件下自身是否具有防护性的措施或者某种灾难性恢复的手段。如当系统出错时，能否在指定时间间隔内修正错误并重新启动系统。容错性测试包括两个方面：</p><ul><li><strong>输入异常数据或进行异常操作，以检验系统的保护性</strong>。</li><li><strong>灾难恢复性测试</strong>。</li></ul><h2 id="7-5-验收测试"><a href="#7-5-验收测试" class="headerlink" title="7.5 验收测试"></a>7.5 验收测试</h2><h3 id="7-5-1-验收测试的过程和主要内容"><a href="#7-5-1-验收测试的过程和主要内容" class="headerlink" title="7.5.1 验收测试的过程和主要内容"></a>7.5.1 验收测试的过程和主要内容</h3><p>**验收测试(Acceptance Test)**：在软件产品完成了功能测试和系统测试之后、产品发布之前所进行的软件测试活动它是技术测试的最后一个阶段,也称为交付测试。</p><p><strong>测试内容</strong>：</p><p>验证系统是否达到了用户需求规格说明书（可能包括项目或产品验收准则）中的要求，测试试图尽可能地发现软件中存留的缺陷，从而为软件进一步改善提供帮助，并保证系统或软件产品最终被用户接受。</p><h3 id="7-5-2-产品规格说明书的验证"><a href="#7-5-2-产品规格说明书的验证" class="headerlink" title="7.5.2 产品规格说明书的验证"></a>7.5.2 产品规格说明书的验证</h3><ul><li>产品规格说明书的审核</li><li>产品规格说明书的验证</li></ul><h3 id="7-5-3-用户界面和可用性测试"><a href="#7-5-3-用户界面和可用性测试" class="headerlink" title="7.5.3 用户界面和可用性测试"></a>7.5.3 用户界面和可用性测试</h3><ul><li>用户界面的7要素：<ul><li>符合标准和规范</li><li>直观性</li><li>一致性</li><li>灵活性</li><li>舒适性</li><li>正确性</li><li>实用性</li></ul></li><li><strong>易用性测试没有具体量化的指标，主观性较强。</strong></li></ul><h3 id="7-5-4-兼容性测试"><a href="#7-5-4-兼容性测试" class="headerlink" title="7.5.4 兼容性测试"></a>7.5.4 兼容性测试</h3><p>软件兼容性测试是指验证软件之间是否正确地交互和共享信息。</p><ul><li>硬件兼容</li><li>软件之间兼容</li><li>数据之间兼容</li><li>向前和向后兼容：<ul><li>向后兼容是指可以使用软件的以前版本。</li><li>向前兼容指的是可以使用软件的未来版本。</li></ul></li></ul><h3 id="7-5-5-可安装性测试和可恢复性测试"><a href="#7-5-5-可安装性测试和可恢复性测试" class="headerlink" title="7.5.5 可安装性测试和可恢复性测试"></a>7.5.5 可安装性测试和可恢复性测试</h3><h4 id="7-5-5-1-可安装性测试"><a href="#7-5-5-1-可安装性测试" class="headerlink" title="7.5.5.1 可安装性测试"></a>7.5.5.1 可安装性测试</h4><ul><li>系统软件安装</li><li>应用软件安装</li><li>服务器的安装</li><li>客户端的安装</li><li>产品升级安装</li><li>等等</li></ul><h4 id="7-5-5-2-可恢复性测试"><a href="#7-5-5-2-可恢复性测试" class="headerlink" title="7.5.5.2 可恢复性测试"></a>7.5.5.2 可恢复性测试</h4><ul><li>恢复测试主要检查系统的容错能力。当系统出错时，能否在指定时间间隔内修正错误或重新启动系统。</li><li>恢复测试首先要通过各种手段，让软件强制性地发生故障，然后验证系统是否能尽快恢复。</li></ul><h3 id="7-5-6-文档测试"><a href="#7-5-6-文档测试" class="headerlink" title="7.5.6 文档测试"></a>7.5.6 文档测试</h3><ul><li>非代码的文档测试主要检查文档的正确性、完备性和可理解性。</li></ul><h2 id="7-6-软件缺陷的描述"><a href="#7-6-软件缺陷的描述" class="headerlink" title="7.6 软件缺陷的描述"></a>7.6 软件缺陷的描述</h2><h3 id="7-6-1-基本的缺陷生命周期"><a href="#7-6-1-基本的缺陷生命周期" class="headerlink" title="7.6.1 基本的缺陷生命周期"></a>7.6.1 基本的缺陷生命周期</h3><p><img src="http://img.fdchen.host//%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%BA%E9%99%B7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image-20210526095141320"></p><h3 id="7-6-2-严重性和优先级"><a href="#7-6-2-严重性和优先级" class="headerlink" title="7.6.2 严重性和优先级"></a>7.6.2 严重性和优先级</h3><ul><li><strong>严重性</strong>（severity）衡量缺陷对客户满意度的影响程度：致命的（fatal）、严重的（critical）、一般的（major）、微小的（minor）</li><li><strong>优先级</strong>(Priority)：指缺陷被修复的紧急程度。立即解决P1、高优先级P2、正常排队P3、低优先级P4。</li></ul><h3 id="7-6-3-完整的缺陷信息"><a href="#7-6-3-完整的缺陷信息" class="headerlink" title="7.6.3 完整的缺陷信息"></a>7.6.3 完整的缺陷信息</h3><ul><li>前提</li><li>操作步骤</li><li>期望结果</li><li>实际结果</li><li>其他缺陷属性</li></ul>]]></content>
      
      
      <categories>
          
          <category> CQU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter</title>
      <link href="/2021/python-jupyter/"/>
      <url>/2021/python-jupyter/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Jupyter安装"><a href="#1-Jupyter安装" class="headerlink" title="1 Jupyter安装"></a>1 Jupyter安装</h1><h2 id="1-1-修改Jupyter默认文件及目录"><a href="#1-1-修改Jupyter默认文件及目录" class="headerlink" title="1.1 修改Jupyter默认文件及目录"></a>1.1 修改Jupyter默认文件及目录</h2><ul><li>详见博客：<a href="https://blog.csdn.net/yuanxiang01/article/details/79217469">修改Jupyter Notebook的默认工作目录</a></li></ul><h2 id="1-2-conda安装pytorch"><a href="#1-2-conda安装pytorch" class="headerlink" title="1.2 conda安装pytorch"></a>1.2 conda安装pytorch</h2><ul><li>详见博客：<a href="https://blog.csdn.net/zzq060143/article/details/88042075">pytorch快速安装【清华源】</a></li></ul><h2 id="1-3-Debug"><a href="#1-3-Debug" class="headerlink" title="1.3 Debug"></a>1.3 Debug</h2><h3 id="1-3-1-Jupyter-500-internal-server-error"><a href="#1-3-1-Jupyter-500-internal-server-error" class="headerlink" title="1.3.1 Jupyter 500 internal server error"></a>1.3.1 Jupyter 500 internal server error</h3><p>由于ipython或者<a href="https://so.csdn.net/so/search?q=jupyter&spm=1001.2101.3001.7020">jupyter</a> notebook某些包与Python版本不兼容的问题, 全更新了就好. </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip install -U &quot;ipython[all]&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>转载自：<a href="https://blog.csdn.net/qq_26684561/article/details/88875442">https://blog.csdn.net/qq_26684561/article/details/88875442</a></p><h1 id="2-Jupyter使用"><a href="#2-Jupyter使用" class="headerlink" title="2 Jupyter使用"></a>2 Jupyter使用</h1><h2 id="2-1-Jupyter快捷键"><a href="#2-1-Jupyter快捷键" class="headerlink" title="2.1 Jupyter快捷键"></a>2.1 Jupyter快捷键</h2><ul><li>详见博客：<a href="https://zhuanlan.zhihu.com/p/100020058">【jupyter】jupyter快捷键</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目管理</title>
      <link href="/2021/cqu-ruan-jian-xiang-mu-guan-li/"/>
      <url>/2021/cqu-ruan-jian-xiang-mu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总论"><a href="#1-总论" class="headerlink" title="1 总论"></a>1 总论</h1><h2 id="1-1-项目管理实施过程的四大挑战"><a href="#1-1-项目管理实施过程的四大挑战" class="headerlink" title="1.1 项目管理实施过程的四大挑战"></a>1.1 项目管理实施过程的四大挑战</h2><ol><li>项目定义中的问题</li><li>项目组织实施中的问题</li><li>项目控制中的问题</li><li>项目评价中的问题</li></ol><h2 id="1-2-项目起源"><a href="#1-2-项目起源" class="headerlink" title="1.2 项目起源"></a>1.2 项目起源</h2><ul><li>有组织活动的分类：</li></ul><ol><li>连续不断、周而复始的活动——运作(operation)</li><li>临时性、一次性的活动——项目(project)</li></ol><h2 id="1-3-项目定义"><a href="#1-3-项目定义" class="headerlink" title="1.3 项目定义"></a>1.3 项目定义</h2><ul><li>项目是独特的<ul><li>即使是同一张图纸盖两栋i相同的楼房也是两个项目，原因是有可能盖房的人变了，低级构造变了，或者盖房的时间变了等。</li></ul></li><li>第一个把项目作为一个系统来进行管理的是曼哈顿原子弹计划。</li></ul><h2 id="1-4-项目管理"><a href="#1-4-项目管理" class="headerlink" title="1.4 项目管理"></a>1.4 项目管理</h2><ul><li>项目管理(project management)就是把知识、技能、工具和技术应用于项目各项工作之中，实现或超过项目利害关系者对项目的要求和期望。</li><li>项目管理是一种管理方法体系，是一种已获得公认的管理项目的科学的管理模式，而不是任意的一次管理过程。</li></ul><h2 id="1-5-软件项目管理的特性"><a href="#1-5-软件项目管理的特性" class="headerlink" title="1.5 软件项目管理的特性"></a>1.5 软件项目管理的特性</h2><ul><li>首先，软件是纯知识产品，其开发进度和质量很难估计和度量，生产效率也难以预测和保证。</li><li>其次，软件系统的复杂性也导致了开发过程种各种风险的难以预见和控制。</li></ul><h2 id="1-6-如何区分项目性质的特征"><a href="#1-6-如何区分项目性质的特征" class="headerlink" title="1.6 如何区分项目性质的特征"></a>1.6 如何区分项目性质的特征</h2><ol><li>涉及非常规任务</li><li>需要策划</li><li>要满足特定的目标或要创造特点的产品</li><li>项目有预先确定的时间跨度</li><li>为别人工作而不是为自己工作</li><li>工作涉及到几个学科</li><li>工作分几个阶段进行</li><li>可用于项目的资源是受到限制的</li><li>项目庞大或者复杂</li></ol><ul><li>与其他项目产品相比，软件项目的产品具有某些不同的特征：不可见性、复杂性、一致性、灵活性。</li></ul><h1 id="2-软件项目计划"><a href="#2-软件项目计划" class="headerlink" title="2 软件项目计划"></a>2 软件项目计划</h1><ul><li>编制进度计划的三部曲<ul><li>任务分解(WBS)——范围基准</li><li>成本估算</li><li>资源、进度安排</li></ul></li></ul><h2 id="2-1-工作分解结构-WBS"><a href="#2-1-工作分解结构-WBS" class="headerlink" title="2.1 工作分解结构(WBS)"></a>2.1 工作分解结构(WBS)</h2><h3 id="2-1-1-WBS含义"><a href="#2-1-1-WBS含义" class="headerlink" title="2.1.1 WBS含义"></a>2.1.1 WBS含义</h3><ul><li>面向成果的项目元素的分组，组织并定义了整个项目范围</li><li>建立和确认项目范围，以便达成共识</li><li>工作元素经常被收集在WBS词典种，一般包括工作描述和其他项目信息</li></ul><h3 id="2-1-2-WBS用途"><a href="#2-1-2-WBS用途" class="headerlink" title="2.1.2 WBS用途"></a>2.1.2 WBS用途</h3><ul><li>确定工作范围</li><li>配备人员</li><li>编制资源计划</li><li>监视进程</li><li>明确阶段里程碑</li><li>具体内容的验证</li></ul><h3 id="2-1-3-WBS作用"><a href="#2-1-3-WBS作用" class="headerlink" title="2.1.3 WBS作用"></a>2.1.3 WBS作用</h3><ol><li>项目认知：WBS的层次结构为我们认识、把握复杂项目的逻辑关系提供了良好的工具；</li><li>良好协同：复杂的项目会遵循自上而下后自下而上的计划指定过程。两种计划的粒度和范围都是不一样的，但二者需要有机地结合起来行成统一的计划，WBS结构为这些信息提供了一个结构框架。</li><li>有效控制：WBS结构有助于界定范围。</li></ol><h3 id="2-1-4-WBS划分方法"><a href="#2-1-4-WBS划分方法" class="headerlink" title="2.1.4 WBS划分方法"></a>2.1.4 WBS划分方法</h3><ul><li>按专业划分<ul><li>优点是容易让人接收</li><li>缺点是不易协调</li></ul></li><li>按系统划分<ul><li>优点是容易界定项目范围</li><li>缺点是有时候不那么直观</li></ul></li><li>按照项目的不同阶段划分<ul><li>优点是有利于项目管理者控制中间结果</li></ul></li></ul><h3 id="2-1-5-WBS分解过程"><a href="#2-1-5-WBS分解过程" class="headerlink" title="2.1.5 WBS分解过程"></a>2.1.5 WBS分解过程</h3><ol><li>确认并分解项目的组成元素</li><li>确定分解标准</li><li>确定分解是否详细</li><li>确定项目交付成果</li><li>验证分解的正确性（建立编号）</li></ol><h3 id="2-1-6-检验分解结果的标准"><a href="#2-1-6-检验分解结果的标准" class="headerlink" title="2.1.6 检验分解结果的标准"></a>2.1.6 检验分解结果的标准</h3><ul><li>最底层的要素是否是实现目标的充分必要条件</li><li>最底层要素是否有重复的</li><li>每个要素是否清晰完整定义</li><li>最底层要素是否有定义清晰的责任人，是否可以进行成本估算和进度安排</li></ul><h3 id="2-1-7-WBS意义"><a href="#2-1-7-WBS意义" class="headerlink" title="2.1.7 WBS意义"></a>2.1.7 WBS意义</h3><ul><li>提供了项目范围基线，是范围变更的重要输入</li><li>为评估和分配任务提供具体的工作包</li><li>进行估算和编制项目进度的基础</li><li>对整个项目成功的集成和控制起到非常重要的作用</li></ul><h3 id="2-1-6-PMI定义WBS"><a href="#2-1-6-PMI定义WBS" class="headerlink" title="2.1.6 PMI定义WBS"></a>2.1.6 PMI定义WBS</h3><ul><li>是面向可交付成果的对项目元素的分组，它组织并定义了整个项目范围，不在WBS种包括的工作就不是该项目的工作。</li><li>它是一个分级的树型结构，是对项目由粗到细的分解过程。工作结构每细分一个层次表示对项目元素更细致的描述。</li></ul><h3 id="2-1-7-PMI定义工作包"><a href="#2-1-7-PMI定义工作包" class="headerlink" title="2.1.7 PMI定义工作包"></a>2.1.7 PMI定义工作包</h3><ul><li>WBS的最低层次的可交付成果。</li><li>工作包应当由唯一一个部分或承包商负责。</li><li>这一交付成果可以分配给另外一位项目经理进行计划和执行，或者通过子项目的方式完成。<ul><li>工作包可进一步分解为子项目的WBS或各个活动</li></ul></li></ul><h3 id="2-1-8-WBS类型"><a href="#2-1-8-WBS类型" class="headerlink" title="2.1.8 WBS类型"></a>2.1.8 WBS类型</h3><ul><li>清单</li></ul><p><img src="http://img.fdchen.host//WBS%E6%B8%85%E5%8D%95%E7%B1%BB%E5%9E%8B.png" alt="image-20210520153447645"></p><ul><li>图表</li></ul><p><img src="http://img.fdchen.host//WBS%E5%9B%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B.png" alt="image-20210520153527722"></p><h1 id="3-软件工作量估算"><a href="#3-软件工作量估算" class="headerlink" title="3 软件工作量估算"></a>3 软件工作量估算</h1><ul><li>要估算的内容包括：软件工作产品的规模、软件项目的工作量和成本、软件项目的进度、项目所需要的人员、计算机等资源。</li></ul><h2 id="3-1-软件项目的规模"><a href="#3-1-软件项目的规模" class="headerlink" title="3.1 软件项目的规模"></a>3.1 软件项目的规模</h2><h3 id="3-1-1-什么是软件项目的规模"><a href="#3-1-1-什么是软件项目的规模" class="headerlink" title="3.1.1 什么是软件项目的规模"></a>3.1.1 什么是软件项目的规模</h3><ul><li>现在常用的办法，是通过对软件程序的规模进行估算的办法，来间接反映软件项目的规模。</li><li>规模是工作量的一个方面，并不能说规模大，工作量就大。在这方面，并不一定是完全等同的。</li></ul><h2 id="3-2-软件项目规模估算方法"><a href="#3-2-软件项目规模估算方法" class="headerlink" title="3.2 软件项目规模估算方法"></a>3.2 软件项目规模估算方法</h2><h3 id="3-2-1-LOC法"><a href="#3-2-1-LOC法" class="headerlink" title="3.2.1 LOC法"></a>3.2.1 LOC法</h3><p>LOC指所有的可执行的源代码行数，包括可交付的工作控制语言(JCL: Job Control Language) 语句、数据定义、数据类型声明、等价声明、输入&#x2F;输出格式声明等。</p><p>单位编码行(1LOC) 的价值和人月均编码行数可以体现一个软件生产组织的生产能力。组织可以根据对历史项目的审计来核算组织的单行编码价值。</p><ul><li>例如，某软件公司统计发现该公司每一万行C语言源代码形成的源文件(. c和. h文件)约为250K。某项目的源文件大小为3.75M,则可估计该项目源编码大约为15万行，该项目累计投入工作量为240人月，每人月费用为10000元(包括人均工资、福利、办公费用公摊等)，则该项目中单位LOC的价值为:</li></ul><p><img src="http://img.fdchen.host//LOC%E6%B3%95%E4%BE%8B%E5%AD%90.png" alt="image-20210520154831483"></p><h3 id="3-2-2-Delphi法"><a href="#3-2-2-Delphi法" class="headerlink" title="3.2.2 Delphi法"></a>3.2.2 Delphi法</h3><p>Delphi法是最流行的专家评估技术，在没有历史数据的情况下，这种方式适用于评定过去与将来，新技术与特定程序之间的差别，但专家“专”的程度及对项目的理解程度是工作中的难点，尽管Delphi技术可以减轻这种偏差，专家评估技术在评定一个新软件实际成本时通常用得不多，但是，这种方式对决定其它模型的输入时特别有用。</p><p>Delphi法的步骤是: </p><ol><li>协调人向各专家提供项目规格和估计表格；</li><li>协调人召集小组会各专家讨论与规模相关的因素；</li><li>专家匿名填写迭代表格；</li><li>协调人整理出一个估计总结，以迭代表的形式返回专家；</li><li>协调人召集小组会，讨论较大的估计差异；</li><li>专家复查估计总结并在迭代表上提交另一个匿名估计；</li><li>重复4 6，直到达到一个最低和最高估计的一致。</li></ol><h3 id="3-2-3-类比法"><a href="#3-2-3-类比法" class="headerlink" title="3.2.3 类比法"></a>3.2.3 类比法</h3><p>类比法适合评估一些与历史项目在应用领域、环境和复杂度的相似的项目，通过新项目与历史项目的比较得到规模估计。类比法估计结果的精确度取决于历史项目数据的完整性和准确度。因此，用好类比法的前提条件之一是组织建立起较好的项目后评价与分析机制，对历史项目的数据分析是可信赖的。</p><p>类比法的基本步骤是:</p><ol><li>整理出项目功能列表和实现每个功能的编码行数；</li><li>标识出每个功能列表与历史项目的相同点和不同点，特别要注意历史项目做得不够的地方；</li><li>通过步骤1和2得出各个功能的估计值；</li><li>产生规模估计。</li></ol><h3 id="3-2-4-功能点技术"><a href="#3-2-4-功能点技术" class="headerlink" title="3.2.4 功能点技术"></a>3.2.4 功能点技术</h3><h4 id="3-2-4-1-信息域特性"><a href="#3-2-4-1-信息域特性" class="headerlink" title="3.2.4.1 信息域特性"></a>3.2.4.1 信息域特性</h4><p>产品信息域的5个特性：</p><ul><li>输入项数(Inp, EI)</li><li>输出项数(Out, EO)</li><li>查询数(Inq, EQ)</li><li>主文件数(Maf, ILF)</li><li>外部接口数(Inf, EIF)</li></ul><h4 id="3-2-4-2-功能点技术基本原理"><a href="#3-2-4-2-功能点技术基本原理" class="headerlink" title="3.2.4.2 功能点技术基本原理"></a>3.2.4.2 功能点技术基本原理</h4><p><img src="http://img.fdchen.host//%E5%8A%9F%E8%83%BD%E7%82%B9%E6%8A%80%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="image-20210520155840237"></p><h4 id="3-2-4-3-估算功能点的步骤"><a href="#3-2-4-3-估算功能点的步骤" class="headerlink" title="3.2.4.3 估算功能点的步骤"></a>3.2.4.3 估算功能点的步骤</h4><ol><li>计算未调整的功能点数CT</li></ol><p><img src="http://img.fdchen.host//%E8%AE%A1%E7%AE%97CT.png" alt="image-20210520160008182"></p><ol start="2"><li>计算技术复杂因子TCF</li></ol><p><img src="http://img.fdchen.host//%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E5%A4%8D%E6%9D%82%E5%9B%A0%E5%AD%90TCF.png" alt="image-20210520160105425"></p><p><img src="http://img.fdchen.host//%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%B0%E7%AE%97%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="image-20210520160145086"></p><h4 id="3-2-4-4-评价功能点技术"><a href="#3-2-4-4-评价功能点技术" class="headerlink" title="3.2.4.4 评价功能点技术"></a>3.2.4.4 评价功能点技术</h4><p>功能点技术没有涉及系统本身的算法复杂性。因此，它仅仅适合算法比较简单的事务处理软件的规模度量；对算法较复杂的大型软件系统并不适应。</p><h3 id="3-2-5-工作量估算"><a href="#3-2-5-工作量估算" class="headerlink" title="3.2.5 工作量估算"></a>3.2.5 工作量估算</h3><p>软件估算模型使用由经验导出的公式来预测软件开发工作量，其中，工作量是软件规模(L0C或FP)的函数，工作量的单位通常是人月(pm)。</p><h4 id="3-2-5-1-静态单变量模型"><a href="#3-2-5-1-静态单变量模型" class="headerlink" title="3.2.5.1 静态单变量模型"></a>3.2.5.1 静态单变量模型</h4><p><img src="http://img.fdchen.host//%E9%9D%99%E6%80%81%E5%8D%95%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F.png" alt="image-20210520160718950"></p><ul><li>面向KLOC的估算模型举例</li></ul><p><img src="http://img.fdchen.host//%E9%9D%A2%E5%90%91KLOC%E7%9A%84%E4%BC%B0%E7%AE%97%E6%A8%A1%E5%9E%8B%E4%B8%BE%E4%BE%8B.png" alt="image-20210520160813478"></p><ul><li>面向FP的估算模型举例</li></ul><p><img src="http://img.fdchen.host//%E9%9D%A2%E5%90%91FP%E7%9A%84%E4%BC%B0%E7%AE%97%E6%A8%A1%E5%9E%8B%E4%B8%BE%E4%BE%8B.png" alt="image-20210520160851955"></p><h4 id="3-2-5-2-动态多变量模型"><a href="#3-2-5-2-动态多变量模型" class="headerlink" title="3.2.5.2 动态多变量模型"></a>3.2.5.2 动态多变量模型</h4><p><img src="http://img.fdchen.host//%E5%8A%A8%E6%80%81%E5%A4%9A%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B.png" alt="image-20210520161045931"></p><p><img src="http://img.fdchen.host//%E5%8A%A8%E6%80%81%E5%A4%9A%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A.png" alt="image-20210520161152242"></p><h4 id="3-2-5-3-COCOMO模型"><a href="#3-2-5-3-COCOMO模型" class="headerlink" title="3.2.5.3 COCOMO模型"></a>3.2.5.3 COCOMO模型</h4><p>COCOMO模型给出了3个层次的工作量估算模型。这3个层次的模型在估算工作量时，对软件细节考虑的详尽程度逐级增加。这些模型既可以用于不同类型的项目，也可以用于同一个项目的不同开发阶段。这三个层次的估算模型分别是:</p><ul><li>基本COCOM0模型</li><li>中间COCOMO模型</li><li>详细COCOMO模型</li></ul><ol><li>COCOMO模型基本原理</li></ol><p><img src="http://img.fdchen.host//COCOMO%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="image-20210520161348780"></p><ul><li>每个成本因素根据它的重要程度和影响大小赋予一定的值，可以把这些成本因素划分为：产品因素、计算机因素、人员因素、项目因素。</li></ul><ol start="2"><li>基本COCOMO模型</li></ol><p><img src="http://img.fdchen.host//%E5%9F%BA%E6%9C%ACCOCOMO%E6%A8%A1%E5%9E%8B.png" alt="image-20210520161910939"></p><ol start="3"><li>中间COCOMO模型</li></ol><p><img src="http://img.fdchen.host//%E4%B8%AD%E9%97%B4COCOMO%E6%A8%A1%E5%9E%8B.png" alt="image-20210520162025095"></p><ol start="4"><li>详细COCOMO模型</li></ol><p><img src="http://img.fdchen.host//%E8%AF%A6%E7%BB%86COCOMO%E6%A8%A1%E5%9E%8B.png" alt="image-20210520162132691"></p><h1 id="4-质量管理"><a href="#4-质量管理" class="headerlink" title="4 质量管理"></a>4 质量管理</h1><h2 id="4-1-质量与质量特性"><a href="#4-1-质量与质量特性" class="headerlink" title="4.1 质量与质量特性"></a>4.1 质量与质量特性</h2><h3 id="4-1-1-质量的含义"><a href="#4-1-1-质量的含义" class="headerlink" title="4.1.1 质量的含义"></a>4.1.1 质量的含义</h3><ul><li>美国质量管理学家朱兰(J. M. Juran)博士认为：“质量就是产品的适用性，即产品在使用时能够满足用户需要的程度。“</li><li>国际标准化组织(ISO)在其《质量管理与质量保障术语》中对于质量的定义是：“ 质量是反映实体(产品、过程或活动等)满足明确的和隐含的需要的能力特性总和。”</li></ul><h3 id="4-1-2-质量的特性"><a href="#4-1-2-质量的特性" class="headerlink" title="4.1.2 质量的特性"></a>4.1.2 质量的特性</h3><p>质量特性就是产品或服务为满足人们明确或隐含的需要所具备的能力、属性和特征的总和。</p><ul><li>内在质量特性</li><li>外在质量特性</li><li>经济质量特性</li><li>商业质量特性</li><li>环保质量特性</li></ul><h3 id="4-1-3-质量管理"><a href="#4-1-3-质量管理" class="headerlink" title="4.1.3 质量管理"></a>4.1.3 质量管理</h3><p>质量管理是确定<strong>质量方针、目标和职责</strong>，并在质量体系中通过诸如质量计划、质量控制、质量保障和质量改进使质量得以实现的全部管理活动。</p><ul><li>最高管理者的质量管理决策(“质量方针、目标和职责”的制定)；</li><li>中层管理者对于质量管理的实施(“质量计划、质量控制、质量保障”等)；</li><li>基层管理者对于质量管理方针政策的贯彻执行(“质量改进”等)。</li></ul><h3 id="4-1-4-质量方针"><a href="#4-1-4-质量方针" class="headerlink" title="4.1.4 质量方针"></a>4.1.4 质量方针</h3><p>质量方针是由组织的最高管理者正式发布的一个组织总的质量宗旨和质量方向，是质量管理的<strong>核心和出发点</strong>。</p><h3 id="4-1-5-质量体系"><a href="#4-1-5-质量体系" class="headerlink" title="4.1.5 质量体系"></a>4.1.5 质量体系</h3><p>质量体系是为实施质量管理所需的组织结构、程序、过程和资源的总称。</p><h3 id="4-1-6-质量计划"><a href="#4-1-6-质量计划" class="headerlink" title="4.1.6 质量计划"></a>4.1.6 质量计划</h3><p>质量计划是确定质量的目标和要求，以及确定采用质量体系要素的目标和要求的活动的过程。</p><h3 id="4-1-7-质量控制"><a href="#4-1-7-质量控制" class="headerlink" title="4.1.7 质量控制"></a>4.1.7 质量控制</h3><p>质量控制是为达到质量要求所采取的作业技术与活动，其内容包括：确定控制对象、规定控制标准、制定控制方法、选用检验技术、处理事故(失控)等等。</p><h3 id="4-1-8-质量保障"><a href="#4-1-8-质量保障" class="headerlink" title="4.1.8 质量保障"></a>4.1.8 质量保障</h3><p>质量保障是为了保障实体能够满足质量要求，并提供足够的证明以表明实体保障能够满足质量要求,而在质量体系中实施，并根据需要进行证实的、全部有计划和有系统的活动。</p><h3 id="4-1-9-质量改进"><a href="#4-1-9-质量改进" class="headerlink" title="4.1.9 质量改进"></a>4.1.9 质量改进</h3><p>质量改进是为向本组织及其顾客提供更多的收益，在整个组织内所采取的旨在提高活动和过程的效益和效率的各种措施。</p><p><img src="http://img.fdchen.host//%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image-20210520233625716"></p><h2 id="4-2-项目的全面质量管理"><a href="#4-2-项目的全面质量管理" class="headerlink" title="4.2 项目的全面质量管理"></a>4.2 项目的全面质量管理</h2><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%85%A8%E9%9D%A2%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86.png" alt="image-20210520233717881"></p><h3 id="4-2-1-全面质量管理的指导思想"><a href="#4-2-1-全面质量管理的指导思想" class="headerlink" title="4.2.1 全面质量管理的指导思想"></a>4.2.1 全面质量管理的指导思想</h3><ul><li>一是整个组织要以质量为核心；</li><li>二是组织的每个员工要积极参与全面质量管理。</li></ul><h3 id="4-2-2-全面质量管理的核心观念"><a href="#4-2-2-全面质量管理的核心观念" class="headerlink" title="4.2.2 全面质量管理的核心观念"></a>4.2.2 全面质量管理的核心观念</h3><ol><li>质量是由客户定义的</li><li>质量是干出来的，不是检验出来的</li><li>质量管理是全体员工的责任</li><li>质量管理的关键是不断地改进和提高</li></ol><h3 id="4-3-戴明环——PDCA循环"><a href="#4-3-戴明环——PDCA循环" class="headerlink" title="4.3 戴明环——PDCA循环"></a>4.3 戴明环——PDCA循环</h3><p><img src="http://img.fdchen.host//%E6%88%B4%E6%98%8E%E7%8E%AF-PDCA%E5%BE%AA%E7%8E%AF.png" alt="image-20210520234142201"></p><ul><li>P(plan)——计划</li><li>D(do)——执行</li><li>C(check)——检查</li><li>A(action)——处理</li></ul><h2 id="4-4-项目质量计划的编制"><a href="#4-4-项目质量计划的编制" class="headerlink" title="4.4 项目质量计划的编制"></a>4.4 项目质量计划的编制</h2><h3 id="4-4-1-项目质量计划的编制依据"><a href="#4-4-1-项目质量计划的编制依据" class="headerlink" title="4.4.1 项目质量计划的编制依据"></a>4.4.1 项目质量计划的编制依据</h3><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E8%AE%A1%E5%88%92%E7%9A%84%E7%BC%96%E5%88%B6.png" alt="image-20210520234446432"></p><h3 id="4-4-2-项目质量计划编制的方法和技术"><a href="#4-4-2-项目质量计划编制的方法和技术" class="headerlink" title="4.4.2 项目质量计划编制的方法和技术"></a>4.4.2 项目质量计划编制的方法和技术</h3><ol><li>成本&#x2F;收益分析法，这也叫经济质量法</li><li>质量标杆法</li><li>流程图</li><li>实验设计法</li></ol><h2 id="4-5-项目质量、成本、进度之间的关系"><a href="#4-5-项目质量、成本、进度之间的关系" class="headerlink" title="4.5 项目质量、成本、进度之间的关系"></a>4.5 项目质量、成本、进度之间的关系</h2><h3 id="4-5-1-项目质量、成本、进度之间的关系"><a href="#4-5-1-项目质量、成本、进度之间的关系" class="headerlink" title="4.5.1 项目质量、成本、进度之间的关系"></a>4.5.1 项目质量、成本、进度之间的关系</h3><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E3%80%81%E6%88%90%E6%9C%AC%E3%80%81%E8%BF%9B%E5%BA%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image-20210520234730637"></p><ul><li>成本、质量、工期是项目管理的三大基本目标，这三个要素之间存在相互制约的关系。</li></ul><h3 id="4-5-2-项目质量成本的构成及相互关系"><a href="#4-5-2-项目质量成本的构成及相互关系" class="headerlink" title="4.5.2 项目质量成本的构成及相互关系"></a>4.5.2 项目质量成本的构成及相互关系</h3><p>高质量对项目成本的影响：</p><ul><li><p>一方面表现为更详细更多的活动和任务，从而需要更多的任务预算或成本；</p></li><li><p>另一方面，项目的高质量也意味着需要更高的质量成本。</p><p>这里的质量成本包括为了预防质量问题发生而采取相应措施支付的费用，以及质量问题发生后采取相应措施的费用。前者叫<strong>质量保障成本</strong>，后者叫<strong>质量故障成本</strong>。</p></li></ul><p><img src="http://img.fdchen.host//%E8%B4%A8%E9%87%8F%E6%88%90%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="image-20210520235125320"></p><h2 id="4-6-项目质量保障内容"><a href="#4-6-项目质量保障内容" class="headerlink" title="4.6 项目质量保障内容"></a>4.6 项目质量保障内容</h2><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E6%8A%A5%E8%B4%A6%E5%86%85%E5%AE%B9.png" alt="image-20210520235213556"></p><h2 id="4-7-项目的质量控制"><a href="#4-7-项目的质量控制" class="headerlink" title="4.7 项目的质量控制"></a>4.7 项目的质量控制</h2><h3 id="4-7-1-项目质量控制概念"><a href="#4-7-1-项目质量控制概念" class="headerlink" title="4.7.1 项目质量控制概念"></a>4.7.1 项目质量控制概念</h3><p>项目的质量控制主要是监督项目的实施结果以决定它们是否符合相关的质量标准及确定排除不满意结果原因的方法。</p><p>这项工作的主要内容包括：</p><ul><li>项目质量实际情况的度量</li><li>项目质量实际与项目质量标准的比较</li><li>项目质量误差与问题的确认，</li><li>项目质量问题的原因分析和采取纠偏措施去消除项目质量差距与问题的一系列活动</li></ul><h3 id="4-7-2-质量控制与质量保障的区别"><a href="#4-7-2-质量控制与质量保障的区别" class="headerlink" title="4.7.2 质量控制与质量保障的区别"></a>4.7.2 质量控制与质量保障的区别</h3><ul><li><strong>项目质量保障</strong>是一种从项目质量管理组织、程序、方法和资源等方面为项目质量保驾护航的工作，是一种<strong>预防性、提高性和保障性</strong>的质量管理活动；</li><li><strong>项目质量控制</strong>是直接对项目质量进行把关的工作，是一种<strong>过程性、纠偏性和把关性</strong>的质量管理活动。</li></ul><h3 id="4-7-3-项目质量控制的依据"><a href="#4-7-3-项目质量控制的依据" class="headerlink" title="4.7.3 项目质量控制的依据"></a>4.7.3 项目质量控制的依据</h3><ol><li>工作结果</li><li>质量管理计划</li><li>操作定义</li><li>检查表：用于核实一系列要求的步骤是否已经实施的结构化工具。</li></ol><h3 id="4-7-4-项目质量控制的方法"><a href="#4-7-4-项目质量控制的方法" class="headerlink" title="4.7.4 项目质量控制的方法"></a>4.7.4 项目质量控制的方法</h3><ol><li>检查</li><li>新老7种控制工具</li><li>统计抽样</li><li>趋势分析</li></ol><h3 id="4-7-5-项目质量控制的结果"><a href="#4-7-5-项目质量控制的结果" class="headerlink" title="4.7.5 项目质量控制的结果"></a>4.7.5 项目质量控制的结果</h3><ol><li>产品或服务的质量获得提高；</li><li>做出验收决定；</li><li>对不符合要求的项目或工作包返工；</li><li>得到完成的检查表；</li><li>根据客户的要求，对项目进行调整等等。</li></ol><h2 id="4-8-质量控制的7种工具"><a href="#4-8-质量控制的7种工具" class="headerlink" title="4.8 质量控制的7种工具"></a>4.8 质量控制的7种工具</h2><ul><li>利用数理统计方法控制质量的步骤</li></ul><p><img src="http://img.fdchen.host//%E5%88%A9%E7%94%A8%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E6%8E%A7%E5%88%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E6%AD%A5%E9%AA%A4.png" alt="image-20210521000039830"></p><ul><li>数理统计方法的7种工具：</li></ul><ol><li>统计分析法</li><li>数据分层法</li><li>散布图</li><li>帕累托图</li><li>因果分析图</li><li>直方图</li><li>控制图</li></ol><ul><li>质量管理的新7种工具：</li></ul><ol><li>关联图法</li><li>系统图法</li><li>矩阵图法</li><li>数据矩阵分析法</li><li>网络图法</li><li>PDPC（过程决策程序图）法</li><li>KJ（川西田二郎）法</li></ol><p>“新7种工具”，不是对前述老7种工具”的替代，而是对它的补充。老7种工具强调用数据说话，重视对过程的质量控制；新7种工具基本上是用来分析语言文字资料(非数据)的，着重解决全面质量管理(TQM)中PDCA循环的P(计划)阶段的有关问题。</p><h2 id="4-9-因果图和控制图"><a href="#4-9-因果图和控制图" class="headerlink" title="4.9 因果图和控制图"></a>4.9 因果图和控制图</h2><p><img src="http://img.fdchen.host//%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%9B%A0%E6%9E%9C%E5%9B%BE%E5%92%8C%E6%8E%A7%E5%88%B6%E5%9B%BE%E7%A4%BA%E4%BE%8B.png" alt="image-20210521000628055"></p><h1 id="5-项目沟通管理"><a href="#5-项目沟通管理" class="headerlink" title="5 项目沟通管理"></a>5 项目沟通管理</h1><h2 id="5-1-项目沟通的作用"><a href="#5-1-项目沟通的作用" class="headerlink" title="5.1 项目沟通的作用"></a>5.1 项目沟通的作用</h2><ol><li>项目决策和计划的基础</li><li>项目组织和控制的依据和手段</li><li>建立和改善人际关系是必不可少的条件</li><li>项目经理成功领导的重要手段</li></ol><h2 id="5-2-项目沟通计划的编制"><a href="#5-2-项目沟通计划的编制" class="headerlink" title="5.2 项目沟通计划的编制"></a>5.2 项目沟通计划的编制</h2><h3 id="5-2-1-项目沟通计划"><a href="#5-2-1-项目沟通计划" class="headerlink" title="5.2.1 项目沟通计划"></a>5.2.1 项目沟通计划</h3><p>沟通计划就是确定项目利害关系者的信息交流沟通的要求。</p><h3 id="5-2-2-项目沟通计划的编制"><a href="#5-2-2-项目沟通计划的编制" class="headerlink" title="5.2.2 项目沟通计划的编制"></a>5.2.2 项目沟通计划的编制</h3><ol><li>沟通需求</li><li>沟通技术</li><li>制约因素和假设</li></ol><h3 id="5-2-3-项目沟通计划内容"><a href="#5-2-3-项目沟通计划内容" class="headerlink" title="5.2.3 项目沟通计划内容"></a>5.2.3 项目沟通计划内容</h3><ol><li>信息收集渠道的结构</li><li>信息分发渠道的结构</li><li>分发信息的形式</li><li>日程表</li><li>更新和细化的方法</li></ol><h2 id="5-3-项目沟通过程"><a href="#5-3-项目沟通过程" class="headerlink" title="5.3 项目沟通过程"></a>5.3 项目沟通过程</h2><ol><li>确定想法</li><li>编码</li><li>选择渠道</li><li>传送信息</li><li>接收信息</li><li>解码</li><li>理解</li><li>反馈</li></ol><h2 id="5-4-正式沟通的5种类型"><a href="#5-4-正式沟通的5种类型" class="headerlink" title="5.4 正式沟通的5种类型"></a>5.4 正式沟通的5种类型</h2><p><img src="http://img.fdchen.host//%E6%AD%A3%E5%BC%8F%E6%B2%9F%E9%80%9A%E7%9A%84%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B.png" alt="image-20210521025043609"></p><h2 id="5-5-非正式沟通4种模式"><a href="#5-5-非正式沟通4种模式" class="headerlink" title="5.5 非正式沟通4种模式"></a>5.5 非正式沟通4种模式</h2><p><img src="http://img.fdchen.host//%E9%9D%9E%E6%AD%A3%E5%BC%8F%E6%B2%9F%E9%80%9A4%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" alt="image-20210521025143348"></p><blockquote><p>戴维斯的研究结果表明，小道消息传播的最普通形式是集束式。</p></blockquote><h2 id="5-6-会议沟通的类型及内容"><a href="#5-6-会议沟通的类型及内容" class="headerlink" title="5.6 会议沟通的类型及内容"></a>5.6 会议沟通的类型及内容</h2><p>项目沟通中最常用的会议有3种：</p><ul><li>项目情况评审会议</li><li>项目问题解决会议</li><li>项目技术评审会议</li></ul><h2 id="5-7-项目沟通存在的主要障碍"><a href="#5-7-项目沟通存在的主要障碍" class="headerlink" title="5.7 项目沟通存在的主要障碍"></a>5.7 项目沟通存在的主要障碍</h2><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E6%B2%9F%E9%80%9A%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E9%9A%9C%E7%A2%8D.png" alt="image-20210521025530908"></p><h2 id="5-8-有效沟通的方法"><a href="#5-8-有效沟通的方法" class="headerlink" title="5.8 有效沟通的方法"></a>5.8 有效沟通的方法</h2><p>沟通是否成功，取决于发信者想要表达的意义与接信者通过理解而获得的意义是否一致。</p><ul><li>改善沟通的一般思路：</li></ul><ol><li>重视双向沟通</li><li>多种沟通渠道并用</li><li>正确运用文字语言</li></ol><h2 id="5-9-沟通术语的规范化"><a href="#5-9-沟通术语的规范化" class="headerlink" title="5.9 沟通术语的规范化"></a>5.9 沟通术语的规范化</h2><p>在沟通信息时，应该尽量注意信息的完整性、正确性、可检验等特征。</p><h1 id="6-软件开发中人员管理"><a href="#6-软件开发中人员管理" class="headerlink" title="6 软件开发中人员管理"></a>6 软件开发中人员管理</h1><h2 id="6-1-信息系统开发人员分类与其职责"><a href="#6-1-信息系统开发人员分类与其职责" class="headerlink" title="6.1 信息系统开发人员分类与其职责"></a>6.1 信息系统开发人员分类与其职责</h2><ol><li>项目投资人：高层领导，批准并支持系统的管理人员；</li><li>项目经理：负责系统总体职责的管理人员；</li><li>项目领导：技术队伍的协调者；</li><li>技术人员：所有指派到项目中的开发人员和技术职员：</li><li>最终用户：那些作为他们的日常工作来操作该系统的人：</li><li>最终用户开发者：来自最终用户组参加开发队的非系统人员；</li><li>系统设计师：总体技术设计人 员；</li><li>应用分析员：复审最终用户需求并定义系统说明的人；</li><li>数据库管理员：数据库的管理人员；</li><li>数据管理员：负责命名和控制数据元素名和内容的人；</li><li>界面设计者：决定最佳人一机接口方法和风格的专业技术人员；</li><li>网络设计师：负责通过数据通讯工具和协议把所有系统成份集成起来的专业技术人员；</li><li>文档人员：开发用户手册、帮助程序和系统的技术说明的专业技术人员；</li><li>系统测试人员：进行系统单元测试和联合测试的人员。</li></ol><h2 id="6-2-软件项目组"><a href="#6-2-软件项目组" class="headerlink" title="6.2 软件项目组"></a>6.2 软件项目组</h2><ul><li>软件工程小组的组织方式：<ul><li>民主分权式(Democratic Decentralized, DD)</li><li>控制分权式(Controlled Decentralized, CD)</li><li>控制集权式(Controlled Centralized, CC)</li></ul></li><li>软件工程小组的组织范型：<ul><li>封闭式范型（类似CC小组）</li><li>随机式范型</li><li>开放式范型</li><li>同步式范型</li></ul></li></ul><h1 id="7-软件项目进度计划"><a href="#7-软件项目进度计划" class="headerlink" title="7 软件项目进度计划"></a>7 软件项目进度计划</h1><h2 id="7-1-进度管理基本概念"><a href="#7-1-进度管理基本概念" class="headerlink" title="7.1 进度管理基本概念"></a>7.1 进度管理基本概念</h2><h3 id="7-1-1-进度与任务的定义"><a href="#7-1-1-进度与任务的定义" class="headerlink" title="7.1.1 进度与任务的定义"></a>7.1.1 进度与任务的定义</h3><ul><li>进度是对执行的活动和里程碑制定的工作计划日期表。</li><li>任务是完成项目的各个交付成果所必须进行的诸项具体活动。</li></ul><h3 id="7-1-2-项目任务的关联关系"><a href="#7-1-2-项目任务的关联关系" class="headerlink" title="7.1.2 项目任务的关联关系"></a>7.1.2 项目任务的关联关系</h3><p><img src="http://img.fdchen.host//%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image-20210520163654745"></p><h3 id="7-1-3-任务之间关联关系的依据"><a href="#7-1-3-任务之间关联关系的依据" class="headerlink" title="7.1.3 任务之间关联关系的依据"></a>7.1.3 任务之间关联关系的依据</h3><ul><li>强制性依赖关系</li><li>软逻辑关系</li><li>外部依赖关系</li></ul><h3 id="7-1-4-进度管理图示"><a href="#7-1-4-进度管理图示" class="headerlink" title="7.1.4 进度管理图示"></a>7.1.4 进度管理图示</h3><h4 id="7-1-4-1-网络图"><a href="#7-1-4-1-网络图" class="headerlink" title="7.1.4.1 网络图"></a>7.1.4.1 网络图</h4><ul><li>PDM(Precedence Diagramming Method)，优先图法，节点法（单代号）网络图</li></ul><p><img src="http://img.fdchen.host//PDM%E5%9B%BE%E4%BE%8B.png" alt="image-20210520164131077"></p><p>构成PDM网络图的基本特点是节点(Box)，节点表示活动（任务），用箭线表示各活动（任务）之间的逻辑关系，可以方便的表示活动之间的各种逻辑关系。</p><ul><li>ADM(Arrow Diagramming Method)，箭线法（双代号）网络图</li></ul><p><img src="http://img.fdchen.host//ADM%E5%9B%BE%E4%BE%8B.png" alt="image-20210520164342154"></p><p>ADM也称为双代号项目网络图，在ADM网络图中，箭线表示活动（任务），两个代号唯一确定一个任务，代号表示前一任务的结束，同时也表示后一任务的开始。</p><h4 id="7-1-4-2-甘特图"><a href="#7-1-4-2-甘特图" class="headerlink" title="7.1.4.2 甘特图"></a>7.1.4.2 甘特图</h4><p><img src="http://img.fdchen.host//%E7%94%98%E7%89%B9%E5%9B%BE%E7%A4%BA%E4%BE%8B.png" alt="image-20210520164840222"></p><h4 id="7-1-4-3-里程碑图"><a href="#7-1-4-3-里程碑图" class="headerlink" title="7.1.4.3 里程碑图"></a>7.1.4.3 里程碑图</h4><p><img src="http://img.fdchen.host//%E9%87%8C%E7%A8%8B%E7%A2%91%E5%9B%BE%E7%A4%BA.png" alt="image-20210520164906879"></p><h4 id="7-1-4-4-资源图"><a href="#7-1-4-4-资源图" class="headerlink" title="7.1.4.4 资源图"></a>7.1.4.4 资源图</h4><p><img src="http://img.fdchen.host//%E8%B5%84%E6%BA%90%E5%9B%BE%E5%9B%BE%E7%A4%BA.png" alt="image-20210520164926205"></p><h2 id="7-2-任务历时估算"><a href="#7-2-任务历时估算" class="headerlink" title="7.2 任务历时估算"></a>7.2 任务历时估算</h2><p>估计任务、路径、项目的持续时间。</p><h3 id="7-2-1-历时估算的基本方法"><a href="#7-2-1-历时估算的基本方法" class="headerlink" title="7.2.1 历时估算的基本方法"></a>7.2.1 历时估算的基本方法</h3><h4 id="7-2-1-1-定额估算法"><a href="#7-2-1-1-定额估算法" class="headerlink" title="7.2.1.1 定额估算法"></a>7.2.1.1 定额估算法</h4><p><img src="http://img.fdchen.host//%E5%AE%9A%E9%A2%9D%E4%BC%B0%E7%AE%97%E6%B3%95.png" alt="image-20210520165133550"></p><h4 id="7-2-1-2-经验导出模型"><a href="#7-2-1-2-经验导出模型" class="headerlink" title="7.2.1.2 经验导出模型"></a>7.2.1.2 经验导出模型</h4><p><img src="http://img.fdchen.host//%E7%BB%8F%E9%AA%8C%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9E%8B.png" alt="image-20210520165257261"></p><ul><li>建议掌握模型</li></ul><p><img src="http://img.fdchen.host//%E7%BB%8F%E9%AA%8C%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9E%8B-%E5%BB%BA%E8%AE%AE%E6%8E%8C%E6%8F%A1%E6%A8%A1%E5%9E%8B.png" alt="image-20210520165406346"></p><h4 id="7-2-1-3-CPM关键路径法估计"><a href="#7-2-1-3-CPM关键路径法估计" class="headerlink" title="7.2.1.3 CPM关键路径法估计"></a>7.2.1.3 CPM关键路径法估计</h4><ol><li>确定项目网络图</li><li>每个任务有单一的历时估算</li><li>确定网络图中任务的逻辑关系</li><li><strong>关键路径是网络图中最长的路径</strong></li><li>关键路径可以确定项目完成时间</li></ol><p><img src="http://img.fdchen.host//%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95%E4%BC%B0%E8%AE%A1%E5%AE%9E%E4%BE%8B.png" alt="image-20210520165755434"></p><blockquote><p>100天</p></blockquote><h4 id="7-2-1-3-PERT工程评估评审技术"><a href="#7-2-1-3-PERT工程评估评审技术" class="headerlink" title="7.2.1.3 PERT工程评估评审技术"></a>7.2.1.3 PERT工程评估评审技术</h4><ul><li>加权算法估算任务历史</li><li>采用加权平均得到期望值 E &#x3D; ( O +4M +P) &#x2F; 6,<ul><li>O是最小估算值：乐观Optimistic</li><li>P是最大估算值：悲观Pessimistic</li><li>M是最大可能估算：Most Likely</li></ul></li><li>PERT的风险指标</li></ul><p><img src="http://img.fdchen.host//PERT%E7%9A%84%E9%A3%8E%E9%99%A9%E6%8C%87%E6%A0%87.png" alt="image-20210520175530545"></p><ul><li><strong>PERT评估存在多个活动的一条路径</strong></li></ul><p><img src="http://img.fdchen.host//PERT%E8%AF%84%E4%BC%B0%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%B4%BB%E5%8A%A8%E7%9A%84%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84.png" alt="image-20210520175619588"></p><ul><li><strong>PERT举例</strong></li></ul><p><img src="http://img.fdchen.host//PERT%E4%B8%BE%E4%BE%8B-1.png" alt="image-20210520175835161"></p><p><img src="http://img.fdchen.host//PERT%E6%8A%80%E6%9C%AF-%E6%A0%87%E5%87%86%E5%B7%AE%E7%9A%84%E6%A6%82%E7%8E%87%E7%90%86%E8%AE%BA.png" alt="image-20210520175852187"></p><p><img src="http://img.fdchen.host//PERT%E4%B8%BE%E4%BE%8B-2.png" alt="image-20210520175946058"></p><p><img src="http://img.fdchen.host//PERT%E4%B8%BE%E4%BE%8B-3.png" alt="image-20210520180008543"></p><blockquote><p>84.2%</p></blockquote><h4 id="7-2-1-4-基于承诺的进度评估"><a href="#7-2-1-4-基于承诺的进度评估" class="headerlink" title="7.2.1.4 基于承诺的进度评估"></a>7.2.1.4 基于承诺的进度评估</h4><p>要求开发人员做出进度承诺，不进行中间的工作量（规模）估计</p><p>优点：</p><ul><li>有利于开发者对进度关注</li><li>有利于开发者在接受承诺后士气高昂</li></ul><p>缺点：</p><ul><li>易于产生大的估算误差</li></ul><h4 id="7-2-1-5-Jones的一阶估算准则"><a href="#7-2-1-5-Jones的一阶估算准则" class="headerlink" title="7.2.1.5 Jones的一阶估算准则"></a>7.2.1.5 Jones的一阶估算准则</h4><ul><li>幂次表<ul><li>系统软件</li><li>商业软件</li><li>封装商品软件</li></ul></li><li>估算项目功能点</li><li>从幂次表中选择合适的幂次将功能点升幂</li></ul><h2 id="7-3-进度计划编排"><a href="#7-3-进度计划编排" class="headerlink" title="7.3 进度计划编排"></a>7.3 进度计划编排</h2><h3 id="7-3-1-关键路径法"><a href="#7-3-1-关键路径法" class="headerlink" title="7.3.1 关键路径法"></a>7.3.1 关键路径法</h3><h4 id="7-3-1-1-基本概念"><a href="#7-3-1-1-基本概念" class="headerlink" title="7.3.1.1 基本概念"></a>7.3.1.1 基本概念</h4><ul><li>最早开始时间Early start</li><li>最晚开始时间Late start</li><li>最早完成时间Early finish</li><li>最晚完成时间Late finish</li></ul><p><img src="http://img.fdchen.host//%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92%E7%BC%96%E6%8E%92ES%E3%80%81EF%E3%80%81LS%E3%80%81LF.png" alt="image-20210520183343038"></p><ul><li>浮动时间：浮动时间是一个任务的机动性，它是一个任务在不影响其他任务或者项目完成的情况下可以延迟的时间量。</li><li>总浮动Total Float：在不延误项目完成日期或违反进度制约因素的前提下，一个可以推迟的总时间量。<ul><li>总浮动时间 &#x3D; 最晚开始时间-最早开始时间 &#x3D; 最晚完成时间-最早完成时间</li></ul></li><li>自由浮动Free Float：在不影响后置任务最早开始时间的前提下，一个任务可以延迟的时间。<ul><li>后续活动的最早开始时间 - 本活动的最早完成时间</li></ul></li></ul><p>浮动时间示例：</p><p><img src="http://img.fdchen.host//%E6%B5%AE%E5%8A%A8%E6%97%B6%E9%97%B4%E7%A4%BA%E4%BE%8B.png" alt="image-20210520192325398"></p><ul><li>滞后Lag</li></ul><p><img src="http://img.fdchen.host//%E6%BB%9E%E5%90%8ELag.png" alt="image-20210520192505245"></p><ul><li>超前Lead</li></ul><p><img src="http://img.fdchen.host//%E4%BB%BB%E5%8A%A1%E8%B6%85%E5%89%8D%E7%A4%BA%E4%BE%8B.png" alt="image-20210520192539660"></p><h4 id="7-3-1-2-关键路径Critical-Path"><a href="#7-3-1-2-关键路径Critical-Path" class="headerlink" title="7.3.1.2 关键路径Critical Path"></a>7.3.1.2 关键路径Critical Path</h4><ul><li>时间浮动为0(Float&#x3D;0)的路径（ES&#x3D;LS, EF&#x3D;LF）</li><li>网络图中最长的路径</li><li>关键路径是决定项目完成的最短时间</li><li>关键路径上的任何活动延迟，都会导致整个项目完成时间的延迟</li><li>关键路径可能不止一条</li></ul><p><img src="http://img.fdchen.host//%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%A4%BA%E4%BE%8B.png" alt="image-20210520192839609"></p><h4 id="7-3-1-3-正推法"><a href="#7-3-1-3-正推法" class="headerlink" title="7.3.1.3 正推法"></a>7.3.1.3 正推法</h4><p>按照时间顺序计算最早开始时间和最早完成时间的方法，称为正推法。</p><ol><li>确定项目的开始时间</li><li>从左到右，从上到下</li><li>计算每个人物的最早开始时间ES和最早完成时间EF：<ul><li>网络图中第一个任务的最早开始时间是项目的开始时间；</li><li>ES+DUration&#x3D;EF(本任务)</li><li>EF(前任务)+Lag&#x3D;ES(后任务)</li><li>当一个任务有多个前置任务时，选择<strong>前置任务中最大的EF加上Lag作为其ES</strong>。</li></ul></li></ol><p><img src="http://img.fdchen.host//%E6%AD%A3%E6%8E%A8%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="image-20210520195749243"></p><h4 id="7-3-1-4-逆推法"><a href="#7-3-1-4-逆推法" class="headerlink" title="7.3.1.4 逆推法"></a>7.3.1.4 逆推法</h4><p>按照逆时间顺序计算最晚开始时间和最晚结束时间的方法,称为逆推法。</p><ol><li>确定项目的结束时间</li><li>从右到左，从上到下</li><li>计算每个任务的最晚开始时间LS和最晚完成时间LF：<ul><li>网络图中最后一个任务最晚完成时间是项目的结束时间；</li><li>LF - Duration&#x3D;LS(本任务)</li><li>LS(本任务) - Lag &#x3D; LF(前任务)</li><li>当一个任务有多个后置任务时，选择其后置任务中最小LS减Lag作为其LF</li></ul></li></ol><p><img src="http://img.fdchen.host//%E9%80%86%E6%8E%A8%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="image-20210520200254610"></p><h4 id="7-3-1-5-小练习"><a href="#7-3-1-5-小练习" class="headerlink" title="7.3.1.5 小练习"></a>7.3.1.5 小练习</h4><p><img src="http://img.fdchen.host//%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95%E7%BB%83%E4%B9%A0-1.png" alt="image-20210520200828970"></p><p><img src="http://img.fdchen.host//%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95%E7%BB%83%E4%B9%A0-2.png" alt="image-20210520200902062"></p><p><img src="http://img.fdchen.host//%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E6%B3%95%E7%BB%83%E4%B9%A0-3.png" alt="image-20210520200926766"></p><h3 id="7-3-2-时间压缩法"><a href="#7-3-2-时间压缩法" class="headerlink" title="7.3.2 时间压缩法"></a>7.3.2 时间压缩法</h3><p>时间压缩发是在不改变项目范围的前提下缩短项目工期的方法。</p><h4 id="7-3-2-1-应急法——赶工-Crash"><a href="#7-3-2-1-应急法——赶工-Crash" class="headerlink" title="7.3.2.1 应急法——赶工(Crash)"></a>7.3.2.1 应急法——赶工(Crash)</h4><ul><li>在最小相关成本增加的条件下，压缩关键路经上的关键活动历时的方法。</li><li>赶工也称为时间-成本平衡方法。</li></ul><p><img src="http://img.fdchen.host//%E8%B5%B6%E5%B7%A5%E6%97%B6%E9%97%B4%E4%B8%8E%E8%B5%B6%E5%B7%A5%E6%88%90%E6%9C%AC%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="image-20210520202139502"></p><ul><li>进度压缩单位成本 &#x3D; （压缩成本 - 正常成本）&#x2F; （正常进度 - 压缩进度）</li></ul><p><img src="http://img.fdchen.host//%E8%BF%9B%E5%BA%A6%E5%8E%8B%E7%BC%A9%E6%88%90%E6%9C%AC%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98.png" alt="image-20210520202422055"></p><ul><li>时间压缩例题</li></ul><p><img src="http://img.fdchen.host//%E6%97%B6%E9%97%B4%E5%8E%8B%E7%BC%A9%E4%BE%8B%E9%A2%98-1.png" alt="image-20210520202807153"></p><p><img src="C:/Users/fdChen/AppData/Roaming/Typora/typora-user-images/image-20210520202823345.png" alt="image-20210520202823345"></p><p><img src="http://img.fdchen.host//%E6%97%B6%E9%97%B4%E5%8E%8B%E7%BC%A9%E4%BE%8B%E9%A2%98-3.png" alt="image-20210520202858494"></p><p><img src="http://img.fdchen.host//%E6%97%B6%E9%97%B4%E5%8E%8B%E7%BC%A9%E4%BE%8B%E9%A2%98-4.png" alt="image-20210520203005953"></p><p><img src="http://img.fdchen.host//%E6%97%B6%E9%97%B4%E5%8E%8B%E7%BC%A9%E4%BE%8B%E9%A2%98-5.png" alt="image-20210520203022662"></p><p><img src="http://img.fdchen.host//%E6%97%B6%E9%97%B4%E5%8E%8B%E7%BC%A9%E4%BE%8B%E9%A2%98-6.png" alt="image-20210520203057560"></p><ul><li>Charles Symons方法</li></ul><p><img src="http://img.fdchen.host//Charles%20Symons%E6%96%B9%E6%B3%95.png" alt="image-20210520203255137"></p><h4 id="7-3-2-2-平行作业法——快速跟进"><a href="#7-3-2-2-平行作业法——快速跟进" class="headerlink" title="7.3.2.2 平行作业法——快速跟进"></a>7.3.2.2 平行作业法——快速跟进</h4><p>改变活动间的逻辑关系，并行开展某些活动。</p><p><img src="http://img.fdchen.host//%E5%B9%B3%E8%A1%8C%E4%BD%9C%E4%B8%9A%E6%B3%95%E4%BE%8B%E5%AD%90.png" alt="image-20210520203541690"></p><ul><li>任务超前(Lead)：<ul><li>解决任务的搭接</li><li>对任务可以进行合理的拆分</li><li>缩短项目工期</li></ul></li></ul><p><img src="http://img.fdchen.host//%E4%BB%BB%E5%8A%A1%E8%B6%85%E5%89%8D%E4%B8%BE%E4%BE%8B.png" alt="image-20210520203710435"></p><h3 id="7-3-3-管理预留"><a href="#7-3-3-管理预留" class="headerlink" title="7.3.3 管理预留"></a>7.3.3 管理预留</h3><p>管理预留是一项加在项目末端的人为任务。</p><ul><li>安全时间与缓冲时间</li></ul><p><img src="http://img.fdchen.host//%E5%AE%89%E5%85%A8%E6%97%B6%E9%97%B4%E4%B8%8E%E7%BC%93%E5%86%B2%E6%97%B6%E9%97%B4.png" alt="image-20210520203823714"></p><h3 id="7-3-4-资源平衡法"><a href="#7-3-4-资源平衡法" class="headerlink" title="7.3.4 资源平衡法"></a>7.3.4 资源平衡法</h3><p>资源优化配置，形成最有效的利用资源。</p><ul><li>使资源闲置的时间最小化</li><li>尽量避免超出资源能力</li><li>工期不能加长</li></ul><h1 id="8-软件项目风险计划"><a href="#8-软件项目风险计划" class="headerlink" title="8 软件项目风险计划"></a>8 软件项目风险计划</h1><h2 id="8-1-风险管理过程"><a href="#8-1-风险管理过程" class="headerlink" title="8.1 风险管理过程"></a>8.1 风险管理过程</h2><h3 id="8-1-1-风险的定义"><a href="#8-1-1-风险的定义" class="headerlink" title="8.1.1 风险的定义"></a>8.1.1 风险的定义</h3><ul><li>损失发生的不确定性</li><li>对潜在的、未来可能发生损害的一种度量</li></ul><h3 id="8-1-2-项目风险的三要素"><a href="#8-1-2-项目风险的三要素" class="headerlink" title="8.1.2 项目风险的三要素"></a>8.1.2 项目风险的三要素</h3><ul><li>一个事件</li><li>事件发生的概率</li><li>事件的影响</li></ul><h3 id="8-1-3-风险类型"><a href="#8-1-3-风险类型" class="headerlink" title="8.1.3 风险类型"></a>8.1.3 风险类型</h3><ul><li>预测角度<ul><li>已知风险</li><li>可预测风险</li><li>不可预测风险</li></ul></li><li>范围角度<ul><li>项目风险</li><li>技术风险</li><li>商业风险</li></ul></li></ul><h3 id="8-1-4-风险的基本性质"><a href="#8-1-4-风险的基本性质" class="headerlink" title="8.1.4 风险的基本性质"></a>8.1.4 风险的基本性质</h3><ul><li>客观性</li><li>不确定性</li><li>不利性</li><li>可变性</li><li>同利益的对称性</li></ul><h3 id="8-1-5-风险管理的四个过程"><a href="#8-1-5-风险管理的四个过程" class="headerlink" title="8.1.5 风险管理的四个过程"></a>8.1.5 风险管理的四个过程</h3><ul><li>风险识别</li><li>风险评估</li><li>风险规划</li><li>风险控制</li></ul><h2 id="8-2-风险规划"><a href="#8-2-风险规划" class="headerlink" title="8.2 风险规划"></a>8.2 风险规划</h2><p>风险规划，即决定采用什么方式方法、如何计划项目风险的活动。指导对于特定项目如何进行风险管理。</p><h3 id="8-3-风险识别"><a href="#8-3-风险识别" class="headerlink" title="8.3 风险识别"></a>8.3 风险识别</h3><p>风险识别是试图通过系统化地确定对项目计划的威胁，识别已知和可预测的风险。</p><ul><li>风险识别过程</li></ul><p><img src="http://img.fdchen.host//%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E8%BF%87%E7%A8%8B.png" alt="image-20210521005458802"></p><p>方法及工具</p><ul><li>德尔菲方法</li><li>头脑风暴法</li><li>情景分析法</li><li>面谈法</li><li>风险条目检查表<ul><li>检查表法是利用检查表作为风险识别的工具</li><li>检查表法是根据风险要素建立软件项目的风险条目列表</li><li>列表中列出所有与风险因素有关的提问</li><li>可以使管理者集中识别常见的类型中的已知和可预测的风险</li></ul></li></ul><h2 id="8-4-风险评估"><a href="#8-4-风险评估" class="headerlink" title="8.4 风险评估"></a>8.4 风险评估</h2><p>确定<strong>风险发生概率</strong>的估计和评价，项目<strong>风险后果严重程度</strong>的估计和评价，项目风险影响范围的分析和评价，以及对于项目<strong>风险发生时间</strong>的估计和评价。</p><h3 id="8-4-1-分析"><a href="#8-4-1-分析" class="headerlink" title="8.4.1 分析"></a>8.4.1 分析</h3><ul><li>风险发生的概率，确定发生的可能性(P)</li><li>风险后果，发生后对项目目标的影响(I)</li><li>风险值，风险的严重程度R&#x3D;F(P, I)</li><li>按风险的严重性排序确定优先次序，确定最需要关注的TOP 10风险</li></ul><h3 id="8-4-1-风险评估的方法——定性风险评估"><a href="#8-4-1-风险评估的方法——定性风险评估" class="headerlink" title="8.4.1 风险评估的方法——定性风险评估"></a>8.4.1 风险评估的方法——定性风险评估</h3><ul><li>风险概率及后果估计——矩阵图</li></ul><p><img src="http://img.fdchen.host//%E9%A3%8E%E9%99%A9%E6%A6%82%E7%8E%87%E5%8F%8A%E5%90%8E%E6%9E%9C%E4%BC%B0%E8%AE%A1%E2%80%94%E7%9F%A9%E9%98%B5%E5%9B%BE.png" alt="image-20210521010220083"></p><h3 id="8-4-2-风险评估的方法——定量风险评估"><a href="#8-4-2-风险评估的方法——定量风险评估" class="headerlink" title="8.4.2 风险评估的方法——定量风险评估"></a>8.4.2 风险评估的方法——定量风险评估</h3><h4 id="8-4-2-1-盈亏平衡分析"><a href="#8-4-2-1-盈亏平衡分析" class="headerlink" title="8.4.2.1 盈亏平衡分析"></a>8.4.2.1 盈亏平衡分析</h4><h4 id="8-4-2-2-模拟"><a href="#8-4-2-2-模拟" class="headerlink" title="8.4.2.2 模拟"></a>8.4.2.2 模拟</h4><h4 id="8-4-2-3-访谈"><a href="#8-4-2-3-访谈" class="headerlink" title="8.4.2.3 访谈"></a>8.4.2.3 访谈</h4><ul><li>确定概率分布模型</li><li>领域专家访谈，信息采集</li></ul><h4 id="8-4-2-4-决策树分析"><a href="#8-4-2-4-决策树分析" class="headerlink" title="8.4.2.4 决策树分析"></a>8.4.2.4 决策树分析</h4><ul><li><p>损失期望值(Expected Monetary Value, EMV)是决策树的一种计算值</p></li><li><p>根据风险发生的概率计算出一种期望的损益。</p></li><li><p>决策树分析例子</p></li></ul><p><img src="http://img.fdchen.host//%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E6%9E%90%E4%BE%8B%E5%AD%90.png" alt="image-20210521010756538"></p><h4 id="8-4-2-5-量化风险条目检查表"><a href="#8-4-2-5-量化风险条目检查表" class="headerlink" title="8.4.2.5 量化风险条目检查表"></a>8.4.2.5 量化风险条目检查表</h4><p><img src="http://img.fdchen.host//%E9%87%8F%E5%8C%96%E9%A3%8E%E9%99%A9%E6%9D%A1%E7%9B%AE%E6%A3%80%E6%9F%A5%E8%A1%A8.png" alt="image-20210521010855257"></p><h2 id="8-5-风险规划"><a href="#8-5-风险规划" class="headerlink" title="8.5 风险规划"></a>8.5 风险规划</h2><p>针对风险分析的结果，为提高实现项目目标的机会，降低风险的负面影响而制定风险应对策略和应对措施的过程，即制定一定的行动和策略来对付、减少、以至于消灭风险事件。</p><h3 id="8-5-1-风险规划的主要策略"><a href="#8-5-1-风险规划的主要策略" class="headerlink" title="8.5.1 风险规划的主要策略"></a>8.5.1 风险规划的主要策略</h3><h4 id="8-5-1-1-回避风险"><a href="#8-5-1-1-回避风险" class="headerlink" title="8.5.1.1 回避风险"></a>8.5.1.1 回避风险</h4><p>回避风险是对所有可能发生的风险尽可能的规避，采取主动放弃或者拒绝使用导致风险的方案。</p><h4 id="8-5-1-2-转移风险"><a href="#8-5-1-2-转移风险" class="headerlink" title="8.5.1.2 转移风险"></a>8.5.1.2 转移风险</h4><p>转移风险是为了避免承担风险损失，有意识将损失或与损失有关的财务后果转嫁出去的方法，例如：</p><ul><li>出售</li><li>分包</li><li>开脱责任合同</li><li>保险</li></ul><h4 id="8-5-1-3-损失控制"><a href="#8-5-1-3-损失控制" class="headerlink" title="8.5.1.3 损失控制"></a>8.5.1.3 损失控制</h4><ul><li>损失预防</li><li>损失抑制</li></ul><h4 id="8-5-1-4-自留风险"><a href="#8-5-1-4-自留风险" class="headerlink" title="8.5.1.4 自留风险"></a>8.5.1.4 自留风险</h4><ul><li>由项目组织自己承担风险事故所致损失的措施。</li><li>类型：<ul><li>主动自留风险和被动自留风险</li><li>全部自留风险和部分自留风险</li></ul></li></ul><h1 id="9-软件项目配置管理计划"><a href="#9-软件项目配置管理计划" class="headerlink" title="9 软件项目配置管理计划"></a>9 软件项目配置管理计划</h1><h2 id="9-1-软件项目配置管理基本概念"><a href="#9-1-软件项目配置管理基本概念" class="headerlink" title="9.1 软件项目配置管理基本概念"></a>9.1 软件项目配置管理基本概念</h2><h3 id="9-1-1-配置管理简述"><a href="#9-1-1-配置管理简述" class="headerlink" title="9.1.1 配置管理简述"></a>9.1.1 配置管理简述</h3><ul><li>记录软件产品的演化过程</li><li>得到精确的产品配置</li><li>最终保证软件产品的<strong>完整性、一致性、追溯性、可塑性</strong></li></ul><h3 id="9-1-2-配置管理的主要功能"><a href="#9-1-2-配置管理的主要功能" class="headerlink" title="9.1.2 配置管理的主要功能"></a>9.1.2 配置管理的主要功能</h3><ul><li>版本管理</li><li>变更管理</li><li>其他</li></ul><h3 id="9-1-3-软件配置项"><a href="#9-1-3-软件配置项" class="headerlink" title="9.1.3 软件配置项"></a>9.1.3 软件配置项</h3><ul><li><p>SCI: Software configuration item</p></li><li><p>受控于软件配置管理的款项</p></li><li><p>配置项例子</p></li></ul><p><img src="http://img.fdchen.host//%E9%85%8D%E7%BD%AE%E9%A1%B9%E4%BE%8B%E5%AD%90.png" alt="image-20210521001342982"></p><h3 id="9-1-4-基线定义"><a href="#9-1-4-基线定义" class="headerlink" title="9.1.4 基线定义"></a>9.1.4 基线定义</h3><ul><li>基线提供了软件生存期中各个开发阶段的一-个特定点</li><li>一个(些)配置项形成并通过审核，即形成基线</li><li>基线标志开发过程一个阶段的结束和里程碑</li><li>基线修改需要按照正式的程序执行</li></ul><h3 id="9-1-5-软件配置控制委员会（SCCB）"><a href="#9-1-5-软件配置控制委员会（SCCB）" class="headerlink" title="9.1.5 软件配置控制委员会（SCCB）"></a>9.1.5 软件配置控制委员会（SCCB）</h3><ul><li>评估变更</li><li>批准变更申请</li><li>在生存期内规范变更申请流程</li><li>对变更进行反馈</li><li>与项目管理层沟通</li></ul><h2 id="9-2-软件项目配置管理过程"><a href="#9-2-软件项目配置管理过程" class="headerlink" title="9.2 软件项目配置管理过程"></a>9.2 软件项目配置管理过程</h2><h3 id="9-2-1-配置项标识、跟踪"><a href="#9-2-1-配置项标识、跟踪" class="headerlink" title="9.2.1 配置项标识、跟踪"></a>9.2.1 配置项标识、跟踪</h3><ul><li>将软件项目种需要进行控制的部分拆分成SCI，配置项被唯一标识</li><li>配置项标识示例</li></ul><p><img src="http://img.fdchen.host//%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%A0%87%E8%AF%86%E7%A4%BA%E4%BE%8B.png" alt="image-20210521001827812"></p><ul><li>建立配置项的对应关系，以便于进行跟踪和版本控制。</li></ul><p><img src="http://img.fdchen.host//%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9A%84%E8%B7%9F%E8%B8%AA.png" alt="image-20210521001937881"></p><h3 id="9-2-2-配置管理环境的建立"><a href="#9-2-2-配置管理环境的建立" class="headerlink" title="9.2.2 配置管理环境的建立"></a>9.2.2 配置管理环境的建立</h3><ul><li>建立配置管理库</li></ul><p>软件配置管理库是用来存储所有基线配置项及相关文件的等内容的系统，是在软件产品的整个生存期中建立和维护软件产品完整性的主要手段。</p><ul><li>受控操作</li></ul><p><img src="http://img.fdchen.host//%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%BA%93%E5%8F%97%E6%8E%A7%E6%93%8D%E4%BD%9C.png" alt="image-20210521002139796"></p><h3 id="9-2-3-基线变更管理过程"><a href="#9-2-3-基线变更管理过程" class="headerlink" title="9.2.3 基线变更管理过程"></a>9.2.3 基线变更管理过程</h3><p>基线修改应受到控制，这种变化要经SCCB授权，按程序进行控制并记录基线修改的过程。</p><ul><li>配置控制内容</li></ul><p><img src="http://img.fdchen.host//%E9%85%8D%E7%BD%AE%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="image-20210521002501558"></p><h3 id="9-2-4-配置管理审计"><a href="#9-2-4-配置管理审计" class="headerlink" title="9.2.4 配置管理审计"></a>9.2.4 配置管理审计</h3><ul><li>配置管理过程审计</li><li>基线审计</li></ul><h2 id="9-3-软件项目配置管理计划"><a href="#9-3-软件项目配置管理计划" class="headerlink" title="9.3 软件项目配置管理计划"></a>9.3 软件项目配置管理计划</h2><h3 id="9-3-1-配置管理计划大纲——举例"><a href="#9-3-1-配置管理计划大纲——举例" class="headerlink" title="9.3.1 配置管理计划大纲——举例"></a>9.3.1 配置管理计划大纲——举例</h3><ul><li>人员职责（确定SSCB等）</li><li>配置项定义</li><li>基线定义</li><li>版本控制（说明配置管理工具）</li><li>定义变更控制系统</li></ul><h3 id="9-3-2-常用配置管理工具"><a href="#9-3-2-常用配置管理工具" class="headerlink" title="9.3.2 常用配置管理工具"></a>9.3.2 常用配置管理工具</h3><ul><li>Harvest、Perforce</li><li>ClearCase、PVCS</li><li>CVS\SVN、VSS</li></ul><h1 id="10-未来企业管理的三大支柱"><a href="#10-未来企业管理的三大支柱" class="headerlink" title="10 未来企业管理的三大支柱"></a>10 未来企业管理的三大支柱</h1><ul><li>战略管理</li><li>项目管理</li><li>影响管理</li></ul><h2 id="10-1-为什么成功的项目很少"><a href="#10-1-为什么成功的项目很少" class="headerlink" title="10.1 为什么成功的项目很少"></a>10.1 为什么成功的项目很少</h2><h3 id="10-1-1-项目成功的标准-IPMA"><a href="#10-1-1-项目成功的标准-IPMA" class="headerlink" title="10.1.1 项目成功的标准(IPMA)"></a>10.1.1 项目成功的标准(IPMA)</h3><ol><li>三个基本标准<ul><li>赞助的机构满意</li><li>传统或经典的项目管理目标：按时、符合预算、达到质量要求</li><li>项目参与者获利</li></ul></li></ol><h3 id="10-1-2-影响项目成功的因素"><a href="#10-1-2-影响项目成功的因素" class="headerlink" title="10.1.2 影响项目成功的因素"></a>10.1.2 影响项目成功的因素</h3><ul><li>人员</li><li>项目领导</li><li>技术&#x2F;工具</li><li>产品</li><li>项目过程</li></ul><h2 id="10-2-项目的分类"><a href="#10-2-项目的分类" class="headerlink" title="10.2 项目的分类"></a>10.2 项目的分类</h2><ul><li>有按项目规模、复杂程度、项目结果、所属行业、用户状况等5种分类依据</li><li>大型项目(program)</li><li>项目(project)</li><li>子项目(subproject)</li><li>活动或任务(activity or task)</li><li>工作包(work packages)</li><li>工作单元(work units)</li></ul><h2 id="10-3-项目成功的因素"><a href="#10-3-项目成功的因素" class="headerlink" title="10.3 项目成功的因素"></a>10.3 项目成功的因素</h2><ul><li>高层领导层的支持</li><li>明确的目标和范围</li><li>优秀的项目经理</li><li>项目团队积极参与</li><li>客户的全称参与</li><li>分包商的良好沟通</li><li>严密而灵活的计划</li><li>随时监控和反馈</li><li>正确的技术</li></ul><h2 id="10-4-项目管理的六要素"><a href="#10-4-项目管理的六要素" class="headerlink" title="10.4 项目管理的六要素"></a>10.4 项目管理的六要素</h2><ul><li>工作范围(scope)</li><li>时间(time)</li><li>成本(cost)</li><li>质量(quality)</li><li>组织(organization)</li><li>客户满意度(customer)</li></ul><h2 id="10-5-如何看待项目管理"><a href="#10-5-如何看待项目管理" class="headerlink" title="10.5 如何看待项目管理"></a>10.5 如何看待项目管理</h2><ul><li>项目管理被看作完整的一套工作流程。<ul><li>项目管理包括<strong>项目启动、项目计划编制、项目实施、项目控制和控制首尾</strong>等一整套工作流程。</li></ul></li><li>项目管理被看作是一种整体工作</li><li>项目管理被看作是为解决实际问题而创建的工作氛围</li><li>项目管理被看作是一套完整的技能和手段的合集</li><li>项目管理是一种管理方法体系</li></ul><h2 id="10-6-PMBOK规定的项目管理体系"><a href="#10-6-PMBOK规定的项目管理体系" class="headerlink" title="10.6 PMBOK规定的项目管理体系"></a>10.6 PMBOK规定的项目管理体系</h2><ul><li>项目整体管理</li><li>项目范围管理</li><li>项目时间管理</li><li>项目成本管理</li><li>项目质量管理</li><li>项目人力资源管理</li><li>项目沟通管理</li><li>项目风险管理</li><li>项目采购管理</li></ul><h1 id="11-软件项目执行控制"><a href="#11-软件项目执行控制" class="headerlink" title="11 软件项目执行控制"></a>11 软件项目执行控制</h1><h2 id="11-1-项目集成管理"><a href="#11-1-项目集成管理" class="headerlink" title="11.1 项目集成管理"></a>11.1 项目集成管理</h2><h3 id="11-1-1-项目跟踪控制过程"><a href="#11-1-1-项目跟踪控制过程" class="headerlink" title="11.1.1 项目跟踪控制过程"></a>11.1.1 项目跟踪控制过程</h3><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E8%B7%9F%E8%B8%AA%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.png" alt="image-20210521012139702"></p><h3 id="11-1-2-项目跟踪控制的关系"><a href="#11-1-2-项目跟踪控制的关系" class="headerlink" title="11.1.2 项目跟踪控制的关系"></a>11.1.2 项目跟踪控制的关系</h3><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E8%B7%9F%E8%B8%AA%E6%8E%A7%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image-20210521012212103"></p><h3 id="11-1-3-项目控制的范围-集成管理"><a href="#11-1-3-项目控制的范围-集成管理" class="headerlink" title="11.1.3 项目控制的范围-集成管理"></a>11.1.3 项目控制的范围-集成管理</h3><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E8%8C%83%E5%9B%B4-%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86.png" alt="image-20210521012236052"></p><h3 id="11-1-4-跟踪控制的程度"><a href="#11-1-4-跟踪控制的程度" class="headerlink" title="11.1.4 跟踪控制的程度"></a>11.1.4 跟踪控制的程度</h3><ul><li>建立偏差的接受准则</li><li>注意力放在解决特殊问题上</li></ul><h3 id="11-1-5-控制标准"><a href="#11-1-5-控制标准" class="headerlink" title="11.1.5 控制标准"></a>11.1.5 控制标准</h3><p><img src="http://img.fdchen.host//%E6%8E%A7%E5%88%B6%E6%A0%87%E5%87%86.png" alt="image-20210521012440622"></p><h3 id="11-1-6-项目控制的步骤"><a href="#11-1-6-项目控制的步骤" class="headerlink" title="11.1.6 项目控制的步骤"></a>11.1.6 项目控制的步骤</h3><ol><li>建立标准</li><li>采集项目信息，观察项目的性能</li><li>将项目的实际结果与计划进行比较</li><li>如果实际的项目同计划有误差时，采取必要的修正措施</li><li>修正计划，通知有关人员和部分</li></ol><h3 id="11-1-7-建立控制标准"><a href="#11-1-7-建立控制标准" class="headerlink" title="11.1.7 建立控制标准"></a>11.1.7 建立控制标准</h3><p>主要的三个基准计划：</p><ul><li>范围（质量）</li></ul><p><img src="http://img.fdchen.host//%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A0%87%E5%87%86.png" alt="image-20210521012710424"></p><ul><li>进度</li></ul><p><img src="http://img.fdchen.host//%E8%BF%9B%E5%BA%A6%E6%8E%A7%E5%88%B6%E6%A0%87%E5%87%86.png" alt="image-20210521012643372"></p><ul><li>成本</li></ul><p><img src="http://img.fdchen.host//%E6%88%90%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%A0%87%E5%87%86.png" alt="image-20210521012729835"></p><h3 id="11-1-8-采集过程"><a href="#11-1-8-采集过程" class="headerlink" title="11.1.8 采集过程"></a>11.1.8 采集过程</h3><ul><li>跟踪采集主要是在项目生存期内根据项目计划中规定的跟踪频率按照规定的步骤对项目管理、技术开发和质量保证活动进行跟踪。</li><li>监控项目实际过程，记录反映当前项目状态的数据</li><li>项目度量实施过程</li></ul><h3 id="11-1-9-项目性能分析的对象"><a href="#11-1-9-项目性能分析的对象" class="headerlink" title="11.1.9 项目性能分析的对象"></a>11.1.9 项目性能分析的对象</h3><ul><li>项目范围监控</li><li>项目成本监控</li><li>项目进度监控</li><li>项目资源监控</li><li>项目质量监控</li><li>项目风险监控</li></ul><h2 id="11-2-范围管理"><a href="#11-2-范围管理" class="headerlink" title="11.2 范围管理"></a>11.2 范围管理</h2><ul><li>项目范围控制</li></ul><p><img src="http://img.fdchen.host//%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E6%8E%A7%E5%88%B6.png" alt="image-20210521012956683"></p><h2 id="11-3-时间-x2F-成本管理"><a href="#11-3-时间-x2F-成本管理" class="headerlink" title="11.3 时间&#x2F;成本管理"></a>11.3 时间&#x2F;成本管理</h2><h3 id="11-3-1-进度、成本、资源控制"><a href="#11-3-1-进度、成本、资源控制" class="headerlink" title="11.3.1 进度、成本、资源控制"></a>11.3.1 进度、成本、资源控制</h3><p><img src="http://img.fdchen.host//%E8%BF%9B%E5%BA%A6%E3%80%81%E6%88%90%E6%9C%AC%E3%80%81%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6.png" alt="image-20210521013039700"></p><h3 id="11-3-2-跟踪项目进度"><a href="#11-3-2-跟踪项目进度" class="headerlink" title="11.3.2 跟踪项目进度"></a>11.3.2 跟踪项目进度</h3><p>跟踪项目进度重要的是<strong>及时更新项目信息</strong>，这样及时反映项目的比较基准计划与实际运行状<br>况的差异，以便于及时调整项目，达到项目跟踪的目的。</p><h3 id="11-3-3-跟踪实际成本"><a href="#11-3-3-跟踪实际成本" class="headerlink" title="11.3.3 跟踪实际成本"></a>11.3.3 跟踪实际成本</h3><ul><li>计算任务的实际成本</li><li>每天更新实际成本</li><li>查看任务成本是否与预算相符</li></ul><h3 id="11-3-4-跟踪项目资源状况"><a href="#11-3-4-跟踪项目资源状况" class="headerlink" title="11.3.4 跟踪项目资源状况"></a>11.3.4 跟踪项目资源状况</h3><ul><li>资源完成的总实际工时</li><li>每天更新资源的实际工时</li><li>查看资源计划工时与实际工时之间的差异</li></ul><h3 id="11-3-5-性能分析的主要技术"><a href="#11-3-5-性能分析的主要技术" class="headerlink" title="11.3.5 性能分析的主要技术"></a>11.3.5 性能分析的主要技术</h3><h4 id="11-3-5-1-图解控制法"><a href="#11-3-5-1-图解控制法" class="headerlink" title="11.3.5.1 图解控制法"></a>11.3.5.1 图解控制法</h4><ul><li><p>进度——甘特图</p></li><li><p>成本——累计费用曲线图</p></li><li><p>人力物力资源——资源载荷图</p></li></ul><p>图解控制法——图例</p><p><img src="http://img.fdchen.host//%E5%9B%BE%E8%A7%A3%E6%8E%A7%E5%88%B6%E6%B3%95-%E5%9B%BE%E4%BE%8B.png" alt="image-20210521013713750"></p><h4 id="11-3-5-2-挣值分析法（盈余分析法、已获取价值分析法）"><a href="#11-3-5-2-挣值分析法（盈余分析法、已获取价值分析法）" class="headerlink" title="11.3.5.2 挣值分析法（盈余分析法、已获取价值分析法）"></a>11.3.5.2 挣值分析法（盈余分析法、已获取价值分析法）</h4><ul><li>挣值分析模型</li></ul><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B.png" alt="image-20210521013756148"></p><ul><li>挣值分析原理</li></ul><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86.png" alt="image-20210521014150538"></p><ul><li><p>输入：</p><ul><li>BCWS (Budgeted cost of work scheduled)，计划工作成本</li><li>ACWP (Actual cost of work performed)，实际工作成本</li><li>BAC (Budget At Completion)，预算总值(估算结果)</li><li>BCWP (Budgeted cost of work performed)，已获值(Earned Value)</li></ul></li><li><p>挣值分析（已获取价值）概念</p><ul><li>利用成本会计评估项目进展的一种方法</li></ul></li><li><p>挣值分析法定义</p><ul><li>是计算实际花在一个项目上的工作量，以及预计该项目所需成本和完成该项目的日期的一种方法。</li></ul></li><li><p>BCWP的计算</p><ul><li>方法一：自下而上-很麻烦</li><li>方法二：公式计算方法<ul><li>50&#x2F;50规则，当一项工作开始时，假定已获得一半的价值</li><li>0&#x2F;100规则，当一项工作开始时，没有产生价值，直到结束获得全部的价值</li><li>经验加权法</li></ul></li><li>挣值（已获取价值）实例</li></ul><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%EF%BC%88%E5%B7%B2%E8%8E%B7%E5%8F%96%E4%BB%B7%E5%80%BC%EF%BC%89%E5%AE%9E%E4%BE%8B.png" alt="image-20210521015157427"></p></li></ul><blockquote><p>如上图，截至今天，仅有任务D没完成，前三个任务皆已经完成，即可按照规则计算。（数据表格里表示的是按照50&#x2F;50规则表示的各任务的完成进度，可得任务D未完成）</p></blockquote><ul><li><p>挣值分析导出量-1</p><ul><li><p>进度差异：SV ( Schedule Variance) &#x3D;BCWP-BCWS</p><ul><li>&#x3D;0：按照进度进行</li><li>&lt;0：落后于进度</li><li>&gt;0：超前于进度</li></ul></li><li><p>费用差异：CV (Cost Variance )&#x3D;BCWP-ACWP</p><ul><li>&#x3D;0：按照预算进行</li><li>&gt; 0: 低于于预算</li><li>&lt; 0：超出预算</li></ul></li></ul></li><li><p>挣值分析导出量-1计算示例</p></li></ul><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E5%AF%BC%E5%87%BA%E9%87%8F%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B.png" alt="image-20210521020046320"></p><ul><li><p>挣值分析导出量-2</p><ul><li><p>成本效能指数: CPI (Cost Performance Index) &#x3D; BCWP&#x2F; ACWP</p><ul><li>费用的支出速度</li><li>&#x3D;1:按照预算进行</li><li>&gt;1:低于预算</li><li>&lt;1:超出预算</li></ul></li><li><p>进度效能指标: SPI (Schedule Performance Index) &#x3D; BCWP&#x2F;BCWS</p><ul><li>已完成工作百分比</li><li>&#x3D;1:按照进度进行</li><li>&gt;1:超前于进度</li><li>&lt;1:落后于进度</li></ul></li></ul></li><li><p>性能指标图示</p></li></ul><p><img src="http://img.fdchen.host//%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%9B%BE%E7%A4%BA.png" alt="image-20210521021812417"></p><ul><li><p>挣值分析导出度量-3</p><ul><li>工作完成的预测成本：<ul><li>EAC (Estimate At Completion) &#x3D;BAC&#x2F;CPI</li></ul></li><li>工作完成的成本差异：<ul><li>VAC (Variance At Completion) &#x3D; BAC- EAC</li></ul></li><li>项目完成的预测时间：<ul><li>SAC (Schedule At Completion )&#x3D;完成时的进度计划&#x2F;SPI</li></ul></li><li>未完工指数<ul><li>TCPI &#x3D;剩余工作&#x2F;剩余成本&#x3D; (Budget-BCWP) &#x2F; (Goal-ACWP)，Budget&#x3D;BAC，如果Goal&#x3D;EAC，TCPI与CPI等同。</li></ul></li></ul></li><li><p>挣值分析例题</p><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E5%88%97%E9%A2%98-4.png" alt="image-20210521022910277"></p></li></ul><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E4%BE%8B%E9%A2%98-1.png" alt="image-20210521022429485"></p><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E4%BE%8B%E9%A2%98-2.png" alt="image-20210521022445876"></p><p><img src="http://img.fdchen.host//%E6%8C%A3%E5%80%BC%E5%88%86%E6%9E%90%E4%BE%8B%E9%A2%98-3.png" alt="image-20210521022503336"></p><h2 id="11-4-质量管理"><a href="#11-4-质量管理" class="headerlink" title="11.4 质量管理"></a>11.4 质量管理</h2><h2 id="11-5-团队管理"><a href="#11-5-团队管理" class="headerlink" title="11.5 团队管理"></a>11.5 团队管理</h2><h3 id="11-5-1-人员选择"><a href="#11-5-1-人员选择" class="headerlink" title="11.5.1 人员选择"></a>11.5.1 人员选择</h3><ul><li>选择合适的项目人员</li><li>高中低三类人员<ul><li>明确项目需要的人员技能</li><li>验证需要的技能</li></ul></li></ul><h3 id="11-5-2-人员培训"><a href="#11-5-2-人员培训" class="headerlink" title="11.5.2 人员培训"></a>11.5.2 人员培训</h3><p>项目培训的特点：</p><ul><li>短期培训</li><li>片段式培训</li><li>针对性强</li><li>见效快</li></ul><h3 id="11-5-3-人员激励"><a href="#11-5-3-人员激励" class="headerlink" title="11.5.3 人员激励"></a>11.5.3 人员激励</h3><ul><li>马斯洛的需求层次理论</li><li>海兹伯格的激励理论</li><li>麦克勒格的 X-理论和Y-理论</li><li>期望理论</li></ul><h3 id="11-5-4-团队管理建设"><a href="#11-5-4-团队管理建设" class="headerlink" title="11.5.4 团队管理建设"></a>11.5.4 团队管理建设</h3><ul><li>创建有确实存在感的项目队伍</li><li>建立奖励机制</li><li>建立良好人际关系</li></ul><h2 id="11-6-沟通管理"><a href="#11-6-沟通管理" class="headerlink" title="11.6 沟通管理"></a>11.6 沟通管理</h2><h3 id="11-6-1-项目沟通的基本原则"><a href="#11-6-1-项目沟通的基本原则" class="headerlink" title="11.6.1 项目沟通的基本原则"></a>11.6.1 项目沟通的基本原则</h3><ul><li>及时性</li><li>准确性</li><li>完整性</li><li>可理解性</li></ul><h3 id="11-6-2-项目沟通的方式"><a href="#11-6-2-项目沟通的方式" class="headerlink" title="11.6.2 项目沟通的方式"></a>11.6.2 项目沟通的方式</h3><ul><li>书面沟通和口头沟通</li><li>语言沟通和非语言沟通</li><li>正式沟通和非正式沟通</li><li>单向沟通和双向沟通</li><li>网络沟通</li></ul><h3 id="11-6-3-项目评审"><a href="#11-6-3-项目评审" class="headerlink" title="11.6.3 项目评审"></a>11.6.3 项目评审</h3><ul><li><p>准备过程</p></li><li><p>评审过程</p></li><li><p>评审报告</p></li><li><p>评审类型（时间）：</p><ul><li>定期评审</li><li>阶段评审</li><li>事件评审</li></ul></li></ul><h2 id="11-7-风险管理"><a href="#11-7-风险管理" class="headerlink" title="11.7 风险管理"></a>11.7 风险管理</h2><h3 id="11-7-1-风险控制"><a href="#11-7-1-风险控制" class="headerlink" title="11.7.1 风险控制"></a>11.7.1 风险控制</h3><ol><li>实施和跟踪风险管理计划</li><li>确保针对风险策略正在合理使用</li><li>监视剩余的风险和识别新的风险</li><li>收集可用于将来的风险分析信息</li></ol><h3 id="11-7-2-风险控制过程"><a href="#11-7-2-风险控制过程" class="headerlink" title="11.7.2 风险控制过程"></a>11.7.2 风险控制过程</h3><p><img src="http://img.fdchen.host//%E9%A3%8E%E9%99%A9%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.png" alt="image-20210521024142374"></p><h3 id="11-7-3-风险控制的方法"><a href="#11-7-3-风险控制的方法" class="headerlink" title="11.7.3 风险控制的方法"></a>11.7.3 风险控制的方法</h3><ul><li>建立项目风险监控体系</li><li>项目风险审核-Top 10风险列表控制</li><li>挣值分析：分析进度、成本等风险</li><li>项目风险评价-例如项目中期检查</li></ul><h2 id="11-8-合同管理"><a href="#11-8-合同管理" class="headerlink" title="11.8 合同管理"></a>11.8 合同管理</h2><h3 id="11-8-1-甲方合同管理"><a href="#11-8-1-甲方合同管理" class="headerlink" title="11.8.1 甲方合同管理"></a>11.8.1 甲方合同管理</h3><ul><li>对采购对象的验证和检验过程</li><li>违约事件处理过程</li></ul><h3 id="11-8-2-乙方合同管理"><a href="#11-8-2-乙方合同管理" class="headerlink" title="11.8.2 乙方合同管理"></a>11.8.2 乙方合同管理</h3><ul><li>合同执行跟踪管理过程</li><li>合同修改控制</li><li>违约事件处理过程</li><li>产品提交过程</li><li>产品维护过程</li></ul><h1 id="12-项目结束过程"><a href="#12-项目结束过程" class="headerlink" title="12 项目结束过程"></a>12 项目结束过程</h1><h2 id="12-1-合同结束"><a href="#12-1-合同结束" class="headerlink" title="12.1 合同结束"></a>12.1 合同结束</h2><p>项目终止的条件：</p><ul><li>项目计划中确定的可交付成果已经出现。</li><li>由于相关原因，项目无法继续进行。</li></ul><p>合同的生存期：</p><ul><li>合同准备</li><li>合同签署</li><li>合同管理</li><li>合同终止</li></ul><h2 id="12-2-项目结束"><a href="#12-2-项目结束" class="headerlink" title="12.2 项目结束"></a>12.2 项目结束</h2><p>项目结束过程：</p><ul><li>项目最后评审</li><li>项目总结</li></ul><h3 id="12-2-1-项目最后评审"><a href="#12-2-1-项目最后评审" class="headerlink" title="12.2.1 项目最后评审"></a>12.2.1 项目最后评审</h3><ul><li>是否实现项目目标</li><li>是否遵循项目进度</li><li>是否在预算成本内完成项目</li><li>项目进度过程中出现问题以及解决措施是否合适</li><li>从该项目的实践中可以得到哪些经验和教训</li></ul><h3 id="12-2-2-项目总结"><a href="#12-2-2-项目总结" class="headerlink" title="12.2.2 项目总结"></a>12.2.2 项目总结</h3><ul><li>项目总结是一个把实际运行情况与项目计划不断比较以提炼经验教训的过程。</li><li>通过项目总结，项目过程中的经验和教训将得到完整的记录和升华，成为“组织财富“。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CQU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 软件项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构与设计</title>
      <link href="/2021/cqu-ruan-jian-jia-gou-yu-she-ji/"/>
      <url>/2021/cqu-ruan-jian-jia-gou-yu-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="0-知识结构"><a href="#0-知识结构" class="headerlink" title="0. 知识结构"></a>0. 知识结构</h1><h2 id="0-1-软件架构设计三大层次"><a href="#0-1-软件架构设计三大层次" class="headerlink" title="0.1 软件架构设计三大层次"></a>0.1 软件架构设计三大层次</h2><p>在软件架构设计时,根据抽象程度从高到低可划分为三个层次的模式：**架构模式(Architectural Pattern)、设计模式(Design Pattern)、代码模式(Coding Pattern)**。</p><ul><li><strong>架构模式</strong>是一个系统的高层次策略，涉及到大尺度的组件以及整体性质。</li><li><strong>设计模式</strong>是中等尺度的结构策略。这些中等尺度的结构实现了一些大尺度组件的行为和它们之间的关系。设计模式定义出子系统或组件的微观结构。</li><li><strong>代码模式（或成例）</strong>是特定的范例和与特定语言有关的编程技巧</li></ul><h2 id="0-2-框架Framework"><a href="#0-2-框架Framework" class="headerlink" title="0.2 框架Framework"></a>0.2 框架Framework</h2><p>软件框架是面向领域（如ERP、计算领域等）的、可复用的“半成品”软件，它实现了该领域的共性部分，并提供了一些定义良好的可变点以保证灵活性和可扩展性。</p><ul><li>框架是可被应用开发者定制的应用骨架。框架实现了某应用领域通用完备功能（除去特殊应用的部分）的底层服务。</li><li>框架具体表现为一组抽象类（构件）以及其实例（对象）之间的相互作用方式。框架描述了系统中所有的构件、构件之间的交互、连接件以及如何将构件和连接件结合的规则。</li><li>软件框架的一个显著特点是<strong>逆向控制（Inversion of Control）</strong>，应用开发人员只要将应用特定的模块绑定到框架内，框架则根据自己的交互机制自动调用该模块，控制由框架负责。</li></ul><p>框架可分为三大类：</p><ul><li><strong>基础设施框架</strong>：用于简化系统级软件的开发</li><li><strong>中间件框架</strong>：用于组装分布式应用和构件</li><li><strong>应用框架</strong>：如Web应用框架Eclipse ，Struts等</li></ul><h2 id="0-3-框架与软件架构-x2F-设计模式对比"><a href="#0-3-框架与软件架构-x2F-设计模式对比" class="headerlink" title="0.3 框架与软件架构&#x2F;设计模式对比"></a>0.3 框架与软件架构&#x2F;设计模式对比</h2><h3 id="0-3-1-框架-与-软件架构"><a href="#0-3-1-框架-与-软件架构" class="headerlink" title="0.3.1 框架 与 软件架构"></a>0.3.1 框架 与 软件架构</h3><ul><li>框架比架构更具体，更偏重于技术</li><li>确定框架后，软件体系结构也随之确定</li><li>对于同一软件体系结构（比如Web开发中的MVC），可以通过多种框架来实现</li></ul><h3 id="0-3-2-框架-与-设计模式"><a href="#0-3-2-框架-与-设计模式" class="headerlink" title="0.3.2 框架 与 设计模式"></a>0.3.2 框架 与 设计模式</h3><ul><li>设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示</li><li>设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用</li><li>框架是软件，而设计模式是软件策略</li></ul><h1 id="1-软件体系结构"><a href="#1-软件体系结构" class="headerlink" title="1 软件体系结构"></a>1 软件体系结构</h1><h2 id="1-1-软件体系结构基本概念"><a href="#1-1-软件体系结构基本概念" class="headerlink" title="1.1 软件体系结构基本概念"></a>1.1 软件体系结构基本概念</h2><blockquote><p>软件体系结构的概念、软件体系结构核心模型及各组成元素的含义</p></blockquote><h3 id="1-1-1-软件体系结构概念"><a href="#1-1-1-软件体系结构概念" class="headerlink" title="1.1.1 软件体系结构概念"></a>1.1.1 软件体系结构概念</h3><p>软件系统的体系结构是指根据计算组件和这些组件之间的交互定义系统。</p><h3 id="1-2-2-软件体系结构核心模型"><a href="#1-2-2-软件体系结构核心模型" class="headerlink" title="1.2.2 软件体系结构核心模型"></a>1.2.2 软件体系结构核心模型</h3><p><img src="http://img.fdchen.host//%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B.png" alt="image-20210617203242151"></p><ul><li><p>软件体系结构<strong>基本组成元素</strong>：</p><ul><li>构件Component：系统的逻辑与功能结构组成单元。<ul><li>构件是具有某种功能的可重用的软件模板单元，表示了系统中主要的计算元素和数据存储。</li><li>构件是一个抽象概念，与具体实现技术无关。</li><li>原子构件不可再分；复合构件可分解为其他复合构件和原子构件。</li><li>构件通过其接口与外部环境交互，接口由一组<strong>端口  （Port）</strong>组成。</li><li><strong>每个端口表示构件和外部环境的交互作用点</strong>。</li></ul></li></ul><p><img src="http://img.fdchen.host//%E5%85%B8%E5%9E%8B%E6%9E%84%E4%BB%B6.png" alt="image-20210617202647617"></p><ul><li>连接件Connector：构件间交互的机制和规则。<ul><li>机制：连接件的具体实现形式</li><li>规则：构件使用连接件应遵循的规范</li><li>角色：连接件的交互参与者</li><li>连接方式分类：单向连接和双向连接、同步&#x2F;异步连接</li></ul></li><li>配置Configuration：表示构件和连接件的拓扑逻辑和约束，包括：<ul><li>构件的端口与连接件的角色之间的关联关系</li><li>复合构件与其子构件的嵌套包含关系</li></ul></li></ul></li></ul><h2 id="1-2-软件体系结构建模"><a href="#1-2-软件体系结构建模" class="headerlink" title="1.2 软件体系结构建模"></a>1.2 软件体系结构建模</h2><blockquote><p>4+1视图概念、关注点、各视图的典型体系结构表示（构件和连接件）</p></blockquote><h3 id="1-2-1-4-1视图概念"><a href="#1-2-1-4-1视图概念" class="headerlink" title="1.2.1 4+1视图概念"></a>1.2.1 4+1视图概念</h3><p>“4+1”视图模型从5个不同的视角来描述软件体系结构：逻辑视角、进程视角、开发视角、物理视角和场景视角。<br>每一个视角只关心系统的一个侧面，5个视角结合在一起反映系统的软件体系结构的完整内容。</p><p><img src="http://img.fdchen.host//4+1%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B.png" alt="image-20210617205943222"></p><ul><li><p><strong>Logic View（逻辑视图）</strong>：基于功能需求抽象，刻画系统的静态结构模型；</p></li><li><p><strong>Process View（进程视图）</strong>：刻画系统运行时的结构模型；</p></li><li><p><strong>Development View（开发视图）</strong>：考虑开发技术、过程与组织，刻画系统的开发管理结构模型；</p></li><li><p><strong>Physical View（物理视图）</strong>：逻辑视图中各功能构件在安装部署环境中的映射，刻画系统的安装部署结构模型；</p></li><li><p><strong>Scenarios View（场景视图）</strong>：从系统使用的角度对系统结构的描述。它反映的是在完成某个系统功能时，系统各功能构件间的交互关系。</p></li></ul><h3 id="1-2-2-4-1视图关注点与典型表示"><a href="#1-2-2-4-1视图关注点与典型表示" class="headerlink" title="1.2.2 4+1视图关注点与典型表示"></a>1.2.2 4+1视图关注点与典型表示</h3><h4 id="1-2-2-1-逻辑视图"><a href="#1-2-2-1-逻辑视图" class="headerlink" title="1.2.2.1 逻辑视图"></a>1.2.2.1 逻辑视图</h4><ul><li>逻辑视图主要关注<strong>系统的功能需求。</strong></li><li>在面向对象技术中，可以用<strong>对象模型</strong>代表逻辑视图，用<strong>类图</strong>描述逻辑视图。<ul><li><strong>构件</strong>：类、类服务、参数化类、类层次（包）</li><li><strong>连接件</strong>：关联、包含聚集、使用、继承、实例化</li></ul></li></ul><h4 id="1-2-2-2-开发视图"><a href="#1-2-2-2-开发视图" class="headerlink" title="1.2.2.2 开发视图"></a>1.2.2.2 开发视图</h4><ul><li>开发视图关注<strong>软件开发环境下实际模块的组织和管理</strong>，体现为软件模块、库、子系统和开发单元的结构化组织。</li><li>开发视图可采用<strong>层次结构</strong>，每一层为上层提供良好定义的接口，层次越低，通用性越好。<ul><li><strong>构件</strong>：模块、子系统、层</li><li><strong>连接件</strong>：参照相关性、模块&#x2F;过程调用</li></ul></li></ul><h4 id="1-2-2-3-进程视图"><a href="#1-2-2-3-进程视图" class="headerlink" title="1.2.2.3 进程视图"></a>1.2.2.3 进程视图</h4><ul><li>进程视图侧重<strong>系统的运行特性</strong>，关注非功能性需求（性能、可用性）。</li><li>它定义逻辑视图中的各个构件具体在进程&#x2F;线程中的映射结构。<ul><li><strong>构件：</strong>进程、简化进程、循环进程 </li><li><strong>连接件：</strong>消息、远程过程调用（RPC）、双向消息、事件广播</li></ul></li></ul><h4 id="1-2-2-4-物理视图"><a href="#1-2-2-4-物理视图" class="headerlink" title="1.2.2.4 物理视图"></a>1.2.2.4 物理视图</h4><ul><li>物理视图主要考虑如何<strong>把软件映射到硬件</strong>，它通常要考虑软件系统在计算物理节点与网络拓扑结构上的运行部署等问题。</li><li>主要关注系统性能、可扩展性、可靠性等软件非功能性需求约束。<ul><li><strong>构件</strong>：处理器、计算机、其它设备 </li><li><strong>连接件</strong>：通信协议等</li></ul></li></ul><h4 id="1-2-2-5-场景视图"><a href="#1-2-2-5-场景视图" class="headerlink" title="1.2.2.5 场景视图"></a>1.2.2.5 场景视图</h4><ul><li>场景视图<strong>从系统使用的角度</strong>对系统结构进行描述。场景反映在完成一个系统功能时，系统各功能构件间的协作关系。</li><li>场景处于中心位置，它使四个视图有机联系起来，从某种意义上说场景是最重要的需求抽象。</li><li>场景的表示法:<ul><li><strong>文本、图形</strong>表示均可；</li><li>静态方面用<strong>用例图</strong>表现，动态方面用<strong>活动图、状态图、交互图</strong>表现。</li></ul></li></ul><h2 id="1-3-软件体系结构风格"><a href="#1-3-软件体系结构风格" class="headerlink" title="1.3 软件体系结构风格"></a>1.3 软件体系结构风格</h2><blockquote><p>内容范围：管道-过滤器，分层体系结构，基于事件的隐式调用，仓库风格</p><p>要点：构件与连接件，实现方式，特点，分类及典型应用</p></blockquote><h3 id="1-3-1-管道-过滤器体系结构风格Pipes-Filters"><a href="#1-3-1-管道-过滤器体系结构风格Pipes-Filters" class="headerlink" title="1.3.1 管道-过滤器体系结构风格Pipes-Filters"></a>1.3.1 管道-过滤器体系结构风格Pipes-Filters</h3><p><img src="http://img.fdchen.host//%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png" alt="image-20210617212211158"></p><ul><li><p>管道-过滤器体系结构风格为处理数据流的软件系统架构提供了一种参考结构。它是由过滤器和管道组成的。每个处理步骤都被封装在一个过滤器组件中，数据流通过相邻过滤器之间的管道进行传输。每个过滤器可以单独修改，功能单一，并且它们之间的顺序可以进行配置。</p></li><li><p><strong>构件类型</strong>：过滤器（Filter）——数据处理构件</p></li><li><p><strong>连接件类型</strong>：管道（Pipe）——过滤器间的连接件</p></li><li><p><strong>分类</strong>：</p><ul><li>被动过滤器（下面的一种的方式）：<ul><li>过滤器从上一个相邻过滤器采用拉入(pull)方式读取数据。</li><li>过滤器采用压出(push)方式输出数据给下一个相邻过滤器。</li></ul></li><li>主动过滤器：<ul><li>过滤器同时支持以上两种方式(Pull&#x2F;Push)读写数据。</li></ul></li></ul></li><li><p><strong>特点</strong>：</p><ul><li>功能特性<ul><li>处理或者转换输入数据流</li><li>对数据流的处理可以容易地分成几个独立的处理步骤</li></ul></li><li>非功能特性（质量特性）<ul><li>系统的升级要求可以通过替换&#x2F;增加&#x2F;重组过滤器实现，有时甚至由使用者完成操作（系统运行时配置更新）</li><li>不同的处理步骤不共享信息（过滤器构件间松耦合）</li></ul></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>高内聚和低耦合</li><li>通过过滤器的增加&#x2F;移除&#x2F;重组可实现数据流处理系统的灵活性&#x2F;可扩展性</li><li>过滤器构件具有可重用性</li><li>有利于系统的维护与更新</li><li>可支持局部步骤的并行处理以提高效率</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>增量式处理数据，存在效率问题</li><li>数据格式转换的问题：数据转换额外开销</li><li>不适合交互式应用系统</li></ul></li><li><p><strong>典型系统案例</strong>：高级语言编译器系统、Windows CMD&#x2F;Unix Shell命令解释器系统</p></li></ul><h3 id="1-3-2-基于事件的隐式调用体系结构风格"><a href="#1-3-2-基于事件的隐式调用体系结构风格" class="headerlink" title="1.3.2 基于事件的隐式调用体系结构风格"></a>1.3.2 基于事件的隐式调用体系结构风格</h3><p><img src="http://img.fdchen.host//%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%9A%90%E5%BC%8F%E8%B0%83%E7%94%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="image-20210617214926793"></p><ul><li>基于事件的(隐式调用风格)系统结构风格中，构件间不采用直接耦合方式交互，而是通过事件机制交互。系统中的事件处理者构件可以通过事件注册来订阅它所关心的事件相关联。当某一事件发生时，系统会通知所有与这个事件相关联的事件处理者构件，即一个事件的激发导致了事件处理者构件与事件源构件间的隐式地交互。</li><li><strong>构件类型</strong>：<ul><li>事件源（Event Source）构件</li><li>事件处理者（Event Handler）构件</li><li>事件分发者（Event Dispatcher）构件</li></ul></li><li><strong>连接件类型</strong>：<ul><li>事件对象（Event）</li></ul></li><li>优点：<ul><li>系统具有很好的灵活性，系统易于伸缩扩展</li></ul></li><li>缺点：<ul><li>系统控制权的问题，系统放弃了全局控制</li><li>数据的交互问题，数据可被一个事件传递，但一些情况下，基于事件的系统必须依靠一个共享的仓库进行交互。</li></ul></li><li>典型系统案例：图形用户界面系统、某些监控系统、现代高级语言的异常处理</li></ul><h3 id="1-3-3-分层体系结构风格"><a href="#1-3-3-分层体系结构风格" class="headerlink" title="1.3.3 分层体系结构风格"></a>1.3.3 分层体系结构风格</h3><p><img src="http://img.fdchen.host//%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png" alt="image-20210617221108262"></p><ul><li>实现方式：<ul><li>将系统分成适当层次，按适当次序放置。</li><li>从最低抽象层次开始，以梯状把抽象层次n放在n-1层顶部。直到功能顶部。</li><li>第n层提供的绝大多数服务由第n-1层提供的服务组成。</li><li>每个层次是一个独立的组件。它的责任是提供由上层使用的服务，并且委派任务给下一层次。</li><li>不允许较高层次直接越级访问较低层次。</li></ul></li><li>构件：每一层对应一个构件<ul><li>层构件内部子构件端口保护：为每个层构件指定一个单一的端口（Port）</li></ul></li><li>连接件：指定相邻层之间的交互模式，Push mode和Pull model</li><li>分类：<ul><li>Top-Down：用户向顶层N发出一个请求</li><li>Botton-Up：从底层开始的动作连</li><li>两个彼此交互的层系统</li></ul></li><li>特点：<ul><li>优点：<ul><li>层构件的封装性、可重用性、可替换性</li><li>系统的局部依赖特性</li></ul></li><li>缺点：<ul><li>层构件间的依赖性，特别是当低层构件的修改影响高层构件的时<br>候，可能引起底层之上的多个层构件的修改。</li><li>效率问题：顶层构件到底层构件之间需要进行层层的参数传递&#x2F;转<br>换等。</li></ul></li></ul></li><li>典型系统案例：TCP&#x2F;IP协议系统，Web应用系统（展现层、业务层、数据访问层）</li></ul><h3 id="1-3-4-仓库体系结构风格Repository"><a href="#1-3-4-仓库体系结构风格Repository" class="headerlink" title="1.3.4 仓库体系结构风格Repository"></a>1.3.4 仓库体系结构风格Repository</h3><p><img src="http://img.fdchen.host//%E4%BB%93%E5%BA%93%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png" alt="image-20210617221314083"></p><ul><li>分类：<ul><li>被动仓库：数据库系统</li><li>主动仓库：黑板系统</li></ul></li><li>特点：<ul><li>优点：<ul><li>可扩展性</li><li>可维护性</li><li>安全性</li><li>并行处理性</li></ul></li><li>缺点：<ul><li>单一失败点：仓库</li></ul></li></ul></li><li>典型系统案例：专家系统</li></ul><h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2 设计模式"></a>2 设计模式</h2><h2 id="2-1-面向对象设计原则"><a href="#2-1-面向对象设计原则" class="headerlink" title="2.1 面向对象设计原则"></a>2.1 面向对象设计原则</h2><blockquote><p>重点是OCP</p></blockquote><h3 id="2-1-1-开闭原则（OCP）（重点）"><a href="#2-1-1-开闭原则（OCP）（重点）" class="headerlink" title="2.1.1 开闭原则（OCP）（重点）"></a>2.1.1 开闭原则（OCP）（重点）</h3><p>软件实体应该对扩展开放，但对修改关闭。</p><ul><li><p>设计模式的支持和体现：</p><p>Strategy模式；Factory模式；Builder模式；Bridge模式；Façade模式；Mediator模式</p></li></ul><h3 id="2-1-2-里氏代换原则（LSP）"><a href="#2-1-2-里氏代换原则（LSP）" class="headerlink" title="2.1.2 里氏代换原则（LSP）"></a>2.1.2 里氏代换原则（LSP）</h3><p>一个软件实体如果使用的是一个基类，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。</p><h3 id="2-1-3-依赖倒转原则（DIP）"><a href="#2-1-3-依赖倒转原则（DIP）" class="headerlink" title="2.1.3 依赖倒转原则（DIP）"></a>2.1.3 依赖倒转原则（DIP）</h3><p>要依赖于抽象，不要依赖于具体（依赖倒转）。要针对接口编程，不要针对实现编程。</p><h3 id="2-1-4-接口隔离原则（ISP）"><a href="#2-1-4-接口隔离原则（ISP）" class="headerlink" title="2.1.4 接口隔离原则（ISP）"></a>2.1.4 接口隔离原则（ISP）</h3><p>使用多个专门的接口比使用单一的总接口要好。（一个类对另一个类的依赖性应当建立在最小的接口之上）。</p><h3 id="2-1-5-合成-x2F-聚合复用原则（CARP）"><a href="#2-1-5-合成-x2F-聚合复用原则（CARP）" class="headerlink" title="2.1.5 合成&#x2F;聚合复用原则（CARP）"></a>2.1.5 合成&#x2F;聚合复用原则（CARP）</h3><p>要尽量使用合成&#x2F;聚合，尽量不要使用继承。</p><h3 id="2-1-6-迪米特法则（LoD）"><a href="#2-1-6-迪米特法则（LoD）" class="headerlink" title="2.1.6 迪米特法则（LoD）"></a>2.1.6 迪米特法则（LoD）</h3><p>一个对象应当对其他对象有尽可能少的了解。</p><p>一个软件实体应当与尽可能少的其他实体发生相互作用（直接通信）。</p><h2 id="2-2-设计模式的分类及适用的问题（意图）"><a href="#2-2-设计模式的分类及适用的问题（意图）" class="headerlink" title="2.2 设计模式的分类及适用的问题（意图）"></a>2.2 设计模式的分类及适用的问题（意图）</h2><blockquote><p>Factory Method Abstract Factory Prototype Singleton </p><p>Adapter（自学理解） Composite Decorator Bridge</p><p>Command Observer(了解) Iterator</p><p>意图、适用性、实现机制、分类、区别</p></blockquote><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h3 id="2-2-1-Factory-Method工厂方法"><a href="#2-2-1-Factory-Method工厂方法" class="headerlink" title="2.2.1 Factory Method工厂方法"></a>2.2.1 Factory Method工厂方法</h3><p><img src="http://img.fdchen.host//Factory%20Method.png" alt="image-20210617222629809"></p><h3 id="2-2-2-Abstract-Factory抽象工厂"><a href="#2-2-2-Abstract-Factory抽象工厂" class="headerlink" title="2.2.2 Abstract Factory抽象工厂"></a>2.2.2 Abstract Factory抽象工厂</h3><p><img src="http://img.fdchen.host//Abstract%20Factory.png" alt="image-20210617222721586"></p><h3 id="2-2-3-Prototype原型"><a href="#2-2-3-Prototype原型" class="headerlink" title="2.2.3 Prototype原型"></a>2.2.3 Prototype原型</h3><p><img src="http://img.fdchen.host//Prototype.png" alt="image-20210617222750554"></p><h3 id="2-2-4-Singleton单例"><a href="#2-2-4-Singleton单例" class="headerlink" title="2.2.4  Singleton单例"></a>2.2.4  Singleton单例</h3><p><img src="http://img.fdchen.host//Singleton.png" alt="image-20210617222809850"></p><h3 id="结构性"><a href="#结构性" class="headerlink" title="结构性"></a>结构性</h3><h3 id="2-2-5-Adapter适配器（自学理解）"><a href="#2-2-5-Adapter适配器（自学理解）" class="headerlink" title="2.2.5 Adapter适配器（自学理解）"></a>2.2.5 Adapter适配器（自学理解）</h3><p><img src="http://img.fdchen.host//Adapter.png" alt="image-20210617222837294"></p><h3 id="2-2-6-Composite组合"><a href="#2-2-6-Composite组合" class="headerlink" title="2.2.6 Composite组合"></a>2.2.6 Composite组合</h3><p><img src="http://img.fdchen.host//Composite.png" alt="image-20210617222955965"></p><ul><li><strong>对于组合模式而言，在安全性和透明性上，会更看重透明性，毕竟组合模式的功能就是要让用户对叶子对象和组合对象的使用具有一致性。而且对于安全性的实现，需要区分是组合对象还是叶子对象，但是有的时候，</strong>你需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。因此在使用组合模式的时候，<strong>建议多用透明性的实现方式，而少用安全性的实现方式</strong>。</li></ul><h3 id="2-2-7-Decorator装饰器"><a href="#2-2-7-Decorator装饰器" class="headerlink" title="2.2.7 Decorator装饰器"></a>2.2.7 Decorator装饰器</h3><p><img src="http://img.fdchen.host//Decorator.png" alt="image-20210617223353031"></p><h3 id="2-2-8-Bridge桥接"><a href="#2-2-8-Bridge桥接" class="headerlink" title="2.2.8 Bridge桥接"></a>2.2.8 Bridge桥接</h3><p><img src="http://img.fdchen.host//Bridge.png" alt="image-20210617222914076"></p><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h3 id="2-2-9-Command命令"><a href="#2-2-9-Command命令" class="headerlink" title="2.2.9 Command命令"></a>2.2.9 Command命令</h3><p><img src="http://img.fdchen.host//Command.png" alt="image-20210617223437485"></p><h3 id="2-2-10-Observer观察者-了解"><a href="#2-2-10-Observer观察者-了解" class="headerlink" title="2.2.10 Observer观察者(了解)"></a>2.2.10 Observer观察者(了解)</h3><p><img src="http://img.fdchen.host//Observer.png" alt="image-20210617223453580"></p><h3 id="2-2-11-Iterator迭代器"><a href="#2-2-11-Iterator迭代器" class="headerlink" title="2.2.11 Iterator迭代器"></a>2.2.11 Iterator迭代器</h3><p><img src="http://img.fdchen.host//Iterator.png" alt="image-20210617223511649"></p><h1 id="3-软件应用框架"><a href="#3-软件应用框架" class="headerlink" title="3 软件应用框架"></a>3 软件应用框架</h1><blockquote><p>应用框架中体系结构和设计模式理论的应用（有点迷，不确定）</p></blockquote><h2 id="3-1-Spring框架（3-0）"><a href="#3-1-Spring框架（3-0）" class="headerlink" title="3.1 Spring框架（3.0）"></a>3.1 Spring框架（3.0）</h2><p><img src="http://img.fdchen.host//Spring%E6%A1%86%E6%9E%B63.0.png" alt="image-20210617225935855"></p><h2 id="3-2-Spring框架中用到的设计模式"><a href="#3-2-Spring框架中用到的设计模式" class="headerlink" title="3.2 Spring框架中用到的设计模式"></a>3.2 Spring框架中用到的设计模式</h2><ul><li>beanfactory：简单工厂模式（不属于23种GOF设计模式之一），单例模式</li><li>FactoryBean：工厂方法</li><li>AOP：代理模式，适配器模式，装饰模式，策略模式</li><li>ApplicationListener：观察者模式</li><li>SimpleInstantiationStrategy：策略模式</li><li>JDBCTemplate：模板模式</li></ul><h2 id="3-3-Spring-MVC的流程"><a href="#3-3-Spring-MVC的流程" class="headerlink" title="3.3 Spring MVC的流程"></a>3.3 Spring MVC的流程</h2><p><img src="http://img.fdchen.host//Spring%20MVC%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="image-20210618171034105"></p>]]></content>
      
      
      <categories>
          
          <category> CQU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件架构 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/yuan-ji-chu-zheng-ze-biao-da-shi/"/>
      <url>/2021/yuan-ji-chu-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Tip: <a href="https://regexr.com/">正则表达式练习网站点此进入</a></strong></p></blockquote><h1 id="1-常用匹配符号"><a href="#1-常用匹配符号" class="headerlink" title="1 常用匹配符号"></a>1 常用匹配符号</h1><ul><li>更多元字符参考：<a href="https://www.runoob.com/regexp/regexp-metachar.html">正则表达式 - 元字符</a></li></ul><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>匹配除断行之外的任意字符</td></tr><tr><td>\w</td><td>匹配阿拉伯数字、英文大小写字母和下划线</td></tr><tr><td>\W</td><td>匹配被\w排除在外的字符（非阿拉伯数字、英文大小写字母或下划线）</td></tr><tr><td>\d</td><td>匹配阿拉伯数字</td></tr><tr><td>\D</td><td>匹配被\d排除在外的字符（非阿拉伯数字）</td></tr><tr><td>\s</td><td>匹配空白字符：空格、制表符tab、断行等</td></tr><tr><td>\S</td><td>匹配被\s排除在外的字符（非空白字符）</td></tr><tr><td>\b</td><td>匹配单词的开始或结束，意思是出现空白字符即停止之前的匹配</td></tr><tr><td>[]</td><td>代表1个字符，比如选择[yY]代表选择y或Y的1个字符</td></tr><tr><td>[选择范围]</td><td>匹配括号中范围内的任意一个字符（采用Unicode编码），比如[0-9]匹配数字0-9、[a-z]匹配小写字母a-z、[\u4e00-\u9fa5]匹配所有汉字</td></tr><tr><td>[范围]+</td><td>重复上一个字符<strong>一次或多次</strong></td></tr><tr><td>[范围]*</td><td>重复上一个字符<strong>零次或多次</strong></td></tr><tr><td>[范围]?</td><td>重复上一个字符<strong>零次或一次</strong></td></tr><tr><td>{a,b}</td><td>重复上一个字符<strong>a次至b次</strong>，{a,}代表至少a次，但不能表示最多几次</td></tr><tr><td>()</td><td>分组匹配，将括号里的表达式匹配的字符分为一组，可以用$1, $2调用（调用有限制）</td></tr><tr><td>^</td><td>1. <strong>限定开头</strong>，匹配输入字符串的开始位置，比如 &#x2F;^A&#x2F;会匹配”An e”中的A；2. 在中括号表达式中使用，当该符号在中括号表达式中使用时，表示<strong>不接受该中括号表达式中的字符集合</strong>，比如：&#x2F;[^a-z\s]&#x2F;会匹配”my 3 sisters”中的”3” ，这里的”^”的意思是字符类的否定，上面的正则表达式的意思是匹配不是（a到z和空白字符）的字符。</td></tr></tbody></table><span id="more"></span><h1 id="2-特殊字符"><a href="#2-特殊字符" class="headerlink" title="2 特殊字符"></a>2 特殊字符</h1><table><thead><tr><th align="left">特殊字符 &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td></tr><tr><td align="left">( )</td><td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用\( 和\)。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。</td></tr><tr><td align="left">[</td><td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 \[。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\“，而 ‘\(‘ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置，除非在中括号表达式中使用，当该符号在中括号表达式中使用时，表示不接受该中括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td align="left">{</td><td align="left">标记限定符表达式的开始。要匹配 {，请使用 \{。</td></tr><tr><td align="left">|</td><td align="left">指明两项之间的一个选择。要匹配 |，请使用 \</td></tr></tbody></table><p><strong>PS</strong>：更多详细语法与教程参考<a href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式|菜鸟教程</a>。</p><h1 id="3-C-正则表达式"><a href="#3-C-正则表达式" class="headerlink" title="3 C++正则表达式"></a>3 C++正则表达式</h1><blockquote><p>转载<a href="https://changkun.de/modern-cpp/zh-cn/06-regex/index.html%EF%BC%8C%E6%AD%A4%E5%A4%84%E5%86%85%E5%AE%B9%E6%9C%89%E7%9C%81%E7%95%A5">https://changkun.de/modern-cpp/zh-cn/06-regex/index.html，此处内容有省略</a></p></blockquote><h2 id="3-1-正则表达式简介"><a href="#3-1-正则表达式简介" class="headerlink" title="3.1 正则表达式简介"></a>3.1 正则表达式简介</h2><p>正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。</p><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ol><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换；</li><li>从某个串中取出符合条件的子串。</li></ol><p>正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><h2 id="3-2-std-regex-及其相关"><a href="#3-2-std-regex-及其相关" class="headerlink" title="3.2 std::regex 及其相关"></a>3.2 std::regex 及其相关</h2><h3 id="3-2-0-综述"><a href="#3-2-0-综述" class="headerlink" title="3.2.0 综述"></a>3.2.0 综述</h3><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。 可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库， 而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时， 使用正则表达式也是工业界最为成熟的普遍做法。</p><p>一般的解决方案就是使用 <code>boost</code> 的正则表达式库。 而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持， 不再依赖第三方。</p><p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象， 模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化， 通过 <code>std::regex_match</code> 进行匹配， 从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）。</p><p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式:</p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, <code>[a-z]</code> 表示匹配一个小写字母, <code>+</code> 可以使前面的表达式匹配多次， 因此 <code>[a-z]+</code> 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 <code>.</code> 表示匹配任意字符，而 <code>\.</code> 则表示匹配字符 <code>.</code>， 最后的 <code>txt</code> 表示严格匹配 <code>txt</code> 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。</li></ul><p><code>std::regex_match</code> 用于匹配字符串和正则表达式，有很多不同的重载形式。 最简单的一个形式就是传入 <code>std::string</code> 以及一个 <code>std::regex</code> 进行匹配， 当匹配成功时，会返回 <code>true</code>，否则返回 <code>false</code>。例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;int main() &#123;    std::string fnames[] &#x3D; &#123;&quot;foo.txt&quot;, &quot;bar.txt&quot;, &quot;test&quot;, &quot;a0.txt&quot;, &quot;AAA.txt&quot;&#125;;    &#x2F;&#x2F; 在 C++ 中 \ 会被作为字符串内的转义符，为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.    std::regex txt_regex(&quot;[a-z]+\\.txt&quot;);     std::regex txt_regex(&quot;[a-z]+\\.txt&quot;, regex::icase); &#x2F;&#x2F; regex::icase 不区分大小写    for (const auto &amp;fname: fnames)        std::cout &lt;&lt; fname &lt;&lt; &quot;: &quot; &lt;&lt; std::regex_match(fname, txt_regex) &lt;&lt; std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种常用的形式就是依次传入 <code>std::string</code>&#x2F;<code>std::smatch</code>&#x2F;<code>std::regex</code> 三个参数， 其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。 在标准库中， <code>std::smatch</code> 被定义为了 <code>std::match_results&lt;std::string::const_iterator&gt;</code>， 也就是一个子串迭代器类型的 <code>match_results</code>。 使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::regex base_regex(&quot;([a-z]+)\\.txt&quot;);std::smatch base_match;for(const auto &amp;fname: fnames) &#123;    if (std::regex_match(fname, base_match, base_regex)) &#123;        &#x2F;&#x2F; std::smatch 的第一个元素匹配整个字符串        &#x2F;&#x2F; std::smatch 的第二个元素匹配了第一个括号表达式        if (base_match.size() &#x3D;&#x3D; 2) &#123;            std::string base &#x3D; base_match[1].str();            std::cout &lt;&lt; &quot;sub-match[0]: &quot; &lt;&lt; base_match[0].str() &lt;&lt; std::endl;            std::cout &lt;&lt; fname &lt;&lt; &quot; sub-match[1]: &quot; &lt;&lt; base &lt;&lt; std::endl;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上两个代码段的输出结果为：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">foo.txt: 1bar.txt: 1test: 0a0.txt: 0AAA.txt: 0sub-match[0]: foo.txtfoo.txt sub-match[1]: foosub-match[0]: bar.txtbar.txt sub-match[1]: bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>以下转载<a href="https://blog.csdn.net/qq_34802416/article/details/79307102">https://blog.csdn.net/qq_34802416/article/details/79307102</a></p></blockquote><h3 id="3-2-1-regex-match"><a href="#3-2-1-regex-match" class="headerlink" title="3.2.1 regex_match"></a>3.2.1 regex_match</h3><h4 id="3-2-1-1-基本概念"><a href="#3-2-1-1-基本概念" class="headerlink" title="3.2.1.1 基本概念"></a>3.2.1.1 基本概念</h4><p>match是全文匹配，即要求整个字符串符合匹配规则。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\\d&quot;)) &lt;&lt; endl;&#x2F;&#x2F;结果为0cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\\d+&quot;)) &lt;&lt; endl;&#x2F;&#x2F;结果为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述方法返回值为bool值，主要用于if条件表达式中。</p><h4 id="3-2-1-2-匹配结果"><a href="#3-2-1-2-匹配结果" class="headerlink" title="3.2.1.2 匹配结果"></a>3.2.1.2 匹配结果</h4><p>更多的时候我们希望能够获得匹配结果（字符串），对结果进行操作。这时就需要对匹配结果进行存储，共有两种存储方式。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">match_results&lt;string::const_iterator&gt; result;smatch result;&#x2F;&#x2F;推荐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二种方式使用起来更简洁、方便，推荐使用。</p><h4 id="3-2-1-3-实例"><a href="#3-2-1-3-实例" class="headerlink" title="3.2.1.3 实例"></a>3.2.1.3 实例</h4><p>下面看一个match方法匹配的实例，看看实际应用：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str &#x3D; &quot;Hello_2018&quot;;smatch result;regex pattern(&quot;(.&#123;5&#125;)_(\\d&#123;4&#125;)&quot;);&#x2F;&#x2F;匹配5个任意单字符 + 下划线 + 4个数字if (regex_match(str, result, pattern))&#123;cout &lt;&lt; result[0] &lt;&lt; endl;&#x2F;&#x2F;完整匹配结果，Hello_2018cout &lt;&lt; result[1] &lt;&lt; endl;&#x2F;&#x2F;第一组匹配的数据，Hellocout &lt;&lt; result[2] &lt;&lt; endl;&#x2F;&#x2F;第二组匹配的数据，2018cout&lt;&lt;&quot;结果显示形式2&quot;&lt;&lt;endl;cout&lt;&lt; result.str() &lt;&lt; endl;&#x2F;&#x2F;完整结果，Hello_2018cout&lt;&lt; result.str(1) &lt;&lt; endl;&#x2F;&#x2F;第一组匹配的数据，Hellocout &lt;&lt; result.str(2) &lt;&lt; endl;&#x2F;&#x2F;第二组匹配的数据，2018&#125;&#x2F;&#x2F;遍历结果for (int i &#x3D; 0; i &lt; result.size(); ++i)&#123;cout &lt;&lt; result[i] &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>result[]与result.str()这两种方式能够获得相同的值，我更喜欢用数组形式的。<br><strong>在匹配规则中，以括号()的方式来划分组别</strong>，实例中的规则共有两个括号，所以共有两组数据。</p><h3 id="3-2-2-regex-search"><a href="#3-2-2-regex-search" class="headerlink" title="3.2.2 regex_search"></a>3.2.2 regex_search</h3><h4 id="3-2-2-1-基本概念"><a href="#3-2-2-1-基本概念" class="headerlink" title="3.2.2.1 基本概念"></a>3.2.2.1 基本概念</h4><p>search是搜索匹配，即搜索字符串中存在符合规则的子字符串。<br>match与search一比较便知：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\\d&quot;)) &lt;&lt; endl;&#x2F;&#x2F;结果为0cout &lt;&lt; regex_search(&quot;123&quot;, regex(&quot;\\d&quot;)) &lt;&lt; endl;&#x2F;&#x2F;结果为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-2-2-2-实例"><a href="#3-2-2-2-实例" class="headerlink" title="3.2.2.2 实例"></a>3.2.2.2 实例</h4><p>直接看例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str &#x3D; &quot;Hello 2018, Bye 2017&quot;;smatch result;regex pattern(&quot;\\d&#123;4&#125;&quot;);&#x2F;&#x2F;匹配四个数字&#x2F;&#x2F;迭代器声明string::const_iterator iterStart &#x3D; str.begin();string::const_iterator iterEnd &#x3D; str.end();string temp;while (regex_search(iterStart, iterEnd, result, pattern))&#123;temp &#x3D; result[0];cout &lt;&lt; temp &lt;&lt; &quot; &quot;;iterStart &#x3D; result[0].second;&#x2F;&#x2F;更新搜索起始位置,搜索剩下的字符串&#125;&#x2F;&#x2F; 输出结果：2018 2017<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要利用迭代器就可以很轻松的访问到所有匹配的结果值。</p><h3 id="3-2-3-regex-replace"><a href="#3-2-3-regex-replace" class="headerlink" title="3.2.3 regex_replace"></a>3.2.3 regex_replace</h3><h4 id="3-2-3-1-基本概念"><a href="#3-2-3-1-基本概念" class="headerlink" title="3.2.3.1 基本概念"></a>3.2.3.1 基本概念</h4><p>replace是替换匹配，即可以将符合匹配规则的子字符串替换为其他字符串。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str &#x3D; &quot;Hello_2018!&quot;;regex pattern(&quot;Hello&quot;);cout &lt;&lt; regex_replace(str, pattern, &quot;&quot;) &lt;&lt; endl;&#x2F;&#x2F;输出：_2018，将Hello替换为&quot;&quot;cout &lt;&lt; regex_replace(str, pattern, &quot;Hi&quot;) &lt;&lt; endl;&#x2F;&#x2F;输出：Hi_2018，将Hello替换为Hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-3-2-扩展"><a href="#3-2-3-2-扩展" class="headerlink" title="3.2.3.2 扩展"></a>3.2.3.2 扩展</h4><p>除了直接替换以外，还有可以用来调整字符串内容（缩短、顺序等）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str &#x3D; &quot;Hello_2018!&quot;;regex pattern2(&quot;(.&#123;3&#125;)(.&#123;2&#125;)_(\\d&#123;4&#125;)&quot;);&#x2F;&#x2F;匹配3个任意字符+2个任意字符+下划线+4个数字cout &lt;&lt; regex_replace(str, pattern2, &quot;$1$3&quot;) &lt;&lt; endl;&#x2F;&#x2F;输出：Hel2018，将字符串替换为第一个和第三个表达式匹配的内容cout &lt;&lt; regex_replace(str, pattern2, &quot;$1$3$2&quot;) &lt;&lt; endl;&#x2F;&#x2F;输出：Hel2018lo，交换位置顺序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>$n用于表示第n组匹配数据</strong>（组这个概念在文章前面部分提到过），所以我们可以利用这种方式来将字符串的内容进行调整。</p><h3 id="3-2-4-匹配忽略大小写"><a href="#3-2-4-匹配忽略大小写" class="headerlink" title="3.2.4 匹配忽略大小写"></a>3.2.4 匹配忽略大小写</h3><p>有时我们希望能够匹配的时候忽略大小写，这时候就要用到Regex的语法选项了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; regex_match(&quot;aaaAAA&quot;, regex(&quot;a*&quot;, regex::icase)) &lt;&lt; endl;&#x2F;&#x2F;结果为1cout &lt;&lt; regex_match(&quot;aaaAAA&quot;, regex(&quot;a*&quot;)) &lt;&lt; endl;&#x2F;&#x2F;结果为0&#x2F;&#x2F; regex::icase：匹配时忽略大小写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-帮助网站"><a href="#3-2-5-帮助网站" class="headerlink" title="3.2.5 帮助网站"></a>3.2.5 帮助网站</h3><p>附上两个写正则表达式常用到的网站</p><ul><li><a href="http://tool.oschina.net/regex/">在线正则表达式验证</a></li><li><a href="https://regexper.com/">regexper</a>（显示正则表达式匹配结构）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 猿基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 常见用法 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_入门教程</title>
      <link href="/2021/linux-ru-men-jiao-cheng/"/>
      <url>/2021/linux-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="1-视频教程"><a href="#1-视频教程" class="headerlink" title="1 视频教程"></a>1 视频教程</h1><p><a href="https://www.bilibili.com/video/BV1dW411M7xL?p=1">尚硅谷Linux教程</a></p><h1 id="2-视频笔记"><a href="#2-视频笔记" class="headerlink" title="2 视频笔记"></a>2 视频笔记</h1><p><a href="http://img.fdchen.host/%E5%B0%9A%E7%A1%85%E8%B0%B7Linux%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0.pdf">尚硅谷Linux课程笔记</a></p><span id="more"></span><h1 id="3-补充"><a href="#3-补充" class="headerlink" title="3 补充"></a>3 补充</h1><h2 id="3-1-笔记补充"><a href="#3-1-笔记补充" class="headerlink" title="3.1 笔记补充"></a>3.1 笔记补充</h2><h3 id="3-1-1-Linux-磁盘分区的方式为mbr分区和gpt分区（笔记中误写成gtp分区）"><a href="#3-1-1-Linux-磁盘分区的方式为mbr分区和gpt分区（笔记中误写成gtp分区）" class="headerlink" title="3.1.1 Linux 磁盘分区的方式为mbr分区和gpt分区（笔记中误写成gtp分区）"></a>3.1.1 Linux 磁盘分区的方式为mbr分区和gpt分区（笔记中误写成gtp分区）</h3><h3 id="3-1-2-vi操作"><a href="#3-1-2-vi操作" class="headerlink" title="3.1.2 vi操作"></a>3.1.2 vi操作</h3><ol><li><p>跳到文本的最后一行：按“G”,即“shift+g”。</p></li><li><p>跳到最后一行的最后一个字符 ： 先重复1的操作即按“G”，之后按“$”键，即“shift+4”。</p></li><li><p>跳到第一行的第一个字符：先按两次“g”。</p></li><li><p>跳转到当前行的第一个字符：在当前行按“0”。</p></li><li><p>vi加密。进入vi，输入”:”  + “X” 之后就提示你输入两次密码。</p></li><li><p>文件重新载入 :e!。</p></li><li><p>单行复制  将光标移到复制行 按 ‘yy’进行复制。</p></li><li><p>多行复制  将光标移到复制首行 按 ‘nyy’进行复制 n&#x3D;1.2.3.4……</p></li><li><p>粘贴 将光标移到粘贴行 按 ‘p’进行粘贴。</p></li><li><p>查找 &#x2F;pattern Enter。</p></li></ol><h2 id="3-2-常用命令补充"><a href="#3-2-常用命令补充" class="headerlink" title="3.2 常用命令补充"></a>3.2 常用命令补充</h2><h3 id="3-2-1-Ctrl-C"><a href="#3-2-1-Ctrl-C" class="headerlink" title="3.2.1 Ctrl+C"></a>3.2.1 Ctrl+C</h3><ul><li>强制中断程序的执行。</li></ul><h3 id="3-2-2-Ctrl-Z"><a href="#3-2-2-Ctrl-Z" class="headerlink" title="3.2.2 Ctrl+Z"></a>3.2.2 Ctrl+Z</h3><ul><li><p>将任务中断，但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态，用户可以使用<strong>fg&#x2F;bg</strong>操作继续前台或后台的任务。</p></li><li><p><strong>fg命令重新启动前台被中断的任务。</strong></p></li><li><p><strong>bg命令把被中断的任务放在后台执行。</strong></p></li></ul><h3 id="3-2-3-Ctrl-d"><a href="#3-2-3-Ctrl-d" class="headerlink" title="3.2.3 Ctrl+d"></a>3.2.3 Ctrl+d</h3><ul><li>不是发送信号，而是表示一个特殊的二进制值，表示 EOF。</li></ul><h3 id="3-2-4-sudo"><a href="#3-2-4-sudo" class="headerlink" title="3.2.4 sudo"></a>3.2.4 sudo</h3><ul><li>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</li></ul><h3 id="3-2-5-ifconfig"><a href="#3-2-5-ifconfig" class="headerlink" title="3.2.5 ifconfig"></a>3.2.5 ifconfig</h3><ul><li>eth0，eth1，eth2……代表网卡一，网卡二，网卡三……</li><li>lo代表127.0.0.1，即localhost</li><li>常见操作：<ul><li>将网卡禁用    ifconfig eth0 down</li><li>将网卡启用    ifconfig eth0 up</li></ul></li></ul><h3 id="3-2-6-tar命令解压到指定的目录"><a href="#3-2-6-tar命令解压到指定的目录" class="headerlink" title="3.2.6 tar命令解压到指定的目录"></a>3.2.6 tar命令解压到指定的目录</h3><ul><li>tar -zxvf &#x2F;bbs.tar.zip -C &#x2F;zzz&#x2F;bbs</li></ul><h3 id="3-2-7-查看当前绝对路径"><a href="#3-2-7-查看当前绝对路径" class="headerlink" title="3.2.7 查看当前绝对路径"></a>3.2.7 查看当前绝对路径</h3><ul><li>pwd</li></ul><h3 id="3-2-8-关机"><a href="#3-2-8-关机" class="headerlink" title="3.2.8 关机"></a>3.2.8 关机</h3><ul><li>halt 立即关机</li></ul><h3 id="3-2-9-后台进程管理"><a href="#3-2-9-后台进程管理" class="headerlink" title="3.2.9 后台进程管理"></a>3.2.9 后台进程管理</h3><ul><li>详见博客：<a href="https://blog.csdn.net/u012787436/article/details/39722583">Linux后台进程管理以及ctrl+z（挂起）、ctrl+c（中断）、ctrl+\（退出）和ctrl+d（EOF）的区别</a></li></ul><h3 id="3-2-10-网络下载，wget"><a href="#3-2-10-网络下载，wget" class="headerlink" title="3.2.10 网络下载，wget"></a>3.2.10 网络下载，wget</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget -P dir&#x2F; https:&#x2F;&#x2F;xxxx  # 将文件保存至目录dir下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-11-自定义alias"><a href="#3-2-11-自定义alias" class="headerlink" title="3.2.11 自定义alias"></a>3.2.11 自定义alias</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">function enshort() &#123;    alias l&#x3D;&#39;ls -a&#39;    alias d&#x3D;&#39;du -h --max-depth 1&#39;    alias n&#x3D;&#39;nvidia-smi&#39;    alias vb&#x3D;&#39;vi ~&#x2F;.bashrc&#39;    alias sb&#x3D;&#39;.~&#x2F;.bashrc&#39;    alias sc&#x3D;&#39;screen&#39;    alias nvfind&#x3D;&#39;fuser -V &#x2F;dev&#x2F;nvidia*&#39;    alias nving&#x3D;&#39;watch -n 0.1 nvidia-smi&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用source让函数生效</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编辑保存后每次连接服务器需要调用此函数才能使用如上alias</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">enshort  # 每次开机后使用此函数命令即可使用如上简化alias<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PS：可以封装一个更高层的函数包含ensort等函数，避免每次连接需要启动多个.bashrc里面的自定义函数</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/1lShNbX9gYQnP0yNHOyMrA">https://mp.weixin.qq.com/s/1lShNbX9gYQnP0yNHOyMrA</a></p><h3 id="3-2-12-向文件追加内容，echo-content-gt-gt-file"><a href="#3-2-12-向文件追加内容，echo-content-gt-gt-file" class="headerlink" title="3.2.12 向文件追加内容，echo content &gt;&gt; file"></a>3.2.12 向文件追加内容，echo content &gt;&gt; file</h3><ul><li><strong>这里注意 &gt;是覆盖，&gt;&gt;是追加</strong></li></ul><h2 id="3-2-13-删除指定前后缀文件-find-x2F-name-‘pre-’-exec-rm"><a href="#3-2-13-删除指定前后缀文件-find-x2F-name-‘pre-’-exec-rm" class="headerlink" title="3.2.13 删除指定前后缀文件 find .&#x2F; -name ‘pre*’ -exec rm {}"></a>3.2.13 删除指定前后缀文件 find .&#x2F; -name ‘pre*’ -exec rm {}</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 指定前缀find .&#x2F; -name &#39;pre*&#39; -exec rm &#123;&#125; \;# 指定后缀find .&#x2F; -name &#39;*.exe&#39; -type f -print -exec rm -rf &#123;&#125; \;(1) &quot;.&quot;    表示从当前目录开始递归查找(2) “ -name &#39;*.exe&#39; &quot;根据名称来查找，要查找所有以.exe结尾的文件夹或者文件(3) &quot; -type f &quot;查找的类型为文件(4) &quot;-print&quot; 输出查找的文件目录名(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>exec选项后面跟随着所要执行的命令或脚本，然后是一对{}，一个空格和一个\，最后是一个分号;</li></ul><h1 id="4-系统配置"><a href="#4-系统配置" class="headerlink" title="4 系统配置"></a>4 系统配置</h1><blockquote><p>系统为 CentOS 7 </p></blockquote><h2 id="4-1-关闭linux退格键和vi发出的嘟嘟声"><a href="#4-1-关闭linux退格键和vi发出的嘟嘟声" class="headerlink" title="4.1 关闭linux退格键和vi发出的嘟嘟声"></a>4.1 关闭linux退格键和vi发出的嘟嘟声</h2><ul><li>root用户下输入 “<strong>rmmod pcspkr</strong>“，本次即可消除，但是下次开机仍然有</li><li>root用户输入”<strong>echo “rmmod pcspkr” &gt;&gt;　&#x2F;etc&#x2F;rc.d&#x2F;rc.local</strong>“，可以永久消除</li></ul><h2 id="4-2-VMWare安装CentOS-7并配置网络"><a href="#4-2-VMWare安装CentOS-7并配置网络" class="headerlink" title="4.2 VMWare安装CentOS 7并配置网络"></a>4.2 VMWare安装CentOS 7并配置网络</h2><ul><li>详见博客：<a href="https://blog.csdn.net/zyq_2014/article/details/79692181">win10下VMware安装CentOS7并配置网络</a></li></ul><h2 id="4-3-安装python-3-8"><a href="#4-3-安装python-3-8" class="headerlink" title="4.3 安装python 3.8"></a>4.3 安装python 3.8</h2><ul><li>详见博客：<a href="https://blog.csdn.net/qq_41261251/article/details/105407495">Centos 7 安装python 3.8</a></li></ul><h2 id="4-4-下载ifconfig"><a href="#4-4-下载ifconfig" class="headerlink" title="4.4 下载ifconfig"></a>4.4 下载ifconfig</h2><ul><li>详见博客：<a href="https://blog.csdn.net/ryu2003/article/details/78492127?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.vipsorttest&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.vipsorttest">CentOS7下解决ifconfig command not found的办法</a></li></ul><h2 id="4-5-安装jdk1-8"><a href="#4-5-安装jdk1-8" class="headerlink" title="4.5 安装jdk1.8"></a>4.5 安装jdk1.8</h2><ul><li>详见博客：<a href="https://blog.csdn.net/java_faep/article/details/71252832">在CentOS7中安装JDK1.8并配置环境变量</a></li></ul><h2 id="4-6-下载web"><a href="#4-6-下载web" class="headerlink" title="4.6 下载web"></a>4.6 下载web</h2><ul><li>详见博客：<a href="https://blog.csdn.net/yg970514/article/details/79032880">关于Python第三方模块安装及问题（web）</a></li></ul><h2 id="4-7-CentOS-7改变系统语言"><a href="#4-7-CentOS-7改变系统语言" class="headerlink" title="4.7 CentOS 7改变系统语言"></a>4.7 CentOS 7改变系统语言</h2><ul><li>详见博客：<a href="https://blog.csdn.net/hanchao_h/article/details/72820999">Centos 7改变系统语言</a>  （待测试）</li></ul><h1 id="5-用户管理"><a href="#5-用户管理" class="headerlink" title="5 用户管理"></a>5 用户管理</h1><h2 id="5-1-新增用户，useradd-d-x2F-home-x2F-xxx-m-user-name"><a href="#5-1-新增用户，useradd-d-x2F-home-x2F-xxx-m-user-name" class="headerlink" title="5.1 新增用户，useradd -d &#x2F;home&#x2F;xxx -m user_name"></a>5.1 新增用户，useradd -d &#x2F;home&#x2F;xxx -m user_name</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">useradd -d &#x2F;home&#x2F;cron&#x2F;log -m bbee<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>创建新用户：useradd</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-d 指定目录文件夹-m 新账号名-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>设置密码</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">passwd bbee<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-2-ubuntu-新建用户不能使用ll等指令，显示出来的信息没有颜色区分的解决方案，usermod-s"><a href="#5-2-ubuntu-新建用户不能使用ll等指令，显示出来的信息没有颜色区分的解决方案，usermod-s" class="headerlink" title="5.2 ubuntu 新建用户不能使用ll等指令，显示出来的信息没有颜色区分的解决方案，usermod -s"></a>5.2 ubuntu 新建用户不能使用ll等指令，显示出来的信息没有颜色区分的解决方案，usermod -s</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo $SHELL #这时会发现使用的&#x2F;bin&#x2F;sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>把用户所使用的shell编译器修改成&#x2F;bin&#x2F;bash即可</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">usermod -s &#x2F;bin&#x2F;bash test #test是用户名字<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时,在echo $SHELL 一下,就会发现是&#x2F;bin&#x2F;bash了。(退出,重新登陆一下)</p><p>原文链接：<a href="https://blog.csdn.net/qq_23934063/article/details/80827911">https://blog.csdn.net/qq_23934063/article/details/80827911</a></p><h2 id="5-3-删除用户"><a href="#5-3-删除用户" class="headerlink" title="5.3 删除用户"></a>5.3 删除用户</h2><p>语法：userdel [-r] 用户名<br>参数：-r 用于彻底删除，用户HOME目录下的档案会被移除，在其他位置上的档案也将一一找出并删除，比如路径&#x2F;var&#x2F;mail&#x2F;用户名 下的邮件。<br>警告：userdel不允许你移除正在线上的使用者帐号。你必须kill此帐号现在在系统上执行的程序才能进行帐号删除。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code使用</title>
      <link href="/2021/yuan-ji-chu-vs-code-shi-yong/"/>
      <url>/2021/yuan-ji-chu-vs-code-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文件夹与工作空间的区别"><a href="#1-文件夹与工作空间的区别" class="headerlink" title="1 文件夹与工作空间的区别"></a>1 文件夹与工作空间的区别</h1><h2 id="1-1-文件夹"><a href="#1-1-文件夹" class="headerlink" title="1.1 文件夹"></a>1.1 文件夹</h2><ul><li>在VS Code的 <strong>“文件”</strong> 菜单中， <strong>“打开文件夹（Open Folder）”</strong> 是指开打项目文件夹的根目录。一个项目文件夹(Project Folder)包含一个或多个文件夹与项目相关的文件夹，以及与该项目相关的VS Code配置(放在.vscode文件夹中)。</li></ul><h2 id="1-2-工作空间"><a href="#1-2-工作空间" class="headerlink" title="1.2 工作空间"></a>1.2 工作空间</h2><ul><li>在VS Code中，工作空间(workspace)具体指后缀为*.code-workspace的文件，它是一个 <strong>JSON with Comments</strong> 格式的文件，里面包含了所有与该工作空间相关联的文件夹，以及相关的VS Code配置信息，如下图所示。</li></ul><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E7%A4%BA%E4%BE%8B.jpg" alt="工作空间信息示例"></p><center>图1-1 工作空间信息示例</center><span id="more"></span><h2 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h2><ul><li>有且仅有需要同时在<strong>多个项目</strong>上工作的时候，才需要创建工作区，这时候，<strong>工作区里面有多个项目文件夹</strong>的根目录(root)，即：Multi-root Workspaces。</li><li>在一个项目上工作，使用文件夹，就够了。针对该项目设置完VS Code后，VS Code会自动在项目文件夹的根目录中创建一个.vscode文件夹存储VS Code配置(settings.json文件)。</li></ul><h2 id="1-4-项目设置"><a href="#1-4-项目设置" class="headerlink" title="1.4 项目设置"></a>1.4 项目设置</h2><ul><li><strong>优先级：用户设置 &lt; 工作空间设置（workspace.code-workspace） &gt; 项目设置(.vscode&#x2F;settings.json文件)</strong></li><li><strong>用户设置即全局设置：</strong>用户自行设定好后，每次打开VSCode即使用的此设定，若某项无设定即使用默认设置。</li><li><strong>工作区设置即工作环境设置：</strong>可对不同的工作环境是用不同的工作环境，若某项无设定，即使用上一层设置。</li><li><strong>文件夹设置即为项目设置：</strong>将一个文件夹当成一个项目，对同一个工作环境下的不同项目，使用不同的设置，若某项无设定，即使用上一层设置。</li></ul><h1 id="2-新建项目（文件夹）"><a href="#2-新建项目（文件夹）" class="headerlink" title="2 新建项目（文件夹）"></a>2 新建项目（文件夹）</h1><ol><li>新建一个空文件夹，并用<strong>VS Code</strong>打开</li><li>按下<strong>“ctrl+shift+P”</strong>打开VS Code命令输入窗口，输入<strong>“task”</strong>，选择<strong>“Confingure Task”</strong>，生成**.vscode**文件夹</li></ol><p><img src="https://github.com/CCSemicircle/img/blob/main/images/%E9%80%89%E6%8B%A9Configure_Task.jpg" alt="选择Confingure Task"></p><center>图2-1 选择Confingure Task</center><ol start="3"><li>打开**.vscode&#x2F;tasks.json**，修改以下信息（以python环境为例）</li></ol><p><img src="http://img.fdchen.host/tasks%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" alt="tasks文件信息"></p><center>图2-2 tasks文件信息</center><ol start="4"><li><strong>新建项目完成</strong>，如果需要设置本项目的项目设置，需要在**.vscode&#x2F;settings.json**文件中配置</li></ol><p><img src="http://img.fdchen.host/settings%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" alt="settings文件信息"></p><center>图2-3 settings文件信息</center><h1 id="3-新建工作区"><a href="#3-新建工作区" class="headerlink" title="3 新建工作区"></a>3 新建工作区</h1><ol><li>选择<strong>”文件 –&gt; 将工作区另存为“</strong></li></ol><p><img src="http://img.fdchen.host/%E5%B0%86%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%8F%A6%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="将工作区另存到文件夹"></p><center>图3-1 将工作区另存到文件夹</center><p><strong>Tip：如果在打开的文件夹的情况下保存工作区，会自动将此文件夹放入工作区，也建议这样使用。</strong></p><ol start="2"><li><p><strong>新建工作空间成功</strong>，可在workspace.code-workspace文件中配置工作空间信息</p><p><img src="http://img.fdchen.host/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE.png" alt="工作空间配置"></p></li></ol><center>图3-2 工作空间配置</center><ol start="3"><li><strong>工作空间配置信息解释</strong></li></ol><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"."</span> 为当前工作区文件所在的文件夹。<span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"../MLProjects"</span> 为自行添加的（项目）文件夹路径。<span class="token property">"python.pythonPath"</span><span class="token operator">:</span> <span class="token string">"C:\\Users\\fdChen\\AppData\\Local\\Programs\\Python\\Python39\\python.exe"</span> 此为python路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>如何在不同的工作区启用&#x2F;禁用不同的插件</strong></li></ol><p>（1）找到当前插件，若是Java或Python等插件集合建议打开其扩展包。有两个选项：</p><ul><li>第一个选项“禁用”为你的用户设置</li><li>第二个选项“禁用（工作区）”为工作区设置</li></ul><p>（2）选择<strong>“禁用（工作区）”</strong></p><p>（3）此设置会只应用到当前工作区下，不会影响用户设置和其他工作区的设置，通过这种方式，将使得安装太多插件下VSCode也不会显得很臃肿，占用内存也会相应地减小，保持一个轻量的VS Code。</p><h1 id="附：常用快捷指令列表"><a href="#附：常用快捷指令列表" class="headerlink" title="附：常用快捷指令列表"></a>附：常用快捷指令列表</h1><h2 id="1-格式化代码：alt-shift-F"><a href="#1-格式化代码：alt-shift-F" class="headerlink" title="1. 格式化代码：alt+shift+F"></a>1. 格式化代码：alt+shift+F</h2><h2 id="2-打开命令行：ctrl-shift-P"><a href="#2-打开命令行：ctrl-shift-P" class="headerlink" title="2. 打开命令行：ctrl+shift+P"></a>2. 打开命令行：ctrl+shift+P</h2>]]></content>
      
      
      <categories>
          
          <category> 猿基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能导论</title>
      <link href="/2021/cqu-ren-gong-zhi-neng-dao-lun/"/>
      <url>/2021/cqu-ren-gong-zhi-neng-dao-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-人工智能的起源与发展"><a href="#1-1-人工智能的起源与发展" class="headerlink" title="1.1 人工智能的起源与发展"></a>1.1 人工智能的起源与发展</h2><h3 id="1-1-1-孕育期"><a href="#1-1-1-孕育期" class="headerlink" title="1.1.1 孕育期"></a>1.1.1 孕育期</h3><ul><li><p>数理逻辑-符号主义学派</p><ul><li>亚里士多德-三段论</li><li>莱布尼茨-形式逻辑符号化</li><li>启发式算法➡专家系统➡知识工程理论与技术</li></ul></li><li><p>人工神经网络-连接主义学派</p><ul><li>麦克洛奇和皮兹-第一个神经网络模型MP模型</li><li>赫布-改变神经网络连接强度的Hebb规则</li></ul></li><li><p>行为主义学派</p><ul><li>维纳-控制论，其影响导致形成了行为主义学派</li></ul></li><li><p>人工智能的载体</p><ul><li>计算机-1946年，第一台通用计算机ENIAC</li></ul></li><li><p>人工智能之父</p><ul><li><p>图灵</p></li><li><p>图灵试验</p></li></ul></li><li><p>AI的诞生</p><ul><li>1956年的一次会议，麦卡锡提议正式采用了Artificial Intelligence这一术语</li></ul></li></ul><span id="more"></span><h3 id="1-1-2-形成期"><a href="#1-1-2-形成期" class="headerlink" title="1.1.2 形成期"></a>1.1.2 形成期</h3><h3 id="1-1-3-第一次低谷"><a href="#1-1-3-第一次低谷" class="headerlink" title="1.1.3 第一次低谷"></a>1.1.3 第一次低谷</h3><h3 id="1-1-4-黄金时代"><a href="#1-1-4-黄金时代" class="headerlink" title="1.1.4 黄金时代"></a>1.1.4 黄金时代</h3><h3 id="1-1-5-第二次低谷"><a href="#1-1-5-第二次低谷" class="headerlink" title="1.1.5 第二次低谷"></a>1.1.5 第二次低谷</h3><h3 id="1-1-6-平稳发展期"><a href="#1-1-6-平稳发展期" class="headerlink" title="1.1.6 平稳发展期"></a>1.1.6 平稳发展期</h3><h3 id="1-1-7-蓬勃发展期"><a href="#1-1-7-蓬勃发展期" class="headerlink" title="1.1.7 蓬勃发展期"></a>1.1.7 蓬勃发展期</h3><ul><li><p>发展现状</p><ul><li>专用人工智能-让人工智能专门去做一件事</li></ul></li></ul><h2 id="1-2-人工智能的三大学派"><a href="#1-2-人工智能的三大学派" class="headerlink" title="1.2 人工智能的三大学派"></a>1.2 人工智能的三大学派</h2><h3 id="1-2-1-图灵测试"><a href="#1-2-1-图灵测试" class="headerlink" title="1.2.1 图灵测试"></a>1.2.1 图灵测试</h3><ul><li>通过让机器模仿人回答某些问题</li><li>判断它是否具备智能<ul><li>核心：不是“计算机能否和人对话”，而是“计算机能否在智力行为上表现得和人无法区分”</li><li>Turing测试第一次给出了检验计算机是否具有智能的哲学说法</li></ul></li></ul><h3 id="1-2-2-符号主义Symbolicism"><a href="#1-2-2-符号主义Symbolicism" class="headerlink" title="1.2.2 符号主义Symbolicism"></a>1.2.2 符号主义Symbolicism</h3><ul><li>逻辑主义、心理学派和计算机派</li><li>其原理主要为物理符号系统（即符号操作系统）假设和有限合理性原理</li><li>人是一个物理符号系统，计算机也是一个物理符号系统，因此，能够用计算机来模拟人的智能行为</li><li>基于逻辑推理的智能模拟方法，源于数学逻辑</li><li>主要成果：机器定理程序（LT、GTM、GPS….）、启发式算法、专家系统</li><li>可以解决逻辑思维,但对于形象思维难于模拟，信息表示成符号后，并在处理或转换时,信息有丢失的情况</li></ul><h3 id="1-2-3-连接主义Connectionism"><a href="#1-2-3-连接主义Connectionism" class="headerlink" title="1.2.3 连接主义Connectionism"></a>1.2.3 连接主义Connectionism</h3><ul><li>又称为仿生学派或生理学派</li><li>其原理主要为神经网络及神经网络间的连接机制与学习算法</li><li>核心思想：认为人的智能归结为人脑的高层活动的结果，强调智能活动是由大量简单的单元通过复杂链接后，并行运行的结果。</li><li>代表成果：人工神经网络，深度神经网络</li><li>不适合于解决逻辑思维，体现结构固定和组成方案， 单一的系统也不适合多种知识的开发</li></ul><h3 id="1-2-4-行为主义Actionism"><a href="#1-2-4-行为主义Actionism" class="headerlink" title="1.2.4  行为主义Actionism"></a>1.2.4  行为主义Actionism</h3><ul><li><p>又称进化主义和控制论学派</p></li><li><p>其原理为控制论及感知——动作型控制系统</p></li><li><p>控制学论</p><ul><li>认为智能取决于感知和行为，取决于对外界复杂环境的适应，而不是表示和推理</li></ul></li><li><p>进化学论</p><ul><li>认为人的智能归根结底是从生物进化中得到</li></ul></li></ul><h3 id="1-2-5-人工智能三种主流方法区别"><a href="#1-2-5-人工智能三种主流方法区别" class="headerlink" title="1.2.5 人工智能三种主流方法区别"></a>1.2.5 人工智能三种主流方法区别</h3><ul><li><p>用规则教</p><ul><li>优势：与人类逻辑推理相似，解释性强</li><li>不足：难以构建完备的知识规则库</li></ul></li><li><p>用数据学</p><ul><li>优势：直接从数据中学</li><li>不足：依赖于数据、解释性不强</li></ul></li><li><p>用问题引导</p><ul><li>优势：从经验中进行能力的持续学习</li><li>不足：非穷举式搜索而需更好策略</li></ul></li></ul><h1 id="2-知识表示"><a href="#2-知识表示" class="headerlink" title="2 知识表示"></a>2 知识表示</h1><h2 id="2-1-知识层次"><a href="#2-1-知识层次" class="headerlink" title="2.1  知识层次"></a>2.1  知识层次</h2><ul><li><p>数据</p><ul><li>一些无关联的事实</li></ul></li><li><p>信息</p><ul><li>建立了事实间的联系后形成的信息</li></ul></li><li><p>知识</p><ul><li>当能建立模式之间的联系后便涌现出了知识</li></ul></li><li><p>智慧</p><ul><li>能描述模式之间关系的规律</li></ul></li></ul><h2 id="2-2-知识表示的过程"><a href="#2-2-知识表示的过程" class="headerlink" title="2.2  知识表示的过程"></a>2.2  知识表示的过程</h2><ul><li>非形式化的自然语言描述➡形式化的易于被计算机理解的表示</li></ul><h2 id="2-3-知识的特性"><a href="#2-3-知识的特性" class="headerlink" title="2.3  知识的特性"></a>2.3  知识的特性</h2><ul><li>相对正确性</li><li>不确定性</li><li>可表示性和可利用性</li></ul><h2 id="2-4-知识的表示"><a href="#2-4-知识的表示" class="headerlink" title="2.4  知识的表示"></a>2.4  知识的表示</h2><ul><li>将人类知识形式化或者模型化</li></ul><h3 id="2-4-1-目的"><a href="#2-4-1-目的" class="headerlink" title="2.4.1 目的"></a>2.4.1 目的</h3><ul><li>让机器存储和运用人类的知识</li></ul><h3 id="2-4-2-选择知识表示方法的原则"><a href="#2-4-2-选择知识表示方法的原则" class="headerlink" title="2.4.2 选择知识表示方法的原则"></a>2.4.2 选择知识表示方法的原则</h3><ul><li>充分表示领域知识</li><li>有利于对知识的利用</li><li>便于对知识的组织、维护与管理</li><li>便于理解和实现</li></ul><h3 id="2-4-3-几种知识表示的方法"><a href="#2-4-3-几种知识表示的方法" class="headerlink" title="2.4.3 几种知识表示的方法"></a>2.4.3 几种知识表示的方法</h3><ul><li><p>符号主义</p><ul><li><p>谓词逻辑</p><ul><li><p>逻辑学之父：亚里士多德-三段论</p></li><li><p>命题逻辑：研究命题和命题之间关系的符号逻辑系统</p><ul><li><p>命题：一个非真即假的陈述句</p></li><li><p>联接词：诸如“没有”、“如果…那么…”等连词</p><ul><li><p>与，命题合取，p且q</p></li><li><p>或，命题析取，p或q</p></li><li><p>非，命题否定，非p</p></li><li><p>条件，命题蕴含，如果p则q</p><ul><li>仅p为true且q为false时，结果为false</li></ul></li><li><p>双向条件，命题双向蕴含，p当且仅当q</p><ul><li>p和q同为true或同为false时，结果为true</li></ul></li></ul></li></ul></li><li><p>复合命题：由联结词和命题连接而成的更加复杂的命题称为复合命题</p><ul><li>逻辑等价的例子</li></ul></li></ul></li></ul><p><img src="http://img.fdchen.host/AIClass/%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="逻辑等价的例子"></p></li><li><p>谓词逻辑</p><ul><li><p>用于刻画个体的性质、状态和个体之间关系的语言成分就是谓词</p><ul><li><p>分类</p></li><li><p>一元谓词A(x)</p><ul><li><p>二元谓词B(x,y)</p></li><li><p>多元谓词P(x1,x2,x3,…,xn)</p></li><li><p>x1,x2,x3,…,xn为客体变量或变元</p></li></ul></li></ul></li><li><p>语法元素</p><ul><li><p>常量（个体符号）</p><ul><li><p>变量符号</p></li><li><p>函数符号</p></li><li><p>习惯上用小写英文字母或小写英文字母串表示</p></li></ul></li><li><p>谓词符号</p><ul><li>习惯上用大写英文字母或者首字母大写的英文字母串表示</li></ul></li><li><p>联结词</p></li></ul></li><li><p>量词</p><ul><li>全称量词<ul><li><p>存在量词</p></li><li><p>全程量词与存在量词的组合</p></li><li><p>∀𝑥¬𝑃(𝑥) ≡ ¬∃𝑥𝑃(𝑥)<br>    - ¬∀𝑥𝑃(𝑥) ≡ ∃𝑥¬𝑃(𝑥)<br>      - ∀𝑥𝑃(𝑥) ≡¬∃𝑥¬𝑃(𝑥)<br>      - ∃𝑥𝑃(𝑥) ≡ ¬∀𝑥¬𝑃(𝑥)</p></li></ul></li></ul></li><li><p>函数与谓词的区别</p><ul><li>函数时从定义域到值域的映射，结果仍为个体<ul><li>谓词时从定义域到{True, False}的映射，结果为命题</li></ul></li></ul></li><li><p>推理规则</p><ul><li><p>全称量词消去UI</p><ul><li>(∀𝑥)𝐴(𝑥) → 𝐴(𝑦)</li></ul></li><li><p>全称量词引入UG</p><ul><li>𝐴(𝑦) → (∀𝑥)𝐴(𝑥)</li></ul></li><li><p>存在量词消去EI</p><ul><li>(∃𝑥)𝐴(𝑥) → 𝐴(𝑐)</li></ul></li><li><p>存在量词引入EG</p><ul><li>𝐴(c) → (∃𝑥)𝐴(𝑥)</li></ul></li></ul></li><li><p>优点</p><ul><li>自然性<ul><li>精确性</li><li>容易实现</li></ul></li></ul></li><li><p>不足</p><ul><li>不能表示不确定性知识<ul><li>形式过于自由，兼容性差</li></ul></li></ul></li></ul></li><li><p>产生式系统</p><ul><li><p>通常用于表示事实、规则以及它们的不确定性度量，适合于表示事实性知识和规则性知识</p></li><li><p>确定性规则知识的产生式表示</p><ul><li>IF P THEN Q 或者 P➡Q<ul><li><p>三元组表示：（对象，属性，值）或者（关系，对象1，对象2）</p><ul><li>（Li，age，40） <ul><li>（friend，Li，Wang）</li></ul></li></ul></li></ul></li></ul></li><li><p>不确定规则知识的产生式表示</p><ul><li>IF P THEN Q（置信度） 或者 P➡Q（置信度）<ul><li><p>四元组表示：（对象，属性，值，置信度）或者 （关系，对象1，对象2，置信度）</p><ul><li>（Li，age，40, 0.8） <ul><li>（friend，Li，Wang, 0.1）</li></ul></li></ul></li></ul></li></ul></li><li><p>产生式和谓词逻辑中的蕴含式的区别</p><ul><li>产生式与谓词逻辑中的蕴涵式的基本形式相同，但蕴涵式只是产生式的一种特殊情况。<ul><li>除逻辑蕴含外，产生式还包括各种操作、规则、变换、算子、函数等。 </li><li>蕴含式只能表示精确知识，而产生式不仅可以表示精确的知识，还可以表示不精确知识。</li></ul></li></ul></li><li><p>基本结构</p><p><img src="http://img.fdchen.host/AIClass/%E4%BA%A7%E7%94%9F%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="产生式系统基本结构"></p><ul><li>规则库<ul><li><p>综合数据库</p></li><li><p>控制系统（推理机）</p><ul><li>推理<ul><li>冲突消解</li><li>执行规则</li><li>检查推理终止条件</li><li>长颈鹿的例子</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="http://img.fdchen.host/AIClass/%E9%95%BF%E9%A2%88%E9%B9%BF%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="长颈鹿的例子"></p><ul><li><p>优点</p><ul><li>自然性<ul><li>模块性</li><li>有效性</li><li>清晰性</li></ul></li></ul></li><li><p>缺点</p><ul><li>效率不高<ul><li>不能表达结构性知识</li></ul></li></ul></li><li><p>专家系统</p><ul><li>专家系统可以模拟某个领域专家的决策能力。</li></ul></li></ul></li><li><p>框架系统</p><ul><li><p>一种结构化的知识表示方法，已在多种系统中得到应用。</p><ul><li><p>一般结构</p><ul><li>框架<ul><li>一个槽用于描述所论对象某一方面的属性</li><li>一个侧面用于描述相应属性的一个方面</li><li>槽和侧面所具有的属性值分别被称为槽值和侧面值</li><li>计算机主机的框架描述示例</li></ul></li></ul><p><img src="http://img.fdchen.host/AIClass/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%A1%86%E6%9E%B6%E6%8F%8F%E8%BF%B0%E7%A4%BA%E4%BE%8B.png" alt="计算机主机的框架描述示例"></p></li></ul></li><li><p>典型的框架知识库FrameNet</p></li><li><p>特点</p><ul><li>结构性</li><li>继承性</li><li>自然性</li></ul></li></ul></li><li><p>经验主义</p><ul><li><p>状态表示（状态空间表示法）</p><ul><li><p>用来表示问题及其搜索过程的一种方法，它是以状态和算符(操作)为基础来表示和求解问题的</p></li><li><p>主要元素</p><ul><li><p>状态</p><ul><li>状态变量</li></ul></li><li><p>操作</p></li><li><p>状态空间</p><ul><li>状态空间用一个三元组表示：（S, F, G）</li><li>状态空间图</li></ul></li></ul></li><li><p>二阶梵塔难题求解过程</p></li><li><p>猴子与香蕉问题求解过程</p></li><li><p>传教士问题求解过程</p></li></ul></li><li><p>特征表示</p></li></ul></li><li><p>连接主义</p><ul><li>网络权重</li><li>语义向量</li></ul></li></ul><h1 id="3-搜索求解策略"><a href="#3-搜索求解策略" class="headerlink" title="3 搜索求解策略"></a>3 搜索求解策略</h1><h2 id="3-1-内容"><a href="#3-1-内容" class="headerlink" title="3.1 内容"></a>3.1 内容</h2><ul><li>早期搜索技术，如图搜索、盲目搜索、启发式搜索</li><li>高级搜索技术，如规则演绎系统、产生式系统</li><li>给定待求解问题→搜索算法按事先设定的逻辑自动寻找答案</li></ul><h2 id="3-2-概念"><a href="#3-2-概念" class="headerlink" title="3.2 概念"></a>3.2 概念</h2><ul><li>根据问题的实际情况不断寻找可利用的知识，构造出一条代价较少的推理路线，使问题得到圆满解决的过程。</li></ul><h2 id="3-3-标准"><a href="#3-3-标准" class="headerlink" title="3.3 标准"></a>3.3 标准</h2><ul><li>搜索空间小</li><li>解最佳</li></ul><h2 id="3-4-图搜索策略"><a href="#3-4-图搜索策略" class="headerlink" title="3.4 图搜索策略"></a>3.4 图搜索策略</h2><h3 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1 基本概念"></a>3.4.1 基本概念</h3><ul><li><p>图的搜索</p><ul><li>一种在图中寻找路径的方法，图中每个节点对应一个状态，每条连线对应一个操作符</li></ul></li><li><p>分类</p><ul><li>无信息搜索（盲目搜索）</li><li>有信息搜索（启发式搜索）</li></ul></li></ul><h3 id="3-4-2-状态图搜索"><a href="#3-4-2-状态图搜索" class="headerlink" title="3.4.2 状态图搜索"></a>3.4.2 状态图搜索</h3><ul><li><p>记录搜索轨迹</p><ul><li>OPEN表（存放待扩展的节点表）</li><li>CLOSED表（存放已扩展的节点）</li><li>从目标返回的路径</li><li>注：每个表示状态的节点结构中必须有指向父节点的指针</li></ul></li><li><p>图的一般搜索策略</p><p>  <img src="http://img.fdchen.host/AIClass/%E5%9B%BE%E7%9A%84%E4%B8%80%E8%88%AC%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt="图的一般搜索策略"></p><ul><li>状态图搜索-例题一</li></ul></li></ul><p><img src="http://img.fdchen.host/AIClass/%E7%8A%B6%E6%80%81%E5%9B%BE%E6%90%9C%E7%B4%A2-%E4%BE%8B%E9%A2%98%E4%B8%80.png" alt="状态图搜索-例题一"></p><h3 id="3-4-3-盲目式搜索"><a href="#3-4-3-盲目式搜索" class="headerlink" title="3.4.3 盲目式搜索"></a>3.4.3 盲目式搜索</h3><h4 id="3-4-3-1-概念"><a href="#3-4-3-1-概念" class="headerlink" title="3.4.3.1  概念"></a>3.4.3.1  概念</h4><ul><li>对特定问题不具有任何相关信息的条件下，按照固定的步骤（依次或者随机）进行搜索，搜索过程中获得的中间信息不用来改进控制策略。</li></ul><h4 id="3-4-3-2-宽度优先搜索"><a href="#3-4-3-2-宽度优先搜索" class="headerlink" title="3.4.3.2  宽度优先搜索"></a>3.4.3.2  宽度优先搜索</h4><ul><li>OPEN表采用先进先出的队列结构，先生成的节点先扩展</li><li>宽度优先搜索策略</li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt="宽度优先搜索策略"></p><ul><li>宽度优先搜索示例</li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B.png" alt="宽度优先搜索示例"></p><ul><li>八数码难题-BFS</li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98-BFS.png" alt="八数码难题-BFS"></p><ul><li><p>特点</p><ul><li>新扩展的节点排在open表的末端</li><li>当问题有解时，一定能找到解</li><li>方法与问题无关，具有通用性</li></ul></li></ul><h4 id="3-4-3-3-深度优先搜索"><a href="#3-4-3-3-深度优先搜索" class="headerlink" title="3.4.3.3  深度优先搜索"></a>3.4.3.3  深度优先搜索</h4><ul><li>OPEN表采用先进后出的堆栈结构，先扩展最新产生的（即最深的）节点</li><li>深度优先搜索策略</li></ul><p><img src="http://img.fdchen.host/AIClass/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt="深度优先搜索策略"></p><ul><li>深度优先搜索示例</li></ul><p><img src="http://img.fdchen.host/AIClass/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B.png" alt="深度优先搜索示例"></p><ul><li><p>深度界限</p><ul><li>防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度——深度界限</li></ul></li><li><p>节点深度</p><ul><li>起始节点的深度为0，任何其他节点的深度等于其父辈节点的深度加1。</li></ul></li><li><p>八数码难题-DFS</p></li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98-DFS.png" alt="八数码难题-DFS"></p><ul><li><p>特点</p><ul><li>一般不能保证找到最优解</li><li>当深度限制不合理时，可能找不到解，可以将算法改为可变深度限制</li><li>最坏情况时，搜索空间等同于穷举</li></ul></li></ul><h4 id="3-4-3-4-等代价搜索"><a href="#3-4-3-4-等代价搜索" class="headerlink" title="3.4.3.4  等代价搜索"></a>3.4.3.4  等代价搜索</h4><ul><li><p>Dijkstra提出——Dijkstra算法</p></li><li><p>是宽度优先搜索的一种推广，不是沿着等长度路径断层进行扩展，而是沿着等代价路径断层进行扩展。状态图中每条连接弧线上的有关代价，表示时间、距离等开销。</p></li><li><p>节点代价</p><ul><li>g (n)： 表示从初始节点 S。到节点n的代价；</li><li>c (n1, n2) : 表示从父节点 n1 到其子节点 n2 的代价；</li><li>g (n2) &#x3D; g (n1) + c ( n1 ,n2)</li></ul></li><li><p>等代价搜索策略</p></li></ul><p><img src="http://img.fdchen.host/AIClass/%E7%AD%89%E4%BB%A3%E4%BB%B7%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt="等代价搜索策略"></p><ul><li>等代价搜索示例</li></ul><p><img src="http://img.fdchen.host/AIClass/%E7%AD%89%E4%BB%A3%E4%BB%B7%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B.png" alt="等代价搜索示例"></p><h4 id="3-4-3-5-盲目式搜索特点"><a href="#3-4-3-5-盲目式搜索特点" class="headerlink" title="3.4.3.5  盲目式搜索特点"></a>3.4.3.5  盲目式搜索特点</h4><ul><li>搜索过程中不使用与问题有关的经验信息</li><li>搜索效率低</li><li>不适合大空间的实际问题求解</li></ul><h3 id="3-4-4-启发式搜索"><a href="#3-4-4-启发式搜索" class="headerlink" title="3.4.4  启发式搜索"></a>3.4.4  启发式搜索</h3><ul><li>启发性信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息。</li></ul><h4 id="3-4-4-1-核心思想"><a href="#3-4-4-1-核心思想" class="headerlink" title="3.4.4.1 核心思想"></a>3.4.4.1 核心思想</h4><ul><li>需定义一个评价函数，对当前的搜索状态进行评估， 找出一个最有希望的节点来扩展。即根据评价函数重排OPEN表， 选择最有希望的节点加以扩展。</li><li>估价函数：f(n) &#x3D; g(n) + h(n)，g(n)表示从起始状态到当前状态n的实际代价，h(n)表示从当前状态到目标状态的估计代价（启发式函数）</li></ul><h4 id="3-4-4-2-A算法"><a href="#3-4-4-2-A算法" class="headerlink" title="3.4.4.2 A算法"></a>3.4.4.2 A算法</h4><ul><li>有序搜索，也称优先搜索&#x2F;全局择优， 选择OPEN表上具有最小 f 值的节点作为下一个要扩展的节点。</li><li>有序搜索算法框图</li></ul><p><img src="http://img.fdchen.host/AIClass/%E6%9C%89%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E6%A1%86%E5%9B%BE.png" alt="有序搜索算法框图"></p><ul><li>A算法求解八数码问题过程</li></ul><p><img src="http://img.fdchen.host/AIClass/A%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%E8%BF%87%E7%A8%8B.png" alt="A算法求解八数码问题过程"></p><ul><li><p>特征</p><ul><li>对h(n)无限制，虽提高了算法效率，但不能保证找到最优解</li><li>不合适的h(n)定义会导致算法找到不解</li></ul></li></ul><h4 id="3-4-4-3-A-算法"><a href="#3-4-4-3-A-算法" class="headerlink" title="3.4.4.3  A*算法"></a>3.4.4.3  A*算法</h4><ul><li><p>彼得.哈特对A算法进行了很小的修改，并证明了当估价函数满足一定的限制条件时，算法一定可以找到最优解。</p></li><li><p>隶属于A算法，估价函数满足一定限制条件的算法称为A*算法</p></li><li><p>f (n) &#x3D; g (n) + h (n), g(n)大于0，h(n)不大于n到目标节点的实际代价</p><ul><li>g (n) &gt;&#x3D;g* (n)，g*(n)是从初始节点S0到任意节点n的一条最佳路径的代价</li><li>h (n) &lt;&#x3D;h* (n)，h*(n)是从节点n到目标节点的一条最佳路径的代价</li><li>f(n)可视为经过节点n，具有最小开销代价值的路径。</li></ul></li><li><p>根据h(n)区分几种算法</p><ul><li>如果第8步的重排OPEN表是依据f(n)&#x3D;g(n)+h(n) 进行的,则称该过程为A算法</li><li>在A算法中,如果对所有的n存在h(n)≤h*(n) ,则称h(n)为h*(n)的下界,它表示某种偏于保守的估计，采用h*(n)的下界h(n)为启发函数的A算法，称为A*算法。</li><li>h(n)&#x3D;0 时，A*算法就变为等代价搜索算法</li></ul></li><li><p>A*算法流程图</p></li></ul><p><img src="http://img.fdchen.host/AIClass/A%2B%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="A*算法流程图"></p><ul><li>A*算法求解八数码问题</li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%88%A9%E7%94%A8A%2B%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98-1.png" alt="利用A\*算法求解八数码问题-1"></p><p><img src="http://img.fdchen.host/AIClass/%E5%88%A9%E7%94%A8A%2B%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98-2.png" alt="利用A\*算法求解八数码问题-2"></p><p><img src="http://img.fdchen.host/AIClass/%E5%88%A9%E7%94%A8A%2B%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98-2.png" alt="利用A\*算法求解八数码问题-3"></p><ul><li><p>A*算法的搜索效率很大程度上取决于h(n), 在满足h(n)&lt;&#x3D;h*(n)的前提下，h(n)的值越大越好,h(n)的比重越大表示启发性越强。</p></li><li><p>如果算法有解， A*算法一定能够找到最优的解答。</p></li><li><p>特点</p><ul><li>在f(n)中，g(n)的比重越大，越倾向于宽度优先搜索，而h(n)的比重越大，表示启发性越强。</li><li>g(n)的作用一般是不可忽略的，保持g(n)项就保持了搜索的宽度优先成分，这有利于搜索的完备性，但会影响搜索的效率。</li></ul></li></ul><h1 id="4-智能计算及其应用"><a href="#4-智能计算及其应用" class="headerlink" title="4 智能计算及其应用"></a>4 智能计算及其应用</h1><h2 id="4-1-遗传算法"><a href="#4-1-遗传算法" class="headerlink" title="4.1  遗传算法"></a>4.1  遗传算法</h2><h3 id="4-1-1-定义"><a href="#4-1-1-定义" class="headerlink" title="4.1.1 定义"></a>4.1.1 定义</h3><ul><li>通过生物遗传和进化过程中选择、交叉、变异机理的模仿，完成对问题求解的自适应搜索过程。</li></ul><h3 id="4-1-2-与生物进化对比"><a href="#4-1-2-与生物进化对比" class="headerlink" title="4.1.2 与生物进化对比"></a>4.1.2 与生物进化对比</h3><p><img src="http://img.fdchen.host/AIClass/%E4%B8%8E%E7%94%9F%E7%89%A9%E8%BF%9B%E5%8C%96%E5%AF%B9%E6%AF%94.png" alt="与生物进化对比"></p><h3 id="4-1-3-基本思想"><a href="#4-1-3-基本思想" class="headerlink" title="4.1.3 基本思想"></a>4.1.3 基本思想</h3><ul><li>把问题的解表示成“染色体”，在算法中即是以一定方式编码的串，在执行遗传算法之前，给定一群“染色体”——即假设解。</li><li>把这些假设解置于问题的“环境”中，并按适者生存的原则：从中选择出较适应环境的“染色体”进行复制，再通过交叉、变异过程产生更适合环境的新一代“染色体”群。</li><li>这样一代一代地进化，最后就会收敛到最适应环境的一个“染色体”上——它就是问题的最优解</li><li>5个基本要素<ul><li>参数编码</li><li>初始群体设定</li><li>适应度函数设定</li><li>遗传操作设计</li><li>控制参数设定</li></ul></li></ul><h3 id="4-1-4-主要操作"><a href="#4-1-4-主要操作" class="headerlink" title="4.1.4 主要操作"></a>4.1.4 主要操作</h3><ul><li><p>编码</p><ul><li>将问题结构变换为位串形式编码表示的过程叫编码(Encoding) </li><li>将位串形式编码表示变换为原问题结构的过程叫解码或译码(Decoding)</li><li>GA中的编码方式：二进制编码、浮点数编码、格雷码编码、符号编码等</li></ul></li><li><p>群体设定</p><ul><li><p>初始种群的产生</p><ul><li>根据问题固有知识，把握最优解所占空间在整个问题空间中的分布范围，然后，在此分布范围内设定初始群体。</li><li>随机产生一定数目的个体，从中挑选最好的个体加到初始群体中。这种过程不断迭代，直到初始群体中个体数目达到了预先确定的规模。</li></ul></li><li><p>种群规模的确定</p><ul><li>规模太小：遗传算法的优化性能不太好，易陷入局部最优解</li><li>规模太大：计算复杂</li></ul></li></ul></li><li><p>适应度函数</p><ul><li><p>表示个体的优劣并作为遗传操作的依据</p><ul><li>个体适应度高：被选择的概率大；反之就小</li></ul></li><li><p>直接将待求解优化问题的目标函数变换而得到</p><ul><li>最大化问题直接为目标函数，最小化问题则为目标函数的倒数</li></ul></li><li><p>在遗传算法中，将所有妨碍适应度值高的个体产生、从而影响算法正常工作的问题统称为欺骗问题（Deceptive Problem）</p><ul><li><p>过早收敛：缩小这些个体的适应度，以降低这些超级个体的竞争力</p></li><li><p>停滞现象：改变原始适应值的比例关系，以提高个体之间的竞争力</p></li><li><p>适应度函数的尺度变换（Fitness Scaling）或者定标：对适应度函数值域的某种映射变换</p><ul><li><p>线性变换</p><ul><li>变换的时候希望满足变换前后它的平均值或者什么保持不变，所以可以加上约束，也可以不加</li></ul></li><li><p>幂函数变换</p></li><li><p>指数变换</p></li></ul></li></ul></li></ul></li><li><p>选择</p><ul><li><p>个体选择概率分配方法</p><ul><li><p>适应度比例方法&#x2F;蒙特卡洛法</p></li><li><p>排序方法</p><ul><li>线性排序</li><li>非线性排序</li></ul></li></ul></li><li><p>选择个体的方法</p><ul><li>轮盘赌选择：适应度➡选择概率➡累积概率，若r&lt;q[1]，选择个体1，否则选择个体k，满足q[k-1]&lt;r≤q[k]。</li><li>最佳个体保存方法<ul><li>把群体中适应度最高的个体直接复制到下一代中，保证遗传算法终止时得到的最后结果一定是历代出现过的最高适应度的个体。</li></ul></li><li>锦标赛选择</li><li>从群体中随机选择一些个体，将其中适应度最高的个体保存到下一代。这一过程反复执行，直到保存到下一代的个体数达到预先设定的数量为止。<ul><li>二元锦标赛：每个选择的个体数为2。</li></ul></li></ul></li></ul></li><li><p>交叉</p><ul><li>一点交叉：在个体串中随机设定一个交叉点，实行交叉时，两个个体的该点前或后的部分结构进行互换，并生成两个新的个体。</li><li>二点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。</li></ul></li><li><p>变异</p><ul><li><p>交叉只能对现有基因池进行重组，变异可以生成新的基因</p></li><li><p>变异概率pm ：控制算法中变异操作的使用频率，变异算法的变异率应该控制在较低的频率</p></li><li><p>方式</p><ul><li><p>位点变异</p><ul><li>群体中的个体码串，随机挑选一个或多个基因座，并对这些基因座的基因值以变异概率作变动</li><li>如果对于某个基因位，产生的随机数小于pm,则改变该基因的取值。否则该基因不发生变异，保持不变。</li></ul></li><li><p>逆转变异</p><ul><li>在个体码串中随机选择两点（逆转点），然后将两点之间的基因值以逆向排序插入到原位置中</li></ul></li><li><p>插入变异</p><ul><li>在个体码串中随机选择一个码，然后将此码插入随机选择的插入点中间</li></ul></li><li><p>互换变异</p><ul><li>随机选取染色体的两个基因进行简单互换</li></ul></li><li><p>移动变异</p><ul><li>随机选取一个基因，向左或者向右移动一个随机位数</li></ul></li></ul></li></ul></li></ul><h3 id="4-1-5-一般步骤"><a href="#4-1-5-一般步骤" class="headerlink" title="4.1.5 一般步骤"></a>4.1.5 一般步骤</h3><p><img src="http://img.fdchen.host/AIClass/%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4.png" alt="一般步骤"></p><h3 id="4-1-6-遗传算法与搜索技术的比较"><a href="#4-1-6-遗传算法与搜索技术的比较" class="headerlink" title="4.1.6 遗传算法与搜索技术的比较"></a>4.1.6 遗传算法与搜索技术的比较</h3><ul><li><p>从形式上：遗传算法与状态空间搜索法非常类似</p><ul><li>状态表示为向量 &#x3D; 状态表示为个体</li><li>状态转移 &#x3D; 个体繁殖</li></ul></li><li><p>在应用中，两种方法略有差别</p><ul><li>状态空间搜索适合于问题清晰、优化目标清晰，容易设想“怎样会更好”，这时设计启发函数，采用状态空间搜索效率很高；若使用遗传算法，往往效率不佳。</li><li>但对于一些限制条件非常多的问题，此时设计启发函数很难，因为很难证明所设计的启发函数是A*的，从而就无法保证搜索总是有效的。这种情形，使用遗传算法反而更有优势。</li></ul></li></ul><h2 id="4-2-粒子群优化算法"><a href="#4-2-粒子群优化算法" class="headerlink" title="4.2  粒子群优化算法"></a>4.2  粒子群优化算法</h2><h3 id="4-2-1-粒子速度和位置的更新"><a href="#4-2-1-粒子速度和位置的更新" class="headerlink" title="4.2.1 粒子速度和位置的更新"></a>4.2.1 粒子速度和位置的更新</h3><p><img src="http://img.fdchen.host/AIClass/%E7%B2%92%E5%AD%90%E9%80%9F%E5%BA%A6%E5%92%8C%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%9B%B4%E6%96%B0.png" alt="粒子速度和位置的更新"></p><ul><li>惯性部分</li><li>认知部分</li><li>社会部分</li></ul><h3 id="4-2-2-流程图"><a href="#4-2-2-流程图" class="headerlink" title="4.2.2 流程图"></a>4.2.2 流程图</h3><p><img src="http://img.fdchen.host/AIClass/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="粒子群算法流程图"></p><h3 id="4-2-3-PSO算法参数分析"><a href="#4-2-3-PSO算法参数分析" class="headerlink" title="4.2.3 PSO算法参数分析"></a>4.2.3 PSO算法参数分析</h3><ul><li><p>参数</p><ul><li><p>群体规模</p></li><li><p>惯性权重</p><ul><li>保持运动惯性，使其有1扩展搜索空间的趋势</li></ul></li><li><p>加速度</p><ul><li>代表将粒子推向个体最优位置和群体最优位置的统计加速项的权重</li></ul></li><li><p>最大速度</p><ul><li>限制粒子的在某维的速度不超过最大速度</li></ul></li><li><p>最大代数</p></li></ul></li><li><p>各部分的影响</p><ul><li><p>只有惯性部分</p><ul><li>粒子将一直以当前速度飞行，直到边界。由于只能搜索有限区域，所以很难找到好解。</li></ul></li><li><p>没有惯性部分</p><ul><li>速度只取决于例子当前位置和其历史最好位置，速度本身没有记忆性。</li></ul></li><li><p>没有认知部分</p><ul><li>粒子没有认知能力，也就是”只有社会“模型。在粒子的相互作用下，有能力达到新的搜索空间。但对复杂问题，容易陷入局部最优点。</li></ul></li><li><p>没有社会部分</p><ul><li>粒子间没有社会共享信息，也就是”只有认知“模型。因为个体间没有交互，一个规模为m的群体等价于m个单个粒子的运行，因而得到最优解的机率非常小。</li></ul></li></ul></li></ul><h3 id="4-2-4-特点"><a href="#4-2-4-特点" class="headerlink" title="4.2.4 特点"></a>4.2.4 特点</h3><ul><li><p>优点</p><ul><li>简单易实现</li><li>收敛速度快</li><li>粒子具有记忆性</li></ul></li><li><p>缺点</p><ul><li>缺乏速度的自适应调节，容易陷入局部最优，可能导致收敛精度低或者不收敛</li><li>标准粒子群算法不能有效求解离散及组合优化问题</li><li>参数难以确定，对不同的问题，需选择合适的参数来达到最优效果</li></ul></li></ul><h2 id="4-3-蚁群算法"><a href="#4-3-蚁群算法" class="headerlink" title="4.3 蚁群算法"></a>4.3 蚁群算法</h2><h3 id="4-3-1-基本原理"><a href="#4-3-1-基本原理" class="headerlink" title="4.3.1 基本原理"></a>4.3.1 基本原理</h3><ul><li><p>信息素</p><ul><li>信息素是一种由蚂蚁自身释放的易挥发的物质，信息素的浓度越高，对应的路径越短</li></ul></li><li><p>正反馈</p><ul><li>蚂蚁会以较大的概率选择信息素浓度较高的路径，并释放一定量的信息素，从而使距离较短路径的信息素被加强，形成一个正反馈。</li></ul></li></ul><h3 id="4-3-2-基本框架"><a href="#4-3-2-基本框架" class="headerlink" title="4.3.2 基本框架"></a>4.3.2 基本框架</h3><ul><li><p>模拟蚂蚁</p><ul><li>每只蚂蚁都有相同的目标，以相同速度运动</li><li>蚂蚁在行走过程中，在达到目的地前，不走回头路，不转圈</li><li>每只蚂蚁都根据相同的原则释放信息素、选择路径</li><li>每只蚂蚁都记得自己经历路径的长度和过程</li><li>种群中蚂蚁的数量不会发生变化</li></ul></li><li><p>模拟环境”地图“</p><ul><li><p>我们将蚂蚁觅食的环境抽象成“具有N个节点的全连通图”</p><ul><li>图上一共有n个节点，每个节点都与其他所有节点直接相连</li><li>任意两点X、Y之间的距离记为：dxy 均为已知</li><li>具有明确的起点和终点</li></ul></li></ul></li><li><p>模拟蚂蚁选择路线</p><ul><li><p>第一种：不考虑信息素的影响，选择距离最短的路线行动，符合贪心原则</p></li><li><p>第二种：不考虑各点之间的距离，选择信息素值最大的路线行动</p></li><li><p>由于蚂蚁智力有限，上面的准则应该概率化</p><ul><li>与该路线的长度成反比</li><li>与该路线上信息素浓度成正比</li></ul></li></ul></li><li><p>蚂蚁选择路线的概率计算式</p></li></ul><p><img src="http://img.fdchen.host/AIClass/%E8%9A%82%E8%9A%81%E9%80%89%E6%8B%A9%E8%B7%AF%E7%BA%BF%E7%9A%84%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97%E5%BC%8F.png" alt="蚂蚁选择路线的概率计算式"></p><ul><li><p>模拟信息素的释放与消散</p><ul><li>信息素随着时间推移而消散</li></ul></li><li><p>一种常见策略：将时间“片段化”，以“cycle”为单位来模拟时间</p><pre><code>  -  一个cycle：表示蚁群中所有蚂蚁均从出发点成功达到目标点</code></pre><ul><li>信息素：在一个cycle结束之后统一更新，不考虑cycle期间的消散和累积</li></ul></li><li><p>信息素的消散公式</p></li></ul><p><img src="http://img.fdchen.host/AIClass/%E4%BF%A1%E6%81%AF%E7%B4%A0%E7%9A%84%E6%B6%88%E6%95%A3%E5%85%AC%E5%BC%8F.png" alt="信息素的消散公式"></p><ul><li>走最短路径的蚂蚁，其留下的信息素值越高，成反比</li></ul><h3 id="4-3-3-参数选择"><a href="#4-3-3-参数选择" class="headerlink" title="4.3.3 参数选择"></a>4.3.3 参数选择</h3><ul><li><p>信息素启发因子</p><ul><li>反映了蚁群在路径搜索种随机性因素作用的强度</li></ul></li><li><p>期望值启发因子</p><ul><li>反映了蚁群在路径搜索种先验性、确定性因素作用的强度</li></ul></li><li><p>信息素挥发度1-p</p><ul><li>当处理的问题规模比较大时，会使那些从未被搜索到的路径（可行解）上的信息量减少到接近于0，因而降低了算法的全局搜索能力</li></ul></li></ul><h3 id="4-3-4-旅行商问题求解过程"><a href="#4-3-4-旅行商问题求解过程" class="headerlink" title="4.3.4 旅行商问题求解过程"></a>4.3.4 旅行商问题求解过程</h3><ul><li>解决TSP问题的基本流程</li></ul><p><img src="http://img.fdchen.host/AIClass/%E8%A7%A3%E5%86%B3TSP%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="解决TSP问题的基本流程"></p><h3 id="4-3-5-特点"><a href="#4-3-5-特点" class="headerlink" title="4.3.5 特点"></a>4.3.5 特点</h3><ul><li><p>优点</p><ul><li>在求解性能上具有很强的鲁棒性，搜索能力较强</li><li>一种基于种群的算法，具有本质并行性，易于并行实现</li><li>很容易与其他算法，如：遗传算法、粒子群算法结合，以改善算法性能</li></ul></li><li><p>不足</p><ul><li>如果初始化参数设置不当，会导致求解速度很慢且所得解的质量特别差</li><li>基本蚁群算法即无改进的蚁群算法，计算量大，求解所需时间较长</li></ul></li></ul><h1 id="5-机器学习"><a href="#5-机器学习" class="headerlink" title="5 机器学习"></a>5 机器学习</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul><li>研究如何使用机器来模拟人类学习活动</li></ul><h3 id="5-1-1-研究内容"><a href="#5-1-1-研究内容" class="headerlink" title="5.1.1 研究内容"></a>5.1.1 研究内容</h3><ul><li>任务-T</li><li>方法-A</li><li>经验-E</li><li>性能-P</li></ul><h3 id="5-1-2-基本过程"><a href="#5-1-2-基本过程" class="headerlink" title="5.1.2 基本过程"></a>5.1.2 基本过程</h3><ul><li>计算机从给定的数据中学习规律，即从观测数据（样本）中寻找规律、建立模型，并利用学习到的规律（模型）对未知或无法观测的数据进行预测。</li></ul><h3 id="5-1-3-分类"><a href="#5-1-3-分类" class="headerlink" title="5.1.3 分类"></a>5.1.3 分类</h3><ul><li><p>监督学习</p></li><li><p>无监督学习</p></li><li><p>半监督学习</p><ul><li>数据没有标签，机器学习出的模型是从数据中提取出来的模式（提取决定性特征或者聚类等），一般是分类或回归等任务。</li></ul></li><li><p>强化学习</p><ul><li>外部环境对输入只给出评价信息而非正确答案，学习机通过强化受奖励的动作来改善自身的性能。常见的应用场景包括动态系统以及机器人控制等。</li></ul></li></ul><h3 id="5-1-4-基本概念"><a href="#5-1-4-基本概念" class="headerlink" title="5.1.4 基本概念"></a>5.1.4 基本概念</h3><ul><li>训练集</li><li>测试集</li><li>样本&#x2F;观测</li><li>标签</li></ul><h3 id="5-1-5-数据划分"><a href="#5-1-5-数据划分" class="headerlink" title="5.1.5 数据划分"></a>5.1.5 数据划分</h3><ul><li><p>训练集</p></li><li><p>测试集</p></li><li><p>验证集</p><ul><li>用来做模型选择（model selection），即做模型的最终优化及确定的</li></ul></li></ul><h3 id="5-1-6-误差与精度"><a href="#5-1-6-误差与精度" class="headerlink" title="5.1.6 误差与精度"></a>5.1.6 误差与精度</h3><ul><li><p>误差</p><ul><li>学习器（Learner）的实际预测输出与样本的真实输出之间的差异</li></ul></li><li><p>错误率</p><ul><li>被错误分类的样本在总样本中的比例。</li></ul></li><li><p>精度</p><ul><li>被正确分类的样本在总样本中的比例，即1 – error rate</li></ul></li><li><p>训练误差</p><ul><li>学习器在训练集上的误差，也称作经验误差（empirical error）</li></ul></li><li><p>测试误差</p><ul><li>学习器在测试集上的误差，用来近似泛化误差。</li></ul></li><li><p>泛化误差</p><ul><li>在新样本的误差，实际误差！</li></ul></li></ul><h3 id="5-1-7-监督学习与无监督学习的区别"><a href="#5-1-7-监督学习与无监督学习的区别" class="headerlink" title="5.1.7 监督学习与无监督学习的区别"></a>5.1.7 监督学习与无监督学习的区别</h3><p><img src="http://img.fdchen.host/AIClass/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="监督学习与无监督学习的区别"></p><h3 id="5-1-8-分类与回归"><a href="#5-1-8-分类与回归" class="headerlink" title="5.1.8 分类与回归"></a>5.1.8 分类与回归</h3><ul><li>分类技术：预测分类响应；分类模型将输入数据分为不同类别</li><li>回归技术：预测连续的响应</li></ul><h3 id="5-1-9-机器学习内容"><a href="#5-1-9-机器学习内容" class="headerlink" title="5.1.9 机器学习内容"></a>5.1.9 机器学习内容</h3><p><img src="http://img.fdchen.host/AIClass/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9.png" alt="机器学习内容"></p><h2 id="5-2-监督学习-分类KNN"><a href="#5-2-监督学习-分类KNN" class="headerlink" title="5.2 监督学习-分类KNN"></a>5.2 监督学习-分类KNN</h2><h3 id="5-2-1-核心思想：近朱者赤近墨者黑"><a href="#5-2-1-核心思想：近朱者赤近墨者黑" class="headerlink" title="5.2.1 核心思想：近朱者赤近墨者黑"></a>5.2.1 核心思想：近朱者赤近墨者黑</h3><ul><li>给定训练集，对于新输入样本，则在与其最邻近前K个训练样本中某个类居多，就认为新样本属于该类别。</li><li>不需要使用训练集进行训练，靠周围有限的邻近样本属性多少判断</li></ul><h3 id="5-2-2-缺点"><a href="#5-2-2-缺点" class="headerlink" title="5.2.2 缺点"></a>5.2.2 缺点</h3><ul><li><p>对参数选择很敏感</p><ul><li><p>较小k值→陷入局部，易发生过拟合</p></li><li><p>较大k值→较大邻域，预测易错误</p></li><li><p>选取一个较小的数值，通常采取交叉验证法来选取最优的k值</p><ul><li>在给定的建模样本中，拿出大部分样本进行建模型，留小部分样本用刚建立的模型进行预报，并求这小部分样本的预报误差，记录它们的平方加和。</li></ul></li></ul></li><li><p>计算量大</p></li></ul><h3 id="5-2-3-距离度量"><a href="#5-2-3-距离度量" class="headerlink" title="5.2.3 距离度量"></a>5.2.3 距离度量</h3><ul><li>欧几里得距离、曼哈顿距离、切比雪夫距离等</li><li>距离函数的选择应该根据数据的特性和分析的需要而定</li><li>距离计算</li></ul><p><img src="http://img.fdchen.host/AIClass/%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97.png" alt="距离计算"></p><h3 id="5-2-4-特征属性归一化的必要性"><a href="#5-2-4-特征属性归一化的必要性" class="headerlink" title="5.2.4 特征属性归一化的必要性"></a>5.2.4 特征属性归一化的必要性</h3><ul><li>各特征量纲不同</li><li>归一化处理</li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%BD%92%E4%B8%80%E5%8C%96%E5%A4%84%E7%90%86.png" alt="归一化处理"></p><h2 id="5-3-监督学习-分类决策树"><a href="#5-3-监督学习-分类决策树" class="headerlink" title="5.3  监督学习-分类决策树"></a>5.3  监督学习-分类决策树</h2><h3 id="5-3-1-决策树定义"><a href="#5-3-1-决策树定义" class="headerlink" title="5.3.1 决策树定义"></a>5.3.1 决策树定义</h3><ul><li><p>决策树是一种树型结构，由结点和有向边组成</p></li><li><p>结点</p><ul><li>内部结点表示一个属性或特征</li><li>叶结点代表一种类别，对应于决策结果</li></ul></li><li><p>有向边&#x2F;分支</p><ul><li>分支代表一个测试输出</li></ul></li></ul><h3 id="5-3-2-决策树算法"><a href="#5-3-2-决策树算法" class="headerlink" title="5.3.2 决策树算法"></a>5.3.2 决策树算法</h3><ul><li><p>基本思想</p><ul><li>采用自顶向下的递归方法，以信息熵为度量构造一棵熵值下降最快的树，到叶子结点处的熵值为零，此时每个叶结点中的实例都属于同一类</li><li>决策树可以看成一个if-then的规则集合</li><li>一个决策树将特征空间划分为不相交的单元(Cell)或区域(Region)</li></ul></li><li><p>算法流程</p><ul><li><p>训练</p><ul><li>利用训练集建立一棵决策树，构建决策树模型。</li></ul></li><li><p>测试</p><ul><li>利用生成的模型对输入数据进行分类</li></ul></li></ul></li><li><p>主要算法</p><ul><li><p>ID3：信息增益</p><ul><li><p>以信息论为基础，以信息熵和信息增益度作为衡量标准，从而实现对数据的归纳分类</p><ul><li>ID3算法是以信息增益为准则，对每次递归的结点属性进行选择的</li></ul></li><li><p>信息熵</p><ul><li>信息熵越小，信息量越大，不确定性越小，样本纯度越高</li></ul></li><li><p>信息增益</p><ul><li>信息增益越大，用属性a划分所获得纯度提升越大</li></ul></li><li><p>优点</p><ul><li>只需对训练实例进行较好地标注，就能进行学习，从一类无序、无规则事物(概念)中推理出分类规则。</li><li>分类模型是树状结构，简单直观，可将决策树中到达每个叶结点的路径转换为IF-THEN形式的分类规则，比较符合人类的理解方式。</li></ul></li><li><p>缺点</p><ul><li>信息增益偏好取值多的属性</li><li>可能会受噪声或小样本影响，易出现过拟合问题 </li><li>无法处理连续值的属性 </li><li>无法处理属性值不完整的训练数据</li></ul></li></ul></li><li><p>C4.5：信息增益率</p></li><li><p>CART：基尼指数</p></li></ul></li></ul><h2 id="5-4-监督学习-线性回归"><a href="#5-4-监督学习-线性回归" class="headerlink" title="5.4 监督学习-线性回归"></a>5.4 监督学习-线性回归</h2><h3 id="5-4-1-回归分析"><a href="#5-4-1-回归分析" class="headerlink" title="5.4.1 回归分析"></a>5.4.1 回归分析</h3><ul><li>学习得到一函数将输入变量映射到连续输出空间，即值域是连续空间。</li></ul><h3 id="5-4-2-相关概念"><a href="#5-4-2-相关概念" class="headerlink" title="5.4.2 相关概念"></a>5.4.2 相关概念</h3><ul><li><p>回归分析</p><ul><li><p>分析不同变量之间存在关系</p></li><li><p>回归模型</p><ul><li>刻画不同变量之间关系的模型</li></ul></li><li><p>线性回归模型</p><ul><li>如果这个模型是线性的</li></ul></li></ul></li></ul><h3 id="5-4-3-参数学习"><a href="#5-4-3-参数学习" class="headerlink" title="5.4.3 参数学习"></a>5.4.3 参数学习</h3><ul><li>最小二乘法</li></ul><p><img src="http://img.fdchen.host/AIClass/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95.png" alt="最小二乘法"></p><ul><li>最小二乘法示例</li></ul><p><img src="http://img.fdchen.host/AIClass/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%A4%BA%E4%BE%8B.png" alt="最小二乘法示例"></p><h2 id="5-5-无监督学习-K均值"><a href="#5-5-无监督学习-K均值" class="headerlink" title="5.5 无监督学习-K均值"></a>5.5 无监督学习-K均值</h2><h3 id="5-5-4-无监督学习的重要因素"><a href="#5-5-4-无监督学习的重要因素" class="headerlink" title="5.5.4 无监督学习的重要因素"></a>5.5.4 无监督学习的重要因素</h3><ul><li><p>数据特征</p></li><li><p>相似度函数</p><ul><li>定义一个相似度计算函数，基于所提取的特征来计算数据之间的相似性</li></ul></li></ul><h3 id="5-5-5-K均值聚类（K-means）"><a href="#5-5-5-K均值聚类（K-means）" class="headerlink" title="5.5.5 K均值聚类（K-means）"></a>5.5.5 K均值聚类（K-means）</h3><ul><li><p>目的</p><ul><li>将𝑛个数据聚类到𝑘个集合（也称为类簇）</li></ul></li><li><p>算法步骤</p></li></ul><ol><li><p>随机选取K个对象作为初始聚类中心</p></li><li><p>将数据样本集合中的样本按照最小距离原则分配到最近邻聚类</p></li><li><p>根据聚类的结果，重新计算K个聚类的中心，并作为新的聚类中心</p><ul><li>平均值法求聚类中心，不一定是样本点</li></ul></li><li><p>重复步骤2、3直到聚类中心不再变化</p></li></ol><ul><li><p>小结</p><ul><li>需事先确定聚类数K——很多时候并不知道应被聚类的数目</li><li>需初始化聚类质心——其对聚类结果有较大的影响</li><li>算法是迭代执行——时间开销非常大</li><li>采用欧氏距离——假设数据每个维度之间的重要性是一样的</li></ul></li></ul><h1 id="6-人工神经网络"><a href="#6-人工神经网络" class="headerlink" title="6 人工神经网络"></a>6 人工神经网络</h1><h2 id="6-1-概述及感知机"><a href="#6-1-概述及感知机" class="headerlink" title="6.1  概述及感知机"></a>6.1  概述及感知机</h2><h3 id="6-1-1-神经元模型"><a href="#6-1-1-神经元模型" class="headerlink" title="6.1.1 神经元模型"></a>6.1.1 神经元模型</h3><p><img src="http://img.fdchen.host/AIClass/%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B.png" alt="神经元模型"></p><h3 id="6-1-2-人工神经网络（ANN）特性"><a href="#6-1-2-人工神经网络（ANN）特性" class="headerlink" title="6.1.2 人工神经网络（ANN）特性"></a>6.1.2 人工神经网络（ANN）特性</h3><ul><li>并行分布处理</li><li>非线性映射</li><li>通过训练进行学习</li><li>适应与集成</li><li>硬件实现</li></ul><h3 id="6-1-3-人工神经网络发展历史"><a href="#6-1-3-人工神经网络发展历史" class="headerlink" title="6.1.3 人工神经网络发展历史"></a>6.1.3 人工神经网络发展历史</h3><ul><li><p>萌芽期</p><ul><li>MP模型</li><li>Hebb提出著名的Hebb学习规则</li></ul></li><li><p>第一次高潮期</p><ul><li>Rosenblatt提出感知机模型</li></ul></li><li><p>反思期</p><ul><li>Minsky和Papert从数学上深入分析了感知器的原理，指出其局限性</li></ul></li><li><p>第二次高潮期</p><ul><li>Rumelhart及Hinton等学者提出了多层感知器的反向传播算法，解决了多层前向神经网络的学习问题</li></ul></li></ul><h3 id="6-1-4-第一个神经元模型"><a href="#6-1-4-第一个神经元模型" class="headerlink" title="6.1.4 第一个神经元模型"></a>6.1.4 第一个神经元模型</h3><p><img src="http://img.fdchen.host/AIClass/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E5%85%83%E6%A8%A1%E5%9E%8B.png" alt="第一个神经元模型"></p><ul><li><p>McCulloch和Pitts提出首个神经元模型，该模型是一个简单的二元分类器，它接受n维的输入：  (x1, x2, ┄ xn ) , x∈ {0,1} ，随后对这个n维的输入进行加权求和，并将其与阈值θ进行比较， 若大于阈值输出1，否则输出0。</p></li><li><p>原始神经元的缺点</p><ul><li>输入输出都是二元的</li><li>不能训练也没有学习能力</li></ul></li></ul><h3 id="6-1-5-激活函数"><a href="#6-1-5-激活函数" class="headerlink" title="6.1.5 激活函数"></a>6.1.5 激活函数</h3><ul><li>线性函数</li></ul><p><img src="http://img.fdchen.host/AIClass/%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0.png" alt="线性函数"></p><ul><li>非线性斜面函数</li></ul><p><img src="http://img.fdchen.host/AIClass/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%9C%E9%9D%A2%E5%87%BD%E6%95%B0.png" alt="非线性斜面函数"></p><ul><li>阈值函数</li></ul><p><img src="http://img.fdchen.host/AIClass/%E9%98%88%E5%80%BC%E5%87%BD%E6%95%B0.png" alt="阈值函数"></p><ul><li>S形函数</li></ul><p><img src="http://img.fdchen.host/AIClass/S%E5%BD%A2%E5%87%BD%E6%95%B0.png" alt="S形函数"></p><h3 id="6-1-6-感知机"><a href="#6-1-6-感知机" class="headerlink" title="6.1.6 感知机"></a>6.1.6 感知机</h3><ul><li><p>感知机与神经元模型相似，主要有以下几点改进</p><ul><li>输入为一个实数向量；</li><li>有多种激活函数可以选择；</li><li>属于一个可学习模型。</li></ul></li><li><p>感知机由两层神经元组成，是最简单的神经网络。</p><ul><li>输入层神经元</li></ul><p><img src="http://img.fdchen.host/AIClass/%E8%BE%93%E5%85%A5%E5%B1%82%E7%A5%9E%E7%BB%8F%E5%85%83.png" alt="输入层神经元"></p><ul><li>输出层神经元</li></ul><p><img src="http://img.fdchen.host/AIClass/%E8%BE%93%E5%87%BA%E5%B1%82%E7%A5%9E%E7%BB%8F%E5%85%83.png" alt="输出层神经元"></p></li><li><p>单层感知机模型</p></li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%8D%95%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="单层感知机模型"></p><ul><li><p>感知机模型的数学原理</p><ul><li>输入向量为二元向量时，方程确定了二维平面上的一条分界线</li><li>输入向量为三元向量时，方程确定了三维平面上的分界面</li><li>逻辑运算的实现</li></ul></li><li><p>单层感知机模型的缺点</p><ul><li>仅能解决一阶谓词逻辑，即只能完成线性划分，对于非线性或者其他分类会遇到很多困难，就连简单的XOR（异或）问题都解决不了（无法找到一个超平面将两类样本区分开）。</li></ul></li><li><p>多层感知机</p><p><img src="http://img.fdchen.host/AIClass/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA.png" alt="多层感知机"></p><ul><li><p>异或问题无法用一个超平面将两类样本分割开，于是人们考虑对多个感知机模型进行组合，即采用多个超平面去分割——多层感知机</p></li><li><p>多层感知机求解异或问题</p><p><img src="http://img.fdchen.host/AIClass/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%B1%82%E8%A7%A3%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98.png" alt="多层感知机求解异或问题"></p><ul><li><p>当中间层的神经元的激励函数分别采用二值和双极时，其结果是不一样的。激励函数：中间是双极+输出是二值时，可以解异或；中间及输出均为二值时，则无解。</p><ul><li>即使网络结构及参数完全一样，但因激励函数的选取差异会导致不同的求解结果。</li></ul></li><li><p>多层网络虽然很好地解决了线性不可分问题，但是，由于无法知道网络隐藏层的神经元的理想输出，所以，感知器的训练算法是难以直接用于多层网的训练。</p></li></ul></li><li><p>多层感知机曲线拟合问题</p></li></ul></li></ul><p><img src="http://img.fdchen.host/AIClass/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98.png" alt="多层感知机曲线拟合问题"></p><ul><li><p>感知机小结</p><ul><li>其学习过程与求线性判决函数(单样本感知器算法)的过程是等价的</li><li>单层感知器只能解决线性可分的问题</li><li>可以证明，只要隐层和隐层单元数足够多，多层感知器网络可实现任何模式分类</li><li>但是，多层感知器网络的权值如何确定，即网络如何进行学习，没有得到解决（多层感知器是一个黑箱，结果不可解释）</li></ul></li></ul><h3 id="6-1-7-梯度下降思想"><a href="#6-1-7-梯度下降思想" class="headerlink" title="6.1.7 梯度下降思想"></a>6.1.7 梯度下降思想</h3><ul><li>导数的方向为误差e上升最快的方向，我们只需将w, b 向着导数的相反方向进行调整，即可使误差e减小——梯度下降。</li></ul><h2 id="6-2-BP神经网络"><a href="#6-2-BP神经网络" class="headerlink" title="6.2  BP神经网络"></a>6.2  BP神经网络</h2><h3 id="6-2-1-基本思想"><a href="#6-2-1-基本思想" class="headerlink" title="6.2.1 基本思想"></a>6.2.1 基本思想</h3><ul><li><p>从后向前反向逐层传播输出层的误差，以间接计算隐层的误差。</p><ul><li>正向过程：从输入层经隐藏层逐层正向计算各单元的输出。</li><li>反向过程：由输出误差逐层反向计算隐层各单元的误差，并用此误差修正前层的权重。</li></ul></li></ul><h3 id="6-2-2-多层前馈神经网络"><a href="#6-2-2-多层前馈神经网络" class="headerlink" title="6.2.2 多层前馈神经网络"></a>6.2.2 多层前馈神经网络</h3><ul><li>每层神经元与下一层神经元完全相连，神经元之间不存在同层连接，也不存在跨层连接。</li><li>BP神经网络模型拓扑结构</li></ul><p><img src="http://img.fdchen.host/AIClass/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt="BP神经网络模型拓扑结构"></p><h3 id="6-2-3-BP网络及算法中的变量符号"><a href="#6-2-3-BP网络及算法中的变量符号" class="headerlink" title="6.2.3 BP网络及算法中的变量符号"></a>6.2.3 BP网络及算法中的变量符号</h3><p><img src="http://img.fdchen.host/AIClass/BP%E7%BD%91%E7%BB%9C%E5%8F%8A%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%AC%A6%E5%8F%B7.png" alt="BP网络及算法中的变量符号"></p><h3 id="6-2-4-反向传播算法的学习过程-x2F-基本思想"><a href="#6-2-4-反向传播算法的学习过程-x2F-基本思想" class="headerlink" title="6.2.4 反向传播算法的学习过程&#x2F;基本思想"></a>6.2.4 反向传播算法的学习过程&#x2F;基本思想</h3><ul><li>选择一组训练样本，每一个样本由输入信息和期望的输出结果两部分组成。</li><li>从训练样本集中取一样本，把输入信息输入到网络中。</li><li>分别计算经神经元处理后的各层结点的输出。</li><li>计算网络的实际输出和期望输出的误差。</li><li>从输出层反向计算到第一个隐层，并按照某种能使误差向减小方向发展的原则，调整网络中各神经元的连接权值。</li><li>对训练样本集中的每一个样本重复(3)-(5)的步骤，直到对整个训练样本集的误差达到要求为止。</li></ul><h3 id="6-2-5-如何设计一个多层前馈神经网络"><a href="#6-2-5-如何设计一个多层前馈神经网络" class="headerlink" title="6.2.5 如何设计一个多层前馈神经网络"></a>6.2.5 如何设计一个多层前馈神经网络</h3><ul><li>网络的输入对应于每个训练元组测量的属性。</li><li>输入同时提供给称作输入层的单元层。</li><li>这些输入通过输入层，然后加权给隐藏层。</li><li>隐藏层的数量是任意的，尽管实践中通常只用一层。 </li><li>最后一个隐藏层的加权输出作为输出层的单元的输入，输出层发布给定元组的网络预测。</li><li>网络是前馈的：如果其权重都不回送到输入单元，或者前一层的输出单元。</li><li>从统计学观点来讲，网络进行非线性回归：给定足够多的隐藏单元和足够的训练样本，多层前馈网络可以逼近任何函数。与多层感知器类似：融合不同的曲线来拟合毫无规律可循的复杂曲线</li></ul><h3 id="6-2-6-如何设计网络拓扑结构"><a href="#6-2-6-如何设计网络拓扑结构" class="headerlink" title="6.2.6 如何设计网络拓扑结构"></a>6.2.6 如何设计网络拓扑结构</h3><ul><li>设计网络拓扑结构: 在训练之前，用户必须说明输入层的单元数、隐藏层数、每个隐藏层的单元数和输出层的单元数</li><li>规一化（Normalize）训练元组的每个属性的测量输入值至 [0.0-1.0]</li><li>一个输入单元每个值阈值权重或偏置）初始化为0</li><li>一个输出单元可以用来表示两个类，如果输出单元大于两个类，则每个类使用一个输出单元。一旦网络经过训练，并且其准确度不能接受，通常用不同的网络拓扑或使用不同的初始权重集</li></ul><h3 id="6-2-7-如何后向传播"><a href="#6-2-7-如何后向传播" class="headerlink" title="6.2.7 如何后向传播"></a>6.2.7 如何后向传播</h3><ul><li><p>原理</p><ul><li>后向传播迭代地处理训练元组数据集，将每个元组的网络预测和实际已知的目标值比较。</li><li>对于每个训练样本，修改权重使网络预测和实际目标值之间的均方误差最小。</li><li>修改“后向”进行：从输出层经每个隐藏层，到第一个隐藏层（因此称作后向传播）</li></ul></li><li><p>算法步骤</p><ul><li>初始化权重为很小的随机数，每个单元有一个关联的偏倚</li><li>向前传播输入（通过运用激励函数） </li><li>向后传播误差（通过更新权重和偏倚）</li><li>终止条件（当误差很小等）</li></ul></li></ul><h3 id="6-2-8-BP学习算法流程图"><a href="#6-2-8-BP学习算法流程图" class="headerlink" title="6.2.8 BP学习算法流程图"></a>6.2.8 BP学习算法流程图</h3><p><img src="http://img.fdchen.host/AIClass/BP%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="BP学习算法流程图"></p><h3 id="6-2-9-BP算法小结"><a href="#6-2-9-BP算法小结" class="headerlink" title="6.2.9 BP算法小结"></a>6.2.9 BP算法小结</h3><ul><li>核心思想：利用前向传播，计算第n层输出值</li><li>优化目标：输出值和实际值的残差</li><li>计算方法：将残差按影响逐步传递回第n-1, n-2,…, 2层，以修正各层连接权值（误差逆传播）</li><li>主要工具：链式法则（复合函数求偏导）</li></ul><h3 id="6-2-10-BP算法局限性"><a href="#6-2-10-BP算法局限性" class="headerlink" title="6.2.10 BP算法局限性"></a>6.2.10 BP算法局限性</h3><ul><li><p>容易过拟合</p><ul><li>早停、正则化</li></ul></li><li><p>容易陷入局部最优</p><ul><li>选取多次初值、随机梯度下降法</li></ul></li><li><p>难以设置隐层个数</p><ul><li>试错法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CQU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多媒体技术</title>
      <link href="/2020/cqu-duo-mei-ti-ji-zhu/"/>
      <url>/2020/cqu-duo-mei-ti-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引论"><a href="#1-引论" class="headerlink" title="1 引论"></a>1 引论</h2><h3 id="1-1-多媒体技术的概念"><a href="#1-1-多媒体技术的概念" class="headerlink" title="1.1 多媒体技术的概念"></a>1.1 多媒体技术的概念</h3><ul><li><p>什么是媒体</p><ul><li>媒体是信息表示、存储和传输的载体</li></ul></li><li><p>媒体的分类</p><ul><li><p>感觉媒体</p><ul><li>能直接作用于人的感官，使人直接产生感觉的一类媒体（作用于人）</li><li>视觉、听觉、嗅觉、味觉、触觉</li></ul></li><li><p>表示媒体</p><ul><li>计算机对信息的表示方法的描述</li><li>表示媒体具体体现为编码</li></ul></li><li><p>表现媒体</p><ul><li>感觉媒体和用于通信的电信号之间转换用的一类媒体，分为输入表现媒体和输出表现媒体</li><li>打印机、音箱、MIDI键盘，扫描仪、键盘、鼠标</li></ul></li><li><p>存储媒体</p><ul><li>用于计算机存放表示媒体，以便计算机随时处理、加工和调用信息编码</li><li>光盘、硬盘、磁带、活动硬盘、优盘等</li></ul></li><li><p>传输媒体</p><ul><li>用于传输表示媒体，将表示媒体从一处传送到另一处的物理载体</li><li>双绞线、同轴电缆、光纤等</li></ul></li></ul></li><li><p>多媒体技术</p><ul><li>计算机综合处理多种媒体信息，在文本、图形、图像、音频和视频等多种信息之间建立逻辑关系，并连同多媒体设备一起集成为一个具有交互性能的应用系统的技术</li></ul></li><li><p>多媒体系统的四个性质</p><ul><li><p>多样性</p><ul><li><p>离散媒体</p><ul><li>独立于时间</li></ul></li><li><p>连续媒体</p><ul><li>时基媒体</li></ul></li></ul></li><li><p>集成性</p><ul><li>信息的媒体集成性</li><li>设备的集成性</li></ul></li><li><p>实时性</p><ul><li>多媒体技术必须要支持实时处理</li></ul></li><li><p>交互性</p><ul><li>低级交互</li><li>中级交互</li><li>高级交互</li></ul></li></ul></li><li><p>为什么字符和多媒体的数据量相差很大？</p><ul><li>因为字符有限，可以逐一编码。但其编码并不是字符本身，字符本身的展示采用输出码。类似于自然人的身份证号和自然人本身</li><li>而多媒体信息的个数无限，例如图像个数是无限的，无法逐一编码，只能针对图像的像素逐一编码，从而导致编码数据量很大</li></ul></li><li><p>体系结构</p><ul><li>多媒体外围设备</li><li>多媒体计算机硬件系统</li><li>多媒体核心系统</li><li>多媒体创作平台及工具</li><li>多媒体创作系统</li><li>多媒体应用系统</li></ul></li></ul><h2 id="2-图形图像技术"><a href="#2-图形图像技术" class="headerlink" title="2 图形图像技术"></a>2 图形图像技术</h2><h3 id="2-1-数字图类分类"><a href="#2-1-数字图类分类" class="headerlink" title="2.1 数字图类分类"></a>2.1 数字图类分类</h3><ul><li><p>符号</p><ul><li>字母、数字、中文</li><li>输入采用输入码</li><li>存储和处理：采用内部编码</li><li>输出采用输出码，图像方式</li></ul></li><li><p>图形</p><ul><li><p>Graphics、矢量图</p></li><li><p>用一系列计算机指令来表示一幅图</p></li><li><p>优点</p><ul><li>存储和传输数据量小</li><li>缩放、旋转、移动图像不会失真，能保证无级缩放</li><li>适合管理图形的每一部分</li><li>容易编辑</li><li>图块可重用</li></ul></li><li><p>缺点</p><ul><li>图形生成花费时间长</li><li>不适合描述彩色图像</li></ul></li><li><p>在显示器上所有几何图形都是通过算法得到的</p></li></ul></li><li><p>图表</p><ul><li>乐谱、直方图</li></ul></li><li><p>图像</p><ul><li><p>Image、位图</p></li><li><p>将一幅图像在空间上离散化为多个像素，每个像素用若干个二进制位来描述其颜色、亮度和属性</p></li><li><p>优点</p><ul><li>显示速度快</li><li>表现力强，可适用于任何自然图像，细腻、层次多、细节丰富</li></ul></li><li><p>缺点</p><ul><li>存储和传输数据量大</li><li>缩放、旋转时算法复杂且容易失真</li></ul></li></ul></li><li><p>位图与矢量图的互转</p><ul><li><p>位图-&gt;矢量图</p><ul><li>跟踪技术</li></ul></li><li><p>矢量图-&gt;位图</p><ul><li>光栅化技术</li></ul></li></ul></li></ul><h3 id="2-2-数字信号处理基础"><a href="#2-2-数字信号处理基础" class="headerlink" title="2.2 数字信号处理基础"></a>2.2 数字信号处理基础</h3><ul><li><p>信号采集（模数转换）</p><ul><li><p>采样</p><ul><li>空间&#x2F;时间离散</li><li>图像分辨率</li></ul></li><li><p>量化</p><ul><li><p>幅值离散</p></li><li><p>量化位数的确定</p></li><li><p>分类</p><ul><li>均匀量化</li><li>非均匀量化</li></ul></li></ul></li></ul></li><li><p>信号表示</p><ul><li><p>编码</p><ul><li><p>定义</p></li><li><p>分类</p><ul><li>非压缩编码</li><li>压缩编码</li></ul></li></ul></li></ul></li><li><p>说明</p><ul><li>模数转换有信号损失（采样、量化均有）</li><li>我们能承受的损失与具体需求和人们的感知有光</li><li>虽然数字信号有损失但数字信号有利于复制和编辑</li><li>音频、视频进行模数转换时同样有采样和量化</li></ul></li></ul><h3 id="2-3-视觉特性"><a href="#2-3-视觉特性" class="headerlink" title="2.3 视觉特性"></a>2.3 视觉特性</h3><ul><li><p>光的自然特性</p><ul><li>光是电磁波的</li><li>声音是机械波</li></ul></li><li><p>三原色理论</p><ul><li>红绿蓝</li></ul></li><li><p>色彩要素</p><ul><li><p>色调</p><ul><li>表明光谱的波长，反映颜色的类别</li></ul></li><li><p>饱和度</p><ul><li>颜色的浓淡成都，反映色彩中掺入白光的数量</li><li>饱和度越高颜色越深，饱和度越低颜色越浅</li></ul></li><li><p>亮度</p><ul><li>光的明暗程度，反映彩光所含能量</li></ul></li><li><p>色度</p><ul><li>色调与饱和度合作，表示颜色类别和深浅</li><li>人眼能区分较少的色调和饱和度，但是对亮度非常敏感</li></ul></li></ul></li><li><p>人眼的感光特性</p><ul><li>颜色只存在于眼睛和大脑中，颜色是视觉系统对可见光的感知结果</li></ul></li><li><p>视觉感知规律</p><ul><li><p>视觉调节力</p></li><li><p>视觉暂留性</p></li><li><p>视觉锐度-视力</p></li><li><p>视网膜上光敏细胞的物理距离决定了视力的极限</p></li><li><p>亮度和对比度影响视力</p></li><li><p>人眼对彩色的分辨率低于对亮度的分辨率</p></li><li><p>注视点一般集中在高频部分</p><ul><li><p>高频信号</p><ul><li>图像强度（亮度&#x2F;灰度）变化剧烈的地方，也就是我们常说的边缘（轮廓）</li></ul></li><li><p>低频信号</p><ul><li>图像强度（亮度&#x2F;灰度）变换平缓的地方，也就是大片色块的地方</li></ul></li><li><p>人眼对低频信号更为敏感，即人眼更容易察觉低频信号的变化</p></li></ul></li></ul></li></ul><h3 id="2-4-图像的颜色模型"><a href="#2-4-图像的颜色模型" class="headerlink" title="2.4 图像的颜色模型"></a>2.4 图像的颜色模型</h3><ul><li><p>基本概念</p></li><li><p>RGB</p><ul><li>用于显示设备</li><li>相加混色模型</li><li>红绿蓝三基色</li></ul></li><li><p>CMYK</p><ul><li><p>用于打印设备</p></li><li><p>相减混色模型</p><ul><li>反射的光线就是我们所看见的物体颜色，这些颜色被称之为减色</li></ul></li><li><p>三种基本颜料颜色青色、品红、黄色</p></li></ul></li><li><p>HSL</p><ul><li><p>用于人眼</p></li><li><p>含义</p><ul><li>H-色调</li><li>S-饱和度</li><li>L-亮度</li></ul></li></ul></li><li><p>YUV</p><ul><li>详见动画视频技术</li></ul></li><li><p>YIQ</p><ul><li>详见动画视频技术</li></ul></li><li><p>Lab</p><ul><li>用于彩色电视</li><li>作为在不同颜色模式之间转换时使用的中间颜色模式</li><li>L<em>a</em>b 颜色模型下所生成的颜色与所使用的设备无关</li><li>在处理速度上，Lab色彩模式与RGB模式同样快，比CMYK模式快很多</li><li>Lab模式的图像在转换成CMYK模式时其色彩不会丢失或被替换，因此避免色彩损失的最佳方法是应用Lab模式</li></ul></li><li><p>Index</p><ul><li>用8bit描述，最多可以使用256种颜色，采用调色板方式实现</li><li>由于限制了调色板中颜色的数目，因而可以减小文件的大小，同时基本上不影响视觉效果</li></ul></li><li><p>Grayscale模式</p><ul><li>用8bit描述，最多使用256级灰度来表现图像，图像中的每个像素有一个0（黑色）到255（白色）之间的亮度值。</li><li>灰度值也可以用黑色油墨覆盖的百分比来表示（0%表示白色，100%表示黑色）。使用灰度模式，使得能够较好地表现出单色图的图像层次</li></ul></li><li><p>Binary</p><ul><li>二值模式图像由一个个黑色和白色的像素点组成</li><li>每一个像素用1bit来表示，只能表示有点和无点两种状态</li></ul></li></ul><h3 id="2-5-位图图像基本属性"><a href="#2-5-位图图像基本属性" class="headerlink" title="2.5 位图图像基本属性"></a>2.5 位图图像基本属性</h3><ul><li><p>分辨率</p><ul><li><p>图像分辨率</p></li><li><p>显示分辨率</p></li><li><p>打印分辨率和扫描分辨率</p></li><li><p>像素分辨率</p><ul><li>像素本身的尺寸</li></ul></li></ul></li><li><p>颜色深度</p><ul><li>图像每个像素所占用的存储位数</li></ul></li><li><p>调色板</p><ul><li>颜色查找表</li></ul></li><li><p>真彩色、伪彩色与直接色</p><ul><li><p>真彩色</p><ul><li>每个像素值中有RGB三个基色分量，每个基色分量直接决定显示设备基色强度</li></ul></li><li><p>伪彩色</p><ul><li>把像素值当作彩色查找表（调色板）的表项入口地址，用查找出的RGB强度值产生的彩色</li></ul></li><li><p>直接色</p><ul><li>每个像素值分成R，G，B分量，每个分量作为单独的索引值对它做变换。也就是通过相应的彩色变换表找出基色强度，用变换后得到的R，G，B强度值产生的彩色</li></ul></li></ul></li><li><p>位图图像数据量</p><ul><li><p>B&#x3D;(h<em>w</em>c)&#x2F;8(Byte)</p><ul><li>h为垂直分辨率</li><li>w为水平分辨率</li><li>c为颜色深度</li></ul></li></ul></li></ul><h3 id="2-6-图类数据的文件类型"><a href="#2-6-图类数据的文件类型" class="headerlink" title="2.6 图类数据的文件类型"></a>2.6 图类数据的文件类型</h3><ul><li><p>BMP图像文件格式</p><ul><li><p>特点</p><ul><li>采用位映射存储格式</li><li>图像颜色深度可选1bit、4bit、8bit及24bit</li><li>不采用其他任何压缩</li><li>包含的图像信息较丰富</li><li>占用的磁盘空间过大，不利于网络传输</li><li>存储数据时，图像的扫描方式是按从左到右、从下到上</li></ul></li><li><p>文件组成</p><ul><li><p>位图文件头</p><ul><li>14字节</li></ul></li><li><p>位图信息头</p><ul><li>40字节</li></ul></li><li><p>颜色表</p></li><li><p>图像数据阵列字节</p></li></ul></li><li><p>图像数据压缩</p><ul><li><p>BI_RLE8</p><ul><li><p>每个像素位8位（索引）的RLE压缩编码，可以使用编码方式和绝对方式中的任何一种编码，这两种方式可在同一幅图中的任何地方使用。此外，还有控制标识。</p></li><li><p>控制标识</p><ul><li>00 00  行的结束</li><li>00 01 图像结束</li><li>00 02 其后的两个字节标识下一个像素从当前开始的水平和垂直位置的偏移量</li></ul></li><li><p>绝对方式</p><ul><li><p>第一个字节为0，第二个字节为0x03-0xFF之间的一个值</p><ul><li><p>第2个字节表示跟在这个字节后面的字节数，每个字节包含单个像素的颜色索引。压缩数据格式需要字边界对齐（存放数据成员的首地址能被数据成员基本长度整除，如此处应该被2整除）</p><ul><li>00 03 45 56 67 00 表示45 56 67</li></ul></li></ul></li></ul></li><li><p>编码方式</p><ul><li><p>第一个字节指定使用相同颜色的像素数目，第二个字节指定使用的颜色索引</p><ul><li>03 04表示 04 04 04</li></ul></li></ul></li></ul></li><li><p>BI_RLB4</p><ul><li><p>每个像素为4位（索引）的RLE压缩编码，可以使用编码方式和绝对方式中的任何一种编码，这两种方式可在同一幅图中的任何地方使用。此外，还有控制标识。</p></li><li><p>控制标识</p><ul><li>00 00  行的结束</li><li>00 01 图像结束</li><li>00 02 其后的两个字节标识下一个像素从当前开始的水平和垂直位置的偏移量</li></ul></li><li><p>绝对方式</p><ul><li><p>第一个字节为0，第二个字节为0x03-0xFF之间的一个值</p><ul><li><p>第2个字节标识颜色所引述，其后续字节包含有颜色索引，颜色索引存方在该字节的高、低4位中，1个颜色索引对饮1个像素。压缩数据格式需要字边界对齐（不论是绝对方式还是编码方式）</p><ul><li>00 06 45 56 67 00表示4 5 5 6 6 7</li></ul></li></ul></li></ul></li><li><p>编码方式</p><ul><li><p>第一个字节指定像素数目，第二个字节包含仅有的两种颜色索引，一个在高4位，一个在低4位。第一个像素使用高4位的颜色索引，第二个像素使用低4位的颜色索引，依次类推</p><ul><li>03 04表示0 4 0</li></ul></li></ul></li></ul></li></ul></li><li><p>颜色表（调色板）</p><ul><li>包含的颜色与位图所具有的颜色数相同</li><li>每个颜色用4个字节表示</li><li>24位真彩色不使用颜色表</li></ul></li><li><p>图像数据阵列字节</p><ul><li><p>图像的每一扫描行由表示图像像素的连续的字节组成</p></li><li><p>每一行的字节数取决于图像的颜色数目和用像素表示的图像宽度，每一行（图像的扫描行）字节数必须位4的倍数</p><ul><li>8*8二值bmp的图像数据需要34字节，(1+3)*8+2</li></ul></li><li><p>扫描行是从左往右，从下往上存储的</p></li><li><p>最后由两个字节00 00为结束符</p></li></ul></li></ul></li><li><p>其他文件类型</p><ul><li><p>常用位图格式</p><p>  - </p></li><li><p>常用矢量图格式</p><ul><li></li></ul></li></ul></li></ul><h2 id="3-音频技术"><a href="#3-音频技术" class="headerlink" title="3 音频技术"></a>3 音频技术</h2><h3 id="3-1-音频种类"><a href="#3-1-音频种类" class="headerlink" title="3.1 音频种类"></a>3.1 音频种类</h3><ul><li><p>声音</p><ul><li>统称，或专指除语音、音乐之外的其他声音</li></ul></li><li><p>语音</p><ul><li>语音是声音的一种特殊类型，因为人类语音的频率范围小于声音的频率范围，且具有独特的发音特点</li></ul></li><li><p>音乐</p><ul><li>声音的一种特殊类型，主要是指MIDI音乐</li></ul></li></ul><h3 id="3-2-声音及其物理特性"><a href="#3-2-声音及其物理特性" class="headerlink" title="3.2 声音及其物理特性"></a>3.2 声音及其物理特性</h3><ul><li><p>声波</p><ul><li><p>振幅</p><ul><li>反映声音的强度</li></ul></li><li><p>频率</p><ul><li>反映声音的音调</li></ul></li><li><p>相位</p><ul><li>声音变化的方向</li></ul></li></ul></li><li><p>按特性分类</p><ul><li><p>规则声音</p><ul><li>语音、音乐、音效</li></ul></li><li><p>不规则声音</p><ul><li>噪声</li></ul></li></ul></li><li><p>按频率分类</p><ul><li>亚音信号（次音信号）</li><li>音频信号</li><li>超音频（超声波）信号</li></ul></li><li><p>声音信号（复合信号）的参数</p><ul><li><p>基频</p><ul><li>主频率</li></ul></li><li><p>谐音</p></li><li><p>分量信号</p></li><li><p>带宽</p></li></ul></li></ul><h3 id="3-3-声音的听觉心理特性"><a href="#3-3-声音的听觉心理特性" class="headerlink" title="3.3 声音的听觉心理特性"></a>3.3 声音的听觉心理特性</h3><ul><li><p>音调</p><ul><li>声音的高低，有（基）频率决定</li></ul></li><li><p>音强（响度）</p><ul><li>取决于振幅的大小</li><li>响度与人耳可闻程度有关</li></ul></li><li><p>等响曲线</p><ul><li>等响曲线同一条线上人耳感知一样</li><li>响度较小时，高、低频声音敏感度降低较明显，而低频段比高频段灵敏度降低更加剧烈，一般应重视加强低频音量</li></ul></li><li><p>听阈</p><ul><li>人能听到的最低声压级</li></ul></li><li><p>痛阈</p><ul><li>当声压级增大到一定强度时，人耳会感到不适或疼痛</li></ul></li><li><p>掩蔽效应</p><ul><li><p>一种频率的声音阻碍听觉系统感受另一种频率的声音的现象。人的耳朵只对最明显的声音反应敏感，而对于不明显的声音，反应则较不敏感</p></li><li><p>前者称为掩蔽声音，后者称为被掩蔽声音</p></li><li><p>频域掩蔽</p><ul><li>指一个强纯音会掩蔽在其附近同时发声的弱纯音</li></ul></li><li><p>时域掩蔽</p><ul><li>指在时间上相邻的声音之间也有掩蔽现象</li></ul></li></ul></li></ul><h3 id="3-4-声音信号数字化"><a href="#3-4-声音信号数字化" class="headerlink" title="3.4 声音信号数字化"></a>3.4 声音信号数字化</h3><ul><li><p>采样</p><ul><li>将声音信号在时间上离散化，即每隔相等的一段时间抽取一个信号样本</li></ul></li><li><p>量化</p><ul><li>将连续的信号幅度离散化。</li><li>均匀量化&#x2F;线性量化</li><li>非均匀量化&#x2F;非线性量化</li></ul></li><li><p>编码</p><ul><li>按一定格式将离散的数字信号记录下来，并在数据的前后加上同步、纠错等控制信号</li></ul></li><li><p>数字音频质量的决定因素</p><ul><li><p>采样频率</p><ul><li><p>Nyquist采样定理</p><ul><li>采样频率高于信号最高频率的两倍，就可以从采样中完全恢复原始信号的波。因此采样频率不一比高低与声音信号最高频率的两倍</li></ul></li></ul></li><li><p>采样精度&#x2F;量化位数</p><ul><li>描述每个采样点样值的二进制位数。常用8位、16位、32位</li><li>信号噪声比（信噪比）SNR，单位为分贝，信噪比越高越好</li></ul></li><li><p>声道数</p><ul><li>指声音记录为一组波形（即单声道）还是两组波形（即双声道立体声），甚至更多组波形（多声道）</li><li>由于立体声声音具有多声道、多方向的特征，因此，声音的播放在时间和空间性能方面都能显示更好的效果</li></ul></li></ul></li><li><p>对应图像音频质量的决定因素</p><ul><li>分辨率</li><li>颜色深度</li><li>颜色通道</li></ul></li><li><p>声音质量的等级</p><ul><li>根据声音的频带划分5个等级，以下由低到高排列</li><li>电话</li><li>调幅广播（AM）</li><li>调频广播（FM）</li><li>激光唱盘（CD-Audio）</li><li>数字录音带（DAT）</li></ul></li><li><p>采样数据量</p><ul><li>数据率(字节每秒)&#x3D;采样频率<em>样本精度</em>声道数&#x2F;8</li><li>采样数据量&#x3D;数据率*采样时间</li></ul></li></ul><h3 id="3-5-语音"><a href="#3-5-语音" class="headerlink" title="3.5 语音"></a>3.5 语音</h3><ul><li><p>语音处理的任务</p><ul><li>以语音的基本特性为基础，主要针对语音的成分进行相应处理，包括语音采样、识别、模拟、合成等技术</li></ul></li><li><p>人机语音通信的两项关键技术</p><ul><li><p>语音合成</p><ul><li>再生预存的语音信号</li><li>模拟发声</li></ul></li><li><p>语音识别</p></li></ul></li></ul><h3 id="3-6-MIDI音乐"><a href="#3-6-MIDI音乐" class="headerlink" title="3.6 MIDI音乐"></a>3.6 MIDI音乐</h3><ul><li><p>数字音乐</p><ul><li>由实现定义好的音色、音调、音符等编号组成的</li><li>数字音乐编码</li></ul></li><li><p>MIDI音乐是一种数字音乐，MIDI音乐通常被称为电子音乐或合成音乐</p></li><li><p>MIDI实质上是由MIDI控制器（或MIDI文件）产生的指示电子音乐合成器要做什么、怎么做的一套标准指令</p></li><li><p>特点</p><ul><li><p>优点</p><ul><li>生成文件比较小</li><li>容易编辑</li><li>可以作为背景音乐</li></ul></li><li><p>缺点</p><ul><li>播放效果因软、硬件而异</li><li>录制较复杂，还须有专门工具</li></ul></li></ul></li></ul><h3 id="3-7-音频文件的格式"><a href="#3-7-音频文件的格式" class="headerlink" title="3.7 音频文件的格式"></a>3.7 音频文件的格式</h3><ul><li>WAV</li><li>MIDI</li><li>MP3</li><li>ra(RealAudio) &amp; rm(RealMedia)</li><li>Widnows Media</li></ul><h2 id="4-动画视频技术"><a href="#4-动画视频技术" class="headerlink" title="4 动画视频技术"></a>4 动画视频技术</h2><h3 id="4-1-动态图像"><a href="#4-1-动态图像" class="headerlink" title="4.1 动态图像"></a>4.1 动态图像</h3><ul><li><p>概念</p><ul><li><p>原理</p><ul><li>利用了人眼的视觉暂留性</li></ul></li><li><p>帧</p></li><li><p>分类</p><ul><li><p>动画</p><ul><li>计算机生成的非真实场景</li></ul></li><li><p>视频</p><ul><li>外界信号，真实场景</li></ul></li></ul></li></ul></li><li><p>特点</p><ul><li><p>时间连续性</p></li><li><p>数据量大</p></li><li><p>相关性强</p></li><li><p>实时性高</p><ul><li>必须在规定的时间内完成更换画面播放的过程</li></ul></li></ul></li><li><p>动态图像参数</p><ul><li>视频纵横比、观察距离和图像细节</li></ul></li></ul><h3 id="4-2-动画基础"><a href="#4-2-动画基础" class="headerlink" title="4.2 动画基础"></a>4.2 动画基础</h3><ul><li><p>传统动画</p><ul><li>脚本编写与动画设计</li><li>关键帧设计</li><li>中间帧生成</li><li>扫描上色</li><li>检查、拍摄</li><li>后期制作</li></ul></li><li><p>计算机动画</p><ul><li><p>关键技术</p><ul><li>计算机动画制作软件及硬件</li></ul></li><li><p>计算机动画的分类</p><ul><li><p>根据运动的控制方式</p><ul><li><p>实时动画</p><ul><li>实时生成</li></ul></li><li><p>逐帧动画</p><ul><li>预先生成</li></ul></li></ul></li><li><p>根据视觉空间</p><ul><li><p>二维动画</p><ul><li>二维模型</li></ul></li><li><p>三维动画</p><ul><li>三维模型，得到的动画仍然是二维的图像数据</li></ul></li></ul></li><li><p>变形动画</p><ul><li><p>景物的形体变化</p></li><li><p>需要对各像素点的颜色、位置做变换</p></li><li><p>图形的变形采用插值算法来实现</p></li><li><p>变形过程</p><ul><li>关键帧选取</li><li>设定关键帧特征结构</li><li>参数设置</li><li>动画生成</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="4-3-视频基础"><a href="#4-3-视频基础" class="headerlink" title="4.3 视频基础"></a>4.3 视频基础</h3><ul><li><p>彩色空间变化</p><ul><li><p>YUV颜色模型</p><ul><li><p>YUV用于PAL制和SECAM彩色电视制式</p></li><li><p>Y为亮度，U、V是色差信号（B-Y, R-Y）</p></li><li><p>优点</p><ul><li>亮度信号Y解决了彩色电视机与黑白电视机的兼容问题</li><li>大量实验表明：人眼对彩色图像细节的分辨本领比对黑白的低得多，因此对色度信号U、V，可以采用“大面积着色原理”。数字化后通常为Y:U:V&#x3D;4:1:1(或者是Y:U:V&#x3D;4:2:2)（可用于数据压缩）</li></ul></li></ul></li><li><p>YIQ颜色模型</p><ul><li><p>YIQ用于NTSC彩色电视制式</p></li><li><p>Y是亮度，I和Q为色差信号，I代表红、黄之间颜色，Q代表蓝与紫之间的颜色</p></li><li><p>优点</p><ul><li>亮度信号Y解决了彩色电视机与黑白电视机的兼容问题</li><li>利用人眼的彩色视觉特性，可降低数字彩色图像所需要的存储容量。实验表明：人眼分辨红、黄之间颜色变化的能力最强，而分辨蓝与紫之间颜色变化的能力最弱（可用于数据压缩）</li></ul></li></ul></li><li><p>YCrCb用于连接在计算机上的显示器</p></li></ul></li><li><p>彩色电视制式</p><ul><li>NTSC制式</li><li>RAL制式</li><li>SECAM制式</li></ul></li></ul><h3 id="4-4-数字视频"><a href="#4-4-数字视频" class="headerlink" title="4.4 数字视频"></a>4.4 数字视频</h3><ul><li>数字视频（Digital Video-DV）是定义压缩图像和声音数据记录及回放过程的标准</li><li>模拟视像设备中的视频信号是模拟信号，如果要将模拟视像设备中的模拟视频信号转变为数字视频信号，就需要通过视频卡的处理</li><li>数字视频可以通过软件播放器在计算机上直接进行播放</li><li>如果要在摄像机、电视机上观看数字视频，需要一个D&#x2F;A数模转换器将二进制信息解码成模拟信号，才能进行播放</li></ul><h3 id="4-5-动画和视频文件格式"><a href="#4-5-动画和视频文件格式" class="headerlink" title="4.5 动画和视频文件格式"></a>4.5 动画和视频文件格式</h3><ul><li><p>动画文件格式</p><ul><li>GIF</li><li>SWF</li><li>FLI&#x2F;FLC</li></ul></li><li><p>常见视频文件格式</p><ul><li><p>微软的AVI</p></li><li><p>苹果的MOV</p></li><li><p>MPEG</p><ul><li>运动图像压缩算法的国际标准，有损压缩</li></ul></li><li><p>RealNetwork公司的RM</p><ul><li>流式视频文件格式</li></ul></li><li><p>ASF、WMV</p><ul><li>微软的流式视频文件格式</li></ul></li></ul></li><li><p>动画和视频制作软件</p><ul><li><p>Flash</p><ul><li>用于制作二维矢量动画</li></ul></li><li><p>3D Studio MAX</p><ul><li>用于制作三维动画</li></ul></li><li><p>Windows Movie Maker</p><ul><li>用于视频摄像和编辑</li></ul></li><li><p>Priemiere</p><ul><li>始于视频非线性编辑</li></ul></li></ul></li></ul><h2 id="5-多媒体数据压缩技术"><a href="#5-多媒体数据压缩技术" class="headerlink" title="5 多媒体数据压缩技术"></a>5 多媒体数据压缩技术</h2><h3 id="5-1-多媒体苏剧压缩的必要性和可能性"><a href="#5-1-多媒体苏剧压缩的必要性和可能性" class="headerlink" title="5.1 多媒体苏剧压缩的必要性和可能性"></a>5.1 多媒体苏剧压缩的必要性和可能性</h3><ul><li><p>必要性</p><ul><li>数字化后的图像、视频和音频等媒体信息的海量性</li><li>计算机存储资源和网络带宽难以满足需要</li></ul></li><li><p>可能性</p><ul><li><p>多媒体数据冗余</p><ul><li><p>统计冗余</p><ul><li>时间冗余</li><li>空间冗余</li></ul></li><li><p>感知冗余</p><ul><li>视觉冗余</li><li>听觉冗余</li></ul></li><li><p>结构冗余</p></li><li><p>知识冗余</p></li></ul></li><li><p>信息表达冗余</p><ul><li>信息熵冗余</li></ul></li></ul></li></ul><h3 id="5-2-数据压缩的基本原理和方法"><a href="#5-2-数据压缩的基本原理和方法" class="headerlink" title="5.2 数据压缩的基本原理和方法"></a>5.2 数据压缩的基本原理和方法</h3><ul><li><p>数据冗余</p><ul><li><p>统计冗余</p><ul><li><p>时间冗余</p><ul><li>视频的前后帧之间存在大量的区域相同或相近</li></ul></li><li><p>空间冗余</p><ul><li>同一个静态图像或画面中有部分区域数值一样或相差不大</li></ul></li></ul></li><li><p>结构冗余</p><ul><li>有些图像存在明显的分布模式（重复出现）</li></ul></li><li><p>知识冗余</p><ul><li>许多图像的理解与某些基础知识有相当大的相关性。如人脸的图像有固定的结构。比如嘴的上方有鼻子，鼻子上方有2个眼睛等</li></ul></li><li><p>感知冗余</p><ul><li><p>视觉冗余</p><ul><li><p>亮度和色度的差别</p><ul><li>人眼对亮度的敏感性比色度要强，所以在色度成分上，可以不要保留太多细节，这样可以使色度成分中出现更多的冗余</li></ul></li><li><p>高亮度区和非高亮度区差别</p><ul><li>在高亮度区，人眼的敏感度会下降。灰度值的量化可以更粗糙些</li></ul></li><li><p>边缘和非边缘区别</p><ul><li>人眼对急剧色彩和亮度变化的物体边缘的敏感度比非边缘区域强</li></ul></li></ul></li><li><p>听觉冗余</p></li></ul></li><li><p>信息熵冗余</p><ul><li><p>信源编码器模型</p><ul><li>X是消息集，由n个信源符号单元xj构成（j&#x3D;1, 2, …, n）</li><li>Am是符号集，由m个码元ai构成（i&#x3D;1, 2, …, m），符号集中的码元组成输出的码字</li><li>Z是输出集（码书），由n个码字zj构成（j&#x3D;1, 2, …, n），zj和xj一一对应</li></ul></li><li><p>压缩目标</p><ul><li>用尽量短的码字表达信源符号，且一一对应</li></ul></li><li><p>信息熵</p><ul><li><p>一组数据所携带的平均信息量（不确定性的度量）</p></li><li><ul><li>N为数据的种类（信源符号）的个数，Pi为第i个信源符号出现的概率</li></ul></li><li><p>平均信息量乘以数据的个数，就是整个一组数据的信息量</p></li><li><p>熵的性质</p><ul><li><p>熵是一个非负数，即总有H≥0</p></li><li><p>当其中一个符号i的出现概率pi&#x3D;1时，其余符号j出现概率pj &#x3D;0，H&#x3D;0，如p0&#x3D;1，则p1&#x3D;…&#x3D;p7&#x3D;0， H（x）&#x3D;0</p></li><li><p>当各个符号出现的概率相同时，则H最大，为log2N</p><ul><li>熵的范围为： 0≤H（x）≤log2N</li></ul></li></ul></li><li><ul><li>d &gt;&gt;H（x）有冗余，称为信息熵冗余</li><li>d &lt;H（x）不可能</li><li>d ≈H（x）最佳编码</li></ul></li><li><p>冗余度</p><p>  - </p></li><li><p>编码效率</p><ul><li></li></ul></li></ul></li></ul></li></ul></li><li><p>数据压缩方法分类</p><ul><li><p>压缩包括数字化过程中的压缩（采样和量化）和数字化后的数据的压缩</p><ul><li>压缩感知技术涉及数字化过程中的压缩</li><li>本课程主要涉及数字化后的数据的压缩</li></ul></li><li><p>根据解码后数据与原始数据是否完全一致</p><ul><li><p>可逆编码（无失真编码，无损编码）</p><ul><li>Huffman编码</li><li>算术编码</li><li>游程长度编码</li></ul></li><li><p>不可逆编码（有失真编码，有损编码）</p><ul><li>变换编码</li><li>预测编码</li></ul></li></ul></li><li><p>根据数据压缩的原理可以分为</p><ul><li><p>统计编码</p><ul><li>针对信息熵冗余</li></ul></li><li><p>预测编码</p><ul><li>针对统计冗余</li></ul></li><li><p>变换编码</p><ul><li>针对感知冗余</li></ul></li><li><p>其他编码</p><ul><li>混合编码</li><li>矢量化编码</li><li>LZW算法（词典编码）</li></ul></li></ul></li></ul></li><li><p>数据压缩方法评价</p><ul><li><p>压缩比（压缩效果）</p><ul><li>压缩前数据量&#x2F;压缩后数据量</li></ul></li><li><p>算法复杂性和运算速度（压缩速度）</p><ul><li><p>编码或解码的快慢程度</p></li><li><p>对称压缩和非对称压缩</p><ul><li>非对称压缩常常在解压缩方面要求是实时的，但压缩可以不是实时的</li></ul></li></ul></li><li><p>失真度（压缩质量）</p><ul><li>压缩以后对媒体的感知效果</li></ul></li></ul></li></ul><h3 id="5-3-统计编码"><a href="#5-3-统计编码" class="headerlink" title="5.3 统计编码"></a>5.3 统计编码</h3><ul><li><p>统计编码的基本原理</p><ul><li>数据压缩技术的理论基础是信息论</li><li>数据压缩的理论极限是信息熵</li><li>如果要求编码过程中不丢失信息量（无损编码），即要求保存信息熵，这种信息保持编码叫熵编码（统计编码）</li><li>熵编码（统计编码）要解决的问题是，如何利用信息熵理论减少数据在存储和传输中的冗余度。也就是要找到去除信源的相关性和概率分布的不均匀性的方法</li><li>无损压缩编码</li><li>根据信源符号出现概率的分布特性进行编码</li><li>统计编码需要在信源符号和码字之间确定严格的一一对应关系，以便准确无误地再现原来信源，同时使平均码长尽量小</li><li>如果所有的信源符号出现的概率相同，则说明平均信息量最大，也就不存在信源的冗余</li></ul></li><li><p>游程（RLE）编码</p><ul><li><p>将颜色值相同的相邻像素用一个计数值和那些像素的颜色值来代替</p></li><li><p>特点</p><ul><li>直观、经济</li><li>压缩比的大小主要取决于图像本身的特点</li><li>适用于计算机生成的图像</li><li>常与其他压缩编码技术联合应用</li></ul></li></ul></li><li><p>Huffman编码</p><ul><li><p>使用变长编码，对出现概率大的信源符号赋于短码字，而对于出现概率小的信源符号赋于长码字</p></li><li><p>概率最大的信源符号不一定只由1位码元编码</p></li><li><p>熵，平均码字长度</p><ul><li>需要考虑信源符号的概率，并非各信源符号的码长直接求平均值，即需要加权求熵</li></ul></li><li><p>整个编码过程实际上是建立二叉树的过程，所以编码时需要对原始数据扫描两遍</p><ul><li>第一遍扫描要精确地统计出原始数据中的每个值（信源符号）出现的频率</li><li>第二遍是通过合并最小概率来建立Huffman树，同时还要进行编码</li></ul></li><li><p>由于需要对多层次的二叉树节点进行编码，因此数据压缩和还原速度都较慢</p></li><li><p>压缩 &#x3D; 概率统计模型 + 编码</p><ul><li><p>概率统计模型</p><ul><li>在压缩程序中，用来处理输入信息，计算符号的概率的模型</li><li>固定概率表</li><li>静态统计模型</li><li>自适应模型</li></ul></li></ul></li><li><p>特点</p><ul><li>Huffman编码是最佳变长码，其优点是编码效率高</li><li>Huffman编码依赖于信源的统计特性</li><li>由于“0”和“1”的指定可以是任意的，所以Huffman编码所得到的编码不是唯一的</li><li>Huffman编码不需要附加同步代码，任何一个字符的编码，都不是另一个字符编码的前缀</li><li>在解码时需要有编码时采用的Huffman表，才能正确解码</li><li>如果信源符号数很大，需要存储的码表（码书）也需很大，从而会影响存储量、编码以及解码速度等各个方面的性能</li><li>Huffman编码是可变长度码，很难随意查找或调用压缩文件中间的内容</li><li>没有错误保护功能，会出现错误传播</li></ul></li><li><p>Huffman编码使用整数位的方法往往无法获得使用熵计算的位数，因此其压缩并非一定最佳</p></li></ul></li><li><p>算术编码</p><ul><li><p>基本原理</p><ul><li>将出现概率较多的“消息”(可以是字符或字符串)  ，用尽可能少的位或字节来表示</li></ul></li><li><p>一种变长码，主要针对出现概率高的消息序列标识的信息进行压缩</p></li><li><p>信源符号是表达消息的符号</p></li><li><p>将消息表示成实数轴上0和1之间的间隔，消息越长，这个间隔就越小，表示这一间隔所需的二进制位数就越多</p></li><li><p>算术编码用到的两个基本的参数是符号的概率和它的编码间隔。信源符号的概率决定压缩编码的效率，也决定编码过程中信源符号的间隔，间隔则决定了符号压缩后的输出</p></li><li><p>算术编码区别于Huffman编码</p><ul><li>它是根据信源符号估计出各个元素的概率，然后进行迭代计算。而不象Huffman编码必须预先得知信源的出现概率</li></ul></li><li><p>编码过程</p></li><li><p>解码过程</p></li><li><p>特点</p><ul><li>算术编码的精度在64位以内，对于运算中的溢出问题，可使用比例缩放方法解决</li><li>在解码器中需要添加一个专门的终止符，当解码器看到终止符时就停止解码，否则会无休止的解码</li><li>算术编码器对整个消息只产生一个码字</li><li>算术编码也是一种对错误很敏感的编码方法</li><li>算术编码可以是静态的或者自适应的</li><li>信源符号概率接近时，建议使用算术编码，这种情况下其效率高于Huffman编码，JPEG扩展系统采用</li></ul></li></ul></li></ul><h3 id="5-4-词典编码"><a href="#5-4-词典编码" class="headerlink" title="5.4 词典编码"></a>5.4 词典编码</h3><ul><li><p>在不知数据统计特性的前提下的通用编码算法，定长码</p></li><li><p>分类</p><ul><li>第一类:用已经出现过的字符串替代重复的部分，输出仅仅是指向早期出现过的字符串的“指针”。LZ77算法</li><li>第二类：创建一个“短语词典”。编码中遇到已在词典中出现的“短语”时，输出词典中的短语的“索引号” 。LZ78算法，后改进为LZW算法</li></ul></li><li><p>LWZ压缩编码算法</p><ul><li><p>查找冗余字符和用较短的符号标记替代冗余字符</p></li><li><p>原理</p></li><li><p>算法步骤</p></li><li><p>解压缩步骤</p></li><li><p>LZW不需要传输压缩编码时建立的词典，而是在解压缩时建立词典，此点不同于Huffman编码。但需要初始化词典&#x2F;表&#x2F;串表</p></li><li><p>特点</p><ul><li>处理过程比其他压缩过程复杂，但过程完全可逆</li><li>对于简单图像和平滑且噪音小的信号源具有较高的压缩比，并且有较高的压缩和解压缩速度。对机器硬件条件要求不高</li><li>可压缩任何类型和格式的数据，对于数据流中连续重复出现的字节和字串，LZW压缩技术具有很高的压缩比</li><li>LZW压缩技术有很多变体方法，常见的例如：ARC、RKARC、PKZIP高效压缩程序</li></ul></li></ul></li></ul><h3 id="5-5-预测编码"><a href="#5-5-预测编码" class="headerlink" title="5.5 预测编码"></a>5.5 预测编码</h3><ul><li><p>针对统计冗余</p></li><li><p>有损与无损</p><ul><li>量化差值：有损，压缩比高</li><li>不量化差值：无损，压缩比不高</li></ul></li><li><p>适合于声音和图像的压缩</p><ul><li>对于声音来讲，预测的对象是声波的下一个幅度、下一个音色</li><li>对于图像而言，预测的对象是下一个像点、下一条线或下一帧</li></ul></li><li><p>基本原理</p></li><li><p>根据预测器的设计分类</p><ul><li><p>线性预测</p><ul><li>为了预测的效率，一般采用</li></ul></li><li><p>非线性预测</p></li></ul></li><li><p>预测编码可以压缩的原因</p><ul><li>差值可能为0，或者较小，可以较少的位数表达</li><li>通过量化差值更可以实现压缩</li></ul></li><li><p>特点</p><ul><li>预测编码主要采用压缩数据的空间冗余和时间冗余的方法</li><li>简捷且易于实现</li><li>需要前面多个信号参与预测，要求数据传输速度很高</li><li>压缩能力有限，预测差值不一定可以大量压缩</li></ul></li></ul><h3 id="5-6-变换编码"><a href="#5-6-变换编码" class="headerlink" title="5.6 变换编码"></a>5.6 变换编码</h3><ul><li><p>针对感知冗余</p></li><li><p>有损压缩编码</p><ul><li>在不考虑运算误差的条件下，变换本身是一种无损且可逆的技术。为了能获得更好的编码效果，忽略了一些不重要的系数（或对于系数进行了量化），由此成为了有损的技术</li></ul></li><li><p>常用于音频信号压缩编码和图像&#x2F;视频压缩信号编码</p></li><li><p>基本原理</p><ul><li>对欲编码的原始数据所在的时间或空间域进行某种数学变换，从一种信号空间变换到另一种信号空间，产生一批变换系数，使得通过变换后能够突出原始数据中的重要部分，以便重点处理。然后再对这些系数进行编码处理</li><li>关键是要寻找一个最佳变换，使信息中最重要的部分易于识别</li><li>重要的系数在变换到其他空间域后，其编码的精确度高于次要的系数</li></ul></li><li><p>数据变换的方式</p><ul><li>傅里叶变换</li><li>沃尔什变换</li><li>正弦变换</li><li>余弦变换</li><li>斜变换</li><li>哈尔变换</li><li>K-L变换</li></ul></li></ul><h3 id="5-7-音频信号压缩技术"><a href="#5-7-音频信号压缩技术" class="headerlink" title="5.7 音频信号压缩技术"></a>5.7 音频信号压缩技术</h3><ul><li><p>音频信号冗余度</p><ul><li>幅度非均匀分布</li><li>样本之间的相关性</li><li>周期之间的相关性</li><li>基音之间的相关性</li><li>静止系数（话音间隙）</li><li>长期相关性</li><li>人类听觉感知冗余</li></ul></li><li><p>音频编译码器的分类</p><ul><li><p>音频编码常采用有损编码</p><ul><li>波形编码</li><li>参数编码</li><li>混合编码</li><li>声音信号数字化过程中，不同采样频率、量化位数本身就是一种压缩</li></ul></li><li><p>波形编译码器</p><ul><li>直接对波形信号进行采样和量化</li><li>根据采样定理对模拟语音信号进行采样，然后进行幅度量化与二进制编码（事实上没有压缩数字信号，但不同编码方式在模拟信号转换为数字信号过程中实现了不同压缩编码）</li><li>特点：简单，失真最小</li><li>典型方法：脉冲编码调制PCM、差分脉冲编码调制DPCM、自适应差分脉冲编码调制ADPCM等</li></ul></li><li><p>音源编译码器</p><ul><li>从话音波形信号中提取话音生成模型的参数，使用这些参数通过话音生成模型重构出话音</li><li>原理：以声音信号产生的模型为基础，将声音信号转换成参数后再进一步编码</li><li>基本参数：基音周期、共振峰、语音谱、声强等</li><li>特点：压缩率大，计算量大，保真度不高，保密性能好，用在军事上</li><li>典型方法：通道声码器、线性预测(LPC)声码器</li></ul></li><li><p>混合编译码器</p><ul><li>综合使用上述两种技术</li><li>MPEGⅠ中的音频部分是一种混合编码</li></ul></li></ul></li><li><p>脉冲编码调制（PCM）</p><p>  - </p><ul><li><p>量化分类</p><ul><li>均匀量化</li><li>非均匀量化</li></ul></li></ul></li><li><p>增量调制（DM）</p><ul><li><p>一种预测编码技术，对实际的采样信号与预测的采样信号之差的极性进行编码，将极性变成“0”和“1”这两种可能的取值之一（等价于对于实际值和预测值的差值进行二值量化）</p></li><li><p>如果实际的采样信号与预测的采样信号之差的极性为“正”，则用“1”表示；相反则用“0”表示</p></li><li><p>斜率过载</p><ul><li>增量调制器的输出不能保持跟踪输入信号的快速变化</li></ul></li><li><p>粒状噪声</p><ul><li>在输入信号缓慢变化部分，即输入信号与预测信号的差值接近零的区域，增量调制器的输出出现随机交变的“0”和“1”</li></ul></li></ul></li><li><p>自适应增量调制（ADM）</p><ul><li>在检测到斜率过载时开始增大量化阶Δ，而在输入信号的斜率减小时降低量化阶Δ</li></ul></li><li><p>自适应脉冲编码调制（APCM）</p><ul><li><p>根据输入信号幅度大小来改变量化阶大小的一种波形编码技术</p></li><li><p>改变量化阶大小的两种方法</p><ul><li><p>前向自适应</p><ul><li>根据未量化的样本值的均方根值来估算输入信号的电平，以此来确定量化阶的大小，并对其电平进行编码作为边信息(side information)传送到接收端</li></ul></li><li><p>后向自适应</p><ul><li>从量化器刚输出的过去样本中来提取量化阶信息。由于后向自适应能在发收两端自动生成量化阶，所以它不需要传送边信息</li></ul></li></ul></li></ul></li><li><p>差分脉冲编码调制（DPCM）</p><ul><li><p>利用样本与样本之间存在的信息冗余度来进行编码（预测编码）</p></li><li><p>PCM、DM、DPCM的不同</p><ul><li>PCM：量化绝对值</li><li>DM：量化相对值（2值量化）</li><li>DPCM：量化相对值（多值量化）</li></ul></li></ul></li><li><p>自适应差分脉冲编码调制（ADPCM）</p><ul><li>综合了APCM的自适应特性和DPCM系统的差分特性</li><li>利用自适应的思想改变量化阶的大小，即使用小的量化阶(step-size)去编码小的差值，使用大的量化阶去编码大的差值</li><li>使用过去的样本值估算下一个输入样本的预测值，使实际样本值和预测值之间的差值总是最小</li></ul></li><li><p>子带编码（SBC）</p><ul><li><p>使用一组带通滤波器(band-pass filter，BPF)把输入音频信号的频带分成若干个连续的频段，每个频段称为子带</p></li><li><p>对每个子带中的音频信号采用单独的编码方案去编码</p></li><li><p>在信道上传送时，将每个子带的代码复合起来</p></li><li><p>在接收端译码时，将每个子带的代码单独译码，然后把它们组合起来，还原成原来的音频信号</p></li><li><p>优点</p><ul><li>对每个子带信号分别进行自适应控制，量化阶(quantization step)的大小可以按照每个子带的能量电平加以调节</li><li>可根据每个子带信号在感觉上的重要性，对每个子带分配不同的位数，用来表示每个样本值</li></ul></li></ul></li><li><p>线性预测编码（LPC）</p><ul><li>通过分析话音波形来产生声道激励和转移函数的参数，对声音波形的编码实际就转化为对这些参数的编码</li><li>在接收端使用LPC分析得到的参数，通过话音合成器重构话音</li></ul></li></ul><h3 id="5-8-压缩感知技术"><a href="#5-8-压缩感知技术" class="headerlink" title="5.8 压缩感知技术"></a>5.8 压缩感知技术</h3><ul><li>解决数据采集设备廉价节能而压缩算法复杂和数据解压缩设备大型高效而解压缩算法相对简单的矛盾</li><li>压缩感知最核心的概念在于试图从原理上降低对一个信号进行测量的成本</li></ul><h2 id="6-多媒体数据压缩标准"><a href="#6-多媒体数据压缩标准" class="headerlink" title="6 多媒体数据压缩标准"></a>6 多媒体数据压缩标准</h2><h3 id="6-1-图像数据压缩标准"><a href="#6-1-图像数据压缩标准" class="headerlink" title="6.1 图像数据压缩标准"></a>6.1 图像数据压缩标准</h3><ul><li><p>种类</p><ul><li><p>JPEG</p><ul><li>静态图像压缩标准</li></ul></li><li><p>MPEG</p><ul><li>动态图像压缩标准</li></ul></li><li><p>H系列（H.261, H.263）</p><ul><li>视频压缩标准H.26x</li></ul></li></ul></li><li><p>JPEG</p><ul><li><p>采用的两种基本压缩算法</p><ul><li><p>以预测为基础的DPCM无损压缩算法</p><ul><li>不对差值量化</li></ul></li><li><p>以离散余弦变换DCT为基础的有损压缩算法</p><ul><li>JPEG压缩通常指此方法</li></ul></li></ul></li><li><p>4种运行模式</p><ul><li>基于DPCM的无损编码模式</li><li>基于DCT的有损顺序编码模式</li><li>基于DCT的递增编码模式</li><li>基于DCT的分层编码模式</li></ul></li><li><p>算法特点</p><ul><li><p>既可用于灰度图像，又可用于彩色图像</p></li><li><p>JPEG算法与色彩空间无关</p><ul><li>JPEG算法处理的彩色图像是单独的彩色分量图像，因此它可以压缩来自不同彩色空间的数据</li></ul></li><li><p>通常使用YUV模式</p></li><li><p>JPEG不仅适于静止图像的压缩，电视图像的帧内图像的压缩编码，也常采用此算法（作为动态图像压缩的一个组成部分）</p></li><li><p>JPEG标准还可以大范围地调节图像压缩比及其保真度</p></li><li><p>JPEG中的有损压缩利用了人的视觉系统的特性，使用变换编码+量化和无损压缩编码相结合来去掉视觉的冗余信息和数据本身的冗余信息</p></li></ul></li><li><p>主要步骤</p><ul><li><p>图像分块</p></li><li><p>正向离散余弦变换(FDCT)</p></li><li><p>量化(quantization)</p></li><li><p>Z字形编排(zigzag scan)</p></li><li><p>使用差分脉冲编码调制(differential pulse code modulation，DPCM)对直流系数(DC)进行编码</p></li><li><p>使用游程长度编码(run-length encoding，RLE)对交流系数(AC)进行编码</p></li><li><p>熵编码(entropy coding)</p><ul><li><p>Huffman编码</p><ul><li><p>交流系数熵编码的中间格式</p><ul><li><p>符号1（游程，尺寸）</p><ul><li>游程：前后两个非0的AC系数之间连续0的个数，1个字节的高4位存储</li><li>尺寸：后一个非0的AC系数复制幅值编码所需比特数，1个字节的低4位存储</li><li>游程取值范围为0-15，超过15用扩展符号（15，0）来扩充</li><li>尺寸的取值范围位0-10</li><li>编码结束用（0，0）来表示</li></ul></li><li><p>符号2（幅值）</p><ul><li>最长10位表示</li></ul></li></ul></li><li><p>直流系数的熵编码</p><ul><li><p>符号1（尺寸）</p></li><li><p>符号2（幅值）</p><ul><li>幅值可以以1位到11位表示</li></ul></li></ul></li></ul></li><li><p>自适应二进制算术编码</p></li></ul></li><li><p>组成位数据流</p></li><li><p>各种压缩技术的组合</p></li></ul></li><li><p>基于DCT的递增编码模式</p><ul><li><p>递增模式每个图像分量的编码要经过多次扫描才完成</p></li><li><p>递增模式</p><ul><li>按频段累进</li><li>按位累进</li></ul></li></ul></li><li><p>基于DCT的分层编码模式</p><ul><li>降低原始图像的空间分辨率</li></ul></li><li><p>基于DPCM的钨酸编码模式</p><ul><li>三领域二维预测编码和熵编码</li></ul></li><li><p>JPEG图像文件格式</p><ul><li>标记码</li><li>压缩数据</li></ul></li><li><p>EXIF格式</p></li></ul></li><li><p>MEPG</p><ul><li><p>M-JPEG技术（运动静止图像（或逐帧）压缩技术）</p><ul><li>M-JPEG只对帧内的空间冗余进行压缩。不对帧间的时间冗余进行压缩，故压缩效率不高</li></ul></li><li><p>MPEG-1和MPEG-2视频数据压缩算法</p><ul><li><p>在空间方向上，图像数据压缩采用JPEG压缩算法来去掉冗余信息</p></li><li><p>在时间方向上，图像数据压缩采用运动补偿(motion compensation)算法来去掉冗余信息</p></li><li><p>实际做法</p><ul><li><p>部分帧采用JPEG压缩，特点与M-JPEG相同</p></li><li><p>部分帧利用别的帧进行预测，依赖于别的帧，压缩比高，压缩质量稍差</p></li><li><p>具体分为I图像、P图像、B图像，需要考虑分布方式，三者图像压缩质量依次递减</p><ul><li><p>I图像（帧内图）</p><ul><li>采用帧内编码方式，即只利用了单帧图像内的空间相关性，而没有利用时间相关性</li></ul></li><li><p>P图像（预测图）</p><ul><li><p>用最近的前一个I图像(或P图像)预测编码得到</p><ul><li><p>以图像宏块为基本算法单元</p></li><li><p>参数</p><ul><li>当前要编码的图像宏块与参考图像的宏块之间的差值</li><li>宏块的运动矢量</li></ul></li></ul></li></ul></li><li><p>B图像（插补图，即双向预测图）</p><ul><li>B图像在预测时, 既可使用前一个图像作参照, 也可使用后一个图像做参照或同时使用前后两个图像作为参照图像(双向预测)</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>H.26x</p><ul><li>可用于低带宽网络上的视频传输</li></ul></li></ul><h3 id="6-2-音频数据压缩标准"><a href="#6-2-音频数据压缩标准" class="headerlink" title="6.2 音频数据压缩标准"></a>6.2 音频数据压缩标准</h3><ul><li><p>中国音视频编码技术标准</p><ul><li>AVS</li></ul></li></ul><h2 id="7-多媒体应用系统创作技术"><a href="#7-多媒体应用系统创作技术" class="headerlink" title="7 多媒体应用系统创作技术"></a>7 多媒体应用系统创作技术</h2><h3 id="7-1-多媒体应用系统设计基本过程"><a href="#7-1-多媒体应用系统设计基本过程" class="headerlink" title="7.1 多媒体应用系统设计基本过程"></a>7.1 多媒体应用系统设计基本过程</h3><ul><li>系统目标确定</li><li>编写系统脚本</li><li>进行脚本分析</li><li>脚本制作</li><li>脚本测试</li><li>系统评价等</li></ul><h3 id="7-2-多媒体系统创作"><a href="#7-2-多媒体系统创作" class="headerlink" title="7.2 多媒体系统创作"></a>7.2 多媒体系统创作</h3><ul><li><p>ToolBook</p><ul><li>面向对象的多媒体开发工具</li><li>设计过程如同构造一本书</li><li>主要通过使用程序设计语言OpenScript来编写脚本</li></ul></li><li><p>Authorware Professional</p><ul><li>基于流程图的可视化多媒体开发工具</li><li>整个过程以流程图为基本处理对象</li></ul></li><li><p>PowerPoint</p></li></ul><h3 id="7-3-多媒体程序设计基础"><a href="#7-3-多媒体程序设计基础" class="headerlink" title="7.3 多媒体程序设计基础"></a>7.3 多媒体程序设计基础</h3><ul><li><p>在Windows系统中，对多媒体设备进行控制主要有三种办法</p><ul><li>使用Microsoft提供的多媒体控制接口MCI</li><li>通过调用Windows的应用程序接口API多媒体相关函数</li><li>使用对象链接与嵌入OLE</li></ul></li></ul><h3 id="7-4-OpenGL"><a href="#7-4-OpenGL" class="headerlink" title="7.4 OpenGL"></a>7.4 OpenGL</h3><ul><li>OpenGL实际上是一种图形与硬件的接口</li></ul><h3 id="7-5-DirectX"><a href="#7-5-DirectX" class="headerlink" title="7.5 DirectX"></a>7.5 DirectX</h3><ul><li>DirectX是Microsoft开发的基于Windows平台的一组API，不仅支持图形&#x2F;图像编程，而且支持声音、视频等</li><li>它是为高速的实时动画渲染、交互式音乐和环境音效等高要求应用开发服务的</li></ul><h3 id="7-6-四大图像库"><a href="#7-6-四大图像库" class="headerlink" title="7.6 四大图像库"></a>7.6 四大图像库</h3><ul><li>OpenCV</li><li>FreeImage</li><li>CImg</li><li>CxImage_Advancing</li></ul>]]></content>
      
      
      <categories>
          
          <category> CQU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 多媒体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件需求分析</title>
      <link href="/2020/cqu-ruan-jian-xu-qiu-fen-xi/"/>
      <url>/2020/cqu-ruan-jian-xu-qiu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本的软件需求"><a href="#1-基本的软件需求" class="headerlink" title="1 基本的软件需求"></a>1 基本的软件需求</h1><h2 id="1-1-为什么要需求分析？"><a href="#1-1-为什么要需求分析？" class="headerlink" title="1.1 为什么要需求分析？"></a>1.1 为什么要需求分析？</h2><ol><li>它具有<strong>决策性，方向性，策略性</strong>的作用，它在软件开发的过程中，具有举足轻重的地位。在一个大型软件系统的开发中，它的作用要远远大于程序设计。</li><li>需求是<strong>软件产品的根源</strong>，需求工作的优劣对软件产品影响最大。</li></ol><h2 id="1-2-需求分析的任务"><a href="#1-2-需求分析的任务" class="headerlink" title="1.2 需求分析的任务"></a>1.2 需求分析的任务</h2><ol><li>需求分析的任务，就是解决“做什么”的问题，就是要全面地理解用户的各项要求。</li><li>需求分析模型如下：</li></ol><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B.jpg" alt="需求分析模型"></p><center>图1-1 需求分析模型</center><table><thead><tr><th></th><th>逻辑模型（本质模型、概念模型）</th><th>物理模型（实时模型、技术模型）</th></tr></thead><tbody><tr><td>现行系统</td><td>描述重要的业务功能，无论系统是如何实施的。</td><td>描述现实系统是如何在物理上实现的。</td></tr><tr><td>目标系统</td><td>描述新系统的主要业务功能和用户新的需求，无论系统应如何实施。</td><td>描述新系统是如何实施的（包括技术）。</td></tr></tbody></table><ol start="3"><li>软件需求活动</li></ol><ul><li>需求诱导</li><li>需求分析</li><li>需求传递</li><li>需求确认</li><li>需求演化</li></ul><span id="more"></span><h2 id="1-3-什么是需求分析？"><a href="#1-3-什么是需求分析？" class="headerlink" title="1.3 什么是需求分析？"></a>1.3 什么是需求分析？</h2><h3 id="1-3-1-软件需求的定义"><a href="#1-3-1-软件需求的定义" class="headerlink" title="1.3.1 软件需求的定义"></a>1.3.1 软件需求的定义</h3><p>IEEE 软件工程标准词汇表中定义软件需求为：</p><p>（1）用户为解决某个问题或达到目标而需具备的条件或能力。</p><p>（2）系统或系统部件为满足合同、标准、规范或其它正式文档而必须满足的条件或能力。</p><p>（3）上述（1）或（2）中定义的条件或能力的文档表达。</p><h3 id="1-3-2-简单理解"><a href="#1-3-2-简单理解" class="headerlink" title="1.3.2 简单理解"></a>1.3.2 简单理解</h3><p>分析软件用户的需求，细致的进行调查，把用户“做什么”的要求，最终转换为一个完全的、精细的软件逻辑模型。并写出软件的需求规格说明。准确地表达用户的要求.。</p><h3 id="1-3-3-需求的层次"><a href="#1-3-3-需求的层次" class="headerlink" title="1.3.3 需求的层次"></a>1.3.3 需求的层次</h3><ul><li>业务需求：表示组织或客户高层次的目标。描述了组织为什么要开发一个系统，即目标。可以用前景和范围文档表述。</li><li>用户需求：描述的是用户的目标，或用户要求系统必须能完成的任务，即用户能使用系统来做些什么。可以用用例、场景描述和事件-响应表表述。</li><li>功能需求：规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求，即开发人员需要实现什么。</li></ul><h3 id="1-3-4-需求的级别"><a href="#1-3-4-需求的级别" class="headerlink" title="1.3.4 需求的级别"></a>1.3.4 需求的级别</h3><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E7%9A%84%E7%BA%A7%E5%88%AB.jpg" alt="需求的级别"></p><center>图1-2 需求的级别</center><h3 id="1-3-5-不属于需求的内容"><a href="#1-3-5-不属于需求的内容" class="headerlink" title="1.3.5 不属于需求的内容"></a>1.3.5 不属于需求的内容</h3><ul><li>设计和实现的细节</li><li>项目的计划信息</li><li>测试信息</li><li>以上信息包含在项目需求中。</li></ul><h2 id="1-4-优秀的团队遇到糟糕的需求"><a href="#1-4-优秀的团队遇到糟糕的需求" class="headerlink" title="1.4 优秀的团队遇到糟糕的需求"></a>1.4 优秀的团队遇到糟糕的需求</h2><h3 id="1-4-1-用户参与不足"><a href="#1-4-1-用户参与不足" class="headerlink" title="1.4.1 用户参与不足"></a>1.4.1 用户参与不足</h3><h3 id="1-4-2-用户需求扩展"><a href="#1-4-2-用户需求扩展" class="headerlink" title="1.4.2 用户需求扩展"></a>1.4.2 用户需求扩展</h3><ul><li>要控制项目范围的改变，首先应明确项目的业务目标、全局规划、范围、限制、成功标准以及产品的预计用途。然后参考这一框架对所有新特性和需求变更进行评估。</li><li>插入的代码可能导致模块违反强内聚和弱耦合这一设计原则。要减少需求变更对质量造成的影响，处理变更时应该先对结构和设计进行适当的修改，而不是直接修改代码。</li></ul><h3 id="1-4-3-有歧义的需求"><a href="#1-4-3-有歧义的需求" class="headerlink" title="1.4.3 有歧义的需求"></a>1.4.3 有歧义的需求</h3><h3 id="1-4-4-镀金问题"><a href="#1-4-4-镀金问题" class="headerlink" title="1.4.4 镀金问题"></a>1.4.4 镀金问题</h3><ul><li>开发人员为产品添加了一项需求说明中没有提到的功能，他认为“用户肯定会喜欢的”，则就是“镀金问题”。</li><li>开发人员和需求分析员不应擅自添加特性，应该把创意和备选方案提交给客户，让客户做决定。</li></ul><h3 id="1-4-5-过于抽象的需求"><a href="#1-4-5-过于抽象的需求" class="headerlink" title="1.4.5 过于抽象的需求"></a>1.4.5 过于抽象的需求</h3><h3 id="1-4-6-忽略了某类用户"><a href="#1-4-6-忽略了某类用户" class="headerlink" title="1.4.6 忽略了某类用户"></a>1.4.6 忽略了某类用户</h3><h3 id="1-4-7-不准确的计划"><a href="#1-4-7-不准确的计划" class="headerlink" title="1.4.7 不准确的计划"></a>1.4.7 不准确的计划</h3><h2 id="1-5-优质需求的好处"><a href="#1-5-优质需求的好处" class="headerlink" title="1.5 优质需求的好处"></a>1.5 优质需求的好处</h2><ul><li>减少需求缺陷</li><li>减少开发过程中的返工</li><li>减少不必要的特性</li><li>降低改进成本</li><li>加快开发进度</li><li>提高沟通效率</li><li>控制需求范围的改变</li><li>项目更有序</li><li>对系统测试的评估更准确</li><li>提高客户和开发人员的满意度</li></ul><h2 id="1-6-需求开发与需求管理"><a href="#1-6-需求开发与需求管理" class="headerlink" title="1.6 需求开发与需求管理"></a>1.6 需求开发与需求管理</h2><ol><li>把所有与需求直接相关单独活动统称为<strong>需求工程</strong>，需求工程中的活动可分为两大类，需求开发、需求管理。</li><li>需求开发，如图：</li></ol><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91.png" alt="需求开发"></p><center>图1-4 需求开发</center><p><strong>Tip：分别是获取、分析、编写规范、确认。</strong></p><ol start="3"><li>需求管理，如图：</li></ol><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86.jpg" alt="需求管理"></p><center>图1-4 需求管理</center><ol start="4"><li>需求开发与需求管理的分界，如图：</li></ol><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91%E4%B8%8E%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%86%E7%95%8C.png" alt="需求开发与需求管理的分界"></p><center>图1-5 需求开发与需求管理的分界</center><h2 id="1-7-优秀需求的特点"><a href="#1-7-优秀需求的特点" class="headerlink" title="1.7 优秀需求的特点"></a>1.7 优秀需求的特点</h2><h3 id="1-7-1-需求陈述的特点"><a href="#1-7-1-需求陈述的特点" class="headerlink" title="1.7.1 需求陈述的特点"></a>1.7.1 需求陈述的特点</h3><ul><li>完整性</li><li>正确性</li><li>可行性</li><li>必要性</li><li>有优先次序</li><li>无歧义</li><li>可验证性</li></ul><h3 id="1-7-2-需求规格说明的特点"><a href="#1-7-2-需求规格说明的特点" class="headerlink" title="1.7.2 需求规格说明的特点"></a>1.7.2 需求规格说明的特点</h3><ul><li>完整性</li><li>一致性：不会与同一类型的其他需求或更高层次的业务、系统或用户需求发生冲突。</li><li>可修改性</li><li>可跟踪性：可跟踪的需求都有一个固定的标识符对其唯一标识。</li></ul><h2 id="1-8-需求与其他软件项目过程的关系"><a href="#1-8-需求与其他软件项目过程的关系" class="headerlink" title="1.8 需求与其他软件项目过程的关系"></a>1.8 需求与其他软件项目过程的关系</h2><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="需求与其他软件项目过程的关系"></p><center>图1-6 需求与其他软件项目过程的关系</center><h1 id="2-客户的需求观"><a href="#2-客户的需求观" class="headerlink" title="2 客户的需求观"></a>2 客户的需求观</h1><h2 id="2-1-了解客户、最终用户、简介用户"><a href="#2-1-了解客户、最终用户、简介用户" class="headerlink" title="2.1 了解客户、最终用户、简介用户"></a>2.1 了解客户、最终用户、简介用户</h2><h3 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h3><p>用户是一种泛称，可细分为如下几个：</p><ol><li>客户：掏钱买软件的用户。</li><li>最终用户：真正操作软件的用户。</li><li>间接用户：间接用户既不掏钱买该软件产品，也不使用该软件，但是它可能对软件产品有很大的影响。一般为政府机构等。</li></ol><h3 id="2-1-2-涉众"><a href="#2-1-2-涉众" class="headerlink" title="2.1.2 涉众"></a>2.1.2 涉众</h3><p>涉众 (stakeholder) ，在软件开发项目中主要是指和这个项目有密切相关利益的人，他们共同感兴趣的就是需求分析阶段。</p><p>这些涉众包括如下：</p><ul><li>客户</li><li>用户</li><li>业务或需求分析员(负责收集客户需求并编写文档，以及负责客户与开发机构之间联系沟通的人)</li><li>开发人员</li><li>测试人员</li><li>用户文档编写者</li><li>项目管理者</li><li>客户管理者</li></ul><h2 id="2-2-客户的权利与义务"><a href="#2-2-客户的权利与义务" class="headerlink" title="2.2 客户的权利与义务"></a>2.2 客户的权利与义务</h2><h3 id="2-2-1-客户的权利"><a href="#2-2-1-客户的权利" class="headerlink" title="2.2.1 客户的权利"></a>2.2.1 客户的权利</h3><ol><li>要求分析人员使用符合客户语言习惯的表达。</li><li>要求分析人员了解客户系统的业务及目标。</li><li>要求分析人员组织需求获取期间所介绍的信息，并编写软件需求规格说明。</li><li>要求开发人员对需求过程中所产生的工作结果进行解释说明。</li><li>要求开发人员在整个交流过程中保持和维护一种合作的职业态度。</li><li>要求开发人员对产品的实现及需求都要提供建议，拿出主意。</li><li>描述产品使其具有易用、好用的特性。</li><li>可以调整需求，允许重用已有的软件组件。</li><li>当需要对需求进行变更时，对成本、影响、得失（ trade-off)有个真实可信的评估。</li><li>获得满足客户功能和质量要求的系统，并且这些要求是开发人员同意的。</li></ol><h3 id="2-2-2-客户的义务"><a href="#2-2-2-客户的义务" class="headerlink" title="2.2.2 客户的义务"></a>2.2.2 客户的义务</h3><ol><li>给分析人员讲解业务及说明业务方面的术语等专业问题。</li><li>抽出时间清楚地说明需求并不断完善。</li><li>当说明系统需求时，力求准确详细。</li><li>需要时要及时对需求做出决策。</li><li>要尊重开发人员的成本估算和对需求的可行性分析。</li><li>对单项需求、系统特性或使用实例划分优先级。</li><li>评审需求文档和原型。</li><li>一旦知道要对项目需求进行变更，要马上与开发人员联系。</li><li>在要求需求变更时，应遵照开发组织确定的工作过程来处理。</li><li>尊重需求工程中开发人员采用的流程（过程)。</li></ol><h1 id="3-需求工程的推荐方法"><a href="#3-需求工程的推荐方法" class="headerlink" title="3 需求工程的推荐方法"></a>3 需求工程的推荐方法</h1><p>7种类型：知识技能、需求获取、需求分析、规格说明、需求确认、需求管理、项目管理，共45种方法，后续章节一一讲述。</p><ul><li>需求工程的过程如图3-1：</li></ul><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="需求工程的过程"></p><center>图3-1 需求工程的过程</center><h1 id="4-需求分析员"><a href="#4-需求分析员" class="headerlink" title="4 需求分析员"></a>4 需求分析员</h1><h2 id="4-1-需求分析员的职责"><a href="#4-1-需求分析员的职责" class="headerlink" title="4.1 需求分析员的职责"></a>4.1 需求分析员的职责</h2><h3 id="4-1-0-需求分析员的概念"><a href="#4-1-0-需求分析员的概念" class="headerlink" title="4.1.0 需求分析员的概念"></a>4.1.0 需求分析员的概念</h3><ul><li>需求分析员，又叫系统分析员、需求工程师、需求经理、分析员。</li><li>需求分析员：<ul><li>对软件项目设计的需求进行收集、分析、记录和验证等工作的主要承担者。 </li><li>用户群体和软件开发团队之间进行需求沟通的桥梁。</li><li>是收集和传播的中心角色。</li></ul></li></ul><h3 id="4-1-1-需求分析员的任务"><a href="#4-1-1-需求分析员的任务" class="headerlink" title="4.1.1 需求分析员的任务"></a>4.1.1 需求分析员的任务</h3><ol><li>定义业务需求</li><li>确定项目承担者和用户类别</li><li>获取需求</li><li>分析需求</li><li>编制需求规格说明书</li><li>为需求建模</li><li>主持对需求的验证</li><li>引导对需求的优先级划分</li><li>管理需求</li></ol><h3 id="4-1-2-需求分析员的基本技能"><a href="#4-1-2-需求分析员的基本技能" class="headerlink" title="4.1.2 需求分析员的基本技能"></a>4.1.2 需求分析员的基本技能</h3><ol><li>倾听的技巧</li><li>交谈和提问的技巧</li><li>分析能力</li><li>协调的能力</li><li>观察能力</li><li>写作能力</li><li>组织能力</li><li>建模能力</li><li>人际交往能力</li><li>创造力</li></ol><h3 id="4-1-3-需求分析员的基本知识"><a href="#4-1-3-需求分析员的基本知识" class="headerlink" title="4.1.3 需求分析员的基本知识"></a>4.1.3 需求分析员的基本知识</h3><ol><li>掌握需求开发和需求管理的知识</li><li>理解项目关系、风险管理和质量工程</li><li>掌握一些领域的知识也是必要的</li></ol><h2 id="4-2-如何培养需求分析员"><a href="#4-2-如何培养需求分析员" class="headerlink" title="4.2 如何培养需求分析员"></a>4.2 如何培养需求分析员</h2><ul><li>需求分析员是培养出来的，而不是训练出来的，主要面向人，而不是面向“软件技术”。</li></ul><h3 id="4-2-1-从用户转为分析员"><a href="#4-2-1-从用户转为分析员" class="headerlink" title="4.2.1 从用户转为分析员"></a>4.2.1 从用户转为分析员</h3><ul><li><p>优点：用户对领域知识和工作环境非常熟悉。</p></li><li><p>缺点：对软件工程知识了解较少，阻碍了与技术人员的交流。</p></li></ul><h3 id="4-2-2-从开发人员转为分析员"><a href="#4-2-2-从开发人员转为分析员" class="headerlink" title="4.2.2 从开发人员转为分析员"></a>4.2.2 从开发人员转为分析员</h3><ul><li>优点：对软件工程知识熟悉，有利于项目的实施。</li><li>缺点：不少开发人员对用户没有耐心，对怎样有效的倾听、协商和引导等知识掌握不多。</li></ul><h3 id="4-2-3-应用领域专家"><a href="#4-2-3-应用领域专家" class="headerlink" title="4.2.3 应用领域专家"></a>4.2.3 应用领域专家</h3><ul><li>优点：精通领域知识，有利于准确的定义需求。</li><li>缺点：应用领域专家根据自己爱好定义需求。系统太复杂、通用性差。</li><li>解决办法：可以让应用领域专家作为用户代言人。</li></ul><h2 id="4-3-创造一个合作的环境"><a href="#4-3-创造一个合作的环境" class="headerlink" title="4.3 创造一个合作的环境"></a>4.3 创造一个合作的环境</h2><p>很多项目中项目承担者之间关系非常紧张，不利于成功开发项目。需求分析员<strong>应引导达成一致</strong>，获得三赢：</p><ul><li>客户对产品感到满意。</li><li>开发组织因产品的成功而感到高兴。</li><li>开发团队成员为自己参加该开发而自豪。</li></ul><h1 id="5-确定产品前景与项目范围"><a href="#5-确定产品前景与项目范围" class="headerlink" title="5 确定产品前景与项目范围"></a>5 确定产品前景与项目范围</h1><h1 id="5-0-基本概念"><a href="#5-0-基本概念" class="headerlink" title="5.0 基本概念"></a>5.0 基本概念</h1><h3 id="5-0-1-业务需求"><a href="#5-0-1-业务需求" class="headerlink" title="5.0.1 业务需求"></a>5.0.1 业务需求</h3><ul><li>代表了需求链中最高层的抽象，为软件系统定义了项目视图和范围。</li></ul><h3 id="5-0-2-功能需求"><a href="#5-0-2-功能需求" class="headerlink" title="5.0.2 功能需求"></a>5.0.2 功能需求</h3><ul><li>必须根据用户需求来考虑，且要与业务需求所设定的目标相一致。</li><li>在确定详细的功能需求之前，必须很好地解决项目的视图和范围问题。</li></ul><h3 id="5-0-3-领域分析（domain-analysis）"><a href="#5-0-3-领域分析（domain-analysis）" class="headerlink" title="5.0.3 领域分析（domain analysis）"></a>5.0.3 领域分析（domain analysis）</h3><ul><li>领域：是指客户希望使用软件的一般性商业或技术领域。</li><li>领域专家：在某个领域中，具有该领域深入知识的人。</li><li>专家系统：具有与该领域专家相同智能的计算机软件系统。</li><li>领域分析：是软件工程师了解背景信息的过程。</li><li>领域分析的工作价值：<ul><li>快速开发</li><li>优化系统</li><li>扩展预测</li></ul></li></ul><h3 id="5-0-4-软件项目的类型分析"><a href="#5-0-4-软件项目的类型分析" class="headerlink" title="5.0.4 软件项目的类型分析"></a>5.0.4 软件项目的类型分析</h3><ul><li>可以根据项目开始时，软件是否存在以及需求是否存在来划分项目的类型，如图5-1，可以分为四种情况：</li></ul><p><img src="http://img.fdchen.host/%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B.png" alt="项目的四种类型"></p><center>图5-1 项目的四种类型</center><ol><li>在A和B项目中，开发小组要从头开发的新的软件。有时称为零起点（green field development），即系统从头开始构建，要从头开发新的软件。</li><li>在C和D项目中，开发小组逐步改进一个现有的系统，这种情况是常见的。</li><li>在A和C项目中，开发小组必须确定软件的需求。必须明白客户要求解决的问题，从而找到最好的方法去解决问题。</li><li>在B和D项目中，客户要求开发小组设计和实现特定的要求，客户的机构已经做好了需求分析。</li></ol><h2 id="5-1-通过业务需求定义前景"><a href="#5-1-通过业务需求定义前景" class="headerlink" title="5.1 通过业务需求定义前景"></a>5.1 通过业务需求定义前景</h2><h3 id="5-1-1-项目视图"><a href="#5-1-1-项目视图" class="headerlink" title="5.1.1 项目视图"></a>5.1.1 项目视图</h3><ul><li>描述了产品所涉及的各个方面和最终所具有的功能。</li></ul><h3 id="5-1-2-项目范围"><a href="#5-1-2-项目范围" class="headerlink" title="5.1.2 项目范围"></a>5.1.2 项目范围</h3><ul><li>描述了产品应包括的部分和不应包括的部分。</li><li>说明了在包括的部分与不包括的部分之间的界线。</li></ul><h2 id="5-2-视图和范围文档"><a href="#5-2-视图和范围文档" class="headerlink" title="5.2 视图和范围文档"></a>5.2 视图和范围文档</h2><h3 id="5-2-1-基本概念"><a href="#5-2-1-基本概念" class="headerlink" title="5.2.1 基本概念"></a>5.2.1 基本概念</h3><p>项目视图和范围文档，包括：</p><ul><li>业务机遇的描述、项目的视图和目标、 产品适用范围和局限性的陈述、客户的特点、项目优先级别和项目成功因素的描述。</li><li>是一个相对简短的文档。</li></ul><h3 id="5-2-2-项目视图和范围文档模板"><a href="#5-2-2-项目视图和范围文档模板" class="headerlink" title="5.2.2 项目视图和范围文档模板"></a>5.2.2 项目视图和范围文档模板</h3><ol><li><p>业务需求</p><p>1.1 背景</p><p>1.2 业务机遇</p><p>1.3 业务目标</p><p>1.4 客户或市场需求</p><p>1.5 提供给客户的价值</p><p>1.6 业务风险</p></li><li><p>项目视图的解决方案</p><p>2.1 项目视图陈述</p><p>2.2 主要特性</p><p>2.3 假设和依赖环境</p></li><li><p>范围和局限性</p><p>3.1 首次发行的范围</p><p>3.2 随后发行的范围</p><p>3.3 局限性和专用性</p></li><li><p>业务环境</p><p>4.1 客户概貌</p><p>4.2 项目优先级</p></li><li><p>产品成功的因素</p></li></ol><h2 id="5-3-关联图"><a href="#5-3-关联图" class="headerlink" title="5.3 关联图"></a>5.3 关联图</h2><ol><li><p>关联图（0层DFD） ：确定了通过某一接口与系统相连的外部实体——有时，称为“端点”，以及外部实体和系统之间的数据流和物流。我们把关联图，作为结构化分析方法，形成数据流图的最高抽象层。 </p></li><li><p>可以把关联图，写入项目视图和范围文档，或软件需求规格说明中，或者作为系统数据流模型的一部分。</p></li></ol><h2 id="5-4-保证范围的适度"><a href="#5-4-保证范围的适度" class="headerlink" title="5.4 保证范围的适度"></a>5.4 保证范围的适度</h2><p>范围扩展，存在两个主要问题：</p><ol><li>全部的工作，必须重新进行，以适应变化。</li><li>当项目的范围增大时，如果没有调整原先所分配的资源和时间，则属性会遭到破坏。</li></ol><h1 id="6-获取客户的需求"><a href="#6-获取客户的需求" class="headerlink" title="6 获取客户的需求"></a>6 获取客户的需求</h1><h2 id="6-0-征求客户的意见，必须采取以下几步"><a href="#6-0-征求客户的意见，必须采取以下几步" class="headerlink" title="6.0 征求客户的意见，必须采取以下几步"></a>6.0 征求客户的意见，必须采取以下几步</h2><ol><li>明确项目用户需求的来源。</li><li>明确使用该产品的不同类型的用户。</li><li>与产品不同用户类的代表进行沟通。</li><li>遵从项目的最终决策者的意见。</li></ol><h2 id="6-1-需求的来源"><a href="#6-1-需求的来源" class="headerlink" title="6.1 需求的来源"></a>6.1 需求的来源</h2><p>软件需求的典型来源：</p><ol><li><p>访问并与有潜力的用户探讨</p></li><li><p>把对目前的或竞争产品的描述，写成文档</p></li><li><p>系统需求规格说明</p></li><li><p>对当前系统的问题分析，并增强要求</p></li><li><p>市场调查和用户问卷调查</p></li><li><p>观察正在工作的用户</p></li><li><p>用户工作的情景分析</p></li><li><p>事件和响应</p></li></ol><h2 id="6-2-用户类"><a href="#6-2-用户类" class="headerlink" title="6.2 用户类"></a>6.2 用户类</h2><ul><li>产品的用户在很多方面存在着差异，不同用户，有不同需求，根据这些差异，可以把用户分成用户小组，称为用户类。</li></ul><h2 id="6-3-寻找用户代言人"><a href="#6-3-寻找用户代言人" class="headerlink" title="6.3 寻找用户代言人"></a>6.3 寻找用户代言人</h2><ol><li><p>在获取用户需求时，要挑选合适的用户，来代表各类用户的需求。即：选择用户代言人。</p></li><li><p>用户代言人必须参加整个软件开发。</p></li><li><p>在用户代言人的参与下，广泛了解不同用户类和不同的专业层次的需求。</p></li></ol><h2 id="6-4-用户代言人"><a href="#6-4-用户代言人" class="headerlink" title="6.4 用户代言人"></a>6.4 用户代言人</h2><h3 id="6-4-0-基本概念"><a href="#6-4-0-基本概念" class="headerlink" title="6.4.0 基本概念"></a>6.4.0 基本概念</h3><ol><li>每一个工程项目，都包括为数不多的关键参与者，这些参与者来自相关的某方面用户团体，并提供客户的需求。我们称这些人为用户代言人或项目协调者。</li><li>用户代言人，可能是软件公司的一员 。</li><li>用户代言人要求必须对应用领域有彻底的了解，并在软件方面具有足够的经验。</li></ol><h3 id="6-4-1-外部用户代言人"><a href="#6-4-1-外部用户代言人" class="headerlink" title="6.4.1 外部用户代言人"></a>6.4.1 外部用户代言人</h3><ul><li>公司内部用户代言人比较困难；</li><li>公司外部用户代言人，如聘请一个具有丰富阅历的用户代言人，同时，为了获得更多的信息，有时需要给用户代言人，一些经济上的鼓励。</li></ul><h3 id="6-4-2-对用户代言人的要求"><a href="#6-4-2-对用户代言人的要求" class="headerlink" title="6.4.2 对用户代言人的要求"></a>6.4.2 对用户代言人的要求</h3><p>表6-1列出了用户代言人要进行的一些工作，不是每个代言人都需要做所有这些工作，可以该表为起点与每位代言人协商他的职责。</p><center>表6-1 用户代言人可能的活动</center><table><thead><tr><th>类别</th><th>工作</th></tr></thead><tbody><tr><td>计划</td><td>推敲产品的范围和限制<br />定义与其他系统的接口<br />评估新系统对业务操作的影响<br />定义从现有系统到新系统的过渡方案</td></tr><tr><td>需求</td><td>收集其他用户的需求<br />开发使用范例和用例<br />解决用户提出的需求种的冲突<br />确定实现的优先级<br />确定质量和性能需求<br />评估用户界面的原型</td></tr><tr><td>确认和验证</td><td>评审需求文档<br />定义用户接受系统的标准<br />根据使用情况开发测试用例<br />提供测试数据集<br />执行beta测试（一种验收测试）</td></tr><tr><td>用户辅助</td><td>编写用户手册和帮助文档<br />准备培训资料<br />向同行演示产品</td></tr><tr><td>变更控制</td><td>评估缺陷修改请求，确定其优先级<br />评估改进请求，确定其优先级<br />评估需求变更对用户和业务流程的影响<br />参与变更决策</td></tr></tbody></table><h3 id="6-4-3-设置多位用户代言人"><a href="#6-4-3-设置多位用户代言人" class="headerlink" title="6.4.3 设置多位用户代言人"></a>6.4.3 设置多位用户代言人</h3><p>一个人很难描述出所有用户对应用程序的需求。要从不同用户类中各挑选一名用户代言人。以图6-1为例，有3名分析员和这4名用户代言人一起工作、收集、分析并记录各用户类的需求。因为购买者和健康安全人员这两个用户类人数和需求都很少，所以由同一位需求分析员负责与这两类的用户代言人合作。最后由一名需求分析员将所有需求整理为一份需求规格说明。</p><p><img src="http://img.fdchen.host/%E5%8C%96%E5%AD%A6%E5%88%B6%E5%93%81%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BB%A3%E8%A8%80%E4%BA%BA%E6%A8%A1%E5%9E%8B.png" alt="化学制品跟踪系统中的用户代言人模型"></p><center>图6-1 化学制品跟踪系统中的用户代言人模型</center><h2 id="6-5-谁来做决策？"><a href="#6-5-谁来做决策？" class="headerlink" title="6.5 谁来做决策？"></a>6.5 谁来做决策？</h2><p>下面给出一些在项目中可能发生的决策问题：</p><ol><li>如果个别用户，不能在需求方面达成一致的意见，那么必须由产品代表者作出决策。 </li><li>如果不同的用户类，有不一致的需求，那么必须决策出，满足哪一类用户的需求更为重要。</li><li>运用项目的业务目标来决定那些是你最核心的客户。</li><li>有时，客户经理所提出的需求与他所在部门的真正用户提出的需求相冲突。</li><li>当开发者想象中的产品与客户需求冲突时，通常应该由客户作出决策。</li><li>如果市场部门所提出的需求与开发者所想要开发的系统发生冲突时，具体情况，具体处理。</li><li>没有简单的正确答案。</li></ol><h2 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h2><h3 id="6-6-1-准备调查"><a href="#6-6-1-准备调查" class="headerlink" title="6.6.1 准备调查"></a>6.6.1 准备调查</h3><ol><li><p>首先，需求分析员应当起草需求调查问题表，将调查重点锁定在该问题表内，否则调查工作将变得漫无边际。</p><ul><li>问题表可以有多份，随着调查的深入，问题表将不断地被细化。</li><li>根据经验，用户通常没有耐心回答复杂的论述题，所以问题表应当以“选择题”和“是非题”为主。</li><li>制定问题表最简便的方法就是从《用户需求说明书》的模板中提取需求问题</li></ul></li><li><p>其次，需求分析员应当确定需求调查的方式，例如：</p><ul><li>与用户交谈，向用户提问题。</li><li>向用户群体发调查问卷。</li><li>参观用户的工作流程，观察用户的操作。</li><li>与同行、专家交谈，听取他们的意见。</li><li>分析已经存在的同类软件产品，提取需求。</li><li>从行业标准、规则中提取需求。</li><li>从Internet上搜查相关资料。</li></ul></li><li><p>最后，需求分析员与被调查者建立联系，确定调查的时间、地点、人员等，撰写需求调查计划。要特别留意的是不要漏掉典型的用户。</p></li></ol><h3 id="6-6-2-执行调查"><a href="#6-6-2-执行调查" class="headerlink" title="6.6.2 执行调查"></a>6.6.2 执行调查</h3><ol><li>准备工作完毕后，需求分析员按照计划执行调查。在调查过程中随时记录（或存储）需求信息 。</li><li>需求分析员与用户面谈时应当注意以下事项：<ul><li>如果与用户约好了时间，切勿迟到或早退。要注意礼节，尽可能获得用户的好感，并为下次打扰他们埋下伏笔。</li><li>需求分析员应事先了解用户的身份、背景，以便随机应变。IT人士不可貌相，有些大企业的领导其外表很土气。如果你路上碰到他，以为是个勤杂工，说：“喂，老师傅，来帮我拎东西。”也许这笔生意就泡汤了。</li></ul></li><li>需求调查，应该先了解宏观问题，再了解细节问题。</li><li>如果双方气氛融洽，可以采用灵活的访谈形式，轻易不要打断用户的谈话。当双方对某些问题的交流合乎逻辑地结束后，即可继续讨论问题表中的其它问题。</li><li>尽可能避免为用户添麻烦，但也不能怕给用户添麻烦而降低需求调查的力度。</li><li>避免片面地听取某些用户的需求而忽视其它用户的需求。</li></ol><h3 id="6-6-3-《用户需求说明书》与《软件需求规格说明书》的主要区别与联系"><a href="#6-6-3-《用户需求说明书》与《软件需求规格说明书》的主要区别与联系" class="headerlink" title="6.6.3 《用户需求说明书》与《软件需求规格说明书》的主要区别与联系"></a>6.6.3 《用户需求说明书》与《软件需求规格说明书》的主要区别与联系</h3><ol><li>前者主要采用自然语言（和应用域术语）来表达用户需求，其内容相对于后者而言比较粗略，不够详细。</li><li>后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求，产品需求是软件系统设计的直接依据。</li><li>两者之间可能并不存在一一影射关系，因为软件开发商会根据产品发展战略、企业当前状况适当地调整产品需求，例如用户需求可能被分配到软件的数个版本中。</li><li>软件开发人员应当依据《软件需求规格说明书》来开发当前产品。</li></ol><h1 id="7-聆听客户的需求"><a href="#7-聆听客户的需求" class="headerlink" title="7 聆听客户的需求"></a>7 聆听客户的需求</h1><p>需求获取是软件工程的核心任务，是在问题及其最终解决方案之间架设桥梁的第一步。 一旦理解了需求，分析者、开发者和客户就能探索出描述这些需求的多种解决方案。</p><h2 id="7-1-获取需求"><a href="#7-1-获取需求" class="headerlink" title="7.1 获取需求"></a>7.1 获取需求</h2><ol><li>需求获取在软件开发中，最重要、最关键，也是最困难、最易出错。</li><li>需求获取只有通过客户和开发者的合作，才能成功。它需要广泛的交流。为了方便清晰地进行交流，要列出的交流小组成员。</li><li>需求获取并不是客户所说的需求的简单誊本。</li><li>研究表明： <ul><li>一个成功的项目，在开发者和客户之间，采用了更多的交流方式。 </li><li>及早并经常进行座谈讨论，是需求获取成功的一个关键途径。</li></ul></li><li>需求获取的方式：面谈、小组讨论、解决冲突等</li></ol><h2 id="7-2-需求获取讨论会"><a href="#7-2-需求获取讨论会" class="headerlink" title="7.2 需求获取讨论会"></a>7.2 需求获取讨论会</h2><p>下列提示可用来指导有效的需求获取会议：</p><ol><li>建立基本规则</li><li>不超出范围——项目范围</li><li>使用活动挂图来捕获以后再考虑的一些，如：条目-停车场</li><li>时间盒讨论，为每一个讨论主题分配一个固定的时间段</li><li>保持较小的团队规模并找到合适的参与者</li><li>取保每个人都积极地参与讨论</li></ol><h2 id="7-3-将客户的意见归类"><a href="#7-3-将客户的意见归类" class="headerlink" title="7.3 将客户的意见归类"></a>7.3 将客户的意见归类</h2><p>用户给出需求不可能是一个简洁、完整、组织良好的需求清单。分析者必须把这些需求，分成不同的类型。这样就能合理地编写信息文档并把它们用最合适的方式表达。除以下情形之外，需求可分为9个类别。</p><p>不能归于9个类别的需求可能属于下列情形之一：</p><ol><li>与软件开发无关的需求。</li><li>项目所受的限制条件。</li><li>假设。</li><li>对数据的需求。</li><li>关于历史、背景或用于描述的附件信息。</li></ol><h3 id="7-3-1-业务需求"><a href="#7-3-1-业务需求" class="headerlink" title="7.3.1 业务需求"></a>7.3.1 业务需求</h3><ul><li>业务需求描述客户和开发组织希望从产品中获得的商业利益，如财务收入，市场份额等。</li></ul><h3 id="7-3-2-用例或场景"><a href="#7-3-2-用例或场景" class="headerlink" title="7.3.2 用例或场景"></a>7.3.2 用例或场景</h3><ul><li>用例是对用户目标或用户需要执行的业务工作的一般性描述。</li><li>使用场景则是某个用例的一条特定路径。</li></ul><h3 id="7-3-3-业务规则"><a href="#7-3-3-业务规则" class="headerlink" title="7.3.3 业务规则"></a>7.3.3 业务规则</h3><ul><li>有关业务过程的操作原则。</li></ul><h3 id="7-3-4-功能性需求"><a href="#7-3-4-功能性需求" class="headerlink" title="7.3.4 功能性需求"></a>7.3.4 功能性需求</h3><ul><li>功能性需求描述了系统在特定条件下表现得可观察的行为，以及系统允许用户执行的操作。</li></ul><h3 id="7-3-5-质量属性"><a href="#7-3-5-质量属性" class="headerlink" title="7.3.5 质量属性"></a>7.3.5 质量属性</h3><ul><li>质量属性是对系统实施某种行为时，或者让用户执行某种操作时，系统表现如何的陈述。</li></ul><h3 id="7-3-6-外部接口需求"><a href="#7-3-6-外部接口需求" class="headerlink" title="7.3.6 外部接口需求"></a>7.3.6 外部接口需求</h3><ul><li>这类需求描述了系统与外部世界的联系。</li></ul><h3 id="7-3-7-约束"><a href="#7-3-7-约束" class="headerlink" title="7.3.7 约束"></a>7.3.7 约束</h3><ul><li>对设计和实现的约束（constraint）合理地限制了开发人员可用地选择。</li></ul><h3 id="7-3-8-数据定义"><a href="#7-3-8-数据定义" class="headerlink" title="7.3.8 数据定义"></a>7.3.8 数据定义</h3><ul><li>当客户描述一个数据项或复杂的业务数据结构的格式、允许值或缺省值时，这种描述就是数据定义。</li></ul><h3 id="7-3-9-解决思路"><a href="#7-3-9-解决思路" class="headerlink" title="7.3.9 解决思路"></a>7.3.9 解决思路</h3><ul><li>很多被用户作为需求提出来的意见都属于解决思路，而非真正的需求。</li></ul><h2 id="7-4-需求获取中的注意事项"><a href="#7-4-需求获取中的注意事项" class="headerlink" title="7.4 需求获取中的注意事项"></a>7.4 需求获取中的注意事项</h2><ol><li>在需求获取的过程中，可能会发现以前的产品范围定义存在误差， 不是太大就是太小 。<ul><li>如果范围太大，此时获取过程，将会拖延。</li><li>如果范围太小，以致不能提供一个令人满意的产品</li></ul></li><li>需求的获取，应该把重点放在“做什么”。</li></ol><h2 id="7-5-寻找遗漏的需求"><a href="#7-5-寻找遗漏的需求" class="headerlink" title="7.5 寻找遗漏的需求"></a>7.5 寻找遗漏的需求</h2><p>在需求获取的过程中，遗漏的需求是不可避免的。应用下列方法可以发现遗漏的需求：</p><ol><li>将高层需求分解；</li><li>让用户类都提出意见；</li><li>跟踪系统的需求、用例、事件-响应表及业务规则等；</li><li>检查边界值，查找被遗漏的需求；</li><li>用多种方法表达需求信息；</li><li>应用CRUDL矩阵；</li></ol><p><img src="http://img.fdchen.host/%E7%94%A8%E4%BA%8E%E5%8C%96%E5%AD%A6%E5%93%81%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84CRUDL%E5%AE%9E%E4%BD%93%E7%94%A8%E4%BE%8B%E7%9F%A9%E9%98%B5.png" alt="用于化学品跟踪管理系统的CRUDL实体/用例矩阵"></p><center>图7-1 用于化学品跟踪管理系统的CRUDL实体/用例矩阵</center><h2 id="7-6-如何判断需求获取是否已完成"><a href="#7-6-如何判断需求获取是否已完成" class="headerlink" title="7.6 如何判断需求获取是否已完成"></a>7.6 如何判断需求获取是否已完成</h2><p>下列的提示，可能标志需求获取的过程完成：</p><ol><li>如果用户不能想出更多的使用实例，也许你就完成了收集需求的工作。</li><li>如果用户提出新的使用实例，但你可以从其它使用实例的相关功能需求中，获得这些新的使用实例，这时也许你就完成了收集需求的工作。</li><li>如果用户开始重复原先讨论过的问题，此时，也许你就完成了收集需求的工作。</li><li>如果所提出的新需求，比你已确定的需求的优先级都低时，也许你就完成了收集需求的工作。</li><li>如果用户提出对将来产品的要求，而不是现在我们讨论的特定产品，也许你就完成了收集需求的工作。</li></ol><h1 id="8-理解用户需求"><a href="#8-理解用户需求" class="headerlink" title="8 理解用户需求"></a>8 理解用户需求</h1><ul><li>需求分析员们一直利用使用场景（usage scenario）来获取需求。场景是对系统的单个使用实例的描述。这种以使用场景为中心的方法称为用例法。</li><li>实时系统经常使用的一种需求获取方法是列出系统必须响应的外部事件以及相应的系统响应。</li></ul><h2 id="8-1-用例法"><a href="#8-1-用例法" class="headerlink" title="8.1 用例法"></a>8.1 用例法</h2><h3 id="8-1-0-基本概念"><a href="#8-1-0-基本概念" class="headerlink" title="8.1.0 基本概念"></a>8.1.0 基本概念</h3><ul><li><strong>用例：</strong>描述了系统与外部角色之间的一系列交互。</li><li><strong>角色：</strong>指与系统交互以实现某种目的的人、软件系统或硬件设备。</li><li><strong>用例法的目标：</strong>描述用户需要通过系统执行的所有工作。</li><li><strong>用例图：</strong>提供了对用户需求的高级可视化表示。</li></ul><h3 id="8-1-1-用例与使用场景"><a href="#8-1-1-用例与使用场景" class="headerlink" title="8.1.1 用例与使用场景"></a>8.1.1 用例与使用场景</h3><ol><li>用例描述中的基本内容包括：<ul><li>唯一的标识</li><li>一个用例名，简要地说明用户的任务，采用“动词+对象”的形式，如“下订单”。</li><li>用自然语言书写的简短的文字描述。</li><li>一组<strong>前置条件</strong>，只有满足这些条件才能使用用例。</li><li><strong>后置条件</strong>，描述用例成功完成后的系统状态。</li><li>一组带编号的步骤，描述从前置条件到后置条件过程中，系统与角色间的一系列会话步骤与交互。</li></ul></li><li><strong>主干过程：</strong>每个用例都有一个场景被确定为时间的主干过程，也称为主过程、基本过程、普通流、主场景、主要的成功场景和快乐之路（happy path）。</li><li><strong>分支过程：</strong>用例中的其他有效场景则被描述为分支过程或次要场景。</li><li><strong>子用例：</strong>有时多个用例都包含一组相同的步骤。为了避免在每个用例中都重复这些步骤，可以定义一个单独的用例来包括这些相同的功能，然后由其他用例来包含这个子用例。</li><li><strong>异常：</strong>妨碍任务成功的条件被称为异常。如果在需求获取过程中未能描述如何处理异常，就可能有两种结果：<ul><li>开发者尽量准确地推测出如何处理这些异常。</li><li>当用户遇到出错条件时，系统会发生故障，因为不曾有人想到过这种可能。</li></ul></li><li>系统崩溃通常不在用户的需求列表中。异常有时候会被视为一种分支过程，但最好还是将他们区别开来。</li><li><strong>宏用例：</strong>用户可以将一系列用例串联成一个宏用例来描述大型的任务。</li></ol><h3 id="8-1-2-确定用例"><a href="#8-1-2-确定用例" class="headerlink" title="8.1.2 确定用例"></a>8.1.2 确定用例</h3><p>可采用以下几种方式确定用例：</p><ol><li>首先明确有哪些角色，然后确定他们各自参与了哪些业务过程。</li><li>确定哪些外部事件是系统必须响应的，将它们与参与的角色和特定用例关联起来。</li><li>用特定场景来描述业务过程，将这些场景归纳为用例，并确定每项用例设计哪些角色。</li><li>从已有的功能性需求推导出可能的用例。如果不能从某些功能性需求推到出任何用力，则要1考虑是否真正需要它们。</li></ol><h3 id="8-1-3-编写用例"><a href="#8-1-3-编写用例" class="headerlink" title="8.1.3 编写用例"></a>8.1.3 编写用例</h3><ol><li>基本用例是比具体用例更高一层的抽象。后者讨论用户与系统交互时采用的具体动作。举例：<ul><li>具体：输入化学药品的标识号。</li><li>基本：指定所需的化学品。</li></ul></li><li>明确用例边界：检查用例的描述时，必须确定前置条件和后置条件准确界定了用例的范围，即用例的前置条件必须在启动第一个步骤前就已经满足，最后一个步骤刚好满足后置条件。</li></ol><h3 id="8-1-4-用例与功能性需求"><a href="#8-1-4-用例与功能性需求" class="headerlink" title="8.1.4 用例与功能性需求"></a>8.1.4 用例与功能性需求</h3><ol><li><strong>功能性需求</strong>是让用户得以执行用例并达成目标的系统行为。</li><li><strong>用例</strong>是从角色的角度来描述系统行为，省略了很多细节。</li><li>要根据自己记录和管理项目软件需求的方式来选择最合适的方法。<ul><li><strong>只使用用例：</strong>一种可能的办法是把功能性需求包含在每个用例描述中，不过还是需要一个单独的补充说明来记录非功能性需求，以及所有不与特定用例相关的功能性需求。对于出现在多个用例中的需求，应该使用交叉引用而不是重复需求。</li><li><strong>用例与软件需求规格说明：</strong>还有一种方法是写一个相当简单的用例描述，同时把从用例中推导出的功能性需求记录在软件需求规格说明中。如果采用这种方法，你需要在用例与相关的功能性需求之间建立起可追溯关系。</li><li><strong>只使用软件需求规格说明：</strong>第三种方法是根据用例或特性来组织软件需求规格说明，并把用例和功能性需求都记录在软件需求规格说明中。这种方式不需单独的用例文档。但是需要标出重复的功能性需求，或者对每项功能性需求只声明一次，当该需求再次出现与其他用例中时，都引用最初的需求声明</li></ul></li></ol><h3 id="8-1-5-用例的好处"><a href="#8-1-5-用例的好处" class="headerlink" title="8.1.5 用例的好处"></a>8.1.5 用例的好处</h3><ul><li>用例能够帮助需求分析员和开发人员理解用户业务和应用领域。</li><li>根据用例法可推导出让用户能够执行某些已知任务的功能性需求，这有助于避免出现“孤立功能”，这类在需求获取过程中看似很好的功能其实并没人使用，因为它们与用户的任务没有直接关系。</li><li>用例法还有技术方面的好处，能够揭示重要的域对象，以及相互间的职责。</li></ul><h3 id="8-1-6使用用例时应避免的问题"><a href="#8-1-6使用用例时应避免的问题" class="headerlink" title="8.1.6使用用例时应避免的问题"></a>8.1.6使用用例时应避免的问题</h3><ol><li>用例过多</li><li>用例过于复杂</li><li>在用例中包含用户界面设计</li><li>在用例中包含数据定义</li><li>用户无法理解用例</li><li>尚不存在的新业务流程</li><li>滥用包含和扩充关系</li></ol><h2 id="8-2-事件-响应表"><a href="#8-2-事件-响应表" class="headerlink" title="8.2 事件-响应表"></a>8.2 事件-响应表</h2><ol><li>事件是在用户环境中发生的某种变化或活动，它能激发软件系统做出响应。</li><li>事件-响应表（也称为事件表或事件列表）列出了所有这类事件和系统应对每个事件做出的反应。</li><li>事件-响应表特别适用于实时控制系统。</li><li>事件-响应表记录的时用户-需求层的信息。</li><li>描述事件的要素属于要素级描述，描述实现的细节属于实现级的描述。</li></ol><h1 id="9-遵守规则"><a href="#9-遵守规则" class="headerlink" title="9 遵守规则"></a>9 遵守规则</h1><h2 id="9-1-业务的规则"><a href="#9-1-业务的规则" class="headerlink" title="9.1 业务的规则"></a>9.1 业务的规则</h2><ul><li>对业务的某个方面进行定义或约束的语句称为业务规则。</li></ul><h3 id="9-1-1-事件"><a href="#9-1-1-事件" class="headerlink" title="9.1.1 事件"></a>9.1.1 事件</h3><ul><li>是对业务的真实陈述，常常描述重要业务术语的关联。</li></ul><h3 id="9-1-2-约束"><a href="#9-1-2-约束" class="headerlink" title="9.1.2 约束"></a>9.1.2 约束</h3><ul><li>限制了系统或它的用户可以执行哪些操作。</li></ul><h3 id="9-1-3-动作触发规则"><a href="#9-1-3-动作触发规则" class="headerlink" title="9.1.3 动作触发规则"></a>9.1.3 动作触发规则</h3><ul><li>在特定条件下触发某个动作的规则。</li></ul><h3 id="9-1-4-计算"><a href="#9-1-4-计算" class="headerlink" title="9.1.4 计算"></a>9.1.4 计算</h3><ul><li>有一类业务规则定义使用特定数学公式或算法进行计算。</li></ul><h3 id="9-1-5-推论"><a href="#9-1-5-推论" class="headerlink" title="9.1.5 推论"></a>9.1.5 推论</h3><ul><li>是根据某个条件的真实性得出得出新事物的规则，也称为推导出的知识。</li></ul><h2 id="9-2-在文档中记录业务规则"><a href="#9-2-在文档中记录业务规则" class="headerlink" title="9.2 在文档中记录业务规则"></a>9.2 在文档中记录业务规则</h2><ul><li>业务规则会影响多个应用程序，必要时建立业务规则数据库。</li></ul><h2 id="9-3-业务规则与需求"><a href="#9-3-业务规则与需求" class="headerlink" title="9.3 业务规则与需求"></a>9.3 业务规则与需求</h2><ul><li>可以通过研讨会发现业务规则，通过从不同角度提问发现业务规则，如图9-1：</li></ul><p><img src="http://img.fdchen.host/%E9%80%9A%E8%BF%87%E4%BB%8E%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E6%8F%90%E9%97%AE%E5%8F%91%E7%8E%B0%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99.png" alt="通过从不同角度提问发现业务规则"></p><center>图9-1 通过从不同角度提问发现业务规则</center><h1 id="10编写需求文档"><a href="#10编写需求文档" class="headerlink" title="10编写需求文档"></a>10编写需求文档</h1><ul><li>需求开发的最终成果是：客户和开发小组对将要开发的产品，达成一致协议。这一协议综合了业务需求、用户需求和软件功能需求。而使用用例文档，则只包含了用户需求。必须应用文档把他们表示出来。即编写软件需求规格说明。</li><li>编写软件需求规格说明，有三种方法：<ul><li><strong>文档：</strong>用结构合理的自然语言来精心编写需求文档。</li><li><strong>图形化模型：</strong>这些模型可以描绘转换过程、系统状态和他们之间的变化、数据关系、逻辑流或者对象类及其关系。</li><li><strong>形式化规格说明：</strong>使用数学上精确的形式逻辑语言来定义需求。</li></ul></li></ul><h2 id="10-1-软件需求规格说明"><a href="#10-1-软件需求规格说明" class="headerlink" title="10.1 软件需求规格说明"></a>10.1 软件需求规格说明</h2><h3 id="10-1-0-基本概念"><a href="#10-1-0-基本概念" class="headerlink" title="10.1.0 基本概念"></a>10.1.0 基本概念</h3><ol><li>软件需求规格说明，有时也称为功能规格说明、产品规格说明、需求文档或系统规格说明。</li><li>软件需求规格说明精确地阐述了一个软件系统必须提供的功能和性能以及它必须遵守的约束。</li><li>软件需求规格说明是所有后续的项目规划、设计和编码的基础，也是系统测试和用户文档的基础。</li><li>必须去使用软件规格说明的受众有以下几类：<ul><li>客户、市场部和销售人员需要了解他们期望的得到什么样的产品。</li><li>项目经理根据产品描述来估计项目的进度、工作量和所需资源。</li><li>开发团队根据软件需求规格说明了解需要开发什么样的产品。</li><li>测试小组使用软件需求规格说明来开发测试计划、测试用例和测试过程。</li><li>软件维护和支持人员根据软件需求规格说明了解产品的每一部分的功能是什么。</li><li>文档编写人员根据软件需求规格说明和用户界面设计来编写用户手册和帮助屏幕。</li><li>培训人员根据软件规格说明和用户文档来编写培训材料。</li><li>公司律师要确保该需求遵守相应的法律法规。</li><li>分包商根据软件需求规格说明来进行工作，当然这要在合法的基础上。</li></ul></li><li>有关需求可读性的建议：<ul><li>对节、小节和单个需求的标记格式必须一致。</li><li>在右边部分留下文本注释区，而不要在两边全部写满。</li><li>允许不受限制地使用空白。</li><li>灵活明智地使用各种可视强调标志（例如，黑体、下划线、斜体和不同字体）。</li><li>创建目录表，也许还需要创建索引，这有助于读者找到他们所需要的信息。</li><li>对所有图和表及进行编号，并给出标题，根据编号来引用这些图和表。</li><li>使用字处理程序的交叉引用功能来引用文档中的其他位置，而不是通过页码或节号进行引用。</li><li>使用超链接使读者可以跳跃到软件需求规格说明或其他文档的相关部分。</li><li>引用合适的模板来组织所有的必要信息。</li></ul></li><li>软件需求规格说明的要求：<ul><li>作为产品需求的最终成果：<ul><li>必须具有综合性 </li><li>必须包括所有的需求</li></ul></li><li>如果任何所期望的功能或非功能需求，未写入软件需求规格说明，那么它将不能在产品中出现。</li><li>必须在开始设计和构造之前，编写出整个产品的软件需求规格说明。</li><li>针对每个需求的集合，必须有一个基准协议。<ul><li>基准：是指正在开发的软件需求规格说明，向已通过评审的软件需求规格说明的过渡过程。</li><li>必须通过项目中，所定义的变更控制过程，来更改基准软件需求规格说明。</li></ul></li></ul></li></ol><h2 id="10-1-1-需求的标识"><a href="#10-1-1-需求的标识" class="headerlink" title="10.1.1 需求的标识"></a>10.1.1 需求的标识</h2><ol><li>序列号：最简单的方法时赋予每个需求一个唯一的标识号，如UR-9或SRS-43。如果删除某个需求，则其序列号就不能再使用。这种方式并不能提供任何相关需求再逻辑上或层次上的信息，而且其标识也不能提供有关每个需求内容的信息。</li><li>层次型编号：如3.1.2等。这种方案不能产生永久性标识，一种改进是对需求中的主要部分进行层次性标号，然后用一个简短文本代码加上一个序列号来标识每个部分中的单个功能性需求。如：“3.5节——编辑功能”，那么这一节中的需求的编号可以是ED-1，ED-2等等。</li><li>层次型文本标签：基于文本的层次型标签方案，如一个需求为“当打印份数大于10份时必须让用户确认”，可标识为Print.ConfirmCopies。<ul><li>优点：具有一定含义，并且不受添加、删除或移动其他需求的影响。</li><li>缺点：比层次型数字编号更加复杂。</li></ul></li></ol><h3 id="10-1-2-处理不完整性"><a href="#10-1-2-处理不完整性" class="headerlink" title="10.1.2 处理不完整性"></a>10.1.2 处理不完整性</h3><ol><li>使用“待确定”（to be determined, TBD）符号来标记这些尚未确定的需求，</li><li>把每个TBD编号，并创建一个TBD列表，这有助于方便地跟踪每个项目。 </li><li>在构造需求集合之前，必须解决所有的TBD问题。如果有TBD问题尚未解决，而又要继续进行开发工作，那么尽可能推迟实现这些需求。</li></ol><h3 id="10-1-3-用户界面和软件需求规格说明"><a href="#10-1-3-用户界面和软件需求规格说明" class="headerlink" title="10.1.3 用户界面和软件需求规格说明"></a>10.1.3 用户界面和软件需求规格说明</h3><p>把用户界面的设计，编入软件需求规格说明。既有好处，也有坏处。</p><ol><li>积极方面：<ul><li>探索潜在的用户界面，有助于精化需求。</li><li>并使用户和系统的交互，对用户和开发人员更具有实在性。</li><li>用户界面的演示，也有助于项目计划的制定和预测。</li></ul></li><li>消极方面：<ul><li>屏幕映像和用户界面机制是解决方案（设计）的描述，而不是需求。</li><li>如果完成了用户界面的设计后,才能确定软件需求规格说明，那么需求开发的过程,将会花费很长的时间</li><li>这将会使那些只关心开发时间的经理、客户或开发人员失去耐心。</li></ul></li><li>一个合理的平衡点：在软件需求规格说明中，加入所选择的用户界面组件的概念映像草图，而在实<br>    现时，并不一定要精确地遵循这些方法。</li></ol><h2 id="10-2-软件需求规格说明模板"><a href="#10-2-软件需求规格说明模板" class="headerlink" title="10.2 软件需求规格说明模板"></a>10.2 软件需求规格说明模板</h2><p>在项目中,应采用标准的软件需求规格说明模板。可以根据项目的需要，来修改标准模板。如果模板中某一特定部分不适合你的项目，那么就在原处保留标题，并注明该项不适用。这将防止,认为是否遗漏了一些重要的部分。</p><ol><li><p>引言.<br>1.1 目的<br>1.2 文档约定<br>1.3 预期的读者和阅读建议<br>1.4 产品的范围<br>1.5 参考文献</p></li><li><p>综合描述<br>2.1 产品的前景<br>2.2 产品的功能<br>2.3 用户类和特征<br>2.4 运行环境<br>2.5 设计和实现上的限制<br>2.6 假设和依赖</p></li><li><p>外部接口需求<br>3.1 用户界面<br>3.2 硬件接口<br>3.3 软件接口<br>3.4 通信接口</p></li><li><p>系统特性<br>4.1 说明和优先级<br>4.2 激励&#x2F;响应序列<br>4.3 功能需求</p></li><li><p>其它非功能需求<br>5.1 性能需求<br>5.2 安全设施需求<br>5.3 安全性需求<br>5.4 软件质量属性<br>5.5 业务规则<br>5.6 用户文档</p></li><li><p>其它需求</p><p>附录A：词汇表<br>附录B：分析模型<br>附录C：待确定问题的列表</p></li></ol><p>每部分对应解释如下：</p><ul><li>引言：引言提出了对软件需求规格说明的纵览，有助于读者理解文档如何编写，且如何阅读和解释。</li><li>综合描述：概述了正在定义的产品以及它所运行的环境、使用产品的用户和已知的限制、假设和依赖。</li><li>外部接口需求：确定可以保证新产品与外部组件正确连接的需求。</li><li>系统特性：选择一种易于理解预期产品的组织方案。</li><li>其他非功能特性：列举出所有非功能需求，而不是外部接口需求和限制。</li><li>其他需求：定义在软件需求规格说明中的其它部分未出现的需求。例如：国际化需求或法律上的需求。</li><li>词汇表：定义所有必要的术语，以便读者可以正确地解释软件需求规格说明。包括：词头和缩写。</li><li>分析模型：包括或涉及到相关的分析模型的位置。例如：数据流程图、类图、状态转换图或实体-关系图。</li><li>待确定问题的列表：编辑一张在软件需求规格说明中待确定问题的列表，其中，每一表项都编上标号，以便于跟踪调查。</li></ul><h2 id="10-3-编写需求文档的原则"><a href="#10-3-编写需求文档的原则" class="headerlink" title="10.3 编写需求文档的原则"></a>10.3 编写需求文档的原则</h2><p>编写优秀的需求文档，没有固定的方法，一般是根据经验进行，应考虑一下几点：</p><ol><li>保持语句和段落的简短。</li><li>采用主动语态的表达方式。</li><li>编写具有正确的语法、拼写和标点的完整句子。</li><li>使用的术语与词汇表中所定义的应该一致。</li><li>需求陈述应该具有一致的样式。</li><li>减少不确定性，避免模糊的、主观的术语。</li><li>避免使用比较性的词汇。</li><li>需求文档，应使用有效的技术和用户术语，而不是计算机专业术语的方式，来编写。</li><li>由于需求的编写是层次化的，因此，可以把顶层不明确的需求，向低层详细分解，直到消除不明确性为止。但不要过于详细，而影响设计。</li><li>必须以相同的详细程度，编写每个需求文档。</li><li>不应该把多个需求集中在一个冗长的叙述段落中。</li><li>文档的编写人员，应考虑用最有效的方法表达每个需求。</li><li>软件需求规格说明中避免使用用有歧义的术语。</li></ol><h2 id="10-4-改进前后的需求"><a href="#10-4-改进前后的需求" class="headerlink" title="10.4 改进前后的需求"></a>10.4 改进前后的需求</h2><ul><li>重申高质量的需求特性：完整性、正确性、可行性、必要性、设定优先级、明确性和可验证性。</li><li>如果不具有这些特征，将会引起混淆，导致将来的返工。</li></ul><h2 id="10-5-数据字典"><a href="#10-5-数据字典" class="headerlink" title="10.5 数据字典"></a>10.5 数据字典</h2><ol><li>概念：定义应用程序中，使用的所有数据元素和结构的含义、类型、数据大小、格式、度量单位、精度以及允许取值范围的共享仓库。</li><li>好处：<ul><li>可以把不同的需求文档和分析模型紧密结合在一起。</li><li>如果所有的开发人员在数据字典上取得一致意见，那么就可以缓和集成性问题。而并不是在每个需求出现的地方定义每一个数据项。</li><li>数据字典的维护独立于软件需求规格说明，并且在产品的开发和维护的任何阶段，各个风险承担者都可以访问数据字典。</li><li>数据字典与数据流图配合，能清楚地表达数据处理的要求。</li></ul></li></ol><h1 id="11-需求的图形化分析"><a href="#11-需求的图形化分析" class="headerlink" title="11 需求的图形化分析"></a>11 需求的图形化分析</h1><p>软件系统中的图形化：</p><p><img src="http://img.fdchen.host/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96.png" alt="软件系统中的图形化"></p><center>图11-1 软件系统中的图形化</center><h2 id="11-1-需求建模"><a href="#11-1-需求建模" class="headerlink" title="11.1 需求建模"></a>11.1 需求建模</h2><ol><li>在需求分析方面或设计方面，是否使用模型取决于建模的目的。在需求开发中通过建立模型有利于理解需求</li><li>模型：描述了问题域的逻辑方面。如：数据组成、事务和转换、现实世界对象和允许的状态等。 方便了项目参与者在系统的某些方面的交流。</li><li>没有一种单一的需求视图能够提供对需求的全面理解，必须在需求中综合使用文本和图形表示法来完整地描述所需的系统。</li><li>分析模型应该补充完善用自然语言编写的需求规格说明，而不是替换它。</li><li>重复是系统建模成功的关键所在。</li></ol><h2 id="11-2-从客户需求到分析模型"><a href="#11-2-从客户需求到分析模型" class="headerlink" title="11.2 从客户需求到分析模型"></a>11.2 从客户需求到分析模型</h2><ol><li>通过认真听取客户如何陈述它们的需求，分析者可以挑选出关键字。这些关键字可以翻译成特定的分析模型元素。</li><li>当把客户输入转变为书面的需求或模型时，还可以根据模型的每个组件回溯到需求部分。</li></ol><h2 id="11-3-数据流图（Data-Flow-Diagram）"><a href="#11-3-数据流图（Data-Flow-Diagram）" class="headerlink" title="11.3 数据流图（Data Flow Diagram）"></a>11.3 数据流图（Data Flow Diagram）</h2><h3 id="11-3-1-基本概念"><a href="#11-3-1-基本概念" class="headerlink" title="11.3.1 基本概念"></a>11.3.1 基本概念</h3><ol><li>是结构化系统分析的基本工具。</li><li>确定了系统的转化过程、系统所操纵的数据或物质的存储。</li><li>可以在一个抽象的广泛范围内表示系统。</li><li>是分层次的，高层数据流图提供一个整体的统览，是对软件需求规格说明的精确、详细叙述的补充。</li><li>描述了功能需求怎样和使用户相结合</li><li>反馈的信息，有助于理解所探讨的任务流，进行提炼加工。</li></ol><h3 id="11-3-2-基本DFD标识符"><a href="#11-3-2-基本DFD标识符" class="headerlink" title="11.3.2 基本DFD标识符"></a>11.3.2 基本DFD标识符</h3><ul><li>矩形用于表示外部实体</li><li>圆表示应用于数据或控件的过程或转换</li><li>箭头表示数据流方向</li><li>平行线表示数据存储</li></ul><h3 id="11-3-3-示例"><a href="#11-3-3-示例" class="headerlink" title="11.3.3 示例"></a>11.3.3 示例</h3><p><img src="http://img.fdchen.host/DFD%E7%A4%BA%E4%BE%8B.png" alt="DFD示例"></p><center>图11-2 DFD示例</center><h2 id="11-4-实体-联系图（Entity-Relationship-Diagram）"><a href="#11-4-实体-联系图（Entity-Relationship-Diagram）" class="headerlink" title="11.4 实体-联系图（Entity-Relationship Diagram）"></a>11.4 实体-联系图（Entity-Relationship Diagram）</h2><h3 id="11-4-1-基本概念"><a href="#11-4-1-基本概念" class="headerlink" title="11.4.1 基本概念"></a>11.4.1 基本概念</h3><ol><li>实体联系图：<ul><li>描绘了系统的数据关系；</li><li>有助于对业务或系统数据组成的理解和交互；</li><li>用一个实体联系图和一个数据字典，来记录数据关系，可以为新的业务过程，提供一个数据组成的概念性框架。</li></ul></li></ol><h3 id="11-4-2-基本ERD元素"><a href="#11-4-2-基本ERD元素" class="headerlink" title="11.4.2 基本ERD元素"></a>11.4.2 基本ERD元素</h3><ul><li><strong>实体</strong>用单名词来命名。用矩形框表示。</li><li>每个实体要用几个<strong>属性</strong>来描述，每个实体的单个实例具有不同的属性值。</li><li><strong>关系</strong>用能描述关系的本质来命名，它确定了一对实体之间在逻辑上和数量上的连接。用菱形框表示。</li></ul><h3 id="11-4-5-示例"><a href="#11-4-5-示例" class="headerlink" title="11.4.5 示例"></a>11.4.5 示例</h3><p><img src="http://img.fdchen.host/ERD%E7%A4%BA%E4%BE%8B.png" alt="ERD示例"></p><center>图11-2 ERD示例</center><h3 id="11-5-状态转换图（State-Transition-Diagram）"><a href="#11-5-状态转换图（State-Transition-Diagram）" class="headerlink" title="11.5 状态转换图（State-Transition Diagram）"></a>11.5 状态转换图（State-Transition Diagram）</h3><h3 id="11-5-1-基本概念"><a href="#11-5-1-基本概念" class="headerlink" title="11.5.1 基本概念"></a>11.5.1 基本概念</h3><ol><li>状态转换图：<ul><li>为状态提供了一个简洁、完整、无二义性的表示。</li><li>表示处理结果可能的状态转换。对于软件系统中只能存在于特定状态的那一部分，可以使用状态转换图来建模。</li><li>有助于开发者理解系统的预期行为。<ul><li>测试者：可以从转换路径的状态转换图中获得测试用例。</li><li>用户：只要稍微学一些符号就可以读懂状态转换图。</li></ul></li></ul></li></ol><h3 id="11-5-2-基本STD元素"><a href="#11-5-2-基本STD元素" class="headerlink" title="11.5.2 基本STD元素"></a>11.5.2 基本STD元素</h3><p><img src="http://img.fdchen.host/STD%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0.png" alt="STD基本元素"></p><center>图11-3 基本STD元素</center><h3 id="11-5-3-示例"><a href="#11-5-3-示例" class="headerlink" title="11.5.3 示例"></a>11.5.3 示例</h3><p><img src="http://img.fdchen.host/STD%E7%A4%BA%E4%BE%8B.png" alt="STD示例"></p><center>图11-4 STD示例</center><h2 id="11-6-对话图（Dialog-Map）"><a href="#11-6-对话图（Dialog-Map）" class="headerlink" title="11.6 对话图（Dialog Map）"></a>11.6 对话图（Dialog Map）</h2><h3 id="11-6-1-基本概念"><a href="#11-6-1-基本概念" class="headerlink" title="11.6.1 基本概念"></a>11.6.1 基本概念</h3><ol><li>对话图（dialog map）：一种状态转换图。</li><li>对话图在较高的抽象层次上表示用户界面的设计，它展示了系统的对话元素及这些元素之间的导航连接，但没有展示详细的屏幕设计。</li><li>在对话图中将每个对话元素表示为一个状态（用矩形框表示），将每个允许的导航选项表示为一个转换（用箭头表示）。触发用户界面导航的条件表示为转换箭头上的文本标签。</li><li>对话图是表示用例中所描述的参与者与系统之间的交互的很好的方法。</li></ol><h3 id="11-6-2-示例"><a href="#11-6-2-示例" class="headerlink" title="11.6.2 示例"></a>11.6.2 示例</h3><p><img src="http://img.fdchen.host/DM%E7%A4%BA%E4%BE%8B.png" alt="DM示例"></p><center>图11-5 DM示例</center><h2 id="11-7-类图（Class-Diagram）"><a href="#11-7-类图（Class-Diagram）" class="headerlink" title="11.7 类图（Class Diagram）"></a>11.7 类图（Class Diagram）</h2><h3 id="11-7-1-基本概念"><a href="#11-7-1-基本概念" class="headerlink" title="11.7.1 基本概念"></a>11.7.1 基本概念</h3><ol><li>类图(class diagram)是用图形方式叙述面向对象分析所确定的类以及它们之间的关系。</li><li>利用面向对象方法开发的产品并不需要特殊的需求开发方法。这是因为需求开发强调用户需要系统做什么以及系统所应包含的功能，而并不关心系统如何做。</li><li>当考虑如何将问题域对象映射到系统对象，并进一步细化每个类的属性和操作时，面向对象技术可以方便需求开发到设计阶段的转换。</li></ol><h3 id="11-7-2-示例"><a href="#11-7-2-示例" class="headerlink" title="11.7.2 示例"></a>11.7.2 示例</h3><p><img src="http://img.fdchen.host/CD%E7%A4%BA%E4%BE%8B.png" alt="CD示例"></p><center>图11-6 CD示例</center><h2 id="11-8-决策表和决策树"><a href="#11-8-决策表和决策树" class="headerlink" title="11.8 决策表和决策树"></a>11.8 决策表和决策树</h2><h3 id="11-8-1-基本概念"><a href="#11-8-1-基本概念" class="headerlink" title="11.8.1 基本概念"></a>11.8.1 基本概念</h3><ol><li>决策表：应用表格的形式进行需求表达。判定表可列出影响系统行为的所有因素的各种取值，并表明对这些因素的每一种组合所期望的系统响应动作。</li><li>决策树：采用一种树形结构表达需求。用树形结构表示动作的各种分支。</li></ol><h3 id="11-8-2-示例"><a href="#11-8-2-示例" class="headerlink" title="11.8.2 示例"></a>11.8.2 示例</h3><ol><li>决策表示例</li></ol><p><img src="http://img.fdchen.host/%E5%86%B3%E7%AD%96%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="决策表示例"></p><center>图11-7 决策表示例</center><p>说明：</p><ul><li>第一行数字表示可能存在的各种需求，包括多种可能性，可以去掉一些不必要可能性，比如当前面行的条件无法满足时，后面行的条件可能无关紧要，此时后面行的可以用“-”表示。</li><li>“T”和“F”表示是否满足对应行的条件。</li><li>“X”表示动作入口，表示当列需求（条件）下系统采取的动作。</li></ul><ol start="2"><li>决策树示例</li></ol><p><img src="http://img.fdchen.host/%E5%86%B3%E7%AD%96%E6%A0%91%E7%A4%BA%E4%BE%8B.png" alt="决策树示例"></p><center>图11-8 决策树示例</center><h2 id="11-9-最后的提醒"><a href="#11-9-最后的提醒" class="headerlink" title="11.9 最后的提醒"></a>11.9 最后的提醒</h2><ol><li>所述的每一种建模都有其优点和局限性。</li><li>牢记，创建的分析模型可以提供对需求理解和通信的一个等级，而这却是文本方式下的软件需求规格说明和其它单一的表示法所不能提供的。</li><li>应该避免陷入在软件开发方法和模型中发生的教条的思维模式。</li></ol><h1 id="12-软件质量属性"><a href="#12-软件质量属性" class="headerlink" title="12 软件质量属性"></a>12 软件质量属性</h1><h2 id="12-0-基本概念"><a href="#12-0-基本概念" class="headerlink" title="12.0 基本概念"></a>12.0 基本概念</h2><ol><li>软件质量属性或质量引述是系统非功能性需求的一部分。</li><li>非功能需求(none-functional requirements)：描述系统展现给用户的行为和执行的操作等。包括:<ul><li>产品必须遵循的标准、规范和合约</li><li>外部界面的具体细节</li><li>性能要求</li><li>设计或实现的约束条件等</li></ul></li><li>质量属性通过多种角度对产品的特点进行描述，从而反映产品功能。</li><li>根据不同的设计，可把质量属性分类：<ul><li>一种方法是把在运行时，可识别的特性与那些不可识别的特性区分开。</li><li>另一种方法，是把对用户很重要的可见特性与对开发者和维护者很重要的不可见特性区分开。</li></ul></li><li>对开发者具有重要意义的属性有：使产品易于更改、验证，并易于移植到新的平台上，从而可以间接地满足客户需要的属性。</li></ol><h2 id="12-1-软件质量属性"><a href="#12-1-软件质量属性" class="headerlink" title="12.1 软件质量属性"></a>12.1 软件质量属性</h2><p>如表12-1，分两类描述每个项目都要考虑的一些质量属性：</p><center>表12-1 软件质量属性</center><table><thead><tr><th>主要对用户重要的属性</th><th>主要对开发人员重要的属性</th></tr></thead><tbody><tr><td>可用性<br />有效性<br />灵活性<br />完整性<br />互操作性<br />可靠性<br />健壮性<br />易用性</td><td>可维护性<br />可移植性<br />可重用性<br />可测试性</td></tr></tbody></table><h2 id="12-2-定义质量属性"><a href="#12-2-定义质量属性" class="headerlink" title="12.2 定义质量属性"></a>12.2 定义质量属性</h2><p>必须根据用户对系统的期望，来确定质量属性。分析员根据每一个属性设计出许多问题。利用这些问题询问每一个用户类的代表，可以把每个属性分成：一级（不必多加考虑的属性）到五级（极其重要的属性）。这些问题的回答有助于分析员决定哪些质量特性是最重要的。然后，分析员与用户一起，为每一属性确定需求。</p><h3 id="12-2-1-对用户重要的属性（理解）"><a href="#12-2-1-对用户重要的属性（理解）" class="headerlink" title="12.2.1 对用户重要的属性（理解）"></a>12.2.1 对用户重要的属性（理解）</h3><ol><li>可用性</li></ol><ul><li>系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。更正式地说，可用性等于系统的平均无故障时间（MTTF）除以平均无故障时间（MTTF）与故障修复时间（MTTR）之和。</li></ul><ol start="2"><li>有效性</li></ol><ul><li>用来衡量系统如何优化处理器、磁盘空间或通信带宽的。</li></ul><ol start="3"><li>灵活性</li></ol><ul><li>表明了在产品中，增加新功能时，所需工作量的大小。</li><li>对于通过一系列连续的发行版本，并采用渐增型和重复型方式开发的产品是很重要的。</li></ul><ol start="4"><li>完整性</li></ol><ul><li>主要涉及防止非法访问系统功能、防止数据丢失、防止病毒入侵，并防止私人数据进入系统。即数据和访问，必须通过特定的方法完全保护起来。</li></ul><ol start="5"><li>互操作性</li></ol><ul><li>表明了产品与其它系统交换数据和服务的难易程度。</li></ul><ol start="6"><li>可靠性</li></ol><ul><li>软件无故障执行一段时间的概率。</li><li>健壮性和有效性有时可看成是可靠性的一部分。</li></ul><ol start="7"><li>健壮性</li></ol><ul><li>指当系统或其组成部分遇到非法输入数据、相关软件或硬件组成部分的缺陷或异常的操作情况时，能继续正确运行功能的程度。</li><li>健壮的软件，可以从发生问题的环境中完好地恢复，并且可容忍用户的错误。</li></ul><ol start="8"><li>易用性</li></ol><ul><li>它所描述的是许多组成“用户友好”的因素。</li><li>衡量准备输入、操作和理解产品输出所花费的努力。</li><li>还包括对于新用户或不常使用产品的用户在学习使用产品时的难易程度。</li></ul><h3 id="12-2-2-对于开发人员重要的属性（理解）"><a href="#12-2-2-对于开发人员重要的属性（理解）" class="headerlink" title="12.2.2 对于开发人员重要的属性（理解）"></a>12.2.2 对于开发人员重要的属性（理解）</h3><ol><li>可维护性</li></ol><ul><li>表明了在软件中纠正一个缺陷或做一次更改的难易程度。</li><li>取决于理解软件、更改软件和测试软件的难易程度。</li></ul><ol start="2"><li>可移植性</li></ol><ul><li>度量把一个软件从一种运行环境转移到另一种运行环境中所花费的工作量。</li><li>对于工程的成功是不重要的。</li></ul><ol start="3"><li>可重用性</li></ol><ul><li>表明了一个软件组件，除了在最初开发的系统中使用之外，还可以在其它应用程序中使用的程度。</li><li>开发可重用软件的费用会更大些。</li></ul><ol start="4"><li>可测试性</li></ol><ul><li>指的是测试软件组件或集成产品时查找缺陷的难易程度。</li></ul><h2 id="12-3-性能需求"><a href="#12-3-性能需求" class="headerlink" title="12.3 性能需求"></a>12.3 性能需求</h2><ul><li>定义了系统必须多好和多快的完成专门的功能。包括：速度、吞吐量、处理能力、定时……</li></ul><h2 id="12-4-属性的折中方案"><a href="#12-4-属性的折中方案" class="headerlink" title="12.4 属性的折中方案"></a>12.4 属性的折中方案</h2><ul><li>为了达到产品特性的最佳平衡，必须在需求获取阶段识别、确定相关的质量属性，并且为之确定优先级。</li></ul><h1 id="13-通过原型法减少项目风险"><a href="#13-通过原型法减少项目风险" class="headerlink" title="13 通过原型法减少项目风险"></a>13 通过原型法减少项目风险</h1><h2 id="13-1-什么是原型和为什么要建立原型"><a href="#13-1-什么是原型和为什么要建立原型" class="headerlink" title="13.1 什么是原型和为什么要建立原型"></a>13.1 什么是原型和为什么要建立原型</h2><h3 id="13-1-1-原型的概念"><a href="#13-1-1-原型的概念" class="headerlink" title="13.1.1 原型的概念"></a>13.1.1 原型的概念</h3><ul><li>一个软件原型是所提出的新产品的部分实现。</li></ul><h3 id="13-1-2-建立原型的主要目的"><a href="#13-1-2-建立原型的主要目的" class="headerlink" title="13.1.2 建立原型的主要目的"></a>13.1.2 建立原型的主要目的</h3><ul><li>明确并完善需求</li><li>探索设计选择方案</li><li>发展为最终的产品</li></ul><h3 id="13-1-3-建立原型的主要原因"><a href="#13-1-3-建立原型的主要原因" class="headerlink" title="13.1.3 建立原型的主要原因"></a>13.1.3 建立原型的主要原因</h3><ul><li>是为了解决在产品开发的早期阶段不确定和二义性的问题。不确定和二义性的问题，使开发者对产品产生困惑。建立一个原型，有助于说明和纠正它们。原型，可以使问题更具体化。</li></ul><h2 id="13-2-水平原型"><a href="#13-2-水平原型" class="headerlink" title="13.2 水平原型"></a>13.2 水平原型</h2><ul><li><p>水平原型，也叫“行为原型”或“演示性模型” 。水平原型显示出用户界面的正面像，但是它仅包含少量的功能，并没有真正实现所有的功能，不深入到体系结构的所有层次。</p></li><li><p>水平原型，可以使用户判断是否有遗漏、  错误或不必要的功能。可以使用不同的屏幕设计工具或甚至使用纸和铅笔来建立水平原型。</p></li></ul><h2 id="13-3-垂直原型"><a href="#13-3-垂直原型" class="headerlink" title="13.3 垂直原型"></a>13.3 垂直原型</h2><ul><li><p>垂直原型，也叫“结构化原型”或“概念性模型”。它实现了一部分应用功能，主要在技术服务层次上实现应用程序用户界面的一部分功能，它触及到了系统实现的所有层次。</p></li><li><p>当不能确信所提出的构造软件的方法是否完善或者当需要优化算法，评价一个数据库的图表或测试临界时间需求时，就要开发一个垂直原型。</p></li></ul><h2 id="13-4-抛弃性原型"><a href="#13-4-抛弃性原型" class="headerlink" title="13.4 抛弃性原型"></a>13.4 抛弃性原型</h2><ul><li>在原型达到预期目的以后，将它抛弃，所以，可以花最小的代价，尽快地建立该原型。</li><li>抛弃型原型，忽略了很多具体的软件构造技术。不能将抛弃型原型中的代码，移植到产品系统中。否则，将在软件生存期中遭遇种种麻烦。</li><li>当遇到需求中的不确定性、二义性、不完整性或含糊性时。最合适的方法，是建立抛弃型原型。<ul><li>原型，可帮助用户和开发者想象如何实现需求和发现需求中的漏洞。</li><li>原型，还可以使用户判断出需求是否可以完成必要的业务过程。</li></ul></li></ul><h2 id="13-5-演化型原型"><a href="#13-5-演化型原型" class="headerlink" title="13.5 演化型原型"></a>13.5 演化型原型</h2><ul><li>演化型原型是螺旋式软件开发生命周期模型和某些面向对象软件开发过程的一个组成部分。</li><li>在已经清楚地定义了需求的情况下，进化型原型为产品提供了坚实的构造基础。</li><li>进化式模型，一开始就必须具有健壮性和产品质量级的代码。</li><li>建立进化型原型比建立抛弃型原型所花的时间要多。</li><li>一个进化型原型必须设计为易于升级和优化的。</li><li>从测试和首次使用中获得的信息，将引起下一次软件原型的更新，正是这样不断增长并更新，使软件才能从一系列进化型原型，发展为实现最终完整的产品。</li><li>这种原型提供了快速获得有用功能的方法。</li><li>软件原型的典型应用，如图13-1：</li></ul><p><img src="http://img.fdchen.host/%E8%BD%AF%E4%BB%B6%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8.png" alt="软件原型的典型应用"></p><center>图13-1 软件原型的典型应用</center><h2 id="13-6-书面和电子原型"><a href="#13-6-书面和电子原型" class="headerlink" title="13.6 书面和电子原型"></a>13.6 书面和电子原型</h2><ul><li>书面原型和电子原型：用平面工具把系统是如何实现的呈现在用户面前。</li></ul><h3 id="13-6-1-书面原型"><a href="#13-6-1-书面原型" class="headerlink" title="13.6.1 书面原型"></a>13.6.1 书面原型</h3><ol><li>是一种廉价、快速，并且不涉及高技术的方法。它可以把一个系统某部分，是如何实现的呈现在用户面前。</li><li>有助于判断用户和开发者，在需求上是否达成共识。可以使在开发产品代码前，对各种可能的解决方案进行试验性的尝试。</li><li>使用的工具：是纸张、索引卡、粘贴纸、塑料板、白板和标记器。在书面原型中，一个人可以充当计算机的角色。即模仿计算机的人，就会把关于显示方面的纸张和索引卡给用户看。</li><li>方便了原型的快速反复性，而在需求开发中反复性是一个关键的成功因素。对于精化需求，是一种优秀的技术。</li></ol><h3 id="13-6-2-电子原型"><a href="#13-6-2-电子原型" class="headerlink" title="13.6.2 电子原型"></a>13.6.2 电子原型</h3><ol><li>如果决定建立一个电子抛弃型原型，那么就有许多工具可以使用。这些工具包括：<ul><li>编程语言</li><li>脚本语言</li><li>商品化的建立原型的工具包、屏幕绘图器和图形用户界面构筑师。</li></ul></li></ol><h2 id="13-7-原型的评估"><a href="#13-7-原型的评估" class="headerlink" title="13.7 原型的评估"></a>13.7 原型的评估</h2><p>在原型评价时，可以提供一些相关的问题：</p><ul><li>这个原型所实现功能与你所期望的一致吗？</li><li>有遗漏的功能吗？</li><li>你能考虑一下这个原型所没涉及的一些出错情况吗？</li><li>有多余的功能吗？</li><li>这些导航对于你意味着怎样的逻辑性和完整性？</li><li>有更简单的方法来完成这一任务吗？</li></ul><h2 id="13-8-创建原型所带来的风险"><a href="#13-8-创建原型所带来的风险" class="headerlink" title="13.8 创建原型所带来的风险"></a>13.8 创建原型所带来的风险</h2><h3 id="13-8-1-风险"><a href="#13-8-1-风险" class="headerlink" title="13.8.1 风险"></a>13.8.1 风险</h3><ul><li>最大的风险是用户或者经理看到一个正在运行的原型，从而以为产品即将完成。</li><li>决不能把抛弃型原型，当作可交付的产品。</li></ul><h2 id="13-8-2-控制风险"><a href="#13-8-2-控制风险" class="headerlink" title="13.8.2 控制风险"></a>13.8.2 控制风险</h2><ol><li>一种方法利用书面原型，而不是电子原型。</li><li>另一种方法是使用不同于在真正开发时所用的原型法工具。这将有助于理解原型开发，并把它当作产品模型。</li></ol><h2 id="13-9-原型法成功的因素"><a href="#13-9-原型法成功的因素" class="headerlink" title="13.9 原型法成功的因素"></a>13.9 原型法成功的因素</h2><p>建立有效的原型，应遵循如下原则：</p><ol><li>在项目计划中，应包括原型风险。</li><li>计划开发多个原型，因为你很少能一次成功。</li><li>尽快并且廉价地建立抛弃型原型。</li><li>在抛弃型原型中，不应含有：代码注释、输入数据有效性检查、保护性编码技术，或者错误处理的代码。</li><li>对于已经理解的需求，不要建立原型。</li><li>不能随意地增加功能。</li><li>不要从水平原型的性能推测最终产品的性能。</li><li>在原型屏幕显示和报表中，使用合理的模拟数据。</li><li>不要期望原型可以代替需求文档。</li></ol><h1 id="14-设定需求优先级"><a href="#14-设定需求优先级" class="headerlink" title="14 设定需求优先级"></a>14 设定需求优先级</h1><h2 id="14-1-为什么设定需求优先级"><a href="#14-1-为什么设定需求优先级" class="headerlink" title="14.1 为什么设定需求优先级"></a>14.1 为什么设定需求优先级</h2><ul><li><p>尽早确定产品应具备的最重要功能。</p></li><li><p>权衡合理的项目范围和进度安排、预算以及质量目标的约束，以最少的费用提供产品的最大功能。</p></li></ul><h2 id="14-2-设定优先级的规则"><a href="#14-2-设定优先级的规则" class="headerlink" title="14.2 设定优先级的规则"></a>14.2 设定优先级的规则</h2><p>项目经理必须权衡合理的项目范围和进度安排、预算、人力资源以及质量目标的约束。把高优先级的需求放在前面，把低优先级的需求推迟到下一版本中去实现或者删除它们。</p><h2 id="14-3-设定优先级的等级"><a href="#14-3-设定优先级的等级" class="headerlink" title="14.3 设定优先级的等级"></a>14.3 设定优先级的等级</h2><p>设定优先级的一般方法是：把需求分成三类：高、中、低。如表14-1描述了需求的4种可能性。</p><center>表14-1 根据重要性和紧迫性来设定需求优先级</center><table><thead><tr><th></th><th>重要</th><th>不重要</th></tr></thead><tbody><tr><td>紧迫</td><td>高优先级</td><td>低优先级</td></tr><tr><td>不紧迫</td><td>中优先级</td><td>低优先级</td></tr></tbody></table><h2 id="14-4-根据价值、成本和风险来设定优先级"><a href="#14-4-根据价值、成本和风险来设定优先级" class="headerlink" title="14.4 根据价值、成本和风险来设定优先级"></a>14.4 根据价值、成本和风险来设定优先级</h2><h3 id="14-4-1-设定优先级过程中的参与者有："><a href="#14-4-1-设定优先级过程中的参与者有：" class="headerlink" title="14.4.1 设定优先级过程中的参与者有："></a>14.4.1 设定优先级过程中的参与者有：</h3><ol><li>项目经理：他指导全过程，解决冲突，并且在必要的时候调整其它参与者的方案。</li><li>重要的客户代表：例如：产品的代言人，他可以提供受益和损失程度。</li><li>开发者代表：例如：开发组的技术指导者，他提供了费用和风险程度。</li></ol><h2 id="14-4-2-优先级设定的步骤"><a href="#14-4-2-优先级设定的步骤" class="headerlink" title="14.4.2 优先级设定的步骤"></a>14.4.2 优先级设定的步骤</h2><ol><li><p>列出要设定优先级的所有需求、特性或使用实例；</p><ul><li>所有项都必须在同一抽象级别上；</li><li>如果某些特性有逻辑上的联系，在分析中只要列出驱动较全面的项。</li><li>如果有更多的项，那么就把相关的特性归成一类，并建立一个可管理的初始化列表。</li><li>如果需要的话，可以在更详细的级别上进行第二轮分析。</li></ul></li><li><p>估计每一个特性提供给客户或业务的相关利益，并用1～9划分等级，1代表可忽略的利益，9代表最大的价值。</p><ul><li>这些利益等级表明了与产品的业务需求的一致性。</li><li>由客户代表来判断这些利益的优先级。</li></ul></li><li><p>估计出如果没有把应该实现的特性包括到产品中，将会给客户或业务上带来的损失。使用1 ～ 9划分等级。1代表基本无损失，9代表严重损失。</p><ul><li>注意：对于具有低利润低损失的需求只会增加费用，而不会增加价值。</li></ul></li><li><p>总价值栏是相对利润和相对损失的总和。总价值&#x3D; 相对利益*利益权值+ 相对损失*损失权值。</p><ul><li>作为一种精化，可以更改这两个因素的相对权值。</li></ul></li><li><p>估计实现每个特性的相对费用，使用1（低）～9（高）划分等级。</p><ul><li>计算出由每一个特性所构成的总费用的百分比。</li><li>根据需求的复杂度，所需求的用户界面的实现情况、所需要的测试量和文档等，开发者可以估算出费用。</li></ul></li><li><p>开发者要估计出与每个特性相关的技术或风险相对程度，并利用1～9划分等级。1级表示可以轻而易举地实现编程，而9级表示需要极大努力实现编程或者使用不成熟或不熟悉的工具和技术。</p><ul><li>计算出每个特性所产生的风险百分比。</li><li>在一般情况下，利润损失，费用和风险的权值是相等的，但是可以调整其权值。</li><li>如果无需在模型中考虑风险，就把风险的权值设为0</li></ul></li><li><p>一旦把所有的估算写入平面图，就可以利用如下公式计算出每一特性的优先级：</p></li></ol><p><img src="http://img.fdchen.host/%E9%9C%80%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="需求优先级计算公式"></p><center>图14-1 需求优先级计算公式</center><ol start="8"><li>按计算出的优先级的降序排列表中的特性。<ul><li>处于列表最顶端的特性，必须具有最高优先级。</li><li>计算出来的优先级序列，只能作为一种指导策略的参考。</li><li>客户和开发者代表应该讨论，从而达成共识。并根据使用情况来校正。</li><li>可以适当调整每一因素的权值，直到所计算出的优先级序列与后来对测试集中需求的重要性评估相吻合为止。</li><li>评估这些需求的优先级，以指明它们与现存的需求之间的一致性。</li><li>在把需求优先级的设定，应以客观和分析为基础。</li></ul></li></ol><ul><li>如图14-2，化学品跟踪系统优先级计算示例：</li></ul><p><img src="http://img.fdchen.host/%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B.png" alt="优先级计算示例"></p><center>图14-2 优先级计算示例</center><h1 id="15-需求确认"><a href="#15-需求确认" class="headerlink" title="15 需求确认"></a>15 需求确认</h1><h2 id="15-0-基本概念"><a href="#15-0-基本概念" class="headerlink" title="15.0 基本概念"></a>15.0 基本概念</h2><ol><li>需求确认是指开发方和客户方共同对《产品需求规格说明书》进行评审，双方对需求达成共识后作出承诺。</li><li>需求确认包含两个重要工作：“需求评审”和“需求承诺”。</li><li>需求评审面临的困难：<ul><li>需求评审的一个通病是“虎头蛇尾”。需求评审的确乏味，也比较费脑子。刚开始评审时，大家都比较认真，越到后头越马虎。</li><li>需求评审涉及的人员可能比较多，有些时候让这么多人聚在一起花费比较长的时间开会并不容易。</li><li>需求评审也可以分段进行。这样每次评审的时间比较短，参加评审的人员也少一些，组织会议就比较容易。</li></ul></li><li>评审会议：<ul><li>开评审会议时经常会“跑题”，导致评审效率很低。有时话匣子一打开后关不上，大家越扯越远，结果评审会议变成了聊天会议。</li><li>主持人应当控制话题，避免大家讨论与主题无关的东西。</li><li>开评审会议时经常会发生争议。适当的争议有利于澄清问题，比什么东西都一致赞成要好。然而当争议变为争吵时就坏事了，争吵不仅对评审工作没有好处，而且会无意中伤害伙伴之间的感情。</li></ul></li><li>需求承诺：<ul><li>是指开发方和客户方的责任人对通过了正式技术评审的《产品需求规格说明书》作出承诺，该承诺具有商业合同的效果。</li></ul></li><li>需求确认中的问题：<ul><li>需求确认，确保了需求规格说明的良好特性。</li><li>需求确认，是对渐增型软件需求规格说明的反复评审，将贯穿着反复获取需求、分析和编写规格说明的整个过程。</li><li>需求确认，可以减少返工，并加快系统测试，从而真正缩短了开发时间。</li></ul></li><li>需求确认的主要活动有以下几方面：<ul><li>软件需求规格说明是否正确描述了预期的系统行为和特征？</li><li>从系统需求或其它来源中得到软件需求的正确性。</li><li>需求是否是完整的和高质量的？</li><li>所有对需求的看法是否一致？</li><li>需求为继续进行产品设计、构造和测试是否提供了足够的基础？</li></ul></li></ol><h2 id="15-1-需求评审"><a href="#15-1-需求评审" class="headerlink" title="15.1 需求评审"></a>15.1 需求评审</h2><ul><li><p>需求文档的评审是一项精益求精的技术。它可以发现二义性的需求和不确定的需求。需求评审分为正式评审和非正式评审。</p></li><li><p>非正式评审是非系统化的，不彻底的，或者在实施过程中具有不一致性。不需要记录备案。可以根据个人爱好的方式进行评审</p></li><li><p>正式评审遵循预先定义好的一系列步骤。内容需要记录在案。正式评审小组的成员，对评审的质量负责。</p></li></ul><h3 id="15-1-1-审查过程"><a href="#15-1-1-审查过程" class="headerlink" title="15.1.1 审查过程"></a>15.1.1 审查过程</h3><ul><li>审查是一个定义明确的分多个阶段完成的过程，由一小组受过培训的参与者完成。</li></ul><ol><li>参与者（5-9人）</li></ol><p>参与者应该代表3种人的观点：</p><ul><li>工作产品的作者，也有可能是作者同级伙伴。</li><li>先前所有的其中有条目正在接受审查的工作产品或规格说明的作者。</li><li>需要根据正在审查的条目来开展工作的人。</li></ul><ol start="2"><li>审查种每个成员所扮演的角色</li></ol><ul><li>作者</li><li>仲裁者</li><li>读者</li><li>记录员</li></ul><ol start="3"><li>进入审查的标准</li></ol><ul><li>文档符合标准模板。</li><li>文档已经做过拼写检查和语法检查。</li><li>作者已经检查了文档在版面安排上所存在的错误。</li><li>已经获得了审查员所需要的先前或参考文档。</li><li>在文档中打印了行序号以方便在审查中对特定位置的查阅。</li><li>所有未解决的问题都被标记为TBD（待确定）。</li><li>包括了文档中使用到的术语词汇表。</li></ul><ol start="4"><li>审查阶段</li></ol><p><img src="http://img.fdchen.host/%E5%AE%A1%E6%9F%A5%E8%BF%87%E7%A8%8B%E9%98%B6%E6%AE%B5.png" alt="审查过程阶段"></p><center>图15-1 审查过程阶段</center><ol start="5"><li>结束审查的标准</li></ol><ul><li>已经明确阐述了审查员提出的所有问题。</li><li>已经正确修改了文档。</li><li>修订过的文档已经进行了拼写检查和语法检查。</li><li>所有TBD的问题已经全部解决，或者已经记录下每个待确定问题的解决过程，目标日期和提出问题的人。</li><li>文档已经登记入项目的配置管理系统。 </li><li>检查是否已将审查过的资料送到有关收集处。</li></ul><ol start="6"><li>需求审查清单</li></ol><ul><li>审查员对所审查每一类型的需求文档，应建立一份清单。这些清单可以提醒审查员以前经常发生的需求问题。</li><li>使用用例文档审查清单</li></ul><p>使用用例是否是独立的分散任务？<br>使用用例的目标或价值度量是否明确？<br>使用用例给操作者带来的益处是否明确？<br>使用用例是否处于抽象级别上，而不具有详细的情节？<br>使用用例中是否不包含设计和实现的细节？<br>是否记录了所有可能的可选过程？<br>是否记录了所有可能的例外条件？<br>是否存在一些普通的动作序列可以分解成独立的使用用例？<br>是否简明书写、无二义性和完整地记录了每个过程的对话？<br>使用用例中的每个操作和步骤是否都与所执行的任务相关？<br>使用用例中定义的每个过程是否都可行？<br>使用用例中定义的每个过程是否都可确认？</p><ul><li>软件需求规格说明的缺陷检查清单</li></ul><p><strong>组织和完整性</strong><br>所有对其它需求的内部交叉引用是否正确？<br>所有需求的编写在细节上是否都一致或者合适？<br>需求是否能为设计提供足够的基础？<br>是否包括了每个需求的实现优先级？<br>是否定义了所有外部硬件、软件和通信接口？<br>是否定义了功能需求内在的算法？<br>软件需求规格说明中是否包括了所有客户代表或系统的需求？<br>是否在需求中遗漏了必要的信息？如果有的话，就把它们标记为待确定的问题。<br>是否记录了所有可能的错误条件所产生的系统行为？<br><strong>正确性</strong><br>是否有需求与其它需求相冲突或重复？<br>是否简明、简洁、无二义性地表达每个需求的？<br>是否每个需求都能通过测试、演示、审查得以确认或分析？<br>是否每个需求都在项目的范围内？<br>是否每个需求都没有内容上和语法上的错误？<br>在现有的资源限制内，是否能实现所有的需求？<br>是否任一个特定的错误信息都具有唯一性和明确的意义？<br><strong>质量属性</strong><br>是否合理地确定了性能目标？<br>是否合理地确定了安全与保密方面的考虑？<br>在确定了合理的折衷情况下，是否详实地记录了其它相关的质量属性？<br><strong>可跟踪性</strong><br>是否每个需求都具有唯一性并且可以正确地识别它？<br>是否可以根据高层需求（如系统需求或使用用例）跟踪到软件功能需求？<br><strong>特殊的问题</strong><br>是否所有的需求都是名副其实的需求而不是设计或实现方案？<br>是否确定了对时间要求很高的功能并且定义了它们的时间标准？<br>是否已经明确地阐述了国际化问题？</p><h3 id="15-1-2-需求评审面临的困难"><a href="#15-1-2-需求评审面临的困难" class="headerlink" title="15.1.2 需求评审面临的困难"></a>15.1.2 需求评审面临的困难</h3><ol><li>大型的需求文档：可以分成几个小组，分别审查材料的不同部分。</li><li>庞大的审查小组：参与者任务明确；理解审查员所代表的观点；把审查组分成若干小组。</li><li>审查员在地域上的分散：视频会议；电话会议；共享网络文件夹中的电子文件，进行文档评审；基于Web的聊天工具，进行实时的远程讨论。</li></ol><h2 id="15-2-测试需求"><a href="#15-2-测试需求" class="headerlink" title="15.2 测试需求"></a>15.2 测试需求</h2><ul><li>软件需求在概念上的测试是通过在开发早期的阶段，寻找需求错误，从而成为一种控制项目费用和进度的强有力的技术。</li><li>如果能把早期的黑盒子测试设计、非正式需求评审、软件需求规格说明审查和其它需求确认技术相结合。将花比以前更少的时间、更低的费用,来构造质量更高的系统。</li></ul><h2 id="15-3-定义验收标准"><a href="#15-3-定义验收标准" class="headerlink" title="15.3 定义验收标准"></a>15.3 定义验收标准</h2><ul><li>按接收要求制定</li><li>重点放在功能需求上</li></ul><h1 id="16-需求开发面临的特殊难题（了解）"><a href="#16-需求开发面临的特殊难题（了解）" class="headerlink" title="16 需求开发面临的特殊难题（了解）"></a>16 需求开发面临的特殊难题（了解）</h1><h2 id="16-1-维护项目的需求"><a href="#16-1-维护项目的需求" class="headerlink" title="16.1 维护项目的需求"></a>16.1 维护项目的需求</h2><h3 id="16-1-1-开始捕获信息"><a href="#16-1-1-开始捕获信息" class="headerlink" title="16.1.1 开始捕获信息"></a>16.1.1 开始捕获信息</h3><ol><li><p>现有系统：文档不全；开发人员调离或辞职。</p><p>采用“逆向工程”方法从代码来理解系统。</p></li><li><p>增强性维护：在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。</p></li></ol><h3 id="16-1-2-亲身实践一下新的需求技术"><a href="#16-1-2-亲身实践一下新的需求技术" class="headerlink" title="16.1.2 亲身实践一下新的需求技术"></a>16.1.2 亲身实践一下新的需求技术</h3><h3 id="16-1-3-遵循跟踪链"><a href="#16-1-3-遵循跟踪链" class="headerlink" title="16.1.3 遵循跟踪链"></a>16.1.3 遵循跟踪链</h3><h2 id="16-2-软件包解决方案的需求"><a href="#16-2-软件包解决方案的需求" class="headerlink" title="16.2 软件包解决方案的需求"></a>16.2 软件包解决方案的需求</h2><h3 id="16-2-1-开发用例"><a href="#16-2-1-开发用例" class="headerlink" title="16.2.1 开发用例"></a>16.2.1 开发用例</h3><h3 id="16-2-2-考虑业务规则"><a href="#16-2-2-考虑业务规则" class="headerlink" title="16.2.2 考虑业务规则"></a>16.2.2 考虑业务规则</h3><h3 id="16-2-3-定义质量需求"><a href="#16-2-3-定义质量需求" class="headerlink" title="16.2.3 定义质量需求"></a>16.2.3 定义质量需求</h3><h2 id="16-3-外包项目的需求"><a href="#16-3-外包项目的需求" class="headerlink" title="16.3 外包项目的需求"></a>16.3 外包项目的需求</h2><p>准备需求文档，要记住以下几点：</p><ul><li>提供细节——精确地给出请求</li><li>避免二义性  </li><li>安排与承包方的接触点</li><li>定义双方都能接受的变更控制过程</li><li>为需求的多次迭代和评审预留时间</li><li>制定验收标准</li></ul><h2 id="16-4-突发型项目的需求"><a href="#16-4-突发型项目的需求" class="headerlink" title="16.4 突发型项目的需求"></a>16.4 突发型项目的需求</h2><h3 id="16-4-1-非正式用户需求规格说明"><a href="#16-4-1-非正式用户需求规格说明" class="headerlink" title="16.4.1 非正式用户需求规格说明"></a>16.4.1 非正式用户需求规格说明</h3><h3 id="16-4-2-现场客户"><a href="#16-4-2-现场客户" class="headerlink" title="16.4.2 现场客户"></a>16.4.2 现场客户</h3><h3 id="16-4-3-尽早地而且要经常地设定优先级"><a href="#16-4-3-尽早地而且要经常地设定优先级" class="headerlink" title="16.4.3 尽早地而且要经常地设定优先级"></a>16.4.3 尽早地而且要经常地设定优先级</h3><h3 id="16-4-4-简单的变更管理"><a href="#16-4-4-简单的变更管理" class="headerlink" title="16.4.4 简单的变更管理"></a>16.4.4 简单的变更管理</h3><h1 id="17-超越需求开发（了解）"><a href="#17-超越需求开发（了解）" class="headerlink" title="17 超越需求开发（了解）"></a>17 超越需求开发（了解）</h1><h2 id="17-1-从需求到项目规划"><a href="#17-1-从需求到项目规划" class="headerlink" title="17.1 从需求到项目规划"></a>17.1 从需求到项目规划</h2><h3 id="17-1-1-需求和评估"><a href="#17-1-1-需求和评估" class="headerlink" title="17.1.1 需求和评估"></a>17.1.1 需求和评估</h3><p>以下是一些常用的预估度量标准：</p><ul><li>功能点和特性点的多少</li><li>图形用户界面元素的数量、类型和复杂度</li><li>用于实现特定需求所需的源代码行数</li><li>对象类的数量或者其它面向对象系统的衡量标准</li><li>单个可测试需求的数量</li></ul><h3 id="17-1-2-需求和进度安排"><a href="#17-1-2-需求和进度安排" class="headerlink" title="17.1.2 需求和进度安排"></a>17.1.2 需求和进度安排</h3><p>正确的规划，需要考虑以下几点：</p><ul><li>根据对需求的清楚理解，来估计产品规模的大小。</li><li>根据历史记录，了解开发小组的工作效率。</li><li>需要一张综合的任务列表，以完整实现和验证每一特性或使用实例。</li><li>有效的预测和规划过程。</li><li>经验。</li></ul><h2 id="17-2-从需求到设计和编码"><a href="#17-2-从需求到设计和编码" class="headerlink" title="17.2 从需求到设计和编码"></a>17.2 从需求到设计和编码</h2><p>需求转化为设计和代码时，可能遇到下列问题：</p><ul><li>可能会遇到不确定和混淆的需求。</li><li>如果不能马上解决问题，那么所做出的假设，猜想或解释，都要编写成文档记录下来，并由客户代表评审。</li><li>如果遇到许多诸如此类的问题，说明需求还不十分清晰或具体。</li><li>在这种情况下，最好安排人员，对剩余的需求进行评审，然后在开展工作。</li></ul><h2 id="17-3-从需求到测试"><a href="#17-3-从需求到测试" class="headerlink" title="17.3 从需求到测试"></a>17.3 从需求到测试</h2><ul><li>详尽的需求，是系统测试的基础。反过来，只能通过测试，来判断软件是否满足了需求。</li></ul><h2 id="17-4-从需求到成功"><a href="#17-4-从需求到成功" class="headerlink" title="17.4 从需求到成功"></a>17.4 从需求到成功</h2><ul><li>项目的成功之处，在于把需求文档作为发行产品的基础。</li><li>需求是从产品概念，通向用户满意之路的最本质的一步。</li></ul><h1 id="18-需求管理的原则与实现"><a href="#18-需求管理的原则与实现" class="headerlink" title="18 需求管理的原则与实现"></a>18 需求管理的原则与实现</h1><h2 id="18-0-基本概念"><a href="#18-0-基本概念" class="headerlink" title="18.0 基本概念"></a>18.0 基本概念</h2><h3 id="18-0-1-需求管理是什么"><a href="#18-0-1-需求管理是什么" class="headerlink" title="18.0.1 需求管理是什么"></a>18.0.1 需求管理是什么</h3><p>需求管理：</p><ul><li>是一种获取、组织并记录系统需求的系统化方案，以及一个使客户与项目团队对不断变更的需求达成并保持一致的过程。</li><li>是对所有相关活动的规划和控制。</li><li>准确地强调了追踪变更以保持涉众与项目团队之间共识的重要性。</li><li>包括：在工程进展过程中维持需求约定集成性和精确性的所有活动。</li></ul><h3 id="18-0-2-需求管理主要内容"><a href="#18-0-2-需求管理主要内容" class="headerlink" title="18.0.2 需求管理主要内容"></a>18.0.2 需求管理主要内容</h3><ul><li>控制对需求基线的变动。</li><li>保持项目计划与需求一致。</li><li>控制单个需求和需求文档的版本情况。</li><li>管理需求和联系链之间的联系或管理单个需求和其它项目之间的依赖关系。</li><li>跟踪基线中需求的状态。</li></ul><h3 id="18-0-3-主要的需求管理活动"><a href="#18-0-3-主要的需求管理活动" class="headerlink" title="18.0.3 主要的需求管理活动"></a>18.0.3 主要的需求管理活动</h3><p><img src="http://img.fdchen.host/%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86%E6%B4%BB%E5%8A%A8.png" alt="主要的需求管理活动"></p><center>图18-1 主要的需求管理活动</center><h2 id="18-1-需求基线"><a href="#18-1-需求基线" class="headerlink" title="18.1 需求基线"></a>18.1 需求基线</h2><ul><li><p>需求基线是某一特定产品版本中实现的功能性和非功能性需求的一组集合。</p></li><li><p>需求基线在客户和开发人员之间建立了计划产品功能需求和非功能需求的一个约定。</p></li></ul><h2 id="18-2-需求管理过程"><a href="#18-2-需求管理过程" class="headerlink" title="18.2 需求管理过程"></a>18.2 需求管理过程</h2><p>需求管理过程，可考虑下列内容：</p><ul><li>用于控制各种需求文档和单个需求版本的工具、技术和约定。</li><li>建议、处理、协商、通告新的需求和变更给有关的功能域的方法。</li><li>如何制定需求基线。</li><li>使用的需求状态是谁允许作出的变更。</li><li>需求状态跟踪和报告过程。</li><li>分析已建议变动的影响应遵循的步骤。</li><li>在何种情况下，需求变更将会怎样影响项目计划和约定。</li></ul><h2 id="18-3-需求版本控制"><a href="#18-3-需求版本控制" class="headerlink" title="18.3 需求版本控制"></a>18.3 需求版本控制</h2><h3 id="18-3-1-概念"><a href="#18-3-1-概念" class="headerlink" title="18.3.1 概念"></a>18.3.1 概念</h3><ol><li>版本控制是管理需求的一个必要方面。需求文档的每一个版本，必须被统一确定。开发组内每个成员，必须得到需求的当前版本。</li><li>每一个公布的需求文档版本，应该包括一个修正版本的历史情况。即：已做变更的内容、变更日期、变更人的姓名以及变更的原因。</li><li>可以使用标准修改符：例如：<ul><li>中划线代表取消</li><li>下化线代表添加</li><li>在页边空白的竖划线指示每个变动的位置等等</li></ul></li></ol><h3 id="18-3-2-基本方法"><a href="#18-3-2-基本方法" class="headerlink" title="18.3.2 基本方法"></a>18.3.2 基本方法</h3><p>最简单方法是，根据标准约定，手工标记软件需求规格说明的每一次修改。</p><p>如：</p><ul><li>任何新文档的第一版当标记为“1.0版(草案1)”</li><li>下一稿标记为“1.0版（草案2）”</li><li>文档被采纳后被标记为“1.0正式版”</li><li>若只有较小的修改，可认为是“1.1版(草案1)”</li><li>若有较大的修改时，可认为是“2.0版(草案1)”</li></ul><h3 id="18-3-3-更高级别的方法"><a href="#18-3-3-更高级别的方法" class="headerlink" title="18.3.3 更高级别的方法"></a>18.3.3 更高级别的方法</h3><ul><li>用版本控制工具来存储需求文档，例如：用登录和退出程序，来管理源代码。</li></ul><h2 id="18-4-需求属性"><a href="#18-4-需求属性" class="headerlink" title="18.4 需求属性"></a>18.4 需求属性</h2><p>每个功能需求，应该有一些相关的信息或属性。对于每个需求，可考虑如下的属性：</p><ul><li>创建需求的日期</li><li>需求的版本号</li><li>创建需求的作者</li><li>负责认可该需求的人员</li><li>需求状态</li><li>需求的原因或根据（或信息的出处）</li><li>需求涉及的子系统</li><li>需求涉及的产品版本号</li><li>使用的验证方法或接受的测试标准</li><li>产品的优先级或重要程度</li><li>需求的稳定性</li></ul><h2 id="18-5-跟踪需求的状态"><a href="#18-5-跟踪需求的状态" class="headerlink" title="18.5 跟踪需求的状态"></a>18.5 跟踪需求的状态</h2><p>在整个开发过程中，跟踪每个需求的状态，是需求管理的一个重要方面。跟踪每个需求的状态，是一种精确地测量项目进度的方法。</p><center>表18-1 建议的需求状态表</center><table><thead><tr><th>状态值</th><th>定义</th></tr></thead><tbody><tr><td>已建议</td><td>该需求已被有权提出需求的人建议</td></tr><tr><td>已批准</td><td>该需求已被分析，估计了其对项目余下部分的影响（包括成本和对项目其余部分的干扰)，已用一个确定的产品版本号或创建编号分配到相关的基线中，软件开发团队已同意实现该项需求</td></tr><tr><td>已实现</td><td>已实现需求代码的设计、编写和单元测试</td></tr><tr><td>已验证</td><td>使用所选择的方法已验证了实现的需求，例如测试和检测，审查该需求跟踪与测试用例相符。该需求现在被认为完成</td></tr><tr><td>已删除</td><td>计划的需求已从基线中删除，但包括一个原因说明和做出删除决定的人员</td></tr><tr><td>已否决</td><td>需求已被提议，但并不计划在下一版本中实现它。要解释为什么否决这一需求，以及是谁决定否决的</td></tr></tbody></table><h2 id="18-6-评估需求管理的工作量"><a href="#18-6-评估需求管理的工作量" class="headerlink" title="18.6 评估需求管理的工作量"></a>18.6 评估需求管理的工作量</h2><p>度量需求管理的情况，一般考虑下列活动的效果：</p><ul><li>提出需求变更和已建议的新需求。</li><li>评估已建议的变更，包括影响分析。</li><li>变更控制委员会活动。</li><li>更新需求文档或数据库。</li><li>在涉及人员或团队中交流需求的变更。</li><li>跟踪和报告需求状态。</li><li>定义和更新需求跟踪能力信息。</li></ul><h2 id="18-7-需求管理与能力成熟度模型（CMM）"><a href="#18-7-需求管理与能力成熟度模型（CMM）" class="headerlink" title="18.7 需求管理与能力成熟度模型（CMM）"></a>18.7 需求管理与能力成熟度模型（CMM）</h2><p>CMM需求管理的目标是：</p><ol><li>控制指定给软件的系统需求，为软件工程和管理应用建立基线；</li><li>保持软件计划、产品和活动与指定给软件的系统需求一致。</li></ol><h1 id="19-变更管理"><a href="#19-变更管理" class="headerlink" title="19 变更管理"></a>19 变更管理</h1><p>不被控制的变更,是引起项目陷入混乱、不能按进度执行或软件质量低劣的原因。为了使开发组织能够控制软件项目，应确保以下事项：</p><ul><li>应仔细评估已建议的变更。</li><li>挑选合适的人选对变更做出决定。</li><li>变更应及时通知所有涉及的人员。</li><li>项目要按一定的程序来采纳需求变更。</li></ul><h2 id="19-1-管理范围蔓延"><a href="#19-1-管理范围蔓延" class="headerlink" title="19.1 管理范围蔓延"></a>19.1 管理范围蔓延</h2><ol><li>业务过程、市场机会、竞争性的产品和软件技术在开发系统期间是可以变更的。</li><li>扩展需求是指在软件需求基线已经确定后，又要增添新的功能或进行较大改动。要是每个建议的需求都被采纳，对于项目出资者、参与者与客户来说项目将永远也不会完成。在项目进度表中，应对必要的需求改动留有余地。若不控制范围的扩展，将使不断地采纳新的功能，而且要不断地调整资源、进度、或质量目标。因此，项目就不可能按客户预期的进度和预期质量交付使用了。</li><li>控制需求扩展的一个有效技术是原型法。</li></ol><h2 id="19-2-变更控制过程"><a href="#19-2-变更控制过程" class="headerlink" title="19.2 变更控制过程"></a>19.2 变更控制过程</h2><ol><li>一个好的变更控制过程，给项目承担者提供了正式的建议需求变更机制。</li><li>通过变更控制过程来跟踪已建议变更的状态，确保不会丢失或疏忽已建议的变更。</li><li>它是一个渠道和过滤器，通过它可以确保采纳最合适的变更，使变更产生的负面影响减少到最小。</li><li>变更过程应该做成文档，尽可能简单，当然首要的是有效性。</li><li>避免变更过程，效率低，且冗长，又很复杂。否则，宁愿用旧方法来做出变更决定。</li></ol><h2 id="19-2-1-变更控制策略"><a href="#19-2-1-变更控制策略" class="headerlink" title="19.2.1 变更控制策略"></a>19.2.1 变更控制策略</h2><p>下述需求变更的策略是有用的：</p><ul><li>所有需求变更，必须遵循一定的过程。如果一个变更需求未被采纳,其后过程不予考虑。</li><li>对于未获批准的变更，除可行性论证之外，不应再做其它设计和实现工作。</li><li>简单请求一个变更不能保证能实现变更，要由项目CCB决定实现哪些变更。</li><li>项目承担者，应该了解变更数据库的内容。</li><li>绝不能从数据库中删除或修改变更请求的原始文档。</li><li>每一个的需求变更，能够跟踪到一个经核准的变更请求。</li></ul><h3 id="19-2-2-变更控制过程描述"><a href="#19-2-2-变更控制过程描述" class="headerlink" title="19.2.2 变更控制过程描述"></a>19.2.2 变更控制过程描述</h3><ol><li><p>绪论<br>1.1 目的<br>1.2 范围<br>1.3 定义</p></li><li><p>角色和责任</p></li><li><p>变更请求状态</p></li><li><p>开始条件</p></li><li><p>任务<br>5.1 产生变更请求<br>5.2 评估变更请求<br>5.3 作出决策<br>5.4 通知变更人员</p></li><li><p>验证</p></li><li><p>结束条件</p></li><li><p>变更控制状态报告</p></li></ol><p>  附录：存储的数据项</p><h2 id="19-3-变更控制委员会"><a href="#19-3-变更控制委员会" class="headerlink" title="19.3 变更控制委员会"></a>19.3 变更控制委员会</h2><ul><li><p>变更控制委员会也称为配置控制委员会（configuration control board，CCB）。</p></li><li><p>变更控制委员会：可以由一个小组担任，也可由多个不同的组担任。负责做出决定：哪一些需求变更或新产品特性付诸应用；决定在哪一些版本中纠正哪一些错误。</p></li></ul><h3 id="19-3-1-CCB的组成"><a href="#19-3-1-CCB的组成" class="headerlink" title="19.3.1 CCB的组成"></a>19.3.1 CCB的组成</h3><p>变更控制委员会，包括如下几方面的代表：</p><ul><li>产品或计划管理部门。</li><li>项目管理部门。</li><li>开发部门。</li><li>测试或质量保证部门。</li><li>市场部或客户代表。</li><li>制作用户文档的部门。</li><li>技术支持部门。</li><li>帮助桌面或用户支持热线部门。</li><li>配置管理部门。</li></ul><p>应该在保证权威性的前提下，尽可能地精简CCB人员。</p><h3 id="19-3-2-CCB规章"><a href="#19-3-2-CCB规章" class="headerlink" title="19.3.2 CCB规章"></a>19.3.2 CCB规章</h3><p>设立变更控制委员会的第一步是写一个总则。描述变更控制委员会的目的、授权范围、成员构成、做出决策的过程及操作步骤。</p><ol><li>制定决策</li><li>交流情况</li><li>重新协商约定</li></ol><h3 id="19-3-3-变更控制工具"><a href="#19-3-3-变更控制工具" class="headerlink" title="19.3.3 变更控制工具"></a>19.3.3 变更控制工具</h3><p>挑选工具时，可以考虑以下几个方面：</p><ul><li><p>可以定义变更请求的数据项。</p></li><li><p>可以定义变更请求生存期的状态转换图。</p></li><li><p>可以加强状态转换图使经授权的用户仅能做出所允许的状态变更。</p></li><li><p>记录每一种状态变更的数据，确认出变更的人员。</p></li><li><p>可定义在提交新请求或请求状态被更新后应该自动通知的设计人员</p></li><li><p>可以根据需要生成标准的或定制的报告和图表。</p></li></ul><h2 id="19-5-测量变更活动"><a href="#19-5-测量变更活动" class="headerlink" title="19.5 测量变更活动"></a>19.5 测量变更活动</h2><p>测量变更活动是评估需求的稳定性和确定某种过程改进时机的一种方法。需求变更活动考虑以下几方面：</p><ul><li>接收、未作决定、结束处理的变更请求的数量。</li><li>已实现需求变更的合计数量。</li><li>每个方面发出的变更请求的数量。</li><li>每一个已应用的需求建议变更和实现变更的数量。</li><li>投入处理变更的人力、物力。</li></ul><h2 id="19-6-变更需要付出代价：影响分析"><a href="#19-6-变更需要付出代价：影响分析" class="headerlink" title="19.6 变更需要付出代价：影响分析"></a>19.6 变更需要付出代价：影响分析</h2><p>影响分析可以提供对建议的变更的准确理解，帮助做出信息量充分的变更批准决策。通过对变更内容的检验，确定对现有的系统做出是修改或抛弃的决定，或者创建新系统以及评估每个任务的工作量。进行影响分析的能力依赖于跟踪能力数据的质量和完整性。没有人愿意做一个费时费力还要担心意想不到情况的需求变更。</p><h3 id="19-6-1-影响分析的过程"><a href="#19-6-1-影响分析的过程" class="headerlink" title="19.6.1 影响分析的过程"></a>19.6.1 影响分析的过程</h3><p>影响分析有3个方面：</p><ol><li>理解进行变更可能涉及的问题。</li><li>确定如果团队将提议的变更包括到产品中，可能必须对哪些文件、模型和文档进行修改。</li><li>确定实现变更所需执行的任务。</li></ol><h2 id="19-6-2-影响分析报告模板"><a href="#19-6-2-影响分析报告模板" class="headerlink" title="19.6.2 影响分析报告模板"></a>19.6.2 影响分析报告模板</h2><p>如图19-1：</p><p><img src="http://img.fdchen.host/%E5%BD%B1%E5%93%8D%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF.png" alt="影响分析报告模板"></p><center>图19-1 影响分析报告模板</center><h1 id="20-需求链中的联系链"><a href="#20-需求链中的联系链" class="headerlink" title="20 需求链中的联系链"></a>20 需求链中的联系链</h1><ul><li>需求跟踪包括编制每个需求同系统元素之间的联系文档。这些元素包括：别的需求、体系结构、其他设计部件、源代码模块、测试、帮助文件、文档等。</li></ul><h2 id="20-1-需求跟踪"><a href="#20-1-需求跟踪" class="headerlink" title="20.1 需求跟踪"></a>20.1 需求跟踪</h2><ol><li>跟踪联系链是能跟踪一个需求使用期限的全过程。即从需求源到实现的前后生存期。跟踪能力是优秀需求规格说明书的一个特征。</li><li>跟踪联系链，记录了单个需求之间的父层、互连、依赖的关系。当某个需求变更（被删除或修改）后，这种信息能够确保正确的变更传播，并将相应的任务作出正确的调整。</li><li>如图20-1，</li></ol><p><img src="http://img.fdchen.host/%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9C%80%E6%B1%82%E8%B7%9F%E8%B8%AA.png" alt="四种类型的需求跟踪"></p><center>图20-1 四种类型的需求跟踪</center><h2 id="20-2-需求跟踪动机"><a href="#20-2-需求跟踪动机" class="headerlink" title="20.2 需求跟踪动机"></a>20.2 需求跟踪动机</h2><p>下面是在项目中使用需求跟踪能力的一些好处：</p><ul><li>审核（certification） </li><li>变更影响分析</li><li>维护</li><li>项目跟踪</li><li>再设计（重新建造） </li><li>重复利用</li><li>减小风险</li><li>测试</li></ul><h2 id="20-3-需求跟踪矩阵"><a href="#20-3-需求跟踪矩阵" class="headerlink" title="20.3 需求跟踪矩阵"></a>20.3 需求跟踪矩阵</h2><p>表示需求和别的系统元素之间的联系链的最普遍方式是使用需求跟踪能力矩阵。如图20-2：</p><p><img src="http://img.fdchen.host/%E4%B8%80%E7%A7%8D%E9%9C%80%E6%B1%82%E8%B7%9F%E8%B8%AA%E8%83%BD%E5%8A%9B%E7%9F%A9%E9%98%B5.png" alt="一种需求跟踪能力矩阵"></p><center>图20-2 一种需求跟踪能力矩阵</center><h2 id="20-4-需求跟踪工具"><a href="#20-4-需求跟踪工具" class="headerlink" title="20.4 需求跟踪工具"></a>20.4 需求跟踪工具</h2><ul><li>需求跟踪能力，不能完全自动化。然而，一旦已确定联系链，特定工具就能帮我们管理巨大的跟踪能力信息。</li><li>可以在工具的数据库中存储需求和其他信息，定义不同对象间的联系链，甚至包括同类需求的对等联系链。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CQU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 软件需求分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_基本用法</title>
      <link href="/2020/java-ji-ben-yong-fa/"/>
      <url>/2020/java-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="1-二维数组传参"><a href="#1-二维数组传参" class="headerlink" title="1. 二维数组传参"></a>1. 二维数组传参</h3><ul><li>不同于C&#x2F;C++，Java二维数组传参必须使用array[] []，而不能使用array[] [2]。</li></ul><h3 id="2-List-add"><a href="#2-List-add" class="headerlink" title="2. List.add()"></a>2. List.add()</h3><ul><li>List.add()加入的元素为对应元素的引用，而不是值，示例如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// EdgeNode的变量为x0,deltaX,yMax</span><span class="token class-name">EdgeNode</span> edgeNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">EdgeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EdgeNode</span><span class="token punctuation">></span></span> NET <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EdgeNode</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>NET<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edgeNode<span class="token punctuation">)</span><span class="token punctuation">;</span>edgeNode<span class="token punctuation">.</span><span class="token function">setX0</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>NET<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edgeNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>NET<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>NET<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getX0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出结果如下：</span><span class="token number">2.0</span> <span class="token number">2.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-交换函数"><a href="#3-交换函数" class="headerlink" title="3. 交换函数"></a>3. 交换函数</h3><ul><li>直接交换和用包装类交换都不能交换两个数的值，而采用数组交换和成员变量交换是可以做到的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算框架MapReduce</title>
      <link href="/2020/da-shu-ju-fen-xi-fen-bu-shi-ji-suan-kuang-jia-mapreduce/"/>
      <url>/2020/da-shu-ju-fen-xi-fen-bu-shi-ji-suan-kuang-jia-mapreduce/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MapReduce概述"><a href="#1-MapReduce概述" class="headerlink" title="1 MapReduce概述"></a>1 MapReduce概述</h1><h2 id="1-1-MapReduce定义"><a href="#1-1-MapReduce定义" class="headerlink" title="1.1 MapReduce定义"></a>1.1 MapReduce定义</h2><ol><li>MapReduce是一个<strong>分布式运算程序的编程框架</strong>，是用户开发“基于Hadoop的<br>数据分析应用”的核心框架。</li><li>MapReducet核心功能是<strong>将用户编写的业务逻辑代码和自带默认组件整合成一个<br>完整的分布式运算程序，并发运行在一个Hadoop集群上。</strong></li></ol><h2 id="1-2-MapReduce优缺点"><a href="#1-2-MapReduce优缺点" class="headerlink" title="1.2 MapReduce优缺点"></a>1.2 MapReduce优缺点</h2><h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h3><ol><li><p>MapReduce易于编程<br>它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量廉价的PC机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一样的。就是因为这个特点使得MapReduce编程变得非常流行。</p></li><li><p>良好的扩展性<br>当尔的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</p></li><li><p>高容错性<br>MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。</p></li><li><p>适合PB级以上海量数据的离线处理<br>可以实现上千台服务器集群并发工作，提供好据处理能力。</p></li></ol><h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><ol><li>不擅长实时计算<br>MapReduce无法像MySQL一样，在毫秒或者秒级内返回结果。</li><li>不擅长流式计算<br>流式计算的输入数据是动态的，而MapReduce的输入数据集是静态的，不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。</li><li>不擅长DAG（有向图）计算<br>多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情兄下，MapReduce并不是不能做，而是使用后，每个MapReducef作业的输出结果都会写入到磁盘，会造成大量的磁盘I&#x2F;O，导致性能非常的低下。</li></ol><span id="more"></span><h2 id="1-3-MapReduce核心思想"><a href="#1-3-MapReduce核心思想" class="headerlink" title="1.3 MapReduce核心思想"></a>1.3 MapReduce核心思想</h2><p><img src="http://img.fdchen.host/MapReduce%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.png" alt="MapReduce核心编程思想"></p><center>图1.1 MapReduce核心编程思想</center><ul><li>分布式的运算程序往往需要分成至少2个阶段。</li></ul><ol><li>第一个阶段的MapTask并发实例，完全并行运行，互不相干。</li><li>第二个阶段的ReduceTask并发实例互不相干，但是他们的数据依赖于上一个阶段的所有MapTask并发实例的输出。</li><li>MapReduce编程模型<strong>只能包含一个Map阶段和一个Reduce阶段</strong>，如果用户的业务逻辑非常复杂，那就只能<strong>多个MapReduce程序，串行运行</strong>。</li></ol><h2 id="1-4-MapReduce进程"><a href="#1-4-MapReduce进程" class="headerlink" title="1.4 MapReduce进程"></a>1.4 MapReduce进程</h2><ul><li>一个完整的MapReduce程序分布式运行时有三类实例进程：</li></ul><ol><li><strong>MrAppMaster：</strong>负责整个程序的过程调度及状态协调。</li><li><strong>MapTask：</strong>负责Map阶段的整个数据处理流程。</li><li><strong>ReduceTask：</strong>负责Reduce阶段的整个数据处理流程。</li></ol><h2 id="1-5-官方WordCount源码"><a href="#1-5-官方WordCount源码" class="headerlink" title="1.5 官方WordCount源码"></a>1.5 官方WordCount源码</h2><p>采用反编译工具反编译源码，发现WordCount案例有Map类、Reduce类和驱动类。且数据的类型是Hadoop自身封装的序列化类型。</p><p><strong>Tip：</strong></p><ul><li><strong>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。详情见第2章。</strong></li></ul><h2 id="1-6-常用数据序列化类型"><a href="#1-6-常用数据序列化类型" class="headerlink" title="1.6 常用数据序列化类型"></a>1.6 常用数据序列化类型</h2><center>表1.1 常用的数据类型对应的Hadoop数据序列化类型</center><table><thead><tr><th><strong>Java类型</strong></th><th><strong>Hadoop Writable类型</strong></th></tr></thead><tbody><tr><td>boolean</td><td>BooleanWritable</td></tr><tr><td>byte</td><td>ByteWritable</td></tr><tr><td>int</td><td>IntWritable</td></tr><tr><td>float</td><td>FloatWritable</td></tr><tr><td>long</td><td>LongWritable</td></tr><tr><td>double</td><td>DoubleWritable</td></tr><tr><td>String</td><td>Text</td></tr><tr><td>map</td><td>MapWritable</td></tr><tr><td>array</td><td>ArrayWritable</td></tr></tbody></table><p><strong>Tip：有关IntWritable等序列化类型使用详见博客<a href="https://blog.csdn.net/ghuilee/article/details/45705169">《IntWritable详解》</a></strong></p><h2 id="1-7-MapReduce编程规范"><a href="#1-7-MapReduce编程规范" class="headerlink" title="1.7 MapReduce编程规范"></a>1.7 MapReduce编程规范</h2><ul><li>用户编写的程序分成三个部分：Mapper、Reducer和Driver。</li></ul><ol><li><strong>Mapper阶段</strong></li></ol><p>（1）用户自定义的Mapper要继承自己的父类<br>（2）Mapper的输入数据是KV(Key-Value)对的形式(KV的类型可自定义)<br>（3）Mapper中的业务逻辑写在map()方法中<br>（4）Mapper的输出数据是KV(Key-Value)对的形式(KV的类型可自定义)<br>（5）map()方法（MapTask进程）对<strong>每一个初始输入数据的&lt;K,V&gt;调用一次</strong></p><ol start="2"><li><strong>Reduce阶段</strong></li></ol><p>（1）用户自定义的Reducer要继承自己的父类<br>（2）Reducer的输入数据类型对应Mapper的输出数据类型，也是KV对<br>（3）Reducer的业务逻辑写在reduce()方法中<br>（4）ReduceTask进程对<strong>Mapper阶段输出的每一组相同k的&lt;k,v&gt;组调用一次</strong>reduce()方法</p><ol start="3"><li><strong>Driver阶段</strong></li></ol><p>相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数job对象。</p><h2 id="1-8-WordCount案例实操"><a href="#1-8-WordCount案例实操" class="headerlink" title="1.8 WordCount案例实操"></a>1.8 WordCount案例实操</h2><ol><li><strong>需求</strong></li></ol><p>在给定的文本文件中统计输出每一个单词出现的总次数</p><p>（1）输入数据为文本文件：<a href="http://img.fdchen.host/hello.txt">hello.txt</a><br>（2）期望输出数据：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">atguigu<span class="token number">2</span>banzhang<span class="token number">1</span>cls<span class="token number">2</span>hadoop<span class="token number">1</span>jiao<span class="token number">1</span>ss<span class="token number">2</span>xue<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>需求分析</strong></li></ol><p>按照MapReduce编程规范，分别编写Mapper，Reducer，Driver，如图1.2：<br><img src="http://img.fdchen.host/WordCount%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" alt="WordCount案例需求分析"></p><center>图1.2 WordCount案例需求分析</center><ol start="3"><li><strong>环境准备</strong></li></ol><p>（1）创建maven工程</p><p>（2）在pom.xml文件中添加如下依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.logging.log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hadoop-common<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hadoop-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hadoop-hdfs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在项目的src&#x2F;main&#x2F;resources目录下，新建一个文件，命名为“log4j.properties”，在文件中填入如下内容：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">INFO, stdout</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d %p [%c] - %m%n</span><span class="token attr-name">log4j.appender.logfile</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.FileAppender</span><span class="token attr-name">log4j.appender.logfile.File</span><span class="token punctuation">=</span><span class="token attr-value">target/spring.log</span><span class="token attr-name">log4j.appender.logfile.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.logfile.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d %p [%c] - %m%n</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>编写程序</strong></li></ol><p>（1）编写Mapper类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>sound<span class="token punctuation">.</span>sampled<span class="token punctuation">.</span></span><span class="token class-name">Line</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IntWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span>  <span class="token comment">// 注意导入正确jar包：xxx.io.Text</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>classfile<span class="token punctuation">.</span></span><span class="token class-name">StackMapTable_attribute</span><span class="token punctuation">.</span>verification_type_info<span class="token punctuation">;</span><span class="token comment">/** * Map阶段 * @param  * KEYIN 输入数据的key * VALUEIN 输入数据的value * KEYOUT 输出数据的key的类型 * VALUEOUT 输出数据的value类型 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">Text</span> k <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IntWritable</span>  v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token comment">// 文本内容为： atguigu atguigu</span><span class="token comment">// 1  获取1行</span><span class="token class-name">String</span> line <span class="token operator">=</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 切割单词</span>        <span class="token comment">// 注意切割符号要正确，不然结果会出现偏差</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3 循环写出</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token operator">:</span>words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// set()将word设置为Text的值</span>k<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）编写Redcuer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IntWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span>  <span class="token comment">// 注意导入正确的jar包：xxx.mapreduce.Reducer</span><span class="token comment">// KEYIN VALUEIN map阶段输出的key和value</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">IntWritable</span>  v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Iterable&lt;IntWritable>为类型为IntWritable的迭代器</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IntWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token comment">// 输入数据为： &lt;atguigu,1> &lt;atguigu,1></span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 1 累加求和</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span> value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 写出atguigu 2</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）编写Driver驱动类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span>  <span class="token comment">// 注意导入正确jar包：xxx.conf.Configuration</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IntWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span>  <span class="token comment">// 注意导入正确jar包：xxx.mapreduce.Job</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span> <span class="token comment">// 注意导入正确jar包：xxx.lib.input.FileInputFormat</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token comment">// 注意导入正确jar包：xxx.lib.output.FileOutputFormat</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token class-name">Configuration</span> conf<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1 获取job对象</span><span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 设置jar存储位置</span><span class="token comment">// setJar()表示设置固定的jar存储位置</span><span class="token comment">// setJarByClass()表示设置随主类变化的动态jar存储位置</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">WordCountDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关联Map和Reduce类</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">WordCountMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">WordCountReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4  设置Mapper阶段输出数据的key和value类型</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 设置最终输出数据的key和value类型</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 设置输入路径和输出路径，路径设置为传参</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 7 提交job</span><span class="token comment">// job.submit();  过时方法</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果传参为true，在成功提交后会打印相关信息</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result<span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><strong>本地测试</strong></li></ol><p>（1）如果电脑系统是win7的就将win7的hadoop jar包解压到非中文路径，并在Windows环境上配置HADOOP_HOME环境变量。如果是电脑win10操作系统，就解压win10的hadoop jar包，并配置HADOOP_HOME环境变量。</p><p><strong>Tip：win8电脑和win10家庭版操作系统可能有问题，需要重新编译源码或者更改操作系统。</strong></p><p>（2）在Eclipse&#x2F;Idea上运行程序，如图1.3：</p><p><img src="http://img.fdchen.host/RunConfiguration%E8%AE%BE%E7%BD%AE.jpg" alt="RunConfiguration设置"></p><center>图1.3 RunConfiguration设置</center><p><strong>Tip：输出路径目录必须未创建，不然会报错。</strong></p><ol start="6"><li><strong>集群上测试</strong></li></ol><p>（0）用maven打jar包，需要添加的打包插件依赖</p><p><strong>Tip：</strong></p><ul><li><strong>标记红颜色的部分需要替换为自己工程主类。</strong></li><li><strong>如果工程上显示红叉。在项目上右键-&gt;maven-&gt;update project即可。</strong></li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRefs</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRef</span><span class="token punctuation">></span></span>jar-with-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRef</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRefs</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.atguigu.mr.WordcountDriver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>make-assembly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（1）将程序打成jar包，然后拷贝到Hadoop集群中</p><p><strong>步骤详情：右键-&gt;Run as-&gt;maven install。</strong>等待编译完成就会在项目的target文件夹中生成jar包。如果看不到。在项目上右键–&gt;Refresh，即可看到。修改不带依赖的jar包名称为wc.jar，并拷贝该jar包到Hadoop集群。</p><p>（2）启动Hadoop集群，<strong>可以启动伪分布式模式，但是一定要先启动NameNode和DataNode进程，再启动yarn进程，否则DataNode进程会yarn进程被屏蔽。</strong></p><p>（3）执行WordCount程序</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop jar wc<span class="token punctuation">.</span>jar mr<span class="token punctuation">.</span>WordCountDriver <span class="token operator">/</span>user/atguigu/input <span class="token operator">/</span>user/atguigu/output<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Tip：</strong></p><ul><li><p><strong>com.atguigu.wordcount.WordcountDriver为驱动类的全类名，在Eclipse里面右键点击类名选择”Copy Qualified Name”即可。</strong></p></li><li><p><strong>输入输出路径是本地路径还是集群路径由集群的运行模式决定，如果是本地模式则输入本地路径，伪分布式和完全分布式输入集群路径。</strong></p></li><li><p><strong>如图1.4报错无法操作存储节点，原因是DataNode被yarn进程屏蔽</strong></p></li></ul><p><img src="/" alt="DataNode被yarn进程屏蔽报错无法操作存储节点"></p><center>图1.4 DataNode被yarn进程屏蔽报错无法操作存储节点</center><ul><li><strong>如图1.5报错无法连接，原因是未启动yarn</strong></li></ul><p><img src="http://img.fdchen.host/DataNode%E8%A2%AByarn%E8%BF%9B%E7%A8%8B%E5%B1%8F%E8%94%BD%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8%E8%8A%82%E7%82%B9.jpg" alt="未启动yarn报错无法连接"></p><center>图1.5 未启动yarn报错无法连接</center><h1 id="2-Hadoop序列化"><a href="#2-Hadoop序列化" class="headerlink" title="2 Hadoop序列化"></a>2 Hadoop序列化</h1><h2 id="2-1-序列化概述"><a href="#2-1-序列化概述" class="headerlink" title="2.1 序列化概述"></a>2.1 序列化概述</h2><h3 id="2-1-1-什么是序列化"><a href="#2-1-1-什么是序列化" class="headerlink" title="2.1.1 什么是序列化"></a>2.1.1 什么是序列化</h3><ol><li><strong>序列化</strong>就是<strong>把内存中的对象，转换成字节序列（或其他数据传输协议）</strong>以便于存储到磁盘（持久化）和网络传输。</li><li><strong>反序列化</strong>就是将收到字节序列（或其他数据传输协议）或者是<strong>磁盘的持久化数据，转换成内存中的对象</strong>。</li></ol><h3 id="2-1-2-为什么要序列化"><a href="#2-1-2-为什么要序列化" class="headerlink" title="2.1.2 为什么要序列化"></a>2.1.2 为什么要序列化</h3><p>一般来说，“活的”对象只生存在内存里，关机断电就没有了。而且“活的”对象只能由本地的进程使用，不能被发送到网络上的另外一台计算机。然而<strong>序列化可以存储“活的”对象，可以将“活的”对象发送到远程计算机。</strong></p><h3 id="2-1-3-为什么不用Java的序列化"><a href="#2-1-3-为什么不用Java的序列化" class="headerlink" title="2.1.3 为什么不用Java的序列化"></a>2.1.3 为什么不用Java的序列化</h3><p>Java的序列化是一个重量级序列化框架(Serializable)，<strong>一个对象被序列化后，会附带很多额外的信息（各种校验信息，Header，继承体系等），不便于在网络中高效传输</strong>。所以，Hadoop自己开发了一套序列化机制(Writable) 。</p><h3 id="2-1-4-Hadoop排序列化特点"><a href="#2-1-4-Hadoop排序列化特点" class="headerlink" title="2.1.4 Hadoop排序列化特点"></a>2.1.4 Hadoop排序列化特点</h3><ul><li><strong>紧凑：</strong>高效使用存储空间。</li><li><strong>快速：</strong>读写数据的额外开销小。</li><li><strong>可扩展：</strong>可随着通信协议的升级而升级。</li><li><strong>互操作：</strong>支持多语言的交互。</li></ul><p><strong>Tip：读写数据的额外开销指的是由于提供检索而额外产生的存储开销等。</strong></p><h2 id="2-2-自定义bean对象实现序列化接口（Writable）"><a href="#2-2-自定义bean对象实现序列化接口（Writable）" class="headerlink" title="2.2 自定义bean对象实现序列化接口（Writable）"></a>2.2 自定义bean对象实现序列化接口（Writable）</h2><p>在企业开发中往往常用的基本序列化类型不能满足所有需求，比如在Hadoop框架内部传递一个bean对象，那么该对象就需要实现序列化接口。</p><p><strong>Tip：JavaBean简单的讲就是实体类，用来封装对象，这个类里面全部都是属性值和get，set方法。</strong></p><p>具体实现bean对象序列化步骤如下6步。</p><ol><li><p>必须实现Writable接口</p></li><li><p>反序列化时，需要反射调用空参构造函数，所以必须有空参构造</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>重写序列化方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">DataOutput</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>upFlow<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>downFlow<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>sumFlow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>重写反序列化方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFields</span><span class="token punctuation">(</span><span class="token class-name">DataInput</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>upFlow <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>downFlow <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sumFlow <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip：注意反序列化的顺序和序列化的顺序要求完全一致，理由是序列化存储到磁盘采用的是队列式传输，先进先出，则先序列化的对象先存储，在磁盘读取时先反序列化最先序列化的对象。</strong></p><ol start="5"><li><p>要想把结果显示在文件中，需要重写toString()，可用”\t”分开，方便后续用。</p></li><li><p>如果需要将自定义的bean放在key中传输，则还需要实现Comparable接口，因为<strong>MapReduce框中的Shuffle过程要求对key必须能排序</strong>。详见后面排序案例。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 倒序排列，从大到小</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-序列化案例实操"><a href="#2-3-序列化案例实操" class="headerlink" title="2.3 序列化案例实操"></a>2.3 序列化案例实操</h2><h3 id="2-3-1-需求"><a href="#2-3-1-需求" class="headerlink" title="2.3.1 需求"></a>2.3.1 需求</h3><ul><li>目标：统计每一个手机号耗费的总上行流量、下行流量、总流量。</li></ul><ol><li>输入数据：<a href="http://img.fdchen.host/phone_data%20.txt">phone_data.txt</a></li><li>输入数据格式</li></ol><pre class="line-numbers language-none"><code class="language-none">7 13560436666120.196.100.991116 954200id手机号码网络ip上行流量  下行流量     网络状态码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>期望输出数据格式</li></ol><pre class="line-numbers language-none"><code class="language-none">13560436666    1116      954 2070手机号码    上行流量        下行流量总流量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3-1-需求分析"><a href="#2-3-1-需求分析" class="headerlink" title="2.3.1 需求分析"></a>2.3.1 需求分析</h3><ol><li><strong>Map阶段</strong></li></ol><p>（1）读取一行数据，切分字段</p><pre class="line-numbers language-none"><code class="language-none">7 13560436666120.196.100.991116 954200<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）抽取手机号、上行流量、下行流量</p><pre class="line-numbers language-none"><code class="language-none">13560436666   1116    954手机号码上行流量  下行流量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）以手机号为key，bean对象为value输出，即context.write(手机号,bean);</p><p>（4）bean对象要想能够传输，必须实现序列化接口</p><ol start="2"><li><strong>Reduce阶段</strong></li></ol><p>（1）累加上行流量和下行流量得到总流量。</p><pre class="line-numbers language-none"><code class="language-none">13560436666   1116 +  954   &#x3D;  2070手机号码上行流量  下行流量   总流量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3-3-编写MapReduce程序"><a href="#2-3-3-编写MapReduce程序" class="headerlink" title="2.3.3 编写MapReduce程序"></a>2.3.3 编写MapReduce程序</h3><ol><li><strong>编写流量统计的Bean对象</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataInput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataOutput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Writable</span><span class="token punctuation">;</span><span class="token comment">// 1 实现writable接口</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowBean</span> <span class="token keyword">implements</span> <span class="token class-name">Writable</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">long</span> upFlow<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">long</span> downFlow<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">long</span> sumFlow<span class="token punctuation">;</span><span class="token comment">// 2 反序列化时，需要反射调用空参构造函数，所以必须定义空参构造函数</span><span class="token keyword">public</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 注意补充this.sumFlow = upFlow + downFlow;</span><span class="token keyword">public</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token keyword">long</span> upFlow<span class="token punctuation">,</span> <span class="token keyword">long</span> downFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>upFlow <span class="token operator">=</span> upFlow<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>downFlow <span class="token operator">=</span> downFlow<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow <span class="token operator">=</span> upFlow <span class="token operator">+</span> downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 3  序列化方法</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">DataOutput</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>upFlow<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>downFlow<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>sumFlow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 4 反序列化方法</span><span class="token comment">// 反序列化方法读顺序必须和写序列化方法的写顺序必须一致</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFields</span><span class="token punctuation">(</span><span class="token class-name">DataInput</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>upFlow<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>downFlow<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 6 编写toString方法，方便后续打印到文本，注意使用"\t"隔开</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> upFlow <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> downFlow <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> sumFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getUpFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> upFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUpFlow</span><span class="token punctuation">(</span><span class="token keyword">long</span> upFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>upFlow <span class="token operator">=</span> upFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDownFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDownFlow</span><span class="token punctuation">(</span><span class="token keyword">long</span> downFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>downFlow <span class="token operator">=</span> downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> sumFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSumFlow</span><span class="token punctuation">(</span><span class="token keyword">long</span> sumFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow <span class="token operator">=</span> sumFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip：构造函数和get与set方法可以由Eclipse自动生成，点击右键–&gt;”source”–&gt;选择想要生成的方法，然后选择需要传入的参数即可。</strong></p><ol start="2"><li><strong>编写Mapper类</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token comment">// 注意导入正确jar包，Text类的包很容易导入错误</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token comment">// LongWritable代表行的偏移量，Text代表这一行的内容</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCountMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token comment">// map方法需要循环多次调用，所以两个输出变量定义在map方法外</span><span class="token class-name">FlowBean</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Text</span> k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用Text类型变量代表手机号</span><span class="token comment">// 1 获取1行</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> key<span class="token punctuation">,</span><span class="token class-name">Text</span> value<span class="token punctuation">,</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取1行</span><span class="token class-name">String</span> line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 切割字段</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 封装对象</span><span class="token comment">// 取出手机号码</span><span class="token class-name">String</span> phoneNum <span class="token operator">=</span> fields<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 取出上行流量和下行流量</span><span class="token keyword">long</span> upFlow <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>fields<span class="token punctuation">[</span>fields<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> downFlow <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>fields<span class="token punctuation">[</span>fields<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>phoneNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// v.setUpFlow(upFlow);</span><span class="token comment">// v.setDownFlow(downFlow);</span><span class="token comment">// 也可在FlowBean里面定义set(downFlow,upFlow);</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>upFlow<span class="token punctuation">,</span>downFlow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 写出</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>编写Reducer类</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token comment">// 注意导入正确jar包，Text类的包很容易导入错误</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCountReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FlowBean</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token keyword">long</span> sum_upFlow<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">long</span> sum_downFlow<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 1 遍历所有bean，将其中的上行流量，下行流量分别累加</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> flowBean<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum_upFlow<span class="token operator">+=</span>flowBean<span class="token punctuation">.</span><span class="token function">getUpFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sum_downFlow<span class="token operator">+=</span>flowBean<span class="token punctuation">.</span><span class="token function">getDownFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 2 封装对象</span><span class="token class-name">FlowBean</span> resultBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span>sum_upFlow<span class="token punctuation">,</span>sum_downFlow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 写出</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> resultBean<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>编写Driver驱动类</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token comment">// 注意导入正确jar包，Text类的包很容易导入错误</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCountDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 加入此行代码后在本地测试时不必再设置run configuration</span>        <span class="token comment">// 但在集群运行时需要把此行代码删去</span>args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"d:/input/inputFlow"</span><span class="token punctuation">,</span><span class="token string">"d:/outputFlow"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1 获取job对象</span><span class="token class-name">Job</span> job<span class="token operator">=</span><span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 设置jar路径</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">FlowCountDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关联mapper和reducer</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">FlowCountMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">FlowCountReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 设置mapper输出的key和value类型</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 设置最终输出的key和value类型</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 设置输入输出路径</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 7 提交job</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result<span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-MapReduce框架原理"><a href="#3-MapReduce框架原理" class="headerlink" title="3 MapReduce框架原理"></a>3 MapReduce框架原理</h1><h2 id="3-1-InputFormat数据输入"><a href="#3-1-InputFormat数据输入" class="headerlink" title="3.1 InputFormat数据输入"></a>3.1 InputFormat数据输入</h2><h3 id="3-1-1-切片与MapTask并行度决定机制"><a href="#3-1-1-切片与MapTask并行度决定机制" class="headerlink" title="3.1.1 切片与MapTask并行度决定机制"></a>3.1.1 切片与MapTask并行度决定机制</h3><ol><li>问题引出</li></ol><ul><li>MapTask的并行度决定Map阶段的任务处理并发度，进而影响到整个Job的处理速度。</li><li>1G的数据，启动8个MapTask，可以提高集群的并发处理能力。那么1K的数据，也启动8个MapTask，会提高集群性能吗？MapTask并行任务是否越多越好呢？哪些因素影响了MapTask并行度？</li></ul><ol start="2"><li>MapTask并行度决定机制</li></ol><ul><li><strong>数据块：</strong>Block是HDFS物理上把数据分成一块一块。</li><li><strong>数据切片：</strong>数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。</li><li>MapTask并行度决定机制如图3.1：</li></ul><p><img src="http://img.fdchen.host/MapTask%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%86%B3%E5%AE%9A%E6%9C%BA%E5%88%B6.png" alt="MapTask并行度决定机制"></p><center>图3.1 MapTask并行度决定机制</center><ul><li>当切片大小为BlockSize时效率最高，因为此时的I&#x2F;O开销很小。</li></ul><h3 id="3-1-2-Job提交流程源码和切片源码详解"><a href="#3-1-2-Job提交流程源码和切片源码详解" class="headerlink" title="3.1.2 Job提交流程源码和切片源码详解"></a>3.1.2 Job提交流程源码和切片源码详解</h3><ol><li><strong>Job提交流程源码详解</strong></li></ol><p>（1）源码结构如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1建立连接</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1）创建提交Job的代理</span><span class="token keyword">new</span> <span class="token class-name">Cluster</span><span class="token punctuation">(</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// （1）判断是本地yarn还是远程</span><span class="token function">initialize</span><span class="token punctuation">(</span>jobTrackAddr<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 提交job</span>submitter<span class="token punctuation">.</span><span class="token function">submitJobInternal</span><span class="token punctuation">(</span><span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> cluster<span class="token punctuation">)</span><span class="token comment">// 1）创建给集群提交数据的Stag路径</span><span class="token class-name">Path</span> jobStagingArea <span class="token operator">=</span> <span class="token class-name">JobSubmissionFiles</span><span class="token punctuation">.</span><span class="token function">getStagingDir</span><span class="token punctuation">(</span>cluster<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2）获取jobid ，并创建Job路径</span><span class="token class-name">JobID</span> jobId <span class="token operator">=</span> submitClient<span class="token punctuation">.</span><span class="token function">getNewJobID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3）拷贝jar包到集群</span><span class="token function">copyAndConfigureFiles</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> submitJobDir<span class="token punctuation">)</span><span class="token punctuation">;</span>rUploader<span class="token punctuation">.</span><span class="token function">uploadFiles</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> jobSubmitDir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4）计算切片，生成切片规划文件</span><span class="token function">writeSplits</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> submitJobDir<span class="token punctuation">)</span><span class="token punctuation">;</span>maps <span class="token operator">=</span> <span class="token function">writeNewSplits</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> jobSubmitDir<span class="token punctuation">)</span><span class="token punctuation">;</span>input<span class="token punctuation">.</span><span class="token function">getSplits</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5）向Stag路径写XML配置文件</span><span class="token function">writeConf</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> submitJobFile<span class="token punctuation">)</span><span class="token punctuation">;</span>conf<span class="token punctuation">.</span><span class="token function">writeXml</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6）提交Job,返回提交状态</span>status <span class="token operator">=</span> submitClient<span class="token punctuation">.</span><span class="token function">submitJob</span><span class="token punctuation">(</span>jobId<span class="token punctuation">,</span> submitJobDir<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> job<span class="token punctuation">.</span><span class="token function">getCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）Job提交流程图解，如图3.2：</p><p><img src="http://img.fdchen.host/Job%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="Job提交流程图解"></p><center>图3.2 Job提交流程图解</center><ol start="2"><li><strong>FileInputFormat切片源码解析(input.getSplits(job))</strong></li></ol><p>（1）<strong>程序先找到数据存储的目录。</strong><br>（2）<strong>开始遍历处理（规划切片）目录下的每一个文件。</strong><br>（3）<strong>遍历第一个文件ss.txt</strong></p><ul><li>获取文件大小fs.sizeOf(ss.txt)；</li><li>计算切片大小；<br>computeSplitSize(Math.max(minSize, Math.min(maxSize, blocksze)))&#x3D;blocksize&#x3D;128M</li><li>默认情况下，切片大小&#x3D;blodksize；</li><li>开始切，形成第1个切片: ss.txt—0:128M第2个切片ss.txt—128:256M第3个切片ss.txt—256M:300M；<br>(每次切片时，都要判断切完剩下的部分是否大于块的1.1倍，不大于1.1倍就划分成一块切片</li><li>将切片信息写到一个切片规划文件中；</li><li>整个切片的核心过程在getSplit()方法中完成；</li><li>lnputSplit只记录了切片的元数据信息，比如起始位置、长度以及所在的节点列表等。</li></ul><p>（4）<strong>提交切片规划文件到YARN上，YARN上的MapReducer就可以很据切片规划文件计算开启MapTask个数。</strong></p><p><strong>Tip：本地模式的BlockSize为32M，Hadoop 1.x为64M，Hadoop 2.x为128M。</strong></p><h3 id="3-1-3-FileInputFormat切片机制"><a href="#3-1-3-FileInputFormat切片机制" class="headerlink" title="3.1.3 FileInputFormat切片机制"></a>3.1.3 FileInputFormat切片机制</h3><ol><li><strong>切片机制</strong></li></ol><p>（1）简单地按照文件的内容长度进行切片；</p><p>（2）切片大小，默认等于Block大小；</p><p>（3）切片时不考虑数据集整体，而是逐个针对每一个文件单独切片。</p><ol start="2"><li><strong>FileInputFormat切片大小的参数配置</strong></li></ol><p>（1）<strong>源码中计算切片大小的公式</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>minSize<span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>maxSize<span class="token punctuation">,</span>blockSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// mapreduce.input.fileinputformat.split.minize=1，默认值为1</span><span class="token comment">// mapreduce.input.fileinputformat.split.maxsize=Long.MAXValue，默认值是Long.MAXValue</span><span class="token comment">// 默认情况下，切片大小=blockSize</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）<strong>切片大小设置</strong></p><p>maxsize（切片最大值）：参数如果调得比blockSize小，则会让切片变小，而且就等于配置的这个参数的值。</p><p>minsize（切片最小值）参数如果调得比blocksize大，则可以让切片变得比blockSize还大。</p><p>（3）<strong>获取切片信息API</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取切片的文件名称</span><span class="token class-name">String</span> name <span class="token operator">=</span> inputSplit<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据文件类型获取切片信息</span><span class="token class-name">FileSplit</span> inputSplit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">FileSplit</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span><span class="token function">getInputSplit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-4-CombineTextInputFormat切片机制"><a href="#3-1-4-CombineTextInputFormat切片机制" class="headerlink" title="3.1.4 CombineTextInputFormat切片机制"></a>3.1.4 CombineTextInputFormat切片机制</h3><p>框架默认的TextInputFormat切片机制是对任务按文件规划切片，<strong>不管文件多小，都会是一个单独的切片</strong>，都会交给一个MapTask，这样<strong>如果有大量小文件，就会产生大量的MapTask</strong>，处理效率极其低下。</p><ol><li><strong>应用场景</strong></li></ol><p>CombineTextInputFormat用于小文件过多的场景，它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个MapTask处理。</p><ol start="2"><li><strong>虚拟存储切片最大值设置</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token function">setMaxInputSplitSize</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">4194304</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 4m</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Tip：虚拟存储切片最大值设置最好根据实际的小文件大小分布情况来设置具体的值。</strong></p><ol start="3"><li><strong>切片机制</strong></li></ol><ul><li>生成切片过程包括：<strong>虚拟存储过程和切片过程二部分</strong>。</li></ul><p><img src="http://img.fdchen.host/CombineTextInputFormat%E5%88%87%E7%89%87%E6%9C%BA%E5%88%B6.png" alt="CombineTextInputFormat切片机制"></p><center>图3.3 CombineTextInputFormat切片机制</center><p>（1）<strong>虚拟存储过程：</strong></p><p>将输入目录下所有文件大小，依次和设置的setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。<strong>如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值2倍，此时将文件均分成2个虚拟存储块（防止出现太小切片）。</strong><br>例如setMaxInputSplitSize值为4M，输入文件大小为8.02M，则先逻辑上分成一个4M。剩余的大小为4.02M，如果按照4M逻辑划分，就会出现0.02M的小的虚拟存储文件，所以将剩余的4.02M文件切分成（2.01M和2.01M）两个文件。</p><p>（2）<strong>切片过程：</strong></p><p>（a）判断虚拟存储的文件大小是否大于setMaxInputSplitSize值，大于等于则单独形成一个切片。<br>（b）如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。<br>（c）测试举例：有4个小文件大小分别为1.7M、5.1M、3.4M以及6.8M这四个小文件，则虚拟存储之后形成6个文件块，大小分别为：<br>1.7M，（2.55M、2.55M），3.4M以及（3.4M、3.4M）<br>最终会形成3个切片，大小分别为：<br>（1.7+2.55）M，（2.55+3.4）M，（3.4+3.4）M</p><h3 id="3-1-5-CombineTextInputFormat案例实操"><a href="#3-1-5-CombineTextInputFormat案例实操" class="headerlink" title="3.1.5 CombineTextInputFormat案例实操"></a>3.1.5 CombineTextInputFormat案例实操</h3><ol><li><strong>需求：</strong>将输入的大量小文件合并成一个切片统一处理。</li></ol><p>（1）输入数据：准备4个小文件</p><p>（2）期望：期望1个切片处理4个文件</p><ol start="2"><li><strong>实现过程</strong></li></ol><p>（1）<strong>不做任何处理，运行WordCount案例程序（自行准备4个小文件，大小对应3.1.4节中四个小文件大小），在控制台观察打印信息，显示切片个数为4。</strong></p><pre class="line-numbers language-none"><code class="language-none">number of splits:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）<strong>在WordcountDriver中增加如下代码，运行程序，并观察运行的切片个数为3。</strong></p><ul><li>在驱动类中添加代码如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 如果不设置InputFormat，它默认用的是TextInputFormat.class</span>job<span class="token punctuation">.</span><span class="token function">setInputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//虚拟存储切片最大值设置4m</span><span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token function">setMaxInputSplitSize</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">4194304</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在控制台观察打印信息，运行结果为3个切片</li></ul><pre class="line-numbers language-none"><code class="language-none">number of splits:3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）<strong>在WordcountDriver中增加如下代码，运行程序，并观察运行的切片个数为1。</strong></p><ul><li>在驱动类中添加代码如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 如果不设置InputFormat，它默认用的是TextInputFormat.class</span>job<span class="token punctuation">.</span><span class="token function">setInputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">CombineTextInputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//虚拟存储切片最大值设置20m</span><span class="token class-name">CombineTextInpu</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在控制台观察打印信息，运行结果为3个切片</li></ul><pre class="line-numbers language-none"><code class="language-none">number of splits:1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-1-6-FileInputFormat实现类"><a href="#3-1-6-FileInputFormat实现类" class="headerlink" title="3.1.6 FileInputFormat实现类"></a>3.1.6 FileInputFormat实现类</h3><ul><li><strong>Q：</strong>在运行MapReduce程序时，输入的文件格式包括:基于行的日志文件、二进制格式文件、数据库表等。那么，针对不同的数据类型，MapReduce是如何读取这些数据的呢?</li><li><strong>A：</strong>FileInputFormat常见的接口实现类包括：<strong>TextInputFormat 、KeyValueTextInputFormat、NLineInputF ormat、CombineTextInputFormat和自定义InputFormat</strong>等。</li></ul><p><strong>Tip：在Eclipse中点击FileInputFormat类，然后按下“CTRL+T”可查看FileInputFormat类的层级结构，如图3.4：</strong></p><p><img src="http://img.fdchen.host/FileInputFormat%E7%B1%BB%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.jpg" alt="FileInputFormat类的层级结构"></p><center>图3.4 FileInputFormat类的层级结构</center><ol><li><strong>TextInputFormat</strong></li></ol><ul><li><p>TextInputFormat是默认的FileIrputFormat实现类。<strong>按行读取每条记录。键是存储该行在整个文件中的起始字节偏移量（相对于文档开始位置的偏移量，包括换行符和回车符），LongWritable类型。值是这行的内容，不包括任何行终止符（换行符和回车符〉，Text类型。</strong></p></li><li><p>文本示例如下：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">Rich learning formIntelligent learning engineLearning more convenientFrom the real demand for more close to the enterprise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>每条记录表示为以下键&#x2F;值对：</li></ul><pre class="line-numbers language-none"><code class="language-none">(0,Rich learning form)(19,Intelligent learning engine)(47,Learning more convenient)(72,From the real demand for more close to the enterprise)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>KeyValueFormat实现类</strong></li></ol><ul><li>每一行均为一条记录，被分隔符分割为key , value。可以通过在驱动类中设置conf.set(KeyValueLineRecordReaderKEY_VALUE_SEFERATOR,”\t”);来设定分隔符。默认分隔符是tab (\t)。</li><li>以下是一个示例，输入是一个包含4条记录的分片。其中——&gt;表标一个(水平方向的)制表符。</li></ul><pre class="line-numbers language-none"><code class="language-none">linel——&gt;Rich learning formlinez——&gt;Intelligent learning engineline3——&gt;Learning more convenientline4——&gt;From the real demand for more close to the enterprise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>每条记录表示为以下键&#x2F;值对</li></ul><pre class="line-numbers language-none"><code class="language-none">(linel,Rich learning form )(line2,Intelligent learning enginej)(line3,Learning more convenient)(line4,From the real demand for more close to the enterprise)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip：此时的键是每行排在分隔符（制表符）之前的Text序列。</strong></p><ol start="3"><li><strong>NLineInputFormat</strong></li></ol><ul><li>如果使用NlineInputFormat，代表每个map进程处理的InputSplit不再按Block块去划分，而是按NineInptFormat指定的行数N味划分。即输入文件的总行数N&#x3D;切片数，如果不整除，切片数&#x3D;商+1。</li><li>以下是一个示例，仍然以上面的4行输入为例：</li></ul><pre class="line-numbers language-none"><code class="language-none">Rich learning formIntelligent learning engineLearning more convenientFrom the real demand for more close to the enterprise<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>例如，如果N是2，则每个输入分片包含2行，开启两个MapTask。</li></ul><pre class="line-numbers language-none"><code class="language-none">(0,Rich learning form)(19,Intelligent learning engine)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(47,Learning more convenient)(72,From the real demand for more close to the enterprise)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Tip：这里的键和值与TextInputFormat生成的一样。</strong></p><h3 id="3-1-7-KeyValueTextInputFormat使用案例"><a href="#3-1-7-KeyValueTextInputFormat使用案例" class="headerlink" title="3.1.7 KeyValueTextInputFormat使用案例"></a>3.1.7 KeyValueTextInputFormat使用案例</h3><ol><li><strong>需求：</strong>统计输入文件每一行的第一个单词相同的行数。</li></ol><p>（1）输入数据</p><pre class="line-numbers language-none"><code class="language-none">banzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）期望结果数据</p><pre class="line-numbers language-none"><code class="language-none">banzhang2xihuan2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><strong>案例分析</strong></li></ol><p><img src="http://img.fdchen.host/KeyValueTextInputFormat%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="KeyValueTextInputFormat使用案例分析"></p><center>图3.5 KeyValueTextInputFormat使用案例分析</center><ol start="3"><li><strong>编写代码</strong></li></ol><p>（1）编写Mapper类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KVTextMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token comment">// 1 封装对象</span><span class="token class-name">LongWritable</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 输入数据格式：bangzhang ni hao</span><span class="token comment">// 2 写出</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）编写Reducer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KVTextReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">LongWritable</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 输入数据格式：&lt;bangzhang, 1></span><span class="token comment">// 1 求和统计</span><span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// get()方法获取LongWritable类型的值</span>sum <span class="token operator">+=</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 输出</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）编写Driver类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token comment">// 以下jar包务必保证正确，采用mapreduce下的jar包，mapred下的jar包已经过时</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">KeyValueLineRecordReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">KeyValueTextInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KVTextDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 本地模式下设置输入输出路径</span>args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"d:/input/inputKVText"</span><span class="token punctuation">,</span><span class="token string">"d:/outputKVText"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置切割符号为空格</span>conf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">KeyValueLineRecordReader</span><span class="token punctuation">.</span>KEY_VALUE_SEPERATOR<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1  获取job对象</span><span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 设置jar包位置</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">KVTextDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关联Mapper类和Reducer类</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">KVTextMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">KVTextReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 设置Map阶段输出数据的key-value类型</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 设置最终输出数据的key-value类型</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 设置输入输出数据路径</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置输入格式</span>job<span class="token punctuation">.</span><span class="token function">setInputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">KeyValueTextInputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 7 提交</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result<span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-8-NLineInputFormat使用案例"><a href="#3-1-8-NLineInputFormat使用案例" class="headerlink" title="3.1.8 NLineInputFormat使用案例"></a>3.1.8 NLineInputFormat使用案例</h3><ol><li><strong>需求：</strong>对每个单词进行个数统计，要求根据每个输入文件的行数来规定输出多少个切片。此案例要求每三行放入一个切片中。</li></ol><p>（1）输入数据</p><pre class="line-numbers language-none"><code class="language-none">banzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhang banzhang ni haoxihuan hadoop banzhang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）期望输出数据</p><pre class="line-numbers language-none"><code class="language-none">控制台显示：Number of splits:4文件输出：banzhang12hadoop6hao6ni6xihuan6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>需求分析</strong></li></ol><p><img src="http://img.fdchen.host/NLineInputFormat%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="NLineInputFormat案例分析"></p><center>图3.6 NLineInputFormat案例分析</center><p>3 <strong>代码实现</strong></p><p>（1）编写Mapper类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NLineTextMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token comment">// 定义输出键值对</span><span class="token class-name">Text</span> k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LongWritable</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 输入数据格式 Rich learning form</span><span class="token comment">// 1 获取一行</span><span class="token class-name">String</span> line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 按照空格切分</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> splits <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 循环写出</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>splits<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>k<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>splits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）编写Reducer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token comment">// Reduce</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NLineTextReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">LongWritable</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 输入数据格式：&lt;Rich,1> &lt;learning,1></span><span class="token comment">// 1 汇总求和</span><span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 输出</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）编写Driver类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">NLineInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NLineTextDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>args<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"d:/input/inputNLineText"</span><span class="token punctuation">,</span><span class="token string">"d:/outputNLineText"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1 获取job对象</span><span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 设置jar包位置</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">NLineTextDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关联Mapper和Reducer类</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">NLineTextMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">NLineTextReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 设置Mpper阶段的输出key-value数据格式</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 设置最终输出key-value数据格式</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 设置输入输出路径，注意修改输入格式</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置输入格式</span>job<span class="token punctuation">.</span><span class="token function">setInputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">NLineInputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置每个切片划分三行记录</span><span class="token class-name">NLineInputFormat</span><span class="token punctuation">.</span><span class="token function">setNumLinesPerSplit</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 7 提交</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result<span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）<strong>测试</strong></p><ul><li>输入数据如下</li></ul><pre class="line-numbers language-none"><code class="language-none">banzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhangbanzhang ni haoxihuan hadoop banzhang banzhang ni haoxihuan hadoop banzhang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制台运行结果如下</li></ul><p><img src="http://img.fdchen.host/NLineInputFormat%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%88%AA%E5%9B%BE.jpg" alt="NLineInputFormat使用案例运行截图"></p><center>图3.7 NLineInputFormat使用案例运行截图</center><ul><li>输出结果如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">banzhang12hadoop6hao6ni6xihuan6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-9-自定义InputFormat"><a href="#3-1-9-自定义InputFormat" class="headerlink" title="3.1.9 自定义InputFormat"></a>3.1.9 自定义InputFormat</h3><ul><li>在企业开发中，Hadoop框架自带的InputF ormmat类型不能满足所有应用场，需要自定义InputFormat来解决实际问题。</li><li>自定义InputFormat步骡如下:<br>（1）自定义一个类继承FileInputFormat。<br>（2）改写RecordReader，实现一次读取一个完整文件封装为KV。<br>（3）在输出时使用SequenceFileOutPutFormat输出合并文件。</li></ul><h3 id="3-1-10-自定义InputFormat案例实操"><a href="#3-1-10-自定义InputFormat案例实操" class="headerlink" title="3.1.10 自定义InputFormat案例实操"></a>3.1.10 自定义InputFormat案例实操</h3><ul><li>无论HDFS还是MapReduce，在处理小文件时效率都非常低，但又难免面临处理大量小文件的场景，此时，就需要有相应解决方案。可以自定义InputFormat实现小文件的合并。</li></ul><ol><li><strong>需求</strong></li></ol><p>将多个小文件合并成一个SequenceFile文件（<strong>SequenceFile文件是Hadoop用来存储二进制形式的key-value对的文件格式</strong>），SequenceFile里面存储着多个文件，<strong>存储的形式为文件路径+名称为key，文件内容为value</strong>。</p><p>（1）输入数据</p><ul><li>三个小文件：<a href="http://img.fdchen.host/one.txt">one.txt</a>，<a href="http://img.fdchen.host/two.txt">two.txt</a>，<a href="http://img.fdchen.host/three.txt">three.txt</a></li></ul><p>（2）期望输出文件格式，SequenceFile文件</p><ul><li><a href="http://img.fdchen.host/WholeFileInputFormat-part-r-00000">part-0000</a></li></ul><p>内容如下</p><pre class="line-numbers language-none"><code class="language-none">SEQorg.apache.hadoop.io.Text&quot;org.apache.hadoop.io.BytesWritable      ?奀Wu授X@鼧?   W   &quot;!file:&#x2F;e:&#x2F;inputinputformat&#x2F;one.txt   1yongpeng weidong weinansanfeng luozong xiaoming   Y   $#file:&#x2F;e:&#x2F;inputinputformat&#x2F;three.txt   1shuaige changmo zhenqiang dongli lingu xuanxuan   €   &quot;!file:&#x2F;e:&#x2F;inputinputformat&#x2F;two.txt   Zlonglong fanfanmazong kailun yuhang yixinlonglong fanfanmazong kailun yuhang yixin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>需求分析</strong></li></ol><p><img src="http://img.fdchen.host/%E8%87%AA%E5%AE%9A%E4%B9%89InputFormat%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.png" alt="自定义InputFormat案例分析"></p><center>图3.8 自定义InputFormat案例分析</center><ol start="3"><li><strong>程序实现</strong></li></ol><p>（1）自定义InputFormat</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BytesWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">InputSplit</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">JobContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">RecordReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">TaskAttemptContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WholeFileInputFormat</span> <span class="token keyword">extends</span> <span class="token class-name">FileInputFormat</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token comment">// 一定不能漏</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isSplitable</span><span class="token punctuation">(</span><span class="token class-name">JobContext</span> context<span class="token punctuation">,</span> <span class="token class-name">Path</span> filename<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">RecordReader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">></span></span> <span class="token function">createRecordReader</span><span class="token punctuation">(</span><span class="token class-name">InputSplit</span> split<span class="token punctuation">,</span> <span class="token class-name">TaskAttemptContext</span> context<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token class-name">WholeRecordReader</span> recordReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WholeRecordReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>recordReader<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> recordReader<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）自定义RecordReader类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">FSDataInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">FileSystem</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BytesWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOUtils</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">InputSplit</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">RecordReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">TaskAttemptContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileSplit</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WholeRecordReader</span> <span class="token keyword">extends</span> <span class="token class-name">RecordReader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">FileSplit</span> split<span class="token punctuation">;</span><span class="token class-name">Configuration</span> configuration<span class="token punctuation">;</span><span class="token class-name">Text</span> k <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BytesWritable</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isProgress<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 依据map源码设置</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">InputSplit</span> split<span class="token punctuation">,</span> <span class="token class-name">TaskAttemptContext</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 初始化</span><span class="token keyword">this</span><span class="token punctuation">.</span>split<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">FileSplit</span><span class="token punctuation">)</span>split<span class="token punctuation">;</span><span class="token comment">// 通过上下文获取配置信息</span>configuration <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">nextKeyValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 核心业务逻辑处理</span><span class="token keyword">if</span><span class="token punctuation">(</span>isProgress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>split<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 1  获取fs对象</span><span class="token class-name">Path</span> path <span class="token operator">=</span> split<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">getFileSystem</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2  获取输入流</span><span class="token class-name">FSDataInputStream</span> fis <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 拷贝</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">readFully</span><span class="token punctuation">(</span>fis<span class="token punctuation">,</span> buf <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 封装v</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 封装k</span>k<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 关闭资源</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>isProgress<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Text</span> <span class="token function">getCurrentKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">BytesWritable</span> <span class="token function">getCurrentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getProgress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated method stub</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token comment">// TODO Auto-generated method stub</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip：依据Mapper类的run函数源码，需要设置标志位来保证nextKeyValue只执行一次，即保证一个文件只读取一次。run函数源码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>  <span class="token function">setup</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">nextKeyValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">map</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getCurrentKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getCurrentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token function">cleanup</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）编写Mapper类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BytesWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputFormatMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span><span class="token class-name">BytesWritable</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 直接写出</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）编写Reducer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BytesWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputFormatReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">BytesWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BytesWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 循环写出</span>        <span class="token comment">// 因为Driver类中设置的输出类是SequenceFileOutputFormat类，所以Reducer输出只需要按文件名-文件内容的键值对形式输出即可</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">BytesWritable</span> value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（5）编写Driver类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BytesWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">SequenceFileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputFormatDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 输入输出路径需要根据自己电脑上实际的输入输出路径设置</span>args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"d:/input/inputInputFormat"</span><span class="token punctuation">,</span> <span class="token string">"d:/outputInputFormat"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token comment">// 1 获取job对象</span><span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 2 设置jar包存储位置、关联自定义的mapper和reducer</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">InputFormatDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">InputFormatMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">InputFormatReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 7 设置输入的inputFormat，设置为自定义的InputFormat类</span>job<span class="token punctuation">.</span><span class="token function">setInputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">WholeFileInputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 8 设置输出的outputFormat，设置为SequenceFileOutputFormat类</span>job<span class="token punctuation">.</span><span class="token function">setOutputFormatClass</span><span class="token punctuation">(</span><span class="token class-name">SequenceFileOutputFormat</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 3 设置map输出端的kv类型</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">BytesWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 4 设置最终输出端的kv类型</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">BytesWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 5 设置输入输出路径</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 6 提交job</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-MapReduce工作流程"><a href="#3-2-MapReduce工作流程" class="headerlink" title="3.2 MapReduce工作流程"></a>3.2 MapReduce工作流程</h2><h3 id="3-2-1-MapReduce工作流程示意图"><a href="#3-2-1-MapReduce工作流程示意图" class="headerlink" title="3.2.1 MapReduce工作流程示意图"></a>3.2.1 MapReduce工作流程示意图</h3><p><img src="http://img.fdchen.host/MapReduce%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89.png" alt="MapReduce工作流程（一）"></p><center>图3.9 MapReduce工作流程（一）</center><p><img src="http://img.fdchen.host/MapReduce%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89.png" alt="MapReduce工作流程（二）"></p><center>图3.10 MapReduce工作流程（二）</center><h3 id="3-2-2-MapReduce工作流程详解"><a href="#3-2-2-MapReduce工作流程详解" class="headerlink" title="3.2.2 MapReduce工作流程详解"></a>3.2.2 MapReduce工作流程详解</h3><p>上面的流程是整个MapReduce最全工作流程，但是Shuffle过程只是从第7步开始到第16步结束，具体Shuffle过程详解，如下：</p><ol><li>MapTask收集我们的map()方法输出的kv对，放到内存缓冲区中；</li><li>从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件；</li><li>多个溢出文件会被合并成大的溢出文件；</li><li>在溢出过程及合并的过程中，都要调用Partitioner进行分区和针对key进行排序；</li><li>ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据；</li><li>ReduceTask会取到同一个分区的来自不同MapTask的结果文件，ReduceTask会将这些文件再进行合并（归并排序）；</li><li>合并成大文件后，Shuffle的过程也就结束了，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Group，调用用户自定义的reduce()方法）</li></ol><h3 id="3-2-3-注意点"><a href="#3-2-3-注意点" class="headerlink" title="3.2.3 注意点"></a>3.2.3 注意点</h3><ol><li><p>Shuffle中的缓冲区大小会影响到MapReduce程序的执行效率，原则上说，缓冲区越大，<strong>磁盘IO的次数越少，执行速度就越快</strong>。</p></li><li><p>缓冲区的大小可以通过参数调整，参数：io.sort.mb默认100M。</p></li></ol><h3 id="3-2-4-源码解析工作流程"><a href="#3-2-4-源码解析工作流程" class="headerlink" title="3.2.4 源码解析工作流程"></a>3.2.4 源码解析工作流程</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 按照层级结构依次调用的主要函数如下</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token class-name">NullWritable</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>collector<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span>partitioner<span class="token punctuation">.</span><span class="token function">getPartition</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> partitions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">HashPartitioner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>collect<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">sortAndSpill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token class-name">QuickSort</span><span class="token function">mergeParts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collector<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-Shuffle机制"><a href="#3-3-Shuffle机制" class="headerlink" title="3.3 Shuffle机制"></a>3.3 Shuffle机制</h2><h3 id="3-3-1-Shuffle机制"><a href="#3-3-1-Shuffle机制" class="headerlink" title="3.3.1 Shuffle机制"></a>3.3.1 Shuffle机制</h3><ul><li>Map方法之后，Reduce方法之前的数据处理过程称之为Shuffle。如图3.11所示：</li></ul><p><img src="http://img.fdchen.host/Shuffle%E6%9C%BA%E5%88%B6.png" alt="Shuffle机制"></p><center>图3.11 Shuffle机制</center><h3 id="3-3-2-Partition分区"><a href="#3-3-2-Partition分区" class="headerlink" title="3.3.2 Partition分区"></a>3.3.2 Partition分区</h3><ol><li><strong>分区概念：</strong>将统计结果输出到不同文件中（分区）。</li><li><strong>默认Partition分区</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashPartitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token keyword">extends</span> <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">R</span> key<span class="token punctuation">,</span> v value<span class="token punctuation">,</span> <span class="token keyword">int</span> numReduceTasks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span>hashCode <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> <span class="token operator">%</span> numReduceTasks<span class="token punctuation">;</span>        <span class="token comment">// key.hashCode () &amp; Integer.MAX_VALUE是为了控制hashCode在int类型的取值范围内</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>默认分区是根据key日的hashCode对ReduceTasks个数取模得到的。用户没法控制哪个key存储到哪个分区。</li></ul><ol start="3"><li><strong>自定义Partition步骤</strong></li></ol><p>（1）自定义类继承Partitioner，重写getPartition()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// kv类型为map阶段输出数据的kv类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustonPartitioner</span> cxtends <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span><span class="token class-name">Flowbean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key，<span class="token class-name">FlowBean</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> numPartitions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 控制分区代码逻辑</span>        ······<span class="token keyword">return</span> partition<span class="token punctuation">;</span> <span class="token comment">// 分区索引从0开始计算</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在Job驱动中，设置自定义Partitioner</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">job<span class="token punctuation">.</span><span class="token function">setPartitionerClass</span><span class="token punctuation">(</span><span class="token class-name">CustomPartitioner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）自定义Patition后，要根据自定义Partitiorer的逻辑设置相应数量的ReduceTask</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">job<span class="token punctuation">.</span><span class="token function">setNumReduceTasks</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><strong>分区总结</strong></li></ol><p>（1）如果<strong>ReduceTask的数量 &gt; getPatitian的结果数</strong>，则会多产生几个空的输出文件part-r-000xx；</p><p>（2）如果<strong>1&lt;ReduceTask的数量&lt;getPartition的结果数</strong>，则有一部分分区数据无处安放，会报错Exception；</p><p>（3）如果<strong>ReduceTask的数量&#x3D;1</strong>，则不管MapTask端输出多少个分区文件，最终结果都交给一个ReduceTask，最终也就具会产生一个结果文件part-r-00000；</p><p>（4）<strong>分区号必须从零开始，逐一累加。</strong></p><ol start="5"><li><strong>案例分析</strong></li></ol><p>例如：假设自定义分区数为5，则<br>（1）job.setNumReduceTasks(1)，会正常运行，只不过会产生一个输出文件；</p><p>（2）job.setNumReduceTasks2)，会报错；</p><p>（3）job.setNumReduceTasks(6)；大于5，程序会正常运行，会产生空文件。</p><h3 id="3-3-3-Partition分区案例"><a href="#3-3-3-Partition分区案例" class="headerlink" title="3.3.3 Partition分区案例"></a>3.3.3 Partition分区案例</h3><ol><li><strong>需求：</strong>将统计结果按照手机归属地不同省份输出到不同文件中（分区）。</li></ol><p>（1）输入数据：<a href="http://img.fdchen.host/phone_data.txt">phone_data.txt</a></p><p>（2）期望输出数据：手机号136、137、138、139开头都分别放到一个独立的4个文件中，其他开头的放到一个文件中。</p><ol start="2"><li><strong>需求分析</strong></li></ol><p>（1）增加一个ProvicePartitioner进行自定义分区</p><pre class="line-numbers language-none"><code class="language-none">136分区0137分区1138分区2139分区3其他分区4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）Driver驱动类修改</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 指定自定义数据分区</span>job<span class="token punctuation">.</span><span class="token function">setPartitionerClass</span><span class="token punctuation">(</span><span class="token class-name">ProvincePartitioner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 指定ReduceTask个数</span>job<span class="token punctuation">.</span><span class="token function">setNumReduceTasks</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>代码实现</strong></li></ol><p>（1）增加一个分区类ProvicePartitioner</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Partitioner</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProvincePartitioner</span> <span class="token keyword">extends</span> <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span><span class="token class-name">FlowBean</span> value<span class="token punctuation">,</span><span class="token keyword">int</span> numPartition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取电话号码的前三位</span><span class="token class-name">String</span> preNum<span class="token operator">=</span>key<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> partition<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 2 判断是哪个省</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"136"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"137"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"138"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"139"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> partition<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在驱动类中添加以下内容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 设置partition类</span>job<span class="token punctuation">.</span><span class="token function">setPartitionerClass</span><span class="token punctuation">(</span><span class="token class-name">ProvincePartitioner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置ReduceTask个数</span>job<span class="token punctuation">.</span><span class="token function">setNumReduceTasks</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-4-WritableComparable排序"><a href="#3-3-4-WritableComparable排序" class="headerlink" title="3.3.4 WritableComparable排序"></a>3.3.4 WritableComparable排序</h3><ol start="0"><li><strong>排序概述</strong></li></ol><p>（1）排序是MapReduce框架中最重要的操作之一。</p><p>（2）MapTask和ReduceTask均会对数据<strong>按照key进行排序</strong>。该操作属于Hadoop的默认行为。<strong>任何应用程序中的数据均会被排序，而不管逻辑上是否需要。</strong></p><p>（3）默认排序是<strong>按照字典顺序排序</strong>，且<strong>实现该排序的方法是快速排序</strong>。</p><p>（4）对于MapTask，它会将处理的结果暂时放到环形缓冲区中，<strong>当环形缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次快速排序</strong>，并将这些有序数据溢写到磁盘上，而<strong>当数据处理完毕后，它会对磁盘上所有文件进行归并排序</strong>。<br>（5）对于ReduceTask，它从每个MapTask上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则溢写磁盘上，否则存储在内存中。如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据溢写到磁盘上；<strong>如果磁盘上文件数目达到一定阈值，则进行一次归并排序以生成一个更大文件（意味着如果文件不够多此部分可能没有）。当所有数据拷贝完毕后，ReduceTask统一对内存和磁盘上的所有数据进行一次归并排序。</strong></p><ol><li><strong>排序的分类</strong></li></ol><p>（1）<strong>部分排序</strong><br>MapReduce根据输入记录的键对数据集排序。保证输出的每个文件内部有序。<br>（2）<strong>全排序</strong><br>最终输出结果只有一个文件，且文件内部有序。实现方式是只设置一个ReduceTask。但该方法在处理大型文件时效率极低，因为一台机器处理所有文件，完全丧失了MapReduwe所提供的并行构。<br>（3）<strong>辅助排序（GroupingCormparator分组）</strong><br>在Reduce端对key进行分组。应用于：在接收的key为bean对象时，想让一个或几个字段相同（全部字段比较不相同）的key进入到同一个reduce方法时，可以采用分组非序。<br>（4）<strong>二次排序</strong><br>在自定义排序过程中，如果compareTo中的判断条件为两个即为二次排序。</p><ol start="2"><li><strong>自定义排序WritableComparable</strong></li></ol><p>（1）bean对象做为key传输，需要实现WritableComparable接口重写compareTo方法，以实现排序。</p><p>（2）重写compareTo方法示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token comment">// 按照总流量大小，倒序排列</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sumFlow <span class="token operator">></span> bean<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sumFlow <span class="token operator">&lt;</span> bean<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-5-WritableComparable排序案例实操（全排序）"><a href="#3-3-5-WritableComparable排序案例实操（全排序）" class="headerlink" title="3.3.5 WritableComparable排序案例实操（全排序）"></a>3.3.5 WritableComparable排序案例实操（全排序）</h3><ol><li><strong>需求：</strong>根据电话流量数据再次对总流量进行排序。</li></ol><p>（1）输入数据：<a href="http://img.fdchen.host/phone_data.txt">phone_data</a></p><p>（2）期望输出数据</p><pre class="line-numbers language-none"><code class="language-none">13509468723733511034911768413736230513248124681271621395643563613215121644138465441212640264······<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>需求分析</strong></li></ol><p>（1）FlowBean实现WritableComparable接口重新compareTo方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> bean<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token comment">// 核心比较条件判断</span><span class="token comment">// 按照总流量大小，倒序排列</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sumFlow <span class="token operator">></span> bean<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sumFlow <span class="token operator">&lt;</span> bean<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）Mapper类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span>phoneNum<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）Reudcer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 循环输出，避免总流量相同情况</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Text</span> text<span class="token operator">:</span>values<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>代码实现</strong></li></ol><p>（1）FlowBean增加比较方法（重写之前的类，实现WritableComparable接口）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataInput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataOutput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">WritableComparable</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowBean</span> <span class="token keyword">implements</span> <span class="token class-name">WritableComparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FlowBean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">long</span> upFlow<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">long</span> downFlow<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">long</span> sumFlow<span class="token punctuation">;</span><span class="token comment">// 反序列化时，需要反射调用空参构造函数</span><span class="token keyword">public</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token keyword">long</span> upFlow<span class="token punctuation">,</span> <span class="token keyword">long</span> downFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>upFlow <span class="token operator">=</span> upFlow<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>downFlow <span class="token operator">=</span> downFlow<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow<span class="token operator">=</span>upFlow<span class="token operator">+</span>downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">long</span> upFlow<span class="token punctuation">,</span><span class="token keyword">long</span> downFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>upFlow<span class="token operator">=</span>upFlow<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>downFlow<span class="token operator">=</span>downFlow<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow<span class="token operator">=</span>upFlow<span class="token operator">+</span>downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getUpFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> upFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUpFlow</span><span class="token punctuation">(</span><span class="token keyword">long</span> upFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>upFlow <span class="token operator">=</span> upFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDownFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDownFlow</span><span class="token punctuation">(</span><span class="token keyword">long</span> downFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>downFlow <span class="token operator">=</span> downFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> sumFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSumFlow</span><span class="token punctuation">(</span><span class="token keyword">long</span> sumFlow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>sumFlow <span class="token operator">=</span> sumFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * TASK 序列化方法 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">DataOutput</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>upFlow<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>downFlow<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeLong</span><span class="token punctuation">(</span>sumFlow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * TASK 反序列化方法 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFields</span><span class="token punctuation">(</span><span class="token class-name">DataInput</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>upFlow<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>downFlow<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sumFlow<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> upFlow<span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>downFlow<span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span>sumFlow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> bean<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token comment">// 核心比较条件判断</span><span class="token comment">// 按照总流量大小，倒序排列</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sumFlow <span class="token operator">></span> bean<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sumFlow <span class="token operator">&lt;</span> bean<span class="token punctuation">.</span><span class="token function">getSumFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）编写Mapper类（重写之前的类，修改输出数据key和value的数据类型）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCountSortMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">FlowBean</span> bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlowBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Text</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取一行</span><span class="token class-name">String</span> line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 截取</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 封装对象</span><span class="token comment">// 取出手机号码</span><span class="token class-name">String</span> phoneNum <span class="token operator">=</span> fields<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 取出上行流量和下行流量</span><span class="token keyword">long</span> upFlow <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>fields<span class="token punctuation">[</span>fields<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> downFlow <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>fields<span class="token punctuation">[</span>fields<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 不能仅仅设置sumFlow，因为bean对象在序列化时，变量必须有值</span>bean<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>upFlow<span class="token punctuation">,</span> downFlow<span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>phoneNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 输出，注意此时key-value的数据类型，总流量为key，电话号码为value</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）编写Reducer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCountSortReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FlowBean</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">FlowBean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 循环输出，避免总流量相同情况（总流量相同时，values的值有多个）</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Text</span> text <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 注意此时输出key-value的数据类型，与map阶段的数据类型相反</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）编写Driver类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCountSortDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 输入输出路径需要根据自己电脑上实际的输入输出路径设置</span>args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"d:/input/inputFlow"</span><span class="token punctuation">,</span><span class="token string">"d:/outputFlowCountSort"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 1 获取配置信息，或者job对象实例</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 指定本程序的jar包所在的本地路径</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">FlowCountSortDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 指定本业务job要使用的mapper/Reducer业务类</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">FlowCountSortMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">FlowCountSortReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 指定mapper输出数据的kv类型</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 指定最终输出的数据的kv类型</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 指定job的输入原始文件所在目录</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 7 将job中配置的相关参数，以及job所用的java类所在的jar包， 提交给yarn去运行</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>总结</strong></li></ol><ul><li><strong>要实现依据总流量排序，在Map阶段的排序即可完成；</strong></li><li><strong>Reduce阶段的排序保证按规定顺序输出。</strong></li></ul><h3 id="3-3-6-WritableComparable排序案例实操（区内排序）"><a href="#3-3-6-WritableComparable排序案例实操（区内排序）" class="headerlink" title="3.3.6 WritableComparable排序案例实操（区内排序）"></a>3.3.6 WritableComparable排序案例实操（区内排序）</h3><ol><li><strong>需求：</strong>要求每个省份手机号输出的文件中按照总流量内部排序。。</li><li><strong>需求分析</strong></li></ol><ul><li><p>基于上一个需求（全排序），增加自定义分区类，分区按照省份手机号设置。</p></li><li><p>输入输出示例如图3.12：</p></li></ul><p><img src="http://img.fdchen.host/WritableComparable%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B%EF%BC%88%E5%8C%BA%E5%86%85%E6%8E%92%E5%BA%8F%EF%BC%89%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B.png" alt="WritableComparable排序案例（区内排序）输入输出示例"></p><center>图3.12 WritableComparable排序案例（区内排序）输入输出示例</center><ol start="3"><li><strong>代码实现</strong></li></ol><p>（1）添加自定义分区类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Partitioner</span><span class="token punctuation">;</span><span class="token comment">// 注意key-value类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProvincePartitioner</span> <span class="token keyword">extends</span> <span class="token class-name">Partitioner</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FlowBean</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPartition</span><span class="token punctuation">(</span><span class="token class-name">FlowBean</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> numPartition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取电话号码的前三位</span><span class="token class-name">String</span> preNum<span class="token operator">=</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> partition<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 2 判断是哪个省</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"136"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"137"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"138"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"139"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>preNum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>partition<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> partition<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在Driver类中添加如下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 设置自定义分区类</span>job<span class="token punctuation">.</span><span class="token function">setPartitionerClass</span><span class="token punctuation">(</span><span class="token class-name">ProvincePartitioner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置ReduceTask个数</span>job<span class="token punctuation">.</span><span class="token function">setNumReduceTasks</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-7-Combiner合并"><a href="#3-3-7-Combiner合并" class="headerlink" title="3.3.7 Combiner合并"></a>3.3.7 Combiner合并</h3><ol><li><p>Combiner是MR程序中Mapper和Reducer之外的一种组件。</p></li><li><p><strong>Combiner组件的父类就是Reducer。</strong></p></li><li><p>Combiner和Reducer的区别在于运行的位置：</p></li></ol><ul><li><strong>Combiner是在每一个MapTask所在的节点运行；</strong></li><li><strong>Reducer是接收全局所有Mapper的输出结果。</strong></li></ul><ol start="4"><li>Combiner的意义就是<strong>对每一个MapTask的输出进行局部汇总</strong>，以减小网络传输量。</li><li>Combiner<strong>能够应用的前提是不能影响最终的业务逻辑</strong>，而且，Combiner的输出kv应该跟Reccer的输入kv类型要对应起来。</li></ol><ul><li>例如，Combiner适用于求和、汇总等场景，Combiner不适用求平均值场景，原因如图3.13：</li></ul><p><img src="http://img.fdchen.host/Combiner%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8EMapReduce%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%E5%9C%BA%E6%99%AF%E5%8E%9F%E5%9B%A0.jpg" alt="Combiner不适用于MapReduce求平均值场景原因"></p><center>图3.13 Combiner不适用于MapReduce求平均值场景原因</center><ol start="6"><li>自定义Combiner实现步骤</li></ol><p>（1）自定义一个Combiner继承Reducer，重写Reduce方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IntWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountCombiner</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">IntWritable</span>  v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IntWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 1 累加求和</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span> value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 写出atguigu 2</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在Driver类中设置：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 设置Combiner类</span>job<span class="token punctuation">.</span><span class="token function">setCombinerClass</span><span class="token punctuation">(</span><span class="token class-name">WordCountCombiner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-3-8-Combiner合并案例实操"><a href="#3-3-8-Combiner合并案例实操" class="headerlink" title="3.3.8 Combiner合并案例实操"></a>3.3.8 Combiner合并案例实操</h3><ol><li><strong>需求：</strong>统计过程中对每一个MapTask的输出进行局部汇总，以减小网络传输量，即采用Combiner功能。</li></ol><p>（1）输入数据：<a href="">hello.txt</a></p><p>（2）期望输出：</p><p>Map阶段输出到Reduce阶段时经过合并，输出数据降低。</p><p>期望控制台显示如图3.13所示：</p><p><img src="http://img.fdchen.host/Combiner%E6%88%90%E5%8A%9F%E7%A4%BA%E4%BE%8B.jpg" alt="Combiner成功示例"></p><center>图3.13 Combiner成功示例</center><ol start="2"><li><strong>需求分析</strong></li></ol><p>（1）方案一</p><ul><li>增加一个WordCombiner类继承Reducer类；</li><li>在WordCountCombiner中实现：统计单词汇总和统计结果输出。</li></ul><p>（2）方案二</p><ul><li>将WordCountReducer作为Combiner在WordCountDriver驱动类中指定</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">job<span class="token punctuation">.</span><span class="token function">setCombinerClass</span><span class="token punctuation">(</span><span class="token class-name">WordCountReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><strong>代码实现（方案一）</strong></li></ol><p>（1）增加一个WordcountCombiner类继承Reducer</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IntWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountCombiner</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token class-name">IntWritable</span>  v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IntWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 1 累加求和</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span> value<span class="token operator">:</span>values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在WordcountDriver驱动类中指定Combiner</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 指定需要使用combiner，以及用哪个类作为combiner的逻辑</span>job<span class="token punctuation">.</span><span class="token function">setCombinerClass</span><span class="token punctuation">(</span><span class="token class-name">WordcountCombiner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-3-9-GroupingComparator分组（辅助排序）"><a href="#3-3-9-GroupingComparator分组（辅助排序）" class="headerlink" title="3.3.9 GroupingComparator分组（辅助排序）"></a>3.3.9 GroupingComparator分组（辅助排序）</h3><ul><li>在Reduce阶段前，根据某一个或几个字段对Map阶段输出的有序键值对进行分组。</li><li>自定义分组排序步骤</li></ul><ol><li><p>自定义类继承WritableComparator</p></li><li><p>重写compare()方法</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">WritableComparable</span> a<span class="token punctuation">,</span> <span class="token class-name">WritableComparable</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 比较的业务逻辑</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建一个构造方法，将比较对象的类传给父类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">OrderGroupingComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">OrderBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-10-GroupingComparator分组案例实操"><a href="#3-3-10-GroupingComparator分组案例实操" class="headerlink" title="3.3.10 GroupingComparator分组案例实操"></a>3.3.10 GroupingComparator分组案例实操</h3><ol><li><strong>需求</strong></li></ol><p>（1）输入数据如下，要求输出每个订单中最贵的商品。</p><ul><li><a href="http://img.fdchen.host/GroupingComparator.txt">GroupingComparator</a></li></ul><p>（2）期望输出数据</p><pre class="line-numbers language-none"><code class="language-none">1222.82722.43232.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>需求分析</strong></li></ol><p>（1）利用“订单id和成交金额”作为key，可以将Map阶段读取到的所有订单数据按照id升序排序，如果id相同再按照金额降序排序，发送到Reduce。</p><p>（2）在Reduce端利用groupingComparator将订单id相同的kv聚合成组，然后取第一个即是该订单中最贵商品，如图3.14所示。</p><p><img src="http://img.fdchen.host/GroupingComparator%E5%88%86%E7%BB%84%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" alt="GroupingComparator分组案例需求分析"></p><center>图3.14 GroupingComparator分组案例需求分析</center><ol start="3"><li><strong>代码实现</strong></li></ol><p>（1）定义订单信息OrderBean类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataInput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">DataOutput</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">WritableComparable</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderBean</span> <span class="token keyword">implements</span> <span class="token class-name">WritableComparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderBean</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> order_id<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">double</span> price<span class="token punctuation">;</span><span class="token comment">// 空参构造</span><span class="token keyword">public</span> <span class="token class-name">OrderBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 有参构造</span><span class="token keyword">public</span> <span class="token class-name">OrderBean</span><span class="token punctuation">(</span><span class="token keyword">int</span> order_id<span class="token punctuation">,</span> <span class="token keyword">double</span> price<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>order_id <span class="token operator">=</span> order_id<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> order_id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOrder_id</span><span class="token punctuation">(</span><span class="token keyword">int</span> order_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>order_id <span class="token operator">=</span> order_id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> price<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> price<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> order_id <span class="token operator">+</span> <span class="token string">"\t"</span> <span class="token operator">+</span> price<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">DataOutput</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>out<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>order_id<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">writeDouble</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFields</span><span class="token punctuation">(</span><span class="token class-name">DataInput</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>order_id <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>price<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">readDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 二次排序：在自定义排序过程中，如果compareTo中的判断条件为两个即为二次排序</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">OrderBean</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token comment">// 比较结果中，-1代表排在前面，1代表排在后面</span><span class="token comment">// order_id正序排列</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order_id <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>order_id <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// 价格倒序排列</span><span class="token keyword">if</span> <span class="token punctuation">(</span>price <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>price <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//result = price >o.getPrice()?-1:1;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）编写OrderMapper类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">LongWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">NullWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Text</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Mapper</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">OrderBean</span><span class="token punctuation">,</span> <span class="token class-name">NullWritable</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token class-name">OrderBean</span> k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取一行</span><span class="token class-name">String</span> line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 截取</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 封装对象</span>k<span class="token punctuation">.</span><span class="token function">setOrder_id</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>fields<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>fields<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 写出，注意NullWritable加上了get()方法</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token class-name">NullWritable</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）编写OrderSortGroupingComparator类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">WritableComparable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">WritableComparator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderSortGroupingComparator</span> <span class="token keyword">extends</span> <span class="token class-name">WritableComparator</span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span> <span class="token class-name">OrderSortGroupingComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 第二个参数true一定不能省，否则会报错</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">OrderBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">WritableComparable</span> a<span class="token punctuation">,</span> <span class="token class-name">WritableComparable</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 只要order_id相同就认为是相同的key</span><span class="token class-name">OrderBean</span> aBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OrderBean</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span><span class="token class-name">OrderBean</span> bBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OrderBean</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span><span class="token keyword">int</span> result<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>aBean<span class="token punctuation">.</span><span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> bBean<span class="token punctuation">.</span><span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>aBean<span class="token punctuation">.</span><span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> bBean<span class="token punctuation">.</span><span class="token function">getOrder_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）编写OrderReducer类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">NullWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Reducer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderBean</span><span class="token punctuation">,</span> <span class="token class-name">NullWritable</span><span class="token punctuation">,</span> <span class="token class-name">OrderBean</span><span class="token punctuation">,</span> <span class="token class-name">NullWritable</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">OrderBean</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NullWritable</span><span class="token punctuation">></span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">NullWritable</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（5）编写OrderDriver类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>conf<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>fs<span class="token punctuation">.</span></span><span class="token class-name">Path</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">NullWritable</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span></span><span class="token class-name">Job</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>input<span class="token punctuation">.</span></span><span class="token class-name">FileInputFormat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>mapreduce<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>output<span class="token punctuation">.</span></span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderDriver</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 输入输出路径需要根据自己电脑上实际的输入输出路径设置</span>args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token string">"d:/input/inputOrder"</span><span class="token punctuation">,</span> <span class="token string">"d:/outputOrder"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 1 获取配置信息</span><span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 设置jar包加载路径</span>job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">OrderDriver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 加载map/reduce类</span>job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">OrderMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">OrderReducer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 8 设置reduce端的分组，负责比较相同key值，然后对进入ReduceTask的键值对进行分组，否则OrderSortGroupingComparator类无法发挥作用，直接把每个键值对单独分为一组</span>job<span class="token punctuation">.</span><span class="token function">setGroupingComparatorClass</span><span class="token punctuation">(</span><span class="token class-name">OrderSortGroupingComparator</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 设置map输出数据key和value类型</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">OrderBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">NullWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 设置最终输出数据的key和value类型</span>job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">OrderBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">NullWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 设置输入数据和输出数据路径</span><span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 7 提交</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>result <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip：</strong></p><ul><li><strong>如果要求获取每个订单号价格前N位的商品，在Reduce方法中，设置同一组内循环输出N次value值即可。</strong></li><li><strong>Reduce阶段对Map阶段输出的键值对进行分组时，默认Map阶段已经排序，仅通过GroupingComparator类从上往下寻找不同组的键值对，然后把不同组键值对以上的部分自动分为一组。</strong></li></ul><center>——————未完待续，以下内容后续补充——————</center><h2 id="3-4-MapTask工作机制"><a href="#3-4-MapTask工作机制" class="headerlink" title="3.4 MapTask工作机制"></a>3.4 MapTask工作机制</h2><h2 id="3-5-ReduceTak工作机制"><a href="#3-5-ReduceTak工作机制" class="headerlink" title="3.5 ReduceTak工作机制"></a>3.5 ReduceTak工作机制</h2><h2 id="3-6-OutputFormat数据输出"><a href="#3-6-OutputFormat数据输出" class="headerlink" title="3.6 OutputFormat数据输出"></a>3.6 OutputFormat数据输出</h2><h3 id="3-6-1-OutputFormat接口实现类"><a href="#3-6-1-OutputFormat接口实现类" class="headerlink" title="3.6.1 OutputFormat接口实现类"></a>3.6.1 OutputFormat接口实现类</h3><h3 id="3-6-2-自定义OutputFormat"><a href="#3-6-2-自定义OutputFormat" class="headerlink" title="3.6.2 自定义OutputFormat"></a>3.6.2 自定义OutputFormat</h3><h3 id="3-6-3-自定义OutputFormat案例实操"><a href="#3-6-3-自定义OutputFormat案例实操" class="headerlink" title="3.6.3 自定义OutputFormat案例实操"></a>3.6.3 自定义OutputFormat案例实操</h3><h2 id="3-7-Join多种应用"><a href="#3-7-Join多种应用" class="headerlink" title="3.7 Join多种应用"></a>3.7 Join多种应用</h2><h3 id="3-7-1-Reduce-Join"><a href="#3-7-1-Reduce-Join" class="headerlink" title="3.7.1 Reduce Join"></a>3.7.1 Reduce Join</h3><h3 id="3-7-2-Reduce-Join案例实操"><a href="#3-7-2-Reduce-Join案例实操" class="headerlink" title="3.7.2 Reduce Join案例实操"></a>3.7.2 Reduce Join案例实操</h3><h3 id="3-7-3-Map-Join"><a href="#3-7-3-Map-Join" class="headerlink" title="3.7.3 Map Join"></a>3.7.3 Map Join</h3><h3 id="3-7-4-Map-Join案例实操"><a href="#3-7-4-Map-Join案例实操" class="headerlink" title="3.7.4 Map Join案例实操"></a>3.7.4 Map Join案例实操</h3><p>······</p><p><strong>PS</strong>：视频教程查看<a href="http://www.atguigu.com/download_detail.shtml?v=52">尚硅谷-Hadoop视频教程</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> MapReduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式文件系统HDFS</title>
      <link href="/2020/da-shu-ju-fen-xi-fen-bu-shi-wen-jian-xi-tong-hdfs/"/>
      <url>/2020/da-shu-ju-fen-xi-fen-bu-shi-wen-jian-xi-tong-hdfs/</url>
      
        <content type="html"><![CDATA[<h1 id="1-HDFS概述"><a href="#1-HDFS概述" class="headerlink" title="1 HDFS概述"></a>1 HDFS概述</h1><h2 id="1-1-HDFS产生背景及定义"><a href="#1-1-HDFS产生背景及定义" class="headerlink" title="1.1 HDFS产生背景及定义"></a>1.1 HDFS产生背景及定义</h2><h3 id="1-1-1-HDFS产生背景"><a href="#1-1-1-HDFS产生背景" class="headerlink" title="1.1.1 HDFS产生背景"></a>1.1.1 HDFS产生背景</h3><p>随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统<br>管理的磁盘中，但是不方便管理和维护，迫切需要一种系统来管理多台机器上的文件，这就是<br>分布式文件管理系统。HDFS只是分布式文件管理系统中的一种。</p><h3 id="1-1-2-HDFS定义"><a href="#1-1-2-HDFS定义" class="headerlink" title="1.1.2 HDFS定义"></a>1.1.2 HDFS定义</h3><ul><li><p>HDFS(Hadoop Distributed File System)，它是一个文件系统，用于存储文件，通过目录树<br>来定位文件;其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各<br>自的角色。</p></li><li><p>HDFS的使用场景：<strong>适合一次写入，多次读出的场景，且不支持文件的修改</strong>。适合用来做数<br>据分析，并不适合用来做网盘应用。</p></li></ul><h2 id="1-2-HDFS-优缺点"><a href="#1-2-HDFS-优缺点" class="headerlink" title="1.2 HDFS 优缺点"></a>1.2 HDFS 优缺点</h2><h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h3><ol><li>高容错性<ul><li>数据自动保存多个副本。通过增加副本的形式，提高容错性。</li><li>某一个副本丢失以后，可以自动恢复。</li></ul></li><li>适合处理大数据<ul><li>数据规模：能够处理数据规模达到GB、TB甚至PB级别的数据。</li><li>文件规模：能够处理百万规模以上的文件数量，数量相当大。</li></ul></li><li>可构建在廉价机器上，通过多副本机制，提高可靠性。</li></ol><span id="more"></span><h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><ol><li>不适合低延时数据访问，比如毫秒级的存储数据是做不到的。</li><li>无法高效地对大量小文件进行存储。<ul><li>存储大量小文件的话，会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存总是有限的。</li><li>小文件存储的寻址时间会超过读取时间，它违反了HDFS的设计目标。</li></ul></li><li>不支持并发写入、文件随机修改。<ul><li>一个文件只能有一个写线程，不允许多个线程同时写。</li><li>仅支持数据追加，不支持文件的随机修改。</li></ul></li></ol><h2 id="1-3-HDFS组成架构"><a href="#1-3-HDFS组成架构" class="headerlink" title="1.3 HDFS组成架构"></a>1.3 HDFS组成架构</h2><p><img src="http://img.fdchen.host/HDFS%E7%BB%84%E6%88%90%E6%9E%B6%E6%9E%84.jpg" alt="HDFS组成架构"></p><center>图1.1 HDFS组成架构</center><ol><li><p><strong>NameNode(nn)：</strong>就是Master，它是一个主管、管理者。</p><ul><li>管里HDFS的名称空间；</li><li>配置副本策略；</li><li>管理数据块(Block）映射信息；</li><li>处理客户端读写请求。</li></ul></li><li><p><strong>DataNode(dn)：</strong>就是Slave。NameNode下达命令，DataNode执行实际的操作。</p><ul><li>存储实际的数据块；</li><li>执行数据块的读写操作。</li></ul></li><li><p><strong>Client：</strong>就是客户端。</p><ul><li>文件切分。文件上传HDFS的时候，Client将文牛切分成一个一个的Block，然后进行上传；</li><li>与NameNode交互，获取文件的位置信息；</li><li>与DataNode交互，读取或者写入数据；</li><li>Client提供一些命令来管理HDFS，比如NameNode格式化；</li><li>Client可以通过一些命令来访问HDFS，比如对HDFS增删查改操作。</li></ul></li><li><p><strong>Secondary NameNode(2nn)：</strong>并非NameNode的热备（备用设备）。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务。</p><ul><li>辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode；</li><li>在紧急情兄下，可辅助恢复NameNode。</li></ul></li></ol><h2 id="1-4-HDFS-文件块大小（重点）"><a href="#1-4-HDFS-文件块大小（重点）" class="headerlink" title="1.4 HDFS 文件块大小（重点）"></a>1.4 HDFS 文件块大小（重点）</h2><ol><li><p>HDFS中的文件在物理上是分块存储（Block ），块的大小可以通过配置参数( dfs.blocksize)来规定，默认大小在Hadoop2.x版本中是128M，老版本Hadoop1.x中是64M。</p></li><li><p>Block大小的计算原理（100M近似取128M）</p></li></ol><p><img src="http://img.fdchen.host/HDFS%E7%9A%84Block%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE.png" alt="HDFS的Block大小设置"></p><center>图1.2 HDFS的Block大小设置</center><ol start="3"><li>为什么Block不能设置太小，也不能设置太大？</li></ol><p>(1）HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置；<br>(2）如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。导致程序在处理这块数据时会非常慢。</p><ol start="4"><li><strong>总结：HDFS的Block大小设置主要取决与磁盘的传输速率</strong>。传输速率快，相同时间下传输的数据多，Block就可以设置得大。</li></ol><h1 id="2-HDFS的Shell操作（开发重点）"><a href="#2-HDFS的Shell操作（开发重点）" class="headerlink" title="2 HDFS的Shell操作（开发重点）"></a>2 HDFS的Shell操作（开发重点）</h1><p><strong>Tip：以下操作可以在伪分布式模式下进行。</strong></p><ol><li><strong>基本语法</strong></li></ol><ul><li>bin&#x2F;hadoop fs 具体命令  OR  bin&#x2F;hdfs dfs 具体命令</li><li>dfs是fs的实现类，所以前者命令集包含后者。</li><li><strong>一般命令区分大小写</strong></li></ul><ol start="2"><li><strong>命令大全</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ bin/hadoop fs<span class="token punctuation">[</span><span class="token operator">-</span>appendToFile &lt;localsrc> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;dst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token function">cat</span> <span class="token punctuation">[</span><span class="token operator">-</span>ignoreCrc<span class="token punctuation">]</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>checksum &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>chgrp <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> <span class="token function">GROUP</span> PATH<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>chmod <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> &lt;MODE<span class="token punctuation">[</span><span class="token punctuation">,</span>MODE<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">|</span> OCTALMODE> PATH<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>chown <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> <span class="token namespace">[OWNER]</span><span class="token punctuation">[</span>:<span class="token namespace">[GROUP]</span><span class="token punctuation">]</span> PATH<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>copyFromLocal <span class="token punctuation">[</span><span class="token operator">-</span>f<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>p<span class="token punctuation">]</span> &lt;localsrc> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;dst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>copyToLocal <span class="token punctuation">[</span><span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>ignoreCrc<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>crc<span class="token punctuation">]</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;localdst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>count <span class="token punctuation">[</span><span class="token operator">-</span>q<span class="token punctuation">]</span> &lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token function">cp</span> <span class="token punctuation">[</span><span class="token operator">-</span>f<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>p<span class="token punctuation">]</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;dst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>createSnapshot &lt;snapshotDir> <span class="token punctuation">[</span>&lt;snapshotName><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>deleteSnapshot &lt;snapshotDir> &lt;snapshotName><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>df <span class="token punctuation">[</span><span class="token operator">-</span>h<span class="token punctuation">]</span> <span class="token punctuation">[</span>&lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>du <span class="token punctuation">[</span><span class="token operator">-</span>s<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>h<span class="token punctuation">]</span> &lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>expunge<span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>get <span class="token punctuation">[</span><span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>ignoreCrc<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>crc<span class="token punctuation">]</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;localdst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>getfacl <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> &lt;path><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>getmerge <span class="token punctuation">[</span><span class="token operator">-</span>nl<span class="token punctuation">]</span> &lt;src> &lt;localdst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>help <span class="token namespace">[cmd ...]</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token function">ls</span> <span class="token punctuation">[</span><span class="token operator">-</span>d<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>h<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> <span class="token punctuation">[</span>&lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>mkdir <span class="token punctuation">[</span><span class="token operator">-</span>p<span class="token punctuation">]</span> &lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>moveFromLocal &lt;localsrc> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;dst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>moveToLocal &lt;src> &lt;localdst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token function">mv</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;dst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>put <span class="token punctuation">[</span><span class="token operator">-</span>f<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>p<span class="token punctuation">]</span> &lt;localsrc> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> &lt;dst><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>renameSnapshot &lt;snapshotDir> &lt;oldName> &lt;newName><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token function">rm</span> <span class="token punctuation">[</span><span class="token operator">-</span>f<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>r<span class="token punctuation">|</span><span class="token operator">-</span>R<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>skipTrash<span class="token punctuation">]</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span><span class="token function">rmdir</span> <span class="token punctuation">[</span><span class="token operator">--</span>ignore-fail-on-non-empty<span class="token punctuation">]</span> &lt;<span class="token function">dir</span>> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>setfacl <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token operator">-</span>b<span class="token punctuation">|</span><span class="token operator">-</span>k<span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span>m<span class="token punctuation">|</span><span class="token operator">-</span>x &lt;acl_spec><span class="token punctuation">&#125;</span> &lt;path><span class="token punctuation">]</span><span class="token punctuation">|</span><span class="token punctuation">[</span><span class="token operator">--</span><span class="token function">set</span> &lt;acl_spec> &lt;path><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>setrep <span class="token punctuation">[</span><span class="token operator">-</span>R<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>w<span class="token punctuation">]</span> &lt;rep> &lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>stat <span class="token namespace">[format]</span> &lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>tail <span class="token punctuation">[</span><span class="token operator">-</span>f<span class="token punctuation">]</span> &lt;file><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>test <span class="token operator">-</span><span class="token namespace">[defsz]</span> &lt;path><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>text <span class="token punctuation">[</span><span class="token operator">-</span>ignoreCrc<span class="token punctuation">]</span> &lt;src> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>touchz &lt;path> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        <span class="token punctuation">[</span><span class="token operator">-</span>usage <span class="token namespace">[cmd ...]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>常用命令实操</strong></li></ol><p><strong>（0）启动Hadoop集群（方便后续的测试）</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ sbin/<span class="token function">start-dfs</span><span class="token punctuation">.</span>sh<span class="token namespace">[atguigu@hadoop103 hadoop-2.7.2]</span>$ sbin/<span class="token function">start-yarn</span><span class="token punctuation">.</span>sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>（1）-help：输出这个命令参数的使用方法</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>help <span class="token function">rm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（2）-ls: 显示目录信息</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">ls</span> <span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（3）-mkdir：在HDFS上创建目录</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>mkdir <span class="token operator">-</span>p <span class="token operator">/</span>sanguo/shuguo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（4）-moveFromLocal：从本地剪切粘贴到HDFS</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ touch kongming<span class="token punctuation">.</span>txt<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs  <span class="token operator">-</span>moveFromLocal  <span class="token punctuation">.</span><span class="token operator">/</span>kongming<span class="token punctuation">.</span>txt  <span class="token operator">/</span>sanguo/shuguo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>（5）-appendToFile：追加一个文件到已经存在的文件末尾</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ touch liubei<span class="token punctuation">.</span>txt<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ vim liubei<span class="token punctuation">.</span>txt输入san <span class="token function">gu</span> mao lu<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>appendToFile liubei<span class="token punctuation">.</span>txt <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（6）-cat：显示文件内容</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">cat</span> <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（7）-chgrp 、-chmod、-chown：Linux文件系统中的用法一样，修改文件所属权限</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs  <span class="token operator">-</span>chmod  777  <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs  <span class="token operator">-</span>chown  atguigu:atguigu  <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>（8）-copyFromLocal：从本地文件系统中拷贝文件到HDFS路径去</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>copyFromLocal README<span class="token punctuation">.</span>txt <span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（9）-copyToLocal：从HDFS拷贝到本地</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>copyToLocal <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt <span class="token punctuation">.</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（10）-cp ：从HDFS的一个路径拷贝到HDFS的另一个路径（复制），前者为源路径，后者为目的路径，具有两个路径参数的命令都如此</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">cp</span> <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt <span class="token operator">/</span>zhuge<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（11）-mv：在HDFS目录中移动文件（剪切）</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">mv</span> <span class="token operator">/</span>zhuge<span class="token punctuation">.</span>txt <span class="token operator">/</span>sanguo/shuguo/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（12）-get：等同于copyToLocal，就是从HDFS下载文件到本地</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>get <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt <span class="token punctuation">.</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（13）-getmerge：合并下载多个文件到一个文件中去，比如HDFS的目录 &#x2F;user&#x2F;atguigu&#x2F;test下有多个文件:log.1, log.2,log.3,…</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>getmerge <span class="token operator">/</span>user/atguigu/test/<span class="token operator">*</span> <span class="token punctuation">.</span><span class="token operator">/</span>zaiyiqi<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（14）-put：等同于copyFromLocal</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>put <span class="token punctuation">.</span><span class="token operator">/</span>zaiyiqi<span class="token punctuation">.</span>txt <span class="token operator">/</span>user/atguigu/test/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（15）-tail：显示一个文件的末尾</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>tail <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（16）-rm：删除HDFS上的文件或文件夹，递归删除文件夹需要加上参数-r</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">rm</span> <span class="token operator">/</span>user/atguigu/test/jinlian2<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（17）-rmdir：删除空目录</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">rmdir</span> <span class="token operator">/</span>test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（18）-du统计文件夹的大小信息</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>du <span class="token operator">-</span>s <span class="token operator">-</span>h <span class="token operator">/</span>user/atguigu/test2<span class="token punctuation">.</span>7 K  <span class="token operator">/</span>user/atguigu/test<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>du  <span class="token operator">-</span>h <span class="token operator">/</span>user/atguigu/test1<span class="token punctuation">.</span>3 K  <span class="token operator">/</span>user/atguigu/test/README<span class="token punctuation">.</span>txt15   <span class="token operator">/</span>user/atguigu/test/jinlian<span class="token punctuation">.</span>txt1<span class="token punctuation">.</span>4 K  <span class="token operator">/</span>user/atguigu/test/zaiyiqi<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>-s代表显示整个文件夹的大小；-h代表给文件大小加上单位（K, M等）</li></ul><p><strong>（19）-setrep：设置HDFS中文件的副本数量，不过是否真的会有这么多副本，还得看DataNode的数量</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>setrep 10 <span class="token operator">/</span>sanguo/shuguo/kongming<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-HDFS客户端操作（开发重点）"><a href="#3-HDFS客户端操作（开发重点）" class="headerlink" title="3 HDFS客户端操作（开发重点）"></a>3 HDFS客户端操作（开发重点）</h1><p><strong>Tip：以下操作可以在伪分布式模式下进行。</strong></p><h2 id="3-1-HDFS客户端环境准备"><a href="#3-1-HDFS客户端环境准备" class="headerlink" title="3.1 HDFS客户端环境准备"></a>3.1 HDFS客户端环境准备</h2><ol><li><strong>根据自己电脑的操作系统拷贝对应的编译后的hadoop jar包到</strong>非中文路径<strong>（例如：D:\Develop\hadoop-2.7.2），如图3.1（可从网上下载）：</strong></li></ol><p><img src="http://img.fdchen.host/%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84hadoop%20jar%E5%8C%85.png" alt="编译后的hadoop jar包"></p><center>图3.1 编译后的hadoop jar包</center><ol start="2"><li><strong>配置HADOOP_HOME环境变量，如图3.2：</strong></li></ol><p><img src="http://img.fdchen.host/%E9%85%8D%E7%BD%AEHADOOP_HOME%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="配置HADOOP_HOME环境变量"></p><center>图3.2 配置HADOOP_HOME环境变量</center><ol start="3"><li><strong>配置Path环境变量，如图3.3：</strong></li></ol><p><img src="http://img.fdchen.host/%E9%85%8D%E7%BD%AEPath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="配置Path环境变量"></p><center>图3.3 配置Path环境变量</center><ol start="4"><li><strong>创建一个Maven工程HdfsClientDemo：</strong></li></ol><p>（1）打开<strong>eclipse</strong>；</p><p>（2）左上角<strong>File</strong> –&gt; <strong>new</strong> –&gt; <strong>Maven Project</strong> –&gt; <strong>Create a simple project</strong>。</p><ol start="5"><li><strong>在</strong>pom.xml<strong>文件中的</strong>&lt;project&gt;&lt;&#x2F;project&gt;<strong>标签中导入相应的依赖坐标+日志添加：</strong></li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.logging.log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hadoop-common<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hadoop-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.hadoop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hadoop-hdfs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>jdk.tools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jdk.tools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>system<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>systemPath</span><span class="token punctuation">></span></span>$&#123;JAVA_HOME&#125;/lib/tools.jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>systemPath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tips：环境配置出现问题可参考本人另一篇博客<a href="http://fdchen.host/2020/10/05/Eclipse%E5%88%9B%E5%BB%BAMaven%20Project%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEDebug/">《Eclipse创建Maven Project环境配置Debug》</a></strong></p><ul><li>如果Eclipse&#x2F;Idea打印不出日志，在控制台上只显示，报错如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">1.log4j:WARN No appenders could be found for logger (org.apache.hadoop.util.Shell).  2.log4j:WARN Please initialize the log4j system properly.  3.log4j:WARN See http:&#x2F;&#x2F;logging.apache.org&#x2F;log4j&#x2F;1.2&#x2F;faq.html#noconfig for more info.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>需要在项目的src&#x2F;main&#x2F;resources目录下，新建一个文件（无法新建.properties文件可在项目外新建记事本输入内容后修改后缀即可），命名为“log4j.properties”，在文件中填入如下内容：</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">INFO, stdout</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d %p [%c] - %m%n</span><span class="token attr-name">log4j.appender.logfile</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.FileAppender</span><span class="token attr-name">log4j.appender.logfile.File</span><span class="token punctuation">=</span><span class="token attr-value">target/spring.log</span><span class="token attr-name">log4j.appender.logfile.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.logfile.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d %p [%c] - %m%n</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><p><strong>创建包名：com.atguigu.hdfs</strong></p></li><li><p><strong>创建HdfsClient类，有两种连接方式</strong></p></li></ol><p>（1）第一种方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HdfsClient</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 配置在集群上运行</span>configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"fs.defaultFS"</span><span class="token punctuation">,</span> <span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 创建目录</span>fs<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/1108/daxian/banzhang"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种情况需要配置用户名称，点击<strong>Run</strong> –&gt; <strong>Run Configurations</strong> –&gt; <strong>双击Java Application</strong> –&gt; 点击新建的<strong>HDFS项目</strong> – &gt; <strong>修改如下内容：</strong> –&gt; <strong>Apply</strong></li></ul><p><img src="http://img.fdchen.host/Eclipse%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E7%A7%B0.png" alt="Eclipse配置用户名称"></p><center>图3.4 Eclipse配置用户名称</center><ul><li>原理解释：客户端去操作HDFS时，是有一个用户身份的。默认情况下，HDFS客户端API会从JVM中获取一个参数来作为自己的用户身份：-DHADOOP_USER_NAME&#x3D;atguigu，atguigu为用户名称。</li></ul><p>（2）第二种方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HdfsClient</span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 创建目录</span>fs<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/1108/daxian/banzhang"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种方式直接运行即可，推荐使用。</li></ul><h2 id="3-2-HDFS的API操作"><a href="#3-2-HDFS的API操作" class="headerlink" title="3.2 HDFS的API操作"></a>3.2 HDFS的API操作</h2><h3 id="3-2-1-HDFS文件上传（测试副本数参数优先级）"><a href="#3-2-1-HDFS文件上传（测试副本数参数优先级）" class="headerlink" title="3.2.1 HDFS文件上传（测试副本数参数优先级）"></a>3.2.1 HDFS文件上传（测试副本数参数优先级）</h3><ol><li>编写源码</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCopyFromLocalFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"dfs.replication"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 客户端代码设置的副本数</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 上传文件</span>fs<span class="token punctuation">.</span><span class="token function">copyFromLocalFile</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"e:/banzhang.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/banzhang.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>将hdfs-site.xml拷贝到项目的资源目录下，包含以下内容：</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token prolog">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.replication<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>副本数参数优先级</strong></li></ol><p>① 客户端代码中设置的值 &gt; ② 客户端项目资源目录下的配置文件 &gt; ③ ClassPath下的用户自定义配置文件hdfs-site.xml  &gt; ④ 服务器的默认配置hdfs-default.xml</p><h3 id="3-2-2-HDFS文件下载"><a href="#3-2-2-HDFS文件下载" class="headerlink" title="3.2.2 HDFS文件下载"></a>3.2.2 HDFS文件下载</h3><ul><li>代码示例如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCopyToLocalFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 执行下载操作</span><span class="token comment">// boolean delSrc 指是否将原文件删除</span><span class="token comment">// Path src 指要下载的文件路径</span><span class="token comment">// Path dst 指将文件下载到的路径</span><span class="token comment">// boolean useRawLocalFileSystem 是否使用本地文件系统，不使用本地文件系统则开启文件校验，会产生.crc文件，默认是false</span>fs<span class="token punctuation">.</span><span class="token function">copyToLocalFile</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/banzhang.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"e:/banhua.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-3-HDFS文件夹删除"><a href="#3-2-3-HDFS文件夹删除" class="headerlink" title="3.2.3 HDFS文件夹删除"></a>3.2.3 HDFS文件夹删除</h3><ul><li>代码示例如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 执行删除</span>    <span class="token comment">// Path 文件夹路径</span>    <span class="token comment">// boolean recursive 如果删除文件夹需设置为true，否则会报错；如果删除文件true 或 false均可</span>fs<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/0508/"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-4-HDFS文件名更改"><a href="#3-2-4-HDFS文件名更改" class="headerlink" title="3.2.4 HDFS文件名更改"></a>3.2.4 HDFS文件名更改</h3><ul><li>代码示例如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRename</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 修改文件名称</span>fs<span class="token punctuation">.</span><span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/banzhang.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/banhua.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-HDFS文件详情查看"><a href="#3-2-5-HDFS文件详情查看" class="headerlink" title="3.2.5 HDFS文件详情查看"></a>3.2.5 HDFS文件详情查看</h3><ul><li>查看文件名称、权限、长度、块信息，代码示例如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 获取文件详情，返回一个迭代器（数组）</span>    <span class="token comment">// Path 文件夹路径</span>    <span class="token comment">// boolean Recursive 是否迭代访问下一级文件</span><span class="token class-name">RemoteIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LocatedFileStatus</span><span class="token punctuation">></span></span> listFiles <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>listFiles<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">LocatedFileStatus</span> status <span class="token operator">=</span> listFiles<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出详情</span><span class="token comment">// 文件名称，先获取文件路径，再获取文件名</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 长度</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">getLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 权限</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">getPermission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分组</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">getGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取存储的块信息，返回值是数组类型</span><span class="token class-name">BlockLocation</span><span class="token punctuation">[</span><span class="token punctuation">]</span> blockLocations <span class="token operator">=</span> status<span class="token punctuation">.</span><span class="token function">getBlockLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BlockLocation</span> blockLocation <span class="token operator">:</span> blockLocations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 获取块存储的主机节点，返回值是数组类型</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hosts <span class="token operator">=</span> blockLocation<span class="token punctuation">.</span><span class="token function">getHosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> host <span class="token operator">:</span> hosts<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------班长的分割线----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 3 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-6-HDFS文件和文件夹判断"><a href="#3-2-6-HDFS文件和文件夹判断" class="headerlink" title="3.2.6 HDFS文件和文件夹判断"></a>3.2.6 HDFS文件和文件夹判断</h3><ul><li>代码示例如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件配置信息</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 获取目标目录下的所有文件或文件夹状态</span><span class="token class-name">FileStatus</span><span class="token punctuation">[</span><span class="token punctuation">]</span> listStatus <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">listStatus</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3 遍历所有文件或文件夹状态</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">FileStatus</span> fileStatus <span class="token operator">:</span> listStatus<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 如果是文件</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fileStatus<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"f:"</span><span class="token operator">+</span>fileStatus<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"d:"</span><span class="token operator">+</span>fileStatus<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 4 关闭资源</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-HDFS的-I-x2F-O-流操作"><a href="#3-3-HDFS的-I-x2F-O-流操作" class="headerlink" title="3.3 HDFS的 I&#x2F;O 流操作"></a>3.3 HDFS的 I&#x2F;O 流操作</h2><ul><li>上面的API操作HDFS系统都是框架封装好的。如果我们想自己实现上述API的操作可以采用<strong>I&#x2F;O流的方式实现数据的上传和下载</strong>。</li></ul><h3 id="3-3-1-HDFS文件上传"><a href="#3-3-1-HDFS文件上传" class="headerlink" title="3.3.1 HDFS文件上传"></a>3.3.1 HDFS文件上传</h3><ol><li><strong>需求：</strong>把本地E盘上的banhua.txt文件上传到HDFS根目录。</li><li><strong>编写代码如下：</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putFileToHDFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 创建输入流，创建一个从本地文件系统输入的数据流</span><span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"e:/banhua.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 获取输出流，创建输出到HDFS的数据流</span><span class="token class-name">FSDataOutputStream</span> fos <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/banhua.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 流对拷</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">copyBytes</span><span class="token punctuation">(</span>fis<span class="token punctuation">,</span> fos<span class="token punctuation">,</span> configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 关闭资源，先关闭输出流，再关闭输入流</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>    fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>整体逻辑</strong>：客户端操作系统可视为“中转站”，本地文件系统将数据输入到客户端操作系统，客户端操作系统进行流对拷之后，将数据输出到HDFS系统。</li></ol><h3 id="3-3-2-HDFS文件下载"><a href="#3-3-2-HDFS文件下载" class="headerlink" title="3.3.2 HDFS文件下载"></a>3.3.2 HDFS文件下载</h3><ol><li><strong>需求：</strong>从HDFS上下载banhua.txt文件到本地E盘上。</li><li><strong>编写代码如下：</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getFileFromHDFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 获取输入流，创建一个从HDFS输入的数据流</span><span class="token class-name">FSDataInputStream</span> fis <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/banhua.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 获取输出流，创建一个输出到本地文件系统的数据流</span><span class="token class-name">FileOutputStream</span> fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"e:/banhua.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 流的对拷</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">copyBytes</span><span class="token punctuation">(</span>fis<span class="token punctuation">,</span> fos<span class="token punctuation">,</span> configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 关闭资源</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip：</strong></p><ul><li>输入输出流中与本地文件系统相联系的前缀是File前缀，与HDFS系统相联系的前缀是FSData。</li><li>创建一个从HDFS输入的数据流使用fs.open(Path)，创建输出到HDFS的数据流使用fs.creat(Path)。</li></ul><h3 id="3-3-3-定位文件读取"><a href="#3-3-3-定位文件读取" class="headerlink" title="3.3.3 定位文件读取"></a>3.3.3 定位文件读取</h3><ol><li><strong>需求：</strong>分块读取HDFS上的大文件。</li><li><strong>编写代码如下：</strong></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 下载第一块</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFileSeek1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 获取输入流</span><span class="token class-name">FSDataInputStream</span> fis <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/hadoop-2.7.2.tar.gz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 创建输出流</span><span class="token class-name">FileOutputStream</span> fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"e:/hadoop-2.7.2.tar.gz.part1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 流的拷贝（只拷贝128M），使用IOUtils.copyBytes()就会全部拷贝，无法定位</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">128</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 5关闭资源</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 拷贝第二块</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFileSeek2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">URISyntaxException</span><span class="token punctuation">&#123;</span><span class="token comment">// 1 获取文件系统</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">FileSystem</span> fs <span class="token operator">=</span> <span class="token class-name">FileSystem</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">URI</span><span class="token punctuation">(</span><span class="token string">"hdfs://hadoop102:9000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2 打开输入流</span><span class="token class-name">FSDataInputStream</span> fis <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span><span class="token string">"/hadoop-2.7.2.tar.gz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3 定位输入数据位置</span>fis<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4 创建输出流</span><span class="token class-name">FileOutputStream</span> fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"e:/hadoop-2.7.2.tar.gz.part2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5 流的对拷，第二块就拷贝完毕可以直接使用IOUtils.copyBytes()，全部拷贝</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">copyBytes</span><span class="token punctuation">(</span>fis<span class="token punctuation">,</span> fos<span class="token punctuation">,</span> configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6 关闭资源</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IOUtils</span><span class="token punctuation">.</span><span class="token function">closeStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>合并文件：</p><p>在Window命令窗口中进入到目录E:\，然后执行如下命令，对数据进行合并，合并完成后，将hadoop-2.7.2.tar.gz.part1重新命名为hadoop-2.7.2.tar.gz。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">type hadoop-2.7.2.tar.gz.part2 &gt;&gt; hadoop-2.7.2.tar.gz.part1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="4-HDFS的数据流（面试重点）"><a href="#4-HDFS的数据流（面试重点）" class="headerlink" title="4 HDFS的数据流（面试重点）"></a>4 HDFS的数据流（面试重点）</h1><h2 id="4-1-HDFS写数据流程"><a href="#4-1-HDFS写数据流程" class="headerlink" title="4.1 HDFS写数据流程"></a>4.1 HDFS写数据流程</h2><h3 id="4-1-1-剖析文件写入"><a href="#4-1-1-剖析文件写入" class="headerlink" title="4.1.1 剖析文件写入"></a>4.1.1 剖析文件写入</h3><p><img src="http://img.fdchen.host/HDFS%E7%9A%84%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E6%B5%81%E7%A8%8B.png" alt="HDFS的写数据流程"></p><center>图4.1 HDFS的写数据流程</center><ol><li><p>客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。</p></li><li><p>NameNode返回是否可以上传。</p></li><li><p>客户端请求第一个 Block上传到哪几个DataNode服务器上。</p></li><li><p>NameNode一般返回3个DataNode节点，分别为dn1、dn2、dn3（优先选择距离近、负载小的DataNode节点）。</p></li><li><p>客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。</p></li><li><p>dn1、dn2、dn3逐级应答客户端。</p></li><li><p>客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet在保存信息之后就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待dn2和dn3的应答，等到获得dn3全部存储完毕的应答之后清空内存。</p></li><li><p>当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。</p></li></ol><h3 id="4-1-2-网络拓扑-节点距离计算"><a href="#4-1-2-网络拓扑-节点距离计算" class="headerlink" title="4.1.2 网络拓扑-节点距离计算"></a>4.1.2 网络拓扑-节点距离计算</h3><ol><li><p><strong>节点距离：两个节点到达最近的共同祖先的距离总和。</strong></p></li><li><p>示例如图：</p></li></ol><p><img src="http://img.fdchen.host/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91-%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B.png" alt="网络拓扑-节点距离计算"></p><center>图4.2 网络拓扑-节点距离计算</center><h3 id="4-1-3-机架感知（副本存储节点选择）"><a href="#4-1-3-机架感知（副本存储节点选择）" class="headerlink" title="4.1.3 机架感知（副本存储节点选择）"></a>4.1.3 机架感知（副本存储节点选择）</h3><ol><li>官方说明：</li></ol><ul><li><a href="http://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#Data_Replication">http://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#Data_Replication</a></li></ul><ol start="2"><li>Hadoop 2.7.2 副本节点选择</li></ol><ul><li>综合考虑I&#x2F;0速度和副本安全性与可靠性</li></ul><p><img src="http://img.fdchen.host/Hadoop2.7.2%E5%89%AF%E6%9C%AC%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9.png" alt="Hadoop2.7.2副本节点选择"></p><center>图4.3 Hadoop2.7.2副本节点选择</center><h2 id="4-2-HDFS读数据流程"><a href="#4-2-HDFS读数据流程" class="headerlink" title="4.2 HDFS读数据流程"></a>4.2 HDFS读数据流程</h2><p><img src="http://img.fdchen.host/HDFS%E7%9A%84%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="HDFS的读数据流程"></p><center>图4.4 HDFS的读数据流程</center><p><strong>详细步骤解读</strong>：</p><ol><li>客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。</li><li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。</li><li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。</li><li>客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。</li></ol><h1 id="5-NameNode-和-Secondary-NameNode（面试开发重点）"><a href="#5-NameNode-和-Secondary-NameNode（面试开发重点）" class="headerlink" title="5 NameNode 和 Secondary NameNode（面试开发重点）"></a>5 NameNode 和 Secondary NameNode（面试开发重点）</h1><h2 id="5-1-NN和2NN的工作机制（重点）"><a href="#5-1-NN和2NN的工作机制（重点）" class="headerlink" title="5.1 NN和2NN的工作机制（重点）"></a>5.1 NN和2NN的工作机制（重点）</h2><ul><li><p><strong>Q：NameNode中的元数据是存储在哪里的？</strong></p></li><li><p><strong>A：</strong></p><ul><li>首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。</li><li>这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</li><li>但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点Secondary NameNode，专门用于FsImage和Edits的合并。</li></ul></li><li><p><strong>详细的NN和2NN工作机制如图5.1：</strong></p></li></ul><p><img src="http://img.fdchen.host/NN%E5%92%8C2NN%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="NN和2NN工作机制"></p><center>图5.1 NN和2NN工作机制</center><ol><li><strong>第一阶段：NameNode启动</strong></li></ol><p>（1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载Edits日志和FsImage文件到内存并生成一个空的edits.inprogress。</p><p>（2）客户端对元数据进行增删改的请求。（<strong>查询元数据的操作不会被记录在Edits中，因为查询操作不会更改元数据信息</strong>）</p><p>（3）NameNode记录操作日志在edits.inprogress中，更新滚动日志。（<strong>先修改日志而不直接操作内存是为了保存操作信息，避免突然断电导致操作终止并丢失</strong>）</p><p>（4）NameNode在内存中对数据进行增删改。</p><ol start="2"><li><strong>第二阶段：Secondary NameNode工作</strong></li></ol><p>（1）Secondary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否需要CheckPoint结果。（<strong>触发条件是定时时间到或者Edits中的数据满了</strong>）</p><p>（2）Secondary NameNode请求执行CheckPoint。</p><p>（3）NameNode滚动正在写的Edits日志。（将Edits分为之前的Edits日志汇总和空的新Edits日志edits.inprogress）</p><p>（4）将滚动前的Edits日志和FsImage文件拷贝到Secondary NameNode。</p><p>（5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。（<strong>所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage</strong>）</p><p>（6）生成新的镜像文件fsimage.chkpoint。</p><p>（7）拷贝fsimage.chkpoint到NameNode。</p><p>（8）NameNode将fsimage.chkpoint重新命名成fsimage替换掉原来的fsimage。</p><ol start="3"><li><strong>补充：</strong></li></ol><p>（1）FsImage：NameNode内存中元数据序列化后形成的文件。</p><p>（2）Edits：记录客户端更新元数据信息的每一步操作（可通过Edits运算出元数据）。</p><p>（3）Secondary NameNode的作用就是帮助NameNode进行Edits和Fsimage的合并工作。</p><p>（4）NameNode在启动时就只需要加载之前未合并的Edits和Fsimage即可，因为合并过的Edits中的元数据信息已经被记录在FsImage中。</p><h2 id="5-2-FsImage和Edits解析（了解）"><a href="#5-2-FsImage和Edits解析（了解）" class="headerlink" title="5.2 FsImage和Edits解析（了解）"></a>5.2 FsImage和Edits解析（了解）</h2><h3 id="5-2-1-概念"><a href="#5-2-1-概念" class="headerlink" title="5.2.1 概念"></a>5.2.1 概念</h3><ol start="0"><li>NameNode被格式化之后，将在**&#x2F;opt&#x2F;module&#x2F;hadoop-2.7.2&#x2F;data&#x2F;tmp&#x2F;dfs&#x2F;name&#x2F;current**目录中产生如下文件：</li></ol><pre class="line-numbers language-none"><code class="language-none">fsimage_0000000000000000000fsimage_0000000000000000000.md5seen_txidVERSION<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息。</li><li>Edits文件:存放HDFS文件系统的所有更新操作的路径，文件系统客户端执行的所有写操作首先<br>会被记录到Edlits文件中。</li><li>sen_txid文件保存的是一个数字，就是最后一个edits_的数字。</li><li>每次NameNode启动的时候都会将Fsimage文件读入内存，加载Edits里面的更新操作，保证内存中的元数据信息是最新的、同步的，可以看成NameNode启动的时候就将FsImage和Edits文件进行了合并。</li></ol><h3 id="5-2-2-oiv查看FsImage文件"><a href="#5-2-2-oiv查看FsImage文件" class="headerlink" title="5.2.2 oiv查看FsImage文件"></a>5.2.2 oiv查看FsImage文件</h3><ol><li>查看oiv和oev命令</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 current]</span>$ hdfsoiv      apply the offline fsimage viewer to an fsimageoev      apply the offline edits viewer to an edits file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>基本语法</li></ol><pre class="line-numbers language-none"><code class="language-none">hdfs oiv -p 文件类型 -i 镜像文件 -o 转换后文件输出路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>案例实操</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 current]</span>$ <span class="token function">pwd</span><span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/<span class="token keyword">data</span><span class="token operator">/</span>tmp/dfs/name/current<span class="token namespace">[atguigu@hadoop102 current]</span>$ hdfs oiv <span class="token operator">-</span>p XML <span class="token operator">-</span>i fsimage_0000000000000000025 <span class="token operator">-</span>o <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/fsimage<span class="token punctuation">.</span>xml<span class="token namespace">[atguigu@hadoop102 current]</span>$ <span class="token function">cat</span> <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/fsimage<span class="token punctuation">.</span>xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将显示的xml文件内容拷贝到Eclipse中创建的xml文件中，并格式化。部分显示结果如下。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inode</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>16386<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>DIRECTORY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mtime</span><span class="token punctuation">></span></span>1512722284477<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mtime</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>permission</span><span class="token punctuation">></span></span>atguigu:supergroup:rwxr-xr-x<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>permission</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nsquota</span><span class="token punctuation">></span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nsquota</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dsquota</span><span class="token punctuation">></span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dsquota</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inode</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inode</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>16387<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>DIRECTORY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mtime</span><span class="token punctuation">></span></span>1512790549080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mtime</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>permission</span><span class="token punctuation">></span></span>atguigu:supergroup:rwxr-xr-x<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>permission</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nsquota</span><span class="token punctuation">></span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nsquota</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dsquota</span><span class="token punctuation">></span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dsquota</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inode</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inode</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>16389<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>FILE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>wc.input<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>replication</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>replication</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mtime</span><span class="token punctuation">></span></span>1512722322219<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mtime</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>atime</span><span class="token punctuation">></span></span>1512722321610<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>atime</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>perferredBlockSize</span><span class="token punctuation">></span></span>134217728<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>perferredBlockSize</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>permission</span><span class="token punctuation">></span></span>atguigu:supergroup:rw-r--r--<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>permission</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blocks</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>block</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>1073741825<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>genstamp</span><span class="token punctuation">></span></span>1001<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>genstamp</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>numBytes</span><span class="token punctuation">></span></span>59<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>numBytes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>block</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blocks</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>inode</span> <span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>Q：可以看出，FsImage中没有记录块所对应DataNode，为什么？</strong></p></li><li><p><strong>A：在集群启动后，要求DataNode上报数据块信息，并间隔一段时间后再次上报。</strong></p></li></ul><p><strong>具体过程如下：</strong>在所有DataNode启动时，每个DataNode对本地磁盘进行扫描，将本DataNode上保存的block信息汇报给NameNode，NameNode在接收到每个DataNode的块信息汇报后，将接收到的块信息，以及其所在的DataNode信息等保存在内存中。（HDFS就是通过这种块信息汇报的方式来完成 block -&gt; DataNodes list的对应表构建。DataNode向NameNode汇报块信息的过程叫做blockReport，而NameNode将block -&gt; DataNodes list的对应表信息保存在一个叫BlocksMap的数据结构中。）</p><h3 id="5-2-3-oev查看Edits文件"><a href="#5-2-3-oev查看Edits文件" class="headerlink" title="5.2.3 oev查看Edits文件"></a>5.2.3 oev查看Edits文件</h3><ol><li>基本语法</li></ol><pre class="line-numbers language-none"><code class="language-none">hdfs oev -p 文件类型 -i 编辑日志 -o 转换后文件输出路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>案例实操</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 current]</span>$ hdfs oev <span class="token operator">-</span>p XML <span class="token operator">-</span>i edits_0000000000000000012-0000000000000000013 <span class="token operator">-</span>o <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/edits<span class="token punctuation">.</span>xml<span class="token namespace">[atguigu@hadoop102 current]</span>$ <span class="token function">cat</span> <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/edits<span class="token punctuation">.</span>xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>将显示的xml文件内容拷贝到Eclipse中创建的xml文件中，并格式化。显示结果如下。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EDITS</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EDITS_VERSION</span><span class="token punctuation">></span></span>-63<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EDITS_VERSION</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OPCODE</span><span class="token punctuation">></span></span>OP_START_LOG_SEGMENT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OPCODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TXID</span><span class="token punctuation">></span></span>129<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TXID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OPCODE</span><span class="token punctuation">></span></span>OP_ADD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OPCODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TXID</span><span class="token punctuation">></span></span>130<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TXID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LENGTH</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LENGTH</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>INODEID</span><span class="token punctuation">></span></span>16407<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>INODEID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PATH</span><span class="token punctuation">></span></span>/hello7.txt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>PATH</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>REPLICATION</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>REPLICATION</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MTIME</span><span class="token punctuation">></span></span>1512943607866<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MTIME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ATIME</span><span class="token punctuation">></span></span>1512943607866<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ATIME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCKSIZE</span><span class="token punctuation">></span></span>134217728<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCKSIZE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CLIENT_NAME</span><span class="token punctuation">></span></span>DFSClient_NONMAPREDUCE_-1544295051_1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>CLIENT_NAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CLIENT_MACHINE</span><span class="token punctuation">></span></span>192.168.1.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>CLIENT_MACHINE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OVERWRITE</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OVERWRITE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PERMISSION_STATUS</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>USERNAME</span><span class="token punctuation">></span></span>atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>USERNAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GROUPNAME</span><span class="token punctuation">></span></span>supergroup<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GROUPNAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MODE</span><span class="token punctuation">></span></span>420<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>PERMISSION_STATUS</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RPC_CLIENTID</span><span class="token punctuation">></span></span>908eafd4-9aec-4288-96f1-e8011d181561<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RPC_CLIENTID</span><span class="token attr-name">&lt;RPC_CALLID</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RPC_CALLID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OPCODE</span><span class="token punctuation">></span></span>OP_ALLOCATE_BLOCK_ID<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OPCODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TXID</span><span class="token punctuation">></span></span>131<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TXID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCK_ID</span><span class="token punctuation">></span></span>1073741839<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCK_ID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OPCODE</span><span class="token punctuation">></span></span>OP_SET_GENSTAMP_V2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OPCODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TXID</span><span class="token punctuation">></span></span>132<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TXID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GENSTAMPV2</span><span class="token punctuation">></span></span>1016<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GENSTAMPV2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OPCODE</span><span class="token punctuation">></span></span>OP_ADD_BLOCK<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OPCODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TXID</span><span class="token punctuation">></span></span>133<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TXID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PATH</span><span class="token punctuation">></span></span>/hello7.txt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>PATH</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCK</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCK_ID</span><span class="token punctuation">></span></span>1073741839<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCK_ID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NUM_BYTES</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NUM_BYTES</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GENSTAMP</span><span class="token punctuation">></span></span>1016<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GENSTAMP</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCK</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RPC_CLIENTID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RPC_CLIENTID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RPC_CALLID</span><span class="token punctuation">></span></span>-2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RPC_CALLID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OPCODE</span><span class="token punctuation">></span></span>OP_CLOSE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OPCODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TXID</span><span class="token punctuation">></span></span>134<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TXID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LENGTH</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LENGTH</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>INODEID</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>INODEID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PATH</span><span class="token punctuation">></span></span>/hello7.txt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>PATH</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>REPLICATION</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>REPLICATION</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MTIME</span><span class="token punctuation">></span></span>1512943608761<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MTIME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ATIME</span><span class="token punctuation">></span></span>1512943607866<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ATIME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCKSIZE</span><span class="token punctuation">></span></span>134217728<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCKSIZE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CLIENT_NAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>CLIENT_NAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CLIENT_MACHINE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>CLIENT_MACHINE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OVERWRITE</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OVERWRITE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCK</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BLOCK_ID</span><span class="token punctuation">></span></span>1073741839<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCK_ID</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NUM_BYTES</span><span class="token punctuation">></span></span>25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NUM_BYTES</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GENSTAMP</span><span class="token punctuation">></span></span>1016<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GENSTAMP</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BLOCK</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PERMISSION_STATUS</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>USERNAME</span><span class="token punctuation">></span></span>atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>USERNAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GROUPNAME</span><span class="token punctuation">></span></span>supergroup<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GROUPNAME</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MODE</span><span class="token punctuation">></span></span>420<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MODE</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>PERMISSION_STATUS</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RECORD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EDITS</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>Q：NameNode如何确定下次开机启动的时候合并哪些Edits？</strong></p></li><li><p><strong>A：NameNode启动的时候合并的是上次停机前正在写入的Edits，即edits_inprogress_xxx，根据seen_txid里面记录最新的FsImage(镜像文件)的值去合并Edits(编辑日志)。</strong></p></li></ul><h3 id="5-3-CheckPoint时间设置"><a href="#5-3-CheckPoint时间设置" class="headerlink" title="5.3 CheckPoint时间设置"></a>5.3 CheckPoint时间设置</h3><ol><li>通常情况下，SecondaryNameNode每隔一小时执行一次。</li></ol><ul><li>[hdfs-default.xml]</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.checkpoint.period<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>3600<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次。</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.checkpoint.txns<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>1000000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>操作动作次数<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.checkpoint.check.period<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>60<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span> 1分钟检查一次操作次数<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span> <span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-NameNode故障处理"><a href="#5-4-NameNode故障处理" class="headerlink" title="5.4 NameNode故障处理"></a>5.4 NameNode故障处理</h2><ul><li><strong>NameNode故障后，可以采用如下两种方法恢复数据。</strong></li></ul><h3 id="5-4-1-方法一：将SecondaryNameNode中数据拷贝到NameNode存储数据的目录"><a href="#5-4-1-方法一：将SecondaryNameNode中数据拷贝到NameNode存储数据的目录" class="headerlink" title="5.4.1 方法一：将SecondaryNameNode中数据拷贝到NameNode存储数据的目录"></a>5.4.1 方法一：将SecondaryNameNode中数据拷贝到NameNode存储数据的目录</h3><ol><li><p>kill -9 NameNode，删除进程</p></li><li><p>删除NameNode存储的数据（&#x2F;opt&#x2F;module&#x2F;hadoop-2.7.2&#x2F;data&#x2F;tmp&#x2F;dfs&#x2F;name）</p></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ <span class="token function">rm</span> <span class="token operator">-</span>rf <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/<span class="token keyword">data</span><span class="token operator">/</span>tmp/dfs/name/<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>拷贝SecondaryNameNode中数据到原NameNode存储数据目录</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 dfs]</span>$ scp <span class="token operator">-</span>r atguigu@hadoop104:<span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/<span class="token keyword">data</span><span class="token operator">/</span>tmp/dfs/namesecondary/<span class="token operator">*</span> <span class="token punctuation">.</span><span class="token operator">/</span>name/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>重新启动NameNode</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ sbin/hadoop-daemon<span class="token punctuation">.</span>sh <span class="token function">start</span> namenode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-4-2-方法二：使用-importCheckpoint选项启动NameNode守护进程，从而将Secondary-NameNode中数据拷贝到NameNode目录中"><a href="#5-4-2-方法二：使用-importCheckpoint选项启动NameNode守护进程，从而将Secondary-NameNode中数据拷贝到NameNode目录中" class="headerlink" title="5.4.2 方法二：使用-importCheckpoint选项启动NameNode守护进程，从而将Secondary NameNode中数据拷贝到NameNode目录中"></a>5.4.2 方法二：使用-importCheckpoint选项启动NameNode守护进程，从而将Secondary NameNode中数据拷贝到NameNode目录中</h3><ol><li>修改hdfs-site.xml中的</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.checkpoint.period<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>120<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.name.dir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>/opt/module/hadoop-2.7.2/data/tmp/dfs/name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>kill -9 NameNode进程</p></li><li><p>删除NameNode存储的数据（&#x2F;opt&#x2F;module&#x2F;hadoop-2.7.2&#x2F;data&#x2F;tmp&#x2F;dfs&#x2F;name）</p></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ <span class="token function">rm</span> <span class="token operator">-</span>rf <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/<span class="token keyword">data</span><span class="token operator">/</span>tmp/dfs/name/<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>如果SecondaryNameNode不和NameNode在一个主机节点上，需要将SecondaryNameNode存储数据的目录拷贝到NameNode存储数据的平级目录（方法一为拷贝到下一级name目录里），并删除in_use.lock文件</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 dfs]</span>$ scp <span class="token operator">-</span>r atguigu@hadoop104:<span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/<span class="token keyword">data</span><span class="token operator">/</span>tmp/dfs/namesecondary <span class="token punctuation">.</span><span class="token operator">/</span><span class="token namespace">[atguigu@hadoop102 namesecondary]</span>$ <span class="token function">rm</span> <span class="token operator">-</span>rf in_use<span class="token punctuation">.</span>lock<span class="token namespace">[atguigu@hadoop102 dfs]</span>$ <span class="token function">pwd</span><span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/<span class="token keyword">data</span><span class="token operator">/</span>tmp/dfs<span class="token namespace">[atguigu@hadoop102 dfs]</span>$ <span class="token function">ls</span><span class="token keyword">data</span>  name  namesecondary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>导入检查点数据（等待一会ctrl+c结束掉）</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ bin/hdfs namenode <span class="token operator">-</span>importCheckpoint<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>启动NameNode</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ sbin/hadoop-daemon<span class="token punctuation">.</span>sh <span class="token function">start</span> namenode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>检查事物更多，过程更为标准。</strong></li></ul><h2 id="5-5-集群安全模式"><a href="#5-5-集群安全模式" class="headerlink" title="5.5 集群安全模式"></a>5.5 集群安全模式</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><ol><li><strong>NameNode启动</strong><br>NarneNode启动时，首先将镜像文件(FsImage）载入内存，并执行编辑日志(Edits）中的各项操作。一旦在内存中成功建立文件系统元数据的映像，则创建一个新的FsImage文件和一个空的编辑日志。此时，NameNode开始监听DataNode请求。这个过程期间，NameNode一直运行在<strong>安全模式，即NameNode的文件系统对于客户湍来说是只读的</strong>。</li><li><strong>DataNode启动</strong><br>系统中的数据块的位置并不是由NameNode维护的，而是以块列表的形式存储在DataNode中。在系统的正常操作期间，NameNode会在内存中保留所有块位置的映射信息。<strong>在安全模式下</strong>，各个DataNode会向NameNode发送新的块列表信息，NameNode了解到足够多的块位置信息之后，即可高效运行文件系统。</li><li><strong>安全模式退出判断</strong><br>如果满足”“最小副本条件”，NameNode会在30利钟之后就退出安全模式。所谓的最小副本条件指的是在整个文件系统中99.9%的块满足最小副本级别（默认值: dfsreplication.rin&#x3D;1)。在启动一个刚刚格式化的HDFS集群时，因为系统中还没有任何块，听以NameNode不会进入安全模式。</li></ol><h3 id="5-5-2-基本语法"><a href="#5-5-2-基本语法" class="headerlink" title="5.5.2 基本语法"></a>5.5.2 基本语法</h3><ul><li>集群处于安全模式，不能执行重要操作（写操作）。集群启动完成后，自动退出安全模式。</li></ul><ol><li><p>bin&#x2F;hdfs dfsadmin -safemode get        （功能描述：查看安全模式状态）</p></li><li><p>bin&#x2F;hdfs dfsadmin -safemode enter  （功能描述：进入安全模式状态）</p></li><li><p>bin&#x2F;hdfs dfsadmin -safemode leave    （功能描述：离开安全模式状态）</p></li><li><p>bin&#x2F;hdfs dfsadmin -safemode wait    （功能描述：等待安全模式状态）</p></li></ol><h3 id="5-5-3-案例"><a href="#5-5-3-案例" class="headerlink" title="5.5.3 案例"></a>5.5.3 案例</h3><ul><li>模拟等待安全模式</li></ul><ol><li><strong>查看当前模式</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfsadmin <span class="token operator">-</span>safemode getSafe mode is OFF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><strong>进入安全模式</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ bin/hdfs dfsadmin <span class="token operator">-</span>safemode enter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><strong>创建并执行下面的脚本</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">在<span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2路径上，编辑一个脚本safemode<span class="token punctuation">.</span>sh<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ touch safemode<span class="token punctuation">.</span>sh<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ vim safemode<span class="token punctuation">.</span>sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>编辑以下内容：</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#!/bin/bash</span><span class="token comment"># 等待离开安全模式之后执行下面的命令</span>hdfs dfsadmin <span class="token operator">-</span>safemode waithdfs dfs <span class="token operator">-</span>put <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/README<span class="token punctuation">.</span>txt <span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改脚本文件权限并执行（初始无反应）</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ chmod 777 safemode<span class="token punctuation">.</span>sh<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ <span class="token punctuation">.</span><span class="token operator">/</span>safemode<span class="token punctuation">.</span>sh <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>再打开一个窗口，执行如下命令，离开安全模式</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ bin/hdfs dfsadmin <span class="token operator">-</span>safemode leave<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li><strong>观察</strong></li></ol><p>（1）再观察上一个窗口，显示：Safe mode is OFF</p><p>（2）HDFS集群上已经有上传的数据了。</p><h2 id="5-6-NameNode多目录配置"><a href="#5-6-NameNode多目录配置" class="headerlink" title="5.6 NameNode多目录配置"></a>5.6 NameNode多目录配置</h2><ol><li><p>NameNode的本地目录可以配置成多个，且每个目录存放内容相同，增加了可靠性。</p></li><li><p>具体配置如下</p></li></ol><p>（1）在hdfs-site.xml文件中增加如下内容，文件路径的个数决定多目录的具体数量</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.name.dir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>file:///&#123;hadoop.tmp.dir&#125;/dfs/name1,file:///&#123;hadoop.tmp.dir&#125;/dfs/name2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）停止集群，删除data和logs中所有数据。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ <span class="token function">rm</span> <span class="token operator">-</span>rf <span class="token keyword">data</span><span class="token operator">/</span> logs/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）格式化集群并启动。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ bin/hdfs namenode –format<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ sbin/<span class="token function">start-dfs</span><span class="token punctuation">.</span>sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（4）查看结果</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 dfs]</span>$ ll总用量 12drwx-<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">.</span> 3 atguigu atguigu 4096 12月 11 08:03 <span class="token keyword">data</span>drwxrwxr-x<span class="token punctuation">.</span> 3 atguigu atguigu 4096 12月 11 08:03 name1drwxrwxr-x<span class="token punctuation">.</span> 3 atguigu atguigu 4096 12月 11 08:03 name2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-DataNode（面试开发重点）"><a href="#6-DataNode（面试开发重点）" class="headerlink" title="6 DataNode（面试开发重点）"></a>6 DataNode（面试开发重点）</h1><h2 id="6-1-DataNode工作机制"><a href="#6-1-DataNode工作机制" class="headerlink" title="6.1 DataNode工作机制"></a>6.1 DataNode工作机制</h2><ol><li>DataNode工作机制如图6.1：</li></ol><p><img src="http://img.fdchen.host/DataNode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="DataNode工作机制"></p><center>图6.1 DataNode工作机制</center><ol start="2"><li><strong>详细解释如下：</strong></li></ol><ul><li><p>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是<strong>元数据包括数据块的长度，块数据的校验和，以及时间戳</strong>。</p></li><li><p>DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。</p></li><li><p>心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟+30秒没有收到某个DataNode的心跳，则认为该节点不可用。</p></li><li><p>集群运行中可以安全加入和退出一些机器。</p></li></ul><h2 id="6-2-数据完整性"><a href="#6-2-数据完整性" class="headerlink" title="6.2 数据完整性"></a>6.2 数据完整性</h2><ul><li><strong>DataNode节点保证数据完整性的方法如下：</strong></li></ul><ol><li><p>当DataNode读取Block的时候，它会计算CheckSum。</p></li><li><p>如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏。</p></li><li><p>Client读取其他DataNode上的Block。</p></li><li><p>DataNode在其文件创建后<strong>周期验证</strong>CheckSum，验证方法示例如图6.2：</p></li></ol><p><img src="http://img.fdchen.host/%E9%AA%8C%E8%AF%81CheckSum%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B.png" alt="验证CheckSum方法示例"></p><center>图6.2 验证CheckSum方法示例</center><p><strong>Tip：CRC校验在实际运用中更合适，更准确。</strong></p><h2 id="6-3-掉线时限参数设置"><a href="#6-3-掉线时限参数设置" class="headerlink" title="6.3 掉线时限参数设置"></a>6.3 掉线时限参数设置</h2><ul><li><strong>DataNode掉线时限参数设置，如图6.3：</strong></li></ul><p><img src="http://img.fdchen.host/DataNode%E6%8E%89%E7%BA%BF%E6%97%B6%E9%99%90%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="DataNode掉线时限参数设置"></p><center>图6.3 DataNode掉线时限参数设置</center><p><strong>Tip：hdfs-site.xml 配置文件中的heartbeat.recheck.interval的单位为毫秒，dfs.heartbeat.interval的单位为秒。</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.heartbeat.recheck-interval<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>300000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--5分钟--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.heartbeat.interval<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--3秒--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-服役新数据节点"><a href="#6-4-服役新数据节点" class="headerlink" title="6.4 服役新数据节点"></a>6.4 服役新数据节点</h2><ol start="0"><li><p><strong>需求</strong></p><p>随着公司业务的增长，数据量越来越大，原有的数据节点的容量已经不能满足存储数据的需求，需要在原有集群基础上<strong>动态添加新的数据节点</strong>。</p></li><li><p><strong>环境准备</strong></p></li></ol><p>（1）在hadoop104主机上再克隆一台hadoop105主机<br>（2）修改IP地址和主机名称<br>（3）删除原来HDFS文件系统留存的文件（&#x2F;opt&#x2F;module&#x2F;hadoop-2.7.2&#x2F;data和log&#x2F;）<br>（4）source一下配置文件</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop105 hadoop-2.7.2]</span>$ source <span class="token operator">/</span>etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><strong>具体步骤</strong></li></ol><p>（1）直接启动DataNode，即可关联到集群</p><p>（2）在hadoop105上上传文件示例如下</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop105 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>put <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/LICENSE<span class="token punctuation">.</span>txt <span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）<strong>如果数据不均衡，可以用命令实现集群的再平衡</strong></p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 sbin]</span>$ <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">start-balancer</span><span class="token punctuation">.</span>shstarting balancer<span class="token punctuation">,</span> logging to <span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/logs/hadoop-atguigu-balancer-hadoop102<span class="token punctuation">.</span>outTime Stamp               Iteration<span class="token comment">#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-5-退役旧数据节点"><a href="#6-5-退役旧数据节点" class="headerlink" title="6.5 退役旧数据节点"></a>6.5 退役旧数据节点</h2><h3 id="6-5-1-添加白名单"><a href="#6-5-1-添加白名单" class="headerlink" title="6.5.1 添加白名单"></a>6.5.1 添加白名单</h3><ul><li><p><strong>添加到白名单的主机节点，都允许访问NameNode，不在白名单的主机节点，都会被退出。</strong></p></li><li><p><strong>配置白名单的步骤如下：</strong></p></li></ul><ol><li><strong>在NameNode的&#x2F;opt&#x2F;module&#x2F;hadoop-2.7.2&#x2F;etc&#x2F;hadoop目录下创建dfs.hosts（自定义名称，但官方建议这样命名）文件</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ <span class="token function">pwd</span><span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/etc/hadoop<span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ touch dfs<span class="token punctuation">.</span>hosts<span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ vi dfs<span class="token punctuation">.</span>hosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>添加如下主机名称（不添加hadoop105），不可有空格或空白</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hadoop102hadoop103hadoop104<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>在NameNode的hdfs-site.xml配置文件中增加dfs.hosts属性</strong></li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.hosts<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>/opt/module/hadoop-2.7.2/etc/hadoop/dfs.hosts<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>配置文件分发</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ xsync hdfs-site<span class="token punctuation">.</span>xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><strong>刷新NameNode</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfsadmin <span class="token operator">-</span>refreshNodesRefresh nodes successful<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="5"><li><strong>更新ResourceManager节点</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ yarn rmadmin <span class="token operator">-</span>refreshNodes17/06/24 14:17:11 INFO client<span class="token punctuation">.</span>RMProxy: Connecting to ResourceManager at hadoop103/192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>1<span class="token punctuation">.</span>103:8033<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="6"><li><strong>在Web浏览器上查看</strong></li></ol><p><img src="http://img.fdchen.host/Web%E6%9F%A5%E7%9C%8BDataNode%E4%BF%A1%E6%81%AF.png" alt="Web查看DataNode信息"></p><center>图6.4 Web查看DataNode信息</center><ol start="7"><li><strong>如果数据不均衡，可以用命令实现集群的再平衡</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 sbin]</span>$ <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">start-balancer</span><span class="token punctuation">.</span>sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-5-2-黑名单退役"><a href="#6-5-2-黑名单退役" class="headerlink" title="6.5.2 黑名单退役"></a>6.5.2 黑名单退役</h3><ul><li><strong>在黑名单上面的主机都会被强制退出。</strong></li><li><strong>具体步骤如下：</strong></li></ul><ol><li><strong>在NameNode的&#x2F;opt&#x2F;module&#x2F;hadoop-2.7.2&#x2F;etc&#x2F;hadoop目录下创建dfs.hosts.exclude文件</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ <span class="token function">pwd</span><span class="token operator">/</span>opt/module/hadoop-2<span class="token punctuation">.</span>7<span class="token punctuation">.</span>2/etc/hadoop<span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ touch dfs<span class="token punctuation">.</span>hosts<span class="token punctuation">.</span>exclude<span class="token namespace">[atguigu@hadoop102 hadoop]</span>$ vi dfs<span class="token punctuation">.</span>hosts<span class="token punctuation">.</span>exclude<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>添加如下主机名称（要退役的节点），不允许有空格或空行</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hadoop105<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><strong>在NameNode的hdfs-site.xml配置文件中增加dfs.hosts.exclude属性</strong></li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.hosts.exclude<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>/opt/module/hadoop-2.7.2/etc/hadoop/dfs.hosts.exclude<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>刷新NameNode、刷新ResourceManager</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfsadmin <span class="token operator">-</span>refreshNodesRefresh nodes successful<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ yarn rmadmin <span class="token operator">-</span>refreshNodes17/06/24 14:55:56 INFO client<span class="token punctuation">.</span>RMProxy: Connecting to ResourceManager at hadoop103/192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>1<span class="token punctuation">.</span>103:8033<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p><strong>检查Web浏览器，退役节点的状态为decommission in progress（退役中），说明数据节点正在复制块到其他节点</strong></p></li><li><p><strong>等待退役节点状态为decommissioned（所有块已经复制完成），停止该节点及节点资源管理器。</strong></p></li></ol><ul><li><strong>Tip：如果副本数是3，服役的节点小于等于3，是不能退役成功的，需要修改副本数后才能退役</strong></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop105 hadoop-2.7.2]</span>$ sbin/hadoop-daemon<span class="token punctuation">.</span>sh stop datanodestopping datanode<span class="token namespace">[atguigu@hadoop105 hadoop-2.7.2]</span>$ sbin/yarn-daemon<span class="token punctuation">.</span>sh stop nodemanagerstopping nodemanager<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><strong>如果数据不均衡，可以用命令实现集群的再平衡</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ sbin/<span class="token function">start-balancer</span><span class="token punctuation">.</span>sh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>Tip：不允许白名单和黑名单中同时出现同一个主机名称。</strong></li></ul><h2 id="6-6-DataNode多目录配置"><a href="#6-6-DataNode多目录配置" class="headerlink" title="6.6 DataNode多目录配置"></a>6.6 DataNode多目录配置</h2><ol><li><strong>DataNode也可以配置成多个目录，每个目录存储的数据不一样（与NameNode不同）。</strong>即：不同路径下数据不同，不是副本的关系。</li><li>具体配置如下（类似NameNode的多目录配置）：</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.datanode.data.dir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>file:///$&#123;hadoop.tmp.dir&#125;/dfs/data1,file:///$&#123;hadoop.tmp.dir&#125;/dfs/data2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-HDFS-2-X-新特性"><a href="#7-HDFS-2-X-新特性" class="headerlink" title="7 HDFS 2.X 新特性"></a>7 HDFS 2.X 新特性</h1><h2 id="7-1-集群间数据拷贝"><a href="#7-1-集群间数据拷贝" class="headerlink" title="7.1 集群间数据拷贝"></a>7.1 集群间数据拷贝</h2><h3 id="7-1-1-scp实现两个远程主机之间的文件复制"><a href="#7-1-1-scp实现两个远程主机之间的文件复制" class="headerlink" title="7.1.1 scp实现两个远程主机之间的文件复制"></a>7.1.1 scp实现两个远程主机之间的文件复制</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">scp <span class="token operator">-</span>r hello<span class="token punctuation">.</span>txt root@hadoop103:<span class="token operator">/</span>user/atguigu/hello<span class="token punctuation">.</span>txt<span class="token operator">/</span><span class="token operator">/</span> 推 pushscp <span class="token operator">-</span>r root@hadoop103:<span class="token operator">/</span>user/atguigu/hello<span class="token punctuation">.</span>txt  hello<span class="token punctuation">.</span>txt<span class="token operator">/</span><span class="token operator">/</span> 拉 pullscp <span class="token operator">-</span>r root@hadoop103:<span class="token operator">/</span>user/atguigu/hello<span class="token punctuation">.</span>txt root@hadoop104:<span class="token operator">/</span>user/atguigu  <span class="token operator">/</span><span class="token operator">/</span>是通过本地主机中转实现两个远程主机的文件复制；如果在两个远程主机之间ssh没有配置的情况下可以使用该方式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-1-2-采用distcp命令实现两个Hadoop集群之间的递归数据复制"><a href="#7-1-2-采用distcp命令实现两个Hadoop集群之间的递归数据复制" class="headerlink" title="7.1.2 采用distcp命令实现两个Hadoop集群之间的递归数据复制"></a>7.1.2 采用distcp命令实现两个Hadoop集群之间的递归数据复制</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$  bin/hadoop distcphdfs:<span class="token operator">/</span><span class="token operator">/</span>haoop102:9000/user/atguigu/hello<span class="token punctuation">.</span>txt hdfs:<span class="token operator">/</span><span class="token operator">/</span>hadoop103:9000/user/atguigu/hello<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-2-小文件存档"><a href="#7-2-小文件存档" class="headerlink" title="7.2 小文件存档"></a>7.2 小文件存档</h2><h3 id="7-2-1-HDFS存储小文件弊端"><a href="#7-2-1-HDFS存储小文件弊端" class="headerlink" title="7.2.1 HDFS存储小文件弊端"></a>7.2.1 HDFS存储小文件弊端</h3><p>每个文件均按块存储，每个块的元教据存储在NameNode的内存中，因此HDFS存储小文件会非常低效。因为大量的小文件会耗尽NamdNode中的大部分内存。但注意，存储小文件所需要的磁盘容量和数据块的大小无关。例如，一个1NMB的文件设置为128MB的块存储，实际使用的是1M的磁盘空间，而不是128M。</p><h3 id="7-2-2-解决存储小文件办法之一"><a href="#7-2-2-解决存储小文件办法之一" class="headerlink" title="7.2.2 解决存储小文件办法之一"></a>7.2.2 解决存储小文件办法之一</h3><p>HDFS存档文件或HAR文件，是一个更高效的文件存档工具，它将文件存入HDFS块，在减少NameNode内存使用的同时，允许对文件进行透明的访问。具体说来，HDFS存档文件对内还是一个一个独立文件，对NameNode而言却是一个整体，减少了NameNode的内存。如图7.1：</p><p><img src="http://img.fdchen.host/HDFS%E5%AD%98%E6%A1%A3%E6%96%87%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="HDFS存档文件示意图"></p><center>图7.1 HDFS存档文件示意图</center><h3 id="7-2-3-案例实操"><a href="#7-2-3-案例实操" class="headerlink" title="7.2.3 案例实操"></a>7.2.3 案例实操</h3><ol><li><strong>需要启动YARN进程</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ <span class="token function">start-yarn</span><span class="token punctuation">.</span>sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><strong>归档文件</strong></li></ol><ul><li>把&#x2F;user&#x2F;atguigu&#x2F;input目录里面的所有文件归档成一个叫input.har的归档文件，并把归档后文件存储到&#x2F;user&#x2F;atguigu&#x2F;output路径下。</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ bin/hadoop archive <span class="token operator">-</span>archiveName input<span class="token punctuation">.</span>har –p <span class="token operator">/</span>user/atguigu/input  <span class="token operator">/</span>user/atguigu/output<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><strong>查看归档</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>lsr <span class="token operator">/</span>user/atguigu/output/input<span class="token punctuation">.</span>har<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>lsr har:<span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>user/atguigu/output/input<span class="token punctuation">.</span>har<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Tip：har是一个协议，用于查看归档成.har的目录。</strong></p><ol start="4"><li><strong>解归档文件</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">cp</span> har:<span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>user/atguigu/output/input<span class="token punctuation">.</span>har/<span class="token operator">*</span>  <span class="token operator">/</span>user/atguigu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-3-回收站"><a href="#7-3-回收站" class="headerlink" title="7.3 回收站"></a>7.3 回收站</h2><ul><li>开启回收站功能，可以将删除的文件在不超时的情况下，恢复原数据，起到防止误删除、备份等作用。</li></ul><h3 id="7-3-1-回收站参数设置及工作机制"><a href="#7-3-1-回收站参数设置及工作机制" class="headerlink" title="7.3.1 回收站参数设置及工作机制"></a>7.3.1 回收站参数设置及工作机制</h3><p><img src="http://img.fdchen.host/%E5%9B%9E%E6%94%B6%E7%AB%99%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="回收站参数设置及工作机制"></p><center>图7.2 回收站参数设置及工作机制</center><ul><li><strong>Tip：fs.trash.interval和fs.trash.checkpoint.interval的单位都为分钟。</strong></li></ul><h3 id="7-3-2-启用回收站"><a href="#7-3-2-启用回收站" class="headerlink" title="7.3.2 启用回收站"></a>7.3.2 启用回收站</h3><ul><li>修改core-site.xml，配置垃圾回收时间为1分钟。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>fs.trash.interval<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-3-查看回收站"><a href="#7-3-3-查看回收站" class="headerlink" title="7.3.3 查看回收站"></a>7.3.3 查看回收站</h3><ul><li>当trash启动的话，每个用户都会有自己的回收站目录，这个目录名是.Trash这个具体路径是&#x2F;user&#x2F;集群用户&#x2F;.Trash，比如：&#x2F;user&#x2F;atguigu&#x2F;.Trash&#x2F;….</li></ul><h3 id="7-3-4-修改访问垃圾回收站用户名称"><a href="#7-3-4-修改访问垃圾回收站用户名称" class="headerlink" title="7.3.4 修改访问垃圾回收站用户名称"></a>7.3.4 修改访问垃圾回收站用户名称</h3><ul><li><p>进入垃圾回收站用户名称，默认是dr.who，修改为atguigu用户</p></li><li><p>[core-site.xml]</p></li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.http.staticuser.user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-5-通过程序删除的文件不会经过回收站，需要调用moveToTrash-才进入回收站"><a href="#7-3-5-通过程序删除的文件不会经过回收站，需要调用moveToTrash-才进入回收站" class="headerlink" title="7.3.5 通过程序删除的文件不会经过回收站，需要调用moveToTrash()才进入回收站"></a>7.3.5 通过程序删除的文件不会经过回收站，需要调用moveToTrash()才进入回收站</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Trash</span> trash <span class="token operator">=</span> <span class="token class-name">New</span> <span class="token class-name">Trash</span><span class="token punctuation">(</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span>trash<span class="token punctuation">.</span><span class="token function">moveToTrash</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7-3-6-恢复回收站数据"><a href="#7-3-6-恢复回收站数据" class="headerlink" title="7.3.6 恢复回收站数据"></a>7.3.6 恢复回收站数据</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span><span class="token function">mv</span><span class="token operator">/</span>user/atguigu/<span class="token punctuation">.</span>Trash/Current/user/atguigu/input   <span class="token operator">/</span>user/atguigu/input<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>实质是文件移动。</li></ul><h3 id="7-3-7-清空回收站"><a href="#7-3-7-清空回收站" class="headerlink" title="7.3.7 清空回收站"></a>7.3.7 清空回收站</h3><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hadoop fs <span class="token operator">-</span>expunge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>Tip：这个命令不是立即清空我们的回收站，而是将回收站的文件全部立即放入由时间戳命名的文件目录。</strong></li></ul><h3 id="7-3-8-回收站工作机制总结"><a href="#7-3-8-回收站工作机制总结" class="headerlink" title="7.3.8 回收站工作机制总结"></a>7.3.8 回收站工作机制总结</h3><ol><li>执行删除文件操作，系统首先会将文件移动到&#x2F;user&#x2F;atguigu&#x2F;.Trash&#x2F;current目录；</li><li>等到下一次回收站进行检查时，处于current目录的文件会被放入对应由时间戳命名的文件目录；</li><li>然后回收站循环检查，逐步清理这些由时间戳命名的文件目录，也就是删除达到存活时间的文件目录；</li><li><strong>文件在回收站的存活时间指的就是被删除文件在这些以时间戳命名的文件目录下的存储时间。</strong></li></ol><h2 id="7-4-快照管理"><a href="#7-4-快照管理" class="headerlink" title="7.4 快照管理"></a>7.4 快照管理</h2><ul><li><p>快照相当于<strong>对目录做一个备份</strong>，并不会立即复制所有文件，而是指向同一个文件。当写入发生时，才会产生新文件，也就是说快照是记录文件变化。</p></li><li><p>基本语法</p></li></ul><ol><li><strong>开启&#x2F;禁用指定目录的快照功能</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfsadmin <span class="token operator">-</span>allowSnapshot <span class="token operator">/</span>user/atguigu/input<span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfsadmin <span class="token operator">-</span>disallowSnapshot <span class="token operator">/</span>user/atguigu/input<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>Tip：禁用快照前，必须删除对应目录的快照，否则无法删除。</strong></li></ul><ol start="2"><li><strong>对目录创建快照，不指定名称时，系统以时间戳命名</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfs <span class="token operator">-</span>createSnapshot <span class="token operator">/</span>user/atguigu/input<span class="token comment"># 通过web访问hdfs://hadoop102:50070/user/atguigu/input/.snapshot/s…  </span><span class="token comment"># 可以发现快照和源文件使用相同数据</span><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfs <span class="token operator">-</span>lsr <span class="token operator">/</span>user/atguigu/input/<span class="token punctuation">.</span>snapshot/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>指定名称创建快照</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfs <span class="token operator">-</span>createSnapshot <span class="token operator">/</span>user/atguigu/input  miao170508<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><strong>重命名快照</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 语法格式：hdfs dfs -renameSnapshot path oldName newName</span><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfs <span class="token operator">-</span>renameSnapshot <span class="token operator">/</span>user/atguigu/input/ miao170508 atguigu170508<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="5"><li><strong>列出当前用户所有可快照目录（允许快照的目录）</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs lsSnapshottableDir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li><strong>比较两个快照目录或者快照与文件目录的不同之处</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 语法格式：hdfs snapshotDiff fromPath . toPath (用.区分两个路径)</span><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs snapshotDiff <span class="token operator">/</span>user/atguigu/input/  <span class="token punctuation">.</span>  <span class="token punctuation">.</span>snapshot/atguigu170508<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Tip：</strong></p><ul><li>用“-”表示后者相对于前者少了一个文件，可能是前者新增了一个文件；</li><li>用“+”表示后者比前者多了一个文件，可能是前者删除了一个文件。</li></ul><ol start="7"><li><strong>恢复快照</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token namespace">[atguigu@hadoop102 hadoop-2.7.2]</span>$ hdfs dfs <span class="token operator">-</span><span class="token function">cp</span><span class="token operator">/</span>user/atguigu/input/<span class="token punctuation">.</span>snapshot/s20170708-134303<span class="token punctuation">.</span>027 <span class="token operator">/</span>user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="8"><li><strong>删除快照</strong></li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># 语法格式：hdfs dfs -deleteSnapshot &lt;path> &lt;snapshotName></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>PS</strong>：视频教程查看<a href="http://www.atguigu.com/download_detail.shtml?v=52">尚硅谷-Hadoop视频教程</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏夹</title>
      <link href="/2020/sui-bi-shou-cang-jia/"/>
      <url>/2020/sui-bi-shou-cang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="1-AI"><a href="#1-AI" class="headerlink" title="1 AI"></a>1 AI</h1><h2 id="1-1-学习笔记"><a href="#1-1-学习笔记" class="headerlink" title="1.1 学习笔记"></a>1.1 学习笔记</h2><h3 id="1-1-1-吴恩达机器学习视频教程笔记"><a href="#1-1-1-吴恩达机器学习视频教程笔记" class="headerlink" title="1.1.1 吴恩达机器学习视频教程笔记"></a>1.1.1 <a href="https://zhuanlan.zhihu.com/p/43654114">吴恩达机器学习视频教程笔记</a></h3><h3 id="1-1-2-NLP-with-DL-by-Chris-Manning"><a href="#1-1-2-NLP-with-DL-by-Chris-Manning" class="headerlink" title="1.1.2 NLP with DL by Chris Manning"></a>1.1.2 NLP with DL by Chris Manning</h3><ul><li>视频链接：<a href="https://www.bilibili.com/video/BV1Eb411H7Pq?p=6">https://www.bilibili.com/video/BV1Eb411H7Pq?p=6</a></li><li>中文笔记链接：<a href="https://github.com/LooperXX/CS224n-Reading-Notes/">https://github.com/LooperXX/CS224n-Reading-Notes/</a></li></ul><h2 id="1-2-优秀博客"><a href="#1-2-优秀博客" class="headerlink" title="1.2 优秀博客"></a>1.2 优秀博客</h2><h3 id="1-2-1-机器学习任务的一般流程及必要步骤"><a href="#1-2-1-机器学习任务的一般流程及必要步骤" class="headerlink" title="1.2.1 机器学习任务的一般流程及必要步骤"></a>1.2.1 <a href="https://blog.csdn.net/XB_please/article/details/102756665">机器学习任务的一般流程及必要步骤</a></h3><h3 id="1-2-2-scikit-learn-预处理数据"><a href="#1-2-2-scikit-learn-预处理数据" class="headerlink" title="1.2.2 scikit-learn-预处理数据"></a>1.2.2 <a href="https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing">scikit-learn-预处理数据</a></h3><h2 id="1-3-资源网站"><a href="#1-3-资源网站" class="headerlink" title="1.3 资源网站"></a>1.3 资源网站</h2><h3 id="1-3-1-竞赛与数据集-Kaggle"><a href="#1-3-1-竞赛与数据集-Kaggle" class="headerlink" title="1.3.1 竞赛与数据集-Kaggle"></a>1.3.1 <a href="https://www.kaggle.com/">竞赛与数据集-Kaggle</a></h3><h3 id="1-3-2-免费GPU-Colab"><a href="#1-3-2-免费GPU-Colab" class="headerlink" title="1.3.2 免费GPU-Colab"></a>1.3.2 <a href="https://colab.research.google.com/?utm_source=scs-index">免费GPU-Colab</a></h3><h3 id="1-3-3-寻找论文源码-Paper-with-code"><a href="#1-3-3-寻找论文源码-Paper-with-code" class="headerlink" title="1.3.3 寻找论文源码-Paper with code"></a>1.3.3 <a href="https://paperswithcode.com/sota">寻找论文源码-Paper with code</a></h3><h1 id="2-辅助工具"><a href="#2-辅助工具" class="headerlink" title="2 辅助工具"></a>2 辅助工具</h1><h2 id="2-1-博客搭建"><a href="#2-1-博客搭建" class="headerlink" title="2.1 博客搭建"></a>2.1 博客搭建</h2><h3 id="2-1-1-Typora-PicGo-七牛云搭建博客写作环境"><a href="#2-1-1-Typora-PicGo-七牛云搭建博客写作环境" class="headerlink" title="2.1.1 Typora+PicGo+七牛云搭建博客写作环境"></a>2.1.1 Typora+PicGo+七牛云搭建博客写作环境</h3><ul><li><a href="https://my.oschina.net/u/4115721/blog/4827426">Typora+PicGo+Gitee搭建博客写作环境</a></li><li><a href="https://blog.csdn.net/javacs123/article/details/106268130">PicGo设置免费图床之七牛云</a></li></ul><h2 id="2-2-PDF在线工具"><a href="#2-2-PDF在线工具" class="headerlink" title="2.2 PDF在线工具"></a>2.2 PDF在线工具</h2><h3 id="2-2-1-PDF在线转换"><a href="#2-2-1-PDF在线转换" class="headerlink" title="2.2.1 PDF在线转换"></a>2.2.1 <a href="https://www.cleverpdf.com/cn">PDF在线转换</a></h3><h1 id="3-优秀项目"><a href="#3-优秀项目" class="headerlink" title="3 优秀项目"></a>3 优秀项目</h1><h2 id="3-1-WebMagic爬虫"><a href="#3-1-WebMagic爬虫" class="headerlink" title="3.1 WebMagic爬虫"></a>3.1 <a href="https://github.com/code4craft/webmagic">WebMagic爬虫</a></h2><h2 id="3-2-系统级项目"><a href="#3-2-系统级项目" class="headerlink" title="3.2 系统级项目"></a>3.2 系统级项目</h2><h3 id="3-2-1-Github实战项目"><a href="#3-2-1-Github实战项目" class="headerlink" title="3.2.1 Github实战项目"></a>3.2.1 <a href="https://www.githubs.cn/real-world">Github实战项目</a></h3><h1 id="4-工具网站"><a href="#4-工具网站" class="headerlink" title="4 工具网站"></a>4 工具网站</h1><h2 id="4-1-云服务器吧"><a href="#4-1-云服务器吧" class="headerlink" title="4.1 云服务器吧"></a>4.1 <a href="https://www.yunfuwuqiba.com/tencent">云服务器吧</a></h2><h2 id="4-2-图片在线处理"><a href="#4-2-图片在线处理" class="headerlink" title="4.2 图片在线处理"></a>4.2 图片在线处理</h2><h3 id="4-2-1-降低图片大小"><a href="#4-2-1-降低图片大小" class="headerlink" title="4.2.1 降低图片大小"></a>4.2.1 降低图片大小</h3><ol><li><a href="https://www.iloveimg.com/zh-cn">iLoveIMG</a></li><li></li></ol><h2 id="4-3-编码规范"><a href="#4-3-编码规范" class="headerlink" title="4.3 编码规范"></a>4.3 编码规范</h2><h3 id="4-3-1-通用缩写"><a href="#4-3-1-通用缩写" class="headerlink" title="4.3.1 通用缩写"></a>4.3.1 通用缩写</h3><ol><li><a href="https://blog.csdn.net/bluehawksky/article/details/79041409">代码通用缩写表</a></li></ol><h2 id="4-4-翻译网站"><a href="#4-4-翻译网站" class="headerlink" title="4.4 翻译网站"></a>4.4 翻译网站</h2><h3 id="4-4-1-DeepL翻译"><a href="#4-4-1-DeepL翻译" class="headerlink" title="4.4.1 DeepL翻译"></a>4.4.1 <a href="https://www.deepl.com/zh/translator">DeepL翻译</a></h3><h1 id="5-优秀网课"><a href="#5-优秀网课" class="headerlink" title="5 优秀网课"></a>5 优秀网课</h1><h2 id="5-1-CQU操作系统网课"><a href="#5-1-CQU操作系统网课" class="headerlink" title="5.1 CQU操作系统网课"></a>5.1 <a href="https://www.bilibili.com/video/BV19741197cf?p=2">CQU操作系统网课</a></h2><h1 id="6-精选图片网站"><a href="#6-精选图片网站" class="headerlink" title="6 精选图片网站"></a>6 精选图片网站</h1><h2 id="6-1-壁纸网站"><a href="#6-1-壁纸网站" class="headerlink" title="6.1 壁纸网站"></a>6.1 壁纸网站</h2><h3 id="6-1-1-WallHaven"><a href="#6-1-1-WallHaven" class="headerlink" title="6.1.1 WallHaven"></a>6.1.1 <a href="https://wallhaven.cc/">WallHaven</a></h3><h2 id="6-2-图片网站"><a href="#6-2-图片网站" class="headerlink" title="6.2 图片网站"></a>6.2 图片网站</h2><h2 id="6-3-矢量图网站"><a href="#6-3-矢量图网站" class="headerlink" title="6.3 矢量图网站"></a>6.3 矢量图网站</h2><h1 id="7-电子书库"><a href="#7-电子书库" class="headerlink" title="7 电子书库"></a>7 电子书库</h1><h2 id="7-1-计算机电子书"><a href="#7-1-计算机电子书" class="headerlink" title="7.1 计算机电子书"></a>7.1 计算机电子书</h2><h3 id="7-1-1-Github仓库"><a href="#7-1-1-Github仓库" class="headerlink" title="7.1.1 Github仓库"></a>7.1.1 Github仓库</h3><ol><li><a href="https://github.com/XiangLinPro/IT_book">IT_book</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏夹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse创建Maven Project之Debug</title>
      <link href="/2020/java-eclipse-chuang-jian-maven-project-huan-jing-pei-zhi-debug/"/>
      <url>/2020/java-eclipse-chuang-jian-maven-project-huan-jing-pei-zhi-debug/</url>
      
        <content type="html"><![CDATA[<h3 id="1-报错JRE-Compiler-Compliance-Problem-和-Java-Build-Path-Problems"><a href="#1-报错JRE-Compiler-Compliance-Problem-和-Java-Build-Path-Problems" class="headerlink" title="1. 报错JRE Compiler Compliance Problem 和  Java Build Path Problems"></a>1. 报错JRE Compiler Compliance Problem 和  Java Build Path Problems</h3><ul><li><strong>错误如图：</strong></li></ul><p><img src="http://img.fdchen.host/JRE%20Compiler%20Compliance%20Problem.jpg" alt="JRE Compiler Compliance Problem"></p><center>图1.1 JRE Compiler Compliance Problem</center><ul><li><strong>产生原因：</strong>pom.xml文件中引入的JDK，与电脑上安装的JDK版本不符。</li></ul><p>pom.xml文件中引入JDK的依赖如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>jdk.tools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jdk.tools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>system<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>systemPath</span><span class="token punctuation">></span></span>$&#123;JAVA_HOME&#125;/lib/tools.jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>systemPath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><ul><li><strong>解决办法：</strong>统一pom.xml文件与电脑上安装的JDK版本，建议使用1.8版本，目前的11.0以及12.0版本没有对应的tool.jar文件，可能出现其他错误。</li><li><strong>Tip：</strong><ul><li>在电脑上配置JDK的教程搜索即可，此处不赘述。</li><li>配置好环境之后，在windows的CMD命令窗口输入“Java -version”，查看JDK版本，如果版本未改变请重启电脑；如果报错请重新尝试配置。</li><li>修改电脑上的JDK版之后记得修改Eclipse上使用的JDK版本，不然会报错，见<strong>错误3</strong>。</li></ul></li></ul><h3 id="2-类中无法自动导入org-apache-hadoop等相关包"><a href="#2-类中无法自动导入org-apache-hadoop等相关包" class="headerlink" title="2. 类中无法自动导入org.apache.hadoop等相关包"></a>2. 类中无法自动导入org.apache.hadoop等相关包</h3><h3 id="或者-报错The-container-‘Maven-Dependencies’-references-non-existing-library"><a href="#或者-报错The-container-‘Maven-Dependencies’-references-non-existing-library" class="headerlink" title="或者 报错The container ‘Maven Dependencies’ references non existing library"></a>或者 报错The container ‘Maven Dependencies’ references non existing library</h3><ul><li><p><strong>产生原因：</strong>pom.xml文件引入的依赖没有成功导入本地库。</p></li><li><p><strong>解决办法：右键点击项目名</strong> –&gt; <strong>Maven</strong> –&gt; <strong>Update Project</strong> –&gt; <strong>勾选Force Update of Snapshots&#x2F;Releases</strong> –&gt; <strong>点击OK</strong>，下载相关插件jar包即可， 时间可能有点长，耐心等待。</p></li><li><p><strong>Tip：</strong></p><ul><li><p>利用Maven下载插件jar包速度很慢，可以采用以下方法加快下载速度：</p><ul><li>获取jar下载位置后自行下载到本地</li><li>将下载的jar包拷贝到maven的本地库，maven本地库的位置是C:\Users\username\.m2\repository</li><li>jar包所在位置可以根据jar的下载地址后半段获知，如图2.1：</li></ul><p><img src="http://img.fdchen.host/jar%E5%8C%85%E7%9A%84%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE.png" alt="jar包的所在位置"></p><center>图2.1 jar包的所在位置</center></li><li><p>部分插件jar包可从此处下载（注意版本是否对应）：</p><ul><li>链接：<a href="https://pan.baidu.com/s/1aWpcGuakhaAJOnvFuLbGjA">https://pan.baidu.com/s/1aWpcGuakhaAJOnvFuLbGjA</a><br>提取码：o1hc</li></ul></li></ul></li></ul><h3 id="3-报错WARNING-Illegal-reflective-access-by-org-apache-hadoop-security-authentication-util-KerberosUtil"><a href="#3-报错WARNING-Illegal-reflective-access-by-org-apache-hadoop-security-authentication-util-KerberosUtil" class="headerlink" title="3. 报错WARNING: Illegal reflective access by org.apache.hadoop.security.authentication.util.KerberosUtil"></a>3. 报错WARNING: Illegal reflective access by org.apache.hadoop.security.authentication.util.KerberosUtil</h3><ul><li><strong>产生原因：</strong>Eclipse调用的JDK版本太高。</li><li><strong>解决办法：</strong>修改Eclipse调用的JDK，使用JDK 1.8版本，步骤如下：<ul><li>点击<strong>Window</strong> –&gt; <strong>Preferences</strong> –&gt; <strong>Java</strong> –&gt; <strong>Installed JREs</strong> –&gt; <strong>Add</strong> –&gt; <strong>Standard VM</strong> –&gt; <strong>Next</strong> –&gt; <strong>Directory</strong> –&gt; <strong>选择JDK的安装目录，如”C:\Program Files\Java\jdk1.8.0_144”</strong> –&gt; <strong>Finish</strong> –&gt; <strong>Apply and Close</strong>。</li></ul></li></ul><h3 id="4-连接Hdoop集群报错Retrying-connect-to-server-hadoop101-x2F-192-168-1-101-9000-Already-tried-0-time-s-maxRetries-x3D-45"><a href="#4-连接Hdoop集群报错Retrying-connect-to-server-hadoop101-x2F-192-168-1-101-9000-Already-tried-0-time-s-maxRetries-x3D-45" class="headerlink" title="4. 连接Hdoop集群报错Retrying connect to server: hadoop101&#x2F;192.168.1.101:9000. Already tried 0 time(s); maxRetries&#x3D;45"></a>4. 连接Hdoop集群报错Retrying connect to server: hadoop101&#x2F;192.168.1.101:9000. Already tried 0 time(s); maxRetries&#x3D;45</h3><ul><li><strong>产生原因：</strong>访问的Hadoop集群的防火墙未关闭，需要关闭防火墙。</li><li><strong>解决办法：</strong>在对应虚拟机上输入命令”service iptables stop”，关闭防火墙（需要root用户输入或者使用sudo命令）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Debug </tag>
            
            <tag> Eclipse </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用MSTSC进行连接阿里云Windows服务器</title>
      <link href="/2020/fu-wu-qi-li-yong-mstsc-jin-xing-lian-jie-a-li-yun-windows-fu-wu-qi/"/>
      <url>/2020/fu-wu-qi-li-yong-mstsc-jin-xing-lian-jie-a-li-yun-windows-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置规则"><a href="#1-配置规则" class="headerlink" title="1 配置规则"></a>1 配置规则</h1><ol><li>在实例详情里面进入“<strong>本实例安全组</strong>”界面，<br><img src="https://img-blog.csdnimg.cn/2020030717415913.png" alt="在这里插入图片描述"></li><li>进入对应实例界面，选择“<strong>快速创建规则</strong>”<br><img src="https://img-blog.csdnimg.cn/20200307174518170.png" alt="在这里插入图片描述"></li><li>选择常用的端口，如：SSH, HTTP, HTTPS, MYSQL等，<br>授权对象自行选择：<br>将端口授权给单个IP地址，填写：123.123.123.123，直接填IP地址即可；<br>将端口授权给IP地址段，填写：10.10.10.1&#x2F;24，直接填IP地址段；<br>将端口授权给全部IP，填写：0.0.0.0&#x2F;0，将端口授权给所有人。<br><img src="https://img-blog.csdnimg.cn/20200307175132754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><span id="more"></span><h1 id="2-登录连接"><a href="#2-登录连接" class="headerlink" title="2 登录连接"></a>2 登录连接</h1><h2 id="2-0-重置实例密码"><a href="#2-0-重置实例密码" class="headerlink" title="2.0 重置实例密码"></a>2.0 重置实例密码</h2><font color="red"><strong>第一次登录需要重置实例密码</strong></font>，如图，选择“<strong>重置实例密码</strong>”。<br><img src="https://img-blog.csdnimg.cn/20200307171231277.png" alt="在这里插入图片描述"><br><font color="red"><strong>Tips：每次重置实例密码之后必须重启才能生效！</strong></font></li></ol><h2 id="2-1-网页远程连接——不支持文件传输"><a href="#2-1-网页远程连接——不支持文件传输" class="headerlink" title="2.1 网页远程连接——不支持文件传输"></a>2.1 网页远程连接——不支持文件传输</h2><p>网页远程连接服务器有两个途径，<strong>workbench</strong> 与 <strong>VNC</strong>。</p><h3 id="2-1-1-workbench连接"><a href="#2-1-1-workbench连接" class="headerlink" title="2.1.1 workbench连接"></a>2.1.1 workbench连接</h3><p>workbench是直接远程连接桌面，如图，用户名在购买之后会以短信形式发送给你，一般是administrator。<br><img src="https://img-blog.csdnimg.cn/20200307171211732.png" alt="在这里插入图片描述"></p><h3 id="2-1-2-VNC连接"><a href="#2-1-2-VNC连接" class="headerlink" title="2.1.2 VNC连接"></a>2.1.2 VNC连接</h3><p>VNC 是 virtual network connection的简称，第一次连接会给一个“远程连接密码”，只会出现一次，一定要记录下来。<br><font color="red"><strong>Tips：“远程连接密码”，只会出现一次，一定要记录下来    ！</strong></font><br><img src="https://img-blog.csdnimg.cn/20200307172156893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>登录之后，在左上角输入指令。<br><img src="https://img-blog.csdnimg.cn/20200307172245784.png" alt="在这里插入图片描述"><br>选择 “CTRL + ALT + DELETE” 进入登录界面，密码是之前设置的“实例密码”，不是远程连接密码。<br><img src="https://img-blog.csdnimg.cn/20200307182019801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-1-3-workbench-与-VNC-的区别"><a href="#2-1-3-workbench-与-VNC-的区别" class="headerlink" title="2.1.3 workbench 与 VNC 的区别"></a>2.1.3 workbench 与 VNC 的区别</h3><ol><li>离开连接页面之后，workbench连接可以保持很久，VNC会很快关闭。</li><li>······（未完待续，之后补充）<h2 id="2-2-利用MSTSC连接——Windows-系统-连接-Windows-系统"><a href="#2-2-利用MSTSC连接——Windows-系统-连接-Windows-系统" class="headerlink" title="2.2 利用MSTSC连接——Windows 系统 连接 Windows 系统"></a>2.2 利用MSTSC连接——Windows 系统 连接 Windows 系统</h2></li><li>MSTSC（Microsoft terminal services client），创建与终端服务器或其他远程计算机的连接，编辑现有“远程桌面连接(.rdp)”配置文件，并将 Windows XP 连接（使用“客户端国防部设备 接管理器”创建的连接）迁移到新的 .rdp 文件中。MSTSC还有一种说法，Microsoft Telnet Screen Control ，即“微软远程桌面控制”。</li><li>打开“<strong>控制面板</strong>” &gt; “<strong>用户账户</strong>”  &gt; “<strong>凭据管理器</strong>” 界面 ，如图，选择“<strong>添加Windows凭据</strong>”。<br><img src="https://img-blog.csdnimg.cn/20200309175620221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>如图输入相应信息，点击“<strong>确认</strong>”即可。<br><img src="https://img-blog.csdnimg.cn/20200309180150645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>打开MSTSC连接界面：“<strong>win + R</strong>” 进入下图界面，输入 “<strong>mstsc</strong>”，点击“<strong>确认</strong>”即可。<br><img src="https://img-blog.csdnimg.cn/20200309201742164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>经过上面的步骤进入下图界面会自动补全服务器网址，有多个网址时在下拉栏选择，如有其它网址未保存至本地计算机“<strong>Windows凭据</strong>”，需要手动输入服务器公网网址与用户名。<br><img src="https://img-blog.csdnimg.cn/20200309202058746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击左下角的“<strong>显示选项</strong>”，进入如下界面<br><img src="https://img-blog.csdnimg.cn/20200309202439885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击“<strong>本地资源</strong>”，进入如下界面<br><img src="https://img-blog.csdnimg.cn/20200309202534694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击“<strong>详细信息</strong>”，勾选你要映射到服务器的磁盘<br><font color="red"><strong>Tips：经过映射的磁盘里的文件在连接服务器之后可直接复制到服务器上。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200309202612760.png" alt="在这里插入图片描述"></li><li>点击“<strong>连接</strong>”，出现如图警告，选择“<strong>查看证书</strong>”<br><img src="https://img-blog.csdnimg.cn/20200309202908100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>选择“<strong>安装证书</strong>”<br><img src="https://img-blog.csdnimg.cn/20200309203050779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>选择“<strong>本地计算机</strong>”，进入“<strong>下一步</strong>”<br><img src="https://img-blog.csdnimg.cn/20200309203123598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>勾选“<strong>将所有证书都放入下列存储</strong>”，<strong>浏览</strong>选择“<strong>受信任的根证书颁发机构</strong>”，进入“<strong>下一步</strong>”<br><img src="https://img-blog.csdnimg.cn/20200309203222683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击“<strong>完成</strong>”，出现此窗口即可<br><img src="https://img-blog.csdnimg.cn/20200309203525316.png" alt="在这里插入图片描述"></li><li>点击“<strong>确认</strong>”，然后下图也点击“<strong>确认</strong>”，<br><img src="https://img-blog.csdnimg.cn/20200309203050779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>最后点击“<strong>是</strong>”，即完成连接。<br><img src="https://img-blog.csdnimg.cn/20200309202908100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>之后再进行登录，会出现“<strong>名称不匹配</strong>”错误，选择“<strong>是</strong>”忽略即可。<br><img src="https://img-blog.csdnimg.cn/20200325145807955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="2-3-利用XShell和XFTP配合连接——适用于Linux、UNIX系统"><a href="#2-3-利用XShell和XFTP配合连接——适用于Linux、UNIX系统" class="headerlink" title="2.3 利用XShell和XFTP配合连接——适用于Linux、UNIX系统"></a>2.3 利用XShell和XFTP配合连接——适用于Linux、UNIX系统</h2></li></ol><p><strong>PS</strong>：</p><ol><li>利用XShell和XFTP也可连接Windows系统的服务器，但步骤繁琐，远不如MSTSC简单，有兴趣的朋友可以参考此文章：<a href="https://www.jianshu.com/p/6e5bc39d386e">《Windows安装OpenSSH服务》</a>。</li><li>利用XShell和SFTP连接Linux或UNIX服务器请跳转至本人另一篇博客<a href="http://fdchen.host/2020/09/27/Linux%E5%85%A5%E9%97%A8/">《Linux入门》</a>。</li></ol><p><font color="red"><strong>Tips：</strong></font><br><font color="red"><strong>1.  附XShell和XFTP的下载链接</strong></font></p><ol><li>官网下载：<a href="https://xshell.en.softonic.com/">XSell</a>，<a href="https://www.netsarang.com/zh/xftp/">XFTP</a>（需分开下载）</li><li>本人上传资源：含 <strong>XSHell 5</strong> 和 <strong>Xftp_5.0.543</strong>，详见本文附加资源。</li></ol><p><font color="red"><strong>2. 想要详细了解XShell 与 XFTP 可参考此文章：<a href="https://blog.csdn.net/m0_37840000/article/details/82154158">《Xshell和Xftp区别》</a></strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MSTSC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/2020/qian-duan-kai-fa-wei-xin-xiao-cheng-xu/"/>
      <url>/2020/qian-duan-kai-fa-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="0-官方文档"><a href="#0-官方文档" class="headerlink" title="0 官方文档"></a>0 官方文档</h1><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/">官方开发文档</a></li></ul><h1 id="1-界面渲染"><a href="#1-界面渲染" class="headerlink" title="1 界面渲染"></a>1 界面渲染</h1><h2 id="1-1-自定义placeholder颜色与样式"><a href="#1-1-自定义placeholder颜色与样式" class="headerlink" title="1.1 自定义placeholder颜色与样式"></a>1.1 自定义placeholder颜色与样式</h2><ul><li>详见博客：<a href="https://blog.csdn.net/august_leo/article/details/80877382">微信小程序-自定义placeholder颜色和样式</a></li></ul><p>PS：</p><ol><li>字体颜色只能通过placeholder-style设置；</li><li>字体大小只能通过placeholder-class设置</li></ol><h2 id="1-2-text组件不设置宽度，文本长度大于默认宽度时会自动换行"><a href="#1-2-text组件不设置宽度，文本长度大于默认宽度时会自动换行" class="headerlink" title="1.2 text组件不设置宽度，文本长度大于默认宽度时会自动换行"></a>1.2 text组件不设置宽度，文本长度大于默认宽度时会自动换行</h2><h2 id="1-3-margin与padding的区别"><a href="#1-3-margin与padding的区别" class="headerlink" title="1.3 margin与padding的区别"></a>1.3 margin与padding的区别</h2><ul><li>margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。（外边距）</li><li>padding是指自身边框到自身内部另一个容器边框之间的距离，就是容器内距离。（内边距）</li></ul><h2 id="1-4-微信小程序width-100-设置margin后宽度超过屏幕"><a href="#1-4-微信小程序width-100-设置margin后宽度超过屏幕" class="headerlink" title="1.4 微信小程序width:100%设置margin后宽度超过屏幕"></a>1.4 微信小程序width:100%设置margin后宽度超过屏幕</h2><p>这个时候宽度不能设置100%，<strong>把宽度改为width:auto</strong>即可解决超过屏幕的问题。</p><h2 id="1-5-微信小程序各种提示框"><a href="#1-5-微信小程序各种提示框" class="headerlink" title="1.5 微信小程序各种提示框"></a>1.5 微信小程序各种提示框</h2><ol><li>弹出提示框，可以选择确定或者取消。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">showModal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>     <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'提示'</span><span class="token punctuation">,</span>     <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'这是一个模态弹窗'</span><span class="token punctuation">,</span>     <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>confirm<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//这里是点击了确定以后</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'用户点击确定'</span><span class="token punctuation">)</span>       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">//这里是点击了取消以后</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'用户点击取消'</span><span class="token punctuation">)</span>       <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>不带确定和取消的，直接提示成功</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'成功'</span><span class="token punctuation">,</span>    <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'success'</span><span class="token punctuation">,</span>    <span class="token literal-property property">duration</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token comment">//持续的时间</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>提示等待中…</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>     <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'等待...'</span><span class="token punctuation">,</span>     <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'loading'</span><span class="token punctuation">,</span>     <span class="token literal-property property">duration</span><span class="token operator">:</span> <span class="token number">2000</span>  <span class="token comment">//持续的时间</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>提示文字，没有任何图标效果，但是文字可以写的很多</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>     <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'这里面可以写很多的文字，比其他的弹窗都要多！'</span><span class="token punctuation">,</span>     <span class="token literal-property property">icon</span><span class="token operator">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span>     <span class="token literal-property property">duration</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token comment">//持续的时间</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>弹窗提示选择，例如选择ABCD那种</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">showActionSheet</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>     <span class="token literal-property property">itemList</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span>cancel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>tapIndex<span class="token punctuation">)</span><span class="token comment">//这里是点击了那个按钮的下标</span>       <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>多用于页面提示加载中</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>loading hidden<span class="token operator">=</span><span class="token string">"&#123;&#123;hidden&#125;&#125;"</span><span class="token operator">></span>       加载中<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>loading<span class="token operator">></span><span class="token comment">// hidden有两个值：false和true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原文链接：<a href="https://jingyan.baidu.com/article/456c463b38ca900a5831449a.html">https://jingyan.baidu.com/article/456c463b38ca900a5831449a.html</a></p><h2 id="1-6-全局变量和全局方法的使用"><a href="#1-6-全局变量和全局方法的使用" class="headerlink" title="1.6 全局变量和全局方法的使用"></a>1.6 全局变量和全局方法的使用</h2><blockquote><p>在app.js中可以定义全局变量和方法<br>在其他js文件中，可以引入 const app &#x3D; getApp（）<br>app上自带公共变量和方法 app.globalData 或 app.myMethod</p></blockquote><ul><li>app.js中可以定义全局变量</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token literal-property property">globalData</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">imgurl</span><span class="token operator">:</span><span class="token string">'/images/common/'</span>  <span class="token punctuation">&#125;</span>， <span class="token function">myMethod</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>页面中使用全局变量，页面js文件中</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">getApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 引入app</span><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// data中使用全局变量</span>    <span class="token literal-property property">imgurl</span><span class="token operator">:</span> app<span class="token punctuation">.</span>globalData<span class="token punctuation">.</span>imgurl<span class="token punctuation">,</span> <span class="token comment">//全局img路径</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更新全局变量</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">app<span class="token punctuation">.</span>globalData<span class="token punctuation">.</span>imgurl<span class="token operator">=</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>result<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原文链接：<a href="https://blog.csdn.net/weixin_43848576/article/details/98472926">https://blog.csdn.net/weixin_43848576/article/details/98472926</a></p><h2 id="1-7-数据类型转换，parseInt-‘1’"><a href="#1-7-数据类型转换，parseInt-‘1’" class="headerlink" title="1.7 数据类型转换，parseInt(‘1’)"></a>1.7 数据类型转换，parseInt(‘1’)</h2><ul><li>字符串转float，int</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"字符串内容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将字符串值转成浮点数</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"字符串内容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将字符串值转成整数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>强制类型转换</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">String</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//把给定的值转换成字符串</span><span class="token function">Boolean</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//把给定的值转换成Boolean型； </span><span class="token function">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//把给定的值转换成数字（可以是整数或浮点数）； </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>保留几位小数点</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">NumberObject<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>位数<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>获取几位数：四舍五入</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">135</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//returns   1e+2</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">135.77</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//returns   135.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原文链接：<a href="https://blog.csdn.net/shanshan_1117/article/details/89371296">https://blog.csdn.net/shanshan_1117/article/details/89371296</a></p><h2 id="1-8-模块化，module-exports"><a href="#1-8-模块化，module-exports" class="headerlink" title="1.8 模块化，module.exports"></a>1.8 模块化，module.exports</h2><ul><li>详见博客：<a href="https://www.cnblogs.com/panlaixing/p/6736499.html">微信小程序module.exports 模块化</a></li></ul><h2 id="1-9-获取当前屏幕可见区域的宽高"><a href="#1-9-获取当前屏幕可见区域的宽高" class="headerlink" title="1.9 获取当前屏幕可见区域的宽高"></a>1.9 获取当前屏幕可见区域的宽高</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">wx<span class="token punctuation">.</span><span class="token function">getSystemInfo</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>windowWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>windowHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-10-小程序寻址范围"><a href="#1-10-小程序寻址范围" class="headerlink" title="1.10 小程序寻址范围"></a>1.10 小程序寻址范围</h2><ul><li><p>仅支持相对寻址，不能寻址至项目文件外</p></li><li><p>解决办法是采用云存储，使用网页访问方式，例：<a href="http://192.168.2.201:88/uploads/images/userAvatar/firstimg.png">http://192.168.2.201:88/uploads/images/userAvatar/firstimg.png</a></p></li></ul><h2 id="1-11-修改data中数组或对象里面的某一项值"><a href="#1-11-修改data中数组或对象里面的某一项值" class="headerlink" title="1.11 修改data中数组或对象里面的某一项值"></a>1.11 修改data中数组或对象里面的某一项值</h2><ul><li>修改对象中的某一项值</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 先定义</span><span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">list</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">data1</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token literal-property property">passengers</span><span class="token operator">:</span><span class="token punctuation">[</span>            <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">''</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 修改</span><span class="token keyword">var</span> that<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">,</span>num<span class="token operator">=</span><span class="token string">"list.data1"</span><span class="token punctuation">;</span>that<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">:</span>that<span class="token punctuation">.</span>data<span class="token punctuation">.</span>list<span class="token punctuation">.</span>data1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">XXX</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改数组的某一项</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 动态绑定input的值</span><span class="token function-variable function">inputVal</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">var</span> index <span class="token operator">=</span> e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>index<span class="token punctuation">;</span>    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token string">'passengers['</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">'].'</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token operator">:</span> e<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>value    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原文链接：<a href="https://blog.csdn.net/lw_1220/article/details/97928464">https://blog.csdn.net/lw_1220/article/details/97928464</a></p><h2 id="1-12-特殊效果——左滑、气泡动画等"><a href="#1-12-特殊效果——左滑、气泡动画等" class="headerlink" title="1.12 特殊效果——左滑、气泡动画等"></a>1.12 特殊效果——左滑、气泡动画等</h2><ul><li>详见博客：<a href="https://blog.csdn.net/anda0109/article/details/76922875">微信小程序特殊效果合集—左滑、气泡各种酷炫动画</a></li></ul><h2 id="1-13-wx-for使用"><a href="#1-13-wx-for使用" class="headerlink" title="1.13 wx:for使用"></a>1.13 wx:for使用</h2><ul><li><p>最好绑定wx:key&#x3D;”index”不然语法不严谨而且会报警告</p></li><li><p>详见博客：<a href="https://blog.csdn.net/hxfghgh/article/details/80521890">微信小程序：wx:for循环输出的使用方法以及简单例子</a></p></li></ul><h3 id="1-13-1-wk-key作用"><a href="#1-13-1-wk-key作用" class="headerlink" title="1.13.1 wk:key作用"></a>1.13.1 wk:key作用</h3><p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并希望列表中的项目保持自己的特征和状态（如&lt;input&#x2F;&gt; 中的输入内容&lt;switch&#x2F;&gt; 的选中状态），需要使用wx:key来指定列表中项目的唯一的标识符。</p><p>wx:key 的值以两种形式提供</p><ol><li>wx:key&#x3D;”property” 其中property是代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。类似于字典的key值</li><li>wx:key&#x3D;”*this”， 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：</li></ol><p><strong>当数据改变触发渲染层重新渲染的时候，会校正带有key的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</strong></p><p>不添加wx:key情况：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>block</span> <span class="token attr-name"><span class="token namespace">wx:</span>for-items</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123;userInfoList&#125;&#125;<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会出现warning： Now you can provide attr “wx:key” for a “wx:for” to improve performance.，如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p><p>推荐array 的 每一个item都添加一个唯一识别的property来管理，这样就可以去掉warning，如果使用保留关键字，好像会出现显示的item都是最后一个的。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>block</span> <span class="token attr-name"><span class="token namespace">wx:</span>for-items</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123;userInfoList&#125;&#125;<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">wx:</span>key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userInfoListId<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原文链接：<a href="https://www.cnblogs.com/psxiao/p/12299751.html">https://www.cnblogs.com/psxiao/p/12299751.html</a></p><h2 id="1-14-一行2个图片列表"><a href="#1-14-一行2个图片列表" class="headerlink" title="1.14 一行2个图片列表"></a>1.14 一行2个图片列表</h2><ul><li>详见博客：<a href="http://www.lanrenmb.com/xiaochengxujiaocheng/9128_2.html">微信小程序列表页样式布局之一行2个图片列表制作教程(2)</a></li></ul><h2 id="1-15-小程序form表单提交"><a href="#1-15-小程序form表单提交" class="headerlink" title="1.15 小程序form表单提交"></a>1.15 小程序form表单提交</h2><ul><li><p>详见博客：<a href="https://www.jianshu.com/p/56c404b5ba3c">小程序form表单提交</a></p></li><li><p>form表单注意事项：</p></li></ul><ol><li>form表单中超过一个input标签设置了auto-focus或focus，将无法调用提交方法</li><li>form表单中的提交按键必须为button，不能为text或其他</li></ol><h2 id="1-16-小程序Cannot-read-property-‘elem’-of-undefined"><a href="#1-16-小程序Cannot-read-property-‘elem’-of-undefined" class="headerlink" title="1.16 小程序Cannot read property ‘elem’ of undefined"></a>1.16 小程序Cannot read property ‘elem’ of undefined</h2><p>基础库2.10.1的问题，换成别的基础库就可以了</p><p>原文链接：<a href="https://blog.csdn.net/Kf_loseHair/article/details/104590506/">https://blog.csdn.net/Kf_loseHair/article/details/104590506/</a></p><h2 id="1-17-Unexpected-token-lt-in-JSON-at-position-0-的错误解析"><a href="#1-17-Unexpected-token-lt-in-JSON-at-position-0-的错误解析" class="headerlink" title="1.17 Unexpected token &lt; in JSON at position 0 的错误解析"></a>1.17 Unexpected token &lt; in JSON at position 0 的错误解析</h2><ul><li>详见博客：<a href="https://segmentfault.com/a/1190000017545154">Unexpected token &lt; in JSON at position 0 的错误解析</a></li></ul><h2 id="1-18-小程序设置延时"><a href="#1-18-小程序设置延时" class="headerlink" title="1.18 小程序设置延时"></a>1.18 小程序设置延时</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//要延时执行的代码</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">//延迟时间 这里是1秒</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-19-小程序如何动态控制view组件高度"><a href="#1-19-小程序如何动态控制view组件高度" class="headerlink" title="1.19 小程序如何动态控制view组件高度"></a>1.19 小程序如何动态控制view组件高度</h2><ul><li>详见博客：<a href="https://www.jb51.net/article/129805.htm">微信小程序实现动态改变view标签宽度和高度的方法</a></li></ul><h2 id="1-20-rpx和px的换算"><a href="#1-20-rpx和px的换算" class="headerlink" title="1.20 rpx和px的换算"></a>1.20 rpx和px的换算</h2><ul><li>详见博客：<a href="https://juejin.cn/post/6877373754601013255">微信小程序 - rpx和px互转，以及系统给的 pixelRatio 值比例不对</a></li></ul><h2 id="1-21-微信小程序动态触发点击事件"><a href="#1-21-微信小程序动态触发点击事件" class="headerlink" title="1.21 微信小程序动态触发点击事件"></a>1.21 微信小程序动态触发点击事件</h2><ul><li>详见博客：<a href="https://www.jianshu.com/p/fb618a61744c">微信小程序动态触发点击事件</a></li></ul><h2 id="1-22-微信小程序设置文字复制功能"><a href="#1-22-微信小程序设置文字复制功能" class="headerlink" title="1.22 微信小程序设置文字复制功能"></a>1.22 微信小程序设置文字复制功能</h2><p>text设置属性  selectable&#x3D;”true”</p><h2 id="1-23-Button组件的宽高设置"><a href="#1-23-Button组件的宽高设置" class="headerlink" title="1.23 Button组件的宽高设置"></a>1.23 Button组件的宽高设置</h2><p>在css(wxss)里面直接设置button的width,height是无效的！！！必须在html(wxml)里面的style进行设置！</p><h1 id="2-后端连接"><a href="#2-后端连接" class="headerlink" title="2 后端连接"></a>2 后端连接</h1><h2 id="2-1-连接M有SQL数据库"><a href="#2-1-连接M有SQL数据库" class="headerlink" title="2.1 连接M有SQL数据库"></a>2.1 连接M有SQL数据库</h2><ul><li>详见博客：<a href="https://blog.csdn.net/qq_38882327/article/details/91377526">微信小程序连接数据库</a></li></ul><blockquote><p>使用PHP接口时，要把mysql_connect等用法改成mysqli_connect,不然会报错</p></blockquote><h2 id="2-2-检查网络状态"><a href="#2-2-检查网络状态" class="headerlink" title="2.2 检查网络状态"></a>2.2 检查网络状态</h2><ul><li>详见博客：<a href="https://blog.csdn.net/mushui0633/article/details/83245269">微信小程序检测网络连接</a></li></ul><h2 id="2-3-JSON取值方式"><a href="#2-3-JSON取值方式" class="headerlink" title="2.3 JSON取值方式"></a>2.3 JSON取值方式</h2><ul><li>详见博客：<a href="https://www.jb51.net/article/121989.htm">实例详解JSON取值(key是中文或者数字)方式</a></li></ul><h2 id="2-4-complete帮助debug"><a href="#2-4-complete帮助debug" class="headerlink" title="2.4 complete帮助debug"></a>2.4 complete帮助debug</h2><p>不论success或fail都可以打印返回结果</p><h2 id="2-5-网络请求一直在pending，可能是访问接口网址不完整"><a href="#2-5-网络请求一直在pending，可能是访问接口网址不完整" class="headerlink" title="2.5 网络请求一直在pending，可能是访问接口网址不完整"></a>2.5 网络请求一直在pending，可能是访问接口网址不完整</h2><ul><li>可以在微信开发者工具栏查看</li></ul><h1 id="3-开发工具技巧"><a href="#3-开发工具技巧" class="headerlink" title="3 开发工具技巧"></a>3 开发工具技巧</h1><h2 id="3-1-调试器部分工具栏功能介绍"><a href="#3-1-调试器部分工具栏功能介绍" class="headerlink" title="3.1 调试器部分工具栏功能介绍"></a>3.1 调试器部分工具栏功能介绍</h2><ol><li><strong>Console：</strong>打印台</li><li><strong>Source：</strong>项目文件信息</li><li><strong>Network：</strong>查看网络请求状态</li><li><strong>Storage：</strong>查看全局存储信息</li><li><strong>AppData：</strong>查看全局变量</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见用法 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从入门到入坟——我的第一篇博客</title>
      <link href="/2020/sui-bi-cong-ru-men-dao-ru-fen-wo-de-di-yi-pian-bo-ke/"/>
      <url>/2020/sui-bi-cong-ru-men-dao-ru-fen-wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么要写博客？——Debug方法的进化论"><a href="#1-为什么要写博客？——Debug方法的进化论" class="headerlink" title="1 为什么要写博客？——Debug方法的进化论"></a>1 为什么要写博客？——Debug方法的进化论</h1><h2 id="1-1-收藏网址"><a href="#1-1-收藏网址" class="headerlink" title="1.1 收藏网址"></a>1.1 收藏网址</h2><p>其实，在大学我才开始接触计算机专业，刚开始学的时候懵懵懂懂，很多简单的东西都不明白，但“浏览器”是个好东西，不懂就查。不过很多时候遇到的一些Bug，过了几天就又不会调了。于是到后来我查到一些重要的知识点或Bug解决方案，我就会把网址收藏起来，但是也没怎么好好分类，往往还夹杂着别的学科，就像图片中看到的，乱七八糟，有时候就算知道曾经收藏过，找也要找很久。(图片来自浏览器的收藏夹)<br><img src="https://img-blog.csdnimg.cn/20200410091718104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlbWljaXJjbGVfQ0hFTg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><span id="more"></span><h2 id="1-2-思维导图"><a href="#1-2-思维导图" class="headerlink" title="1.2 思维导图"></a>1.2 思维导图</h2><p>大二的时候我需要做一个项目，很多东西都是边学边做，但是边学边做的坏处就是很容易忘。好在无意中接触到了思维导图（原谅我大一从未用过或了解），当时就觉得，我应该用思维导图做我的学习笔记。于是，一个名为《从入门到入坟》的思维导图面世了，我会把一些Bug解决方案的网址添加在上面作为超链接，着实方便。不过半个月以后，问题又来了，有些Bug是很小的的问题，但是我也想记录下来，放在思维导图里面就显得很繁琐，虽然可以搜索关键字，但是思维导图显得很大很繁杂。（图为 《从入门到入坟》思维导图 ）<br><img src="https://img-blog.csdnimg.cn/20200307000107340.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODU2NTg3,size_16,color_FFFFFF,t_70" alt="“从入门到入坟”思维导图"></p><h2 id="1-3-博客"><a href="#1-3-博客" class="headerlink" title="1.3 博客"></a>1.3 博客</h2><p>现在，我终于找到了一个合适的方法来做学习笔记——写博客。不得不说，写博客确实是一个很好的办法，每次解决一个问题都可以记录下来，不仅可以方便以后再用，而且每每写完都会有些许成就感，毕竟我始终坚信生活需要仪式感！对了，之前的思维导图不能浪费，后续我会慢慢写成博客，当然，支持原创，我会在原作的基础上进行符合我实际情况的修改。</p><h1 id="2-聊以慰藉的感想——纪念我的第一篇博客"><a href="#2-聊以慰藉的感想——纪念我的第一篇博客" class="headerlink" title="2 聊以慰藉的感想——纪念我的第一篇博客"></a>2 聊以慰藉的感想——纪念我的第一篇博客</h1><p>第一篇博客，如同“处女作”一般，当然十分重要，为此我也去找了一篇名为<a href="https://blog.csdn.net/cungudafa/article/details/84658703">《【小白】如何写好自己的一篇CSDN博客（美化1）》</a>的博客学习，有兴趣的可以去看一看。怎么说呢，还是喜欢白底黑字，于是字体、背景什么的我就不去设置了，各位看官多多担待。<br>我也不知道未来的我会变得如何，会不会因为太忙而没有时间写博客，会不会像大家所言“人最终会变成自己所讨厌的人”，未来的一切终究是未知的，但是回顾之前的岁月，往往过得不尽人意，所以在这里，我列下几个问题，写给未来的自己。</p><h1 id="3-Questions"><a href="#3-Questions" class="headerlink" title="3 Questions"></a>3 Questions</h1><ol><li>你每天做的事是不是你当初所想的？</li><li>你有没有实现当初的“豪言壮志”？</li><li>你有没有变成你所讨厌的人？</li><li>······（未完待续，一时间没想到，之后补充）</li></ol><h1 id="4-留言"><a href="#4-留言" class="headerlink" title="4 留言"></a>4 留言</h1><p><em><strong>会当凌绝顶，一览众山小。        ——杜甫《望岳》</strong></em><br><em><strong>我告诉自己，再熬一熬，枯坐比久睡要好。        ——来自小H</strong></em><br><em><strong>77不88。        ——来自小Y</strong></em><br><em><strong>不能失去目标否则将会变成一条咸鱼！        ——来自小K</strong></em><br>——于2020年3月7日0:27第一次编辑，谨以此纪念！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
